# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentMaintenanceTaskInvocationArgs',
    'AgentMaintenanceTaskInvocationArgsDict',
    'AlarmTemplatePolicyArgs',
    'AlarmTemplatePolicyArgsDict',
    'AlarmTemplatePolicyHierarchicalValueArgs',
    'AlarmTemplatePolicyHierarchicalValueArgsDict',
    'AlarmruleAlarmActionArgs',
    'AlarmruleAlarmActionArgsDict',
    'AlarmruleConditionArgs',
    'AlarmruleConditionArgsDict',
    'AlarmruleInsufficientdataActionArgs',
    'AlarmruleInsufficientdataActionArgsDict',
    'AlarmruleMetricArgs',
    'AlarmruleMetricArgsDict',
    'AlarmruleMetricDimensionArgs',
    'AlarmruleMetricDimensionArgsDict',
    'AlarmruleOkActionArgs',
    'AlarmruleOkActionArgsDict',
    'AlarmruleResourceArgs',
    'AlarmruleResourceArgsDict',
    'AlarmruleResourceDimensionArgs',
    'AlarmruleResourceDimensionArgsDict',
    'DashboardExtendInfoArgs',
    'DashboardExtendInfoArgsDict',
    'DashboardWidgetLocationArgs',
    'DashboardWidgetLocationArgsDict',
    'DashboardWidgetMetricArgs',
    'DashboardWidgetMetricArgsDict',
    'DashboardWidgetMetricDimensionsArgs',
    'DashboardWidgetMetricDimensionsArgsDict',
    'DashboardWidgetPropertiesArgs',
    'DashboardWidgetPropertiesArgsDict',
    'EventReportDetailArgs',
    'EventReportDetailArgsDict',
    'EventReportDetailDimensionArgs',
    'EventReportDetailDimensionArgsDict',
    'MetricDataAddMetricArgs',
    'MetricDataAddMetricArgsDict',
    'MetricDataAddMetricDimensionArgs',
    'MetricDataAddMetricDimensionArgsDict',
    'MicroserviceEngineConfigCenterAddressArgs',
    'MicroserviceEngineConfigCenterAddressArgsDict',
    'MicroserviceEngineServiceRegistryAddressArgs',
    'MicroserviceEngineServiceRegistryAddressArgsDict',
    'MicroserviceInstanceDataCenterArgs',
    'MicroserviceInstanceDataCenterArgsDict',
    'MicroserviceInstanceHealthCheckArgs',
    'MicroserviceInstanceHealthCheckArgsDict',
    'NotificationMaskPolicyArgs',
    'NotificationMaskPolicyArgsDict',
    'NotificationMaskPolicyExtraInfoArgs',
    'NotificationMaskPolicyExtraInfoArgsDict',
    'NotificationMaskResourceArgs',
    'NotificationMaskResourceArgsDict',
    'NotificationMaskResourceDimensionArgs',
    'NotificationMaskResourceDimensionArgsDict',
    'OneClickAlarmAlarmNotificationArgs',
    'OneClickAlarmAlarmNotificationArgsDict',
    'OneClickAlarmDimensionNamesArgs',
    'OneClickAlarmDimensionNamesArgsDict',
    'OneClickAlarmOkNotificationArgs',
    'OneClickAlarmOkNotificationArgsDict',
    'ResourceGroupResourceArgs',
    'ResourceGroupResourceArgsDict',
    'ResourceGroupResourceDimensionArgs',
    'ResourceGroupResourceDimensionArgsDict',
    'GetMultipleMetricsDataMetricArgs',
    'GetMultipleMetricsDataMetricArgsDict',
    'GetMultipleMetricsDataMetricDimensionArgs',
    'GetMultipleMetricsDataMetricDimensionArgsDict',
]

MYPY = False

if not MYPY:
    class AgentMaintenanceTaskInvocationArgsDict(TypedDict):
        create_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        When the task was created.
        """
        current_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current version of the agent.
        """
        elastic_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The EIP list.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the server ID.
        This parameter is mandatory when the task type is **INSTALL** or **UPDATE**.
        """
        instance_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The server name
        """
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The server type.
        """
        intranet_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The private IP address list.
        """
        invocation_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the task ID.
        This parameter is mandatory when the task type is **ROLLBACK** or **RETRY**.
        """
        invocation_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The task status.
        """
        invocation_target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the task object. Only **telescope** is supported.
        """
        invocation_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the task type.
        The valid value can be **INSTALL**, **UPDATE**, **ROLLBACK** or **RETRY**.
        """
        target_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target version.
        """
        update_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        When the task was updated.
        """
elif False:
    AgentMaintenanceTaskInvocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentMaintenanceTaskInvocationArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[_builtins.int]] = None,
                 current_version: Optional[pulumi.Input[_builtins.str]] = None,
                 elastic_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_name: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 intranet_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 invocation_id: Optional[pulumi.Input[_builtins.str]] = None,
                 invocation_status: Optional[pulumi.Input[_builtins.str]] = None,
                 invocation_target: Optional[pulumi.Input[_builtins.str]] = None,
                 invocation_type: Optional[pulumi.Input[_builtins.str]] = None,
                 target_version: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] create_time: When the task was created.
        :param pulumi.Input[_builtins.str] current_version: The current version of the agent.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] elastic_ips: The EIP list.
        :param pulumi.Input[_builtins.str] instance_id: Specifies the server ID.
               This parameter is mandatory when the task type is **INSTALL** or **UPDATE**.
        :param pulumi.Input[_builtins.str] instance_name: The server name
        :param pulumi.Input[_builtins.str] instance_type: The server type.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] intranet_ips: The private IP address list.
        :param pulumi.Input[_builtins.str] invocation_id: Specifies the task ID.
               This parameter is mandatory when the task type is **ROLLBACK** or **RETRY**.
        :param pulumi.Input[_builtins.str] invocation_status: The task status.
        :param pulumi.Input[_builtins.str] invocation_target: Specifies the task object. Only **telescope** is supported.
        :param pulumi.Input[_builtins.str] invocation_type: Specifies the task type.
               The valid value can be **INSTALL**, **UPDATE**, **ROLLBACK** or **RETRY**.
        :param pulumi.Input[_builtins.str] target_version: The target version.
        :param pulumi.Input[_builtins.int] update_time: When the task was updated.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if current_version is not None:
            pulumi.set(__self__, "current_version", current_version)
        if elastic_ips is not None:
            pulumi.set(__self__, "elastic_ips", elastic_ips)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if intranet_ips is not None:
            pulumi.set(__self__, "intranet_ips", intranet_ips)
        if invocation_id is not None:
            pulumi.set(__self__, "invocation_id", invocation_id)
        if invocation_status is not None:
            pulumi.set(__self__, "invocation_status", invocation_status)
        if invocation_target is not None:
            pulumi.set(__self__, "invocation_target", invocation_target)
        if invocation_type is not None:
            pulumi.set(__self__, "invocation_type", invocation_type)
        if target_version is not None:
            pulumi.set(__self__, "target_version", target_version)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When the task was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current version of the agent.
        """
        return pulumi.get(self, "current_version")

    @current_version.setter
    def current_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_version", value)

    @_builtins.property
    @pulumi.getter(name="elasticIps")
    def elastic_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The EIP list.
        """
        return pulumi.get(self, "elastic_ips")

    @elastic_ips.setter
    def elastic_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "elastic_ips", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the server ID.
        This parameter is mandatory when the task type is **INSTALL** or **UPDATE**.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The server name
        """
        return pulumi.get(self, "instance_name")

    @instance_name.setter
    def instance_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_name", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The server type.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="intranetIps")
    def intranet_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The private IP address list.
        """
        return pulumi.get(self, "intranet_ips")

    @intranet_ips.setter
    def intranet_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "intranet_ips", value)

    @_builtins.property
    @pulumi.getter(name="invocationId")
    def invocation_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the task ID.
        This parameter is mandatory when the task type is **ROLLBACK** or **RETRY**.
        """
        return pulumi.get(self, "invocation_id")

    @invocation_id.setter
    def invocation_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_id", value)

    @_builtins.property
    @pulumi.getter(name="invocationStatus")
    def invocation_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The task status.
        """
        return pulumi.get(self, "invocation_status")

    @invocation_status.setter
    def invocation_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_status", value)

    @_builtins.property
    @pulumi.getter(name="invocationTarget")
    def invocation_target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the task object. Only **telescope** is supported.
        """
        return pulumi.get(self, "invocation_target")

    @invocation_target.setter
    def invocation_target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_target", value)

    @_builtins.property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the task type.
        The valid value can be **INSTALL**, **UPDATE**, **ROLLBACK** or **RETRY**.
        """
        return pulumi.get(self, "invocation_type")

    @invocation_type.setter
    def invocation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_type", value)

    @_builtins.property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target version.
        """
        return pulumi.get(self, "target_version")

    @target_version.setter
    def target_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_version", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When the task was updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AlarmTemplatePolicyArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        """
        Specifies the comparison conditions for alarm threshold.
        + When `type` is **0**, metric alarm template value options: **>**, **<**, **=**, **>=**, **<=**, **!=**,
        **cycle_decrease**, **cycle_increase**, **cycle_wave**.
        + When `type` is **2**, event alarm template value options: **>**, **<**, **=**, **>=**, **<=**, **!=**.
        """
        count: pulumi.Input[_builtins.int]
        """
        Specifies the number of consecutive alarm triggering times.
        + For event alarms, the value ranges from **1** to **180**.
        + For metric and website alarms, the value can be **1**, **2**, **3**, **4**, **5**, **10**, **15**, **30**, **60**,
        **90**, **120**, **180**.
        """
        filter: pulumi.Input[_builtins.str]
        """
        Specifies the data rollup methods.
        Value options: **average**, **variance**, **min**, **max**, **sum**.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        Specifies the alarm metric name.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the namespace of the service.
        """
        period: pulumi.Input[_builtins.int]
        """
        Specifies the judgment period of alarm condition.
        Value options: **0**, **1**, **300**, **1200**, **3600**, **14400**, **86400**.
        """
        suppress_duration: pulumi.Input[_builtins.int]
        """
        Specifies the alarm suppression cycle. Unit: second.
        Only one alarm is sent when the alarm suppression period is **0**.
        Value options: **0**, **300**, **600**, **900**, **1800**, **3600**, **10800**, **21600**,
        **43200**, **86400**.
        """
        alarm_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the alarm level. It means no level if not set.
        The valid values are as follows:
        + **1**: critical.
        + **2**: major.
        + **3**: minor.
        + **4**: informational.
        """
        dimension_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the resource dimension.
        The name starts with a letter and separated by commas(,) for multiple dimensions,
        can contain only letters, digits, hyphens (-) and hyphens (-),
        and contain a maximum of `32` characters for each dimension.

        <a name="CesAlarmTemplate_Policy_hierarchical_value"></a>
        The `hierarchical_value` block supports:
        """
        hierarchical_value: NotRequired[pulumi.Input['AlarmTemplatePolicyHierarchicalValueArgsDict']]
        """
        Specifies the multiple levels of alarm thresholds.
        The hierarchical_value structure is documented below.

        > When `hierarchical_value` and `value` are used at the same time, `hierarchical_value` takes precedence.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit string of the alarm threshold.
        The unit can contain a maximum of `32` characters.
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the alarm threshold.
        """
elif False:
    AlarmTemplatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmTemplatePolicyArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 count: pulumi.Input[_builtins.int],
                 filter: pulumi.Input[_builtins.str],
                 metric_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 period: pulumi.Input[_builtins.int],
                 suppress_duration: pulumi.Input[_builtins.int],
                 alarm_level: Optional[pulumi.Input[_builtins.int]] = None,
                 dimension_name: Optional[pulumi.Input[_builtins.str]] = None,
                 hierarchical_value: Optional[pulumi.Input['AlarmTemplatePolicyHierarchicalValueArgs']] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] comparison_operator: Specifies the comparison conditions for alarm threshold.
               + When `type` is **0**, metric alarm template value options: **>**, **<**, **=**, **>=**, **<=**, **!=**,
               **cycle_decrease**, **cycle_increase**, **cycle_wave**.
               + When `type` is **2**, event alarm template value options: **>**, **<**, **=**, **>=**, **<=**, **!=**.
        :param pulumi.Input[_builtins.int] count: Specifies the number of consecutive alarm triggering times.
               + For event alarms, the value ranges from **1** to **180**.
               + For metric and website alarms, the value can be **1**, **2**, **3**, **4**, **5**, **10**, **15**, **30**, **60**,
               **90**, **120**, **180**.
        :param pulumi.Input[_builtins.str] filter: Specifies the data rollup methods.
               Value options: **average**, **variance**, **min**, **max**, **sum**.
        :param pulumi.Input[_builtins.str] metric_name: Specifies the alarm metric name.
        :param pulumi.Input[_builtins.str] namespace: Specifies the namespace of the service.
        :param pulumi.Input[_builtins.int] period: Specifies the judgment period of alarm condition.
               Value options: **0**, **1**, **300**, **1200**, **3600**, **14400**, **86400**.
        :param pulumi.Input[_builtins.int] suppress_duration: Specifies the alarm suppression cycle. Unit: second.
               Only one alarm is sent when the alarm suppression period is **0**.
               Value options: **0**, **300**, **600**, **900**, **1800**, **3600**, **10800**, **21600**,
               **43200**, **86400**.
        :param pulumi.Input[_builtins.int] alarm_level: Specifies the alarm level. It means no level if not set.
               The valid values are as follows:
               + **1**: critical.
               + **2**: major.
               + **3**: minor.
               + **4**: informational.
        :param pulumi.Input[_builtins.str] dimension_name: Specifies the resource dimension.
               The name starts with a letter and separated by commas(,) for multiple dimensions,
               can contain only letters, digits, hyphens (-) and hyphens (-),
               and contain a maximum of `32` characters for each dimension.
               
               <a name="CesAlarmTemplate_Policy_hierarchical_value"></a>
               The `hierarchical_value` block supports:
        :param pulumi.Input['AlarmTemplatePolicyHierarchicalValueArgs'] hierarchical_value: Specifies the multiple levels of alarm thresholds.
               The hierarchical_value structure is documented below.
               
               > When `hierarchical_value` and `value` are used at the same time, `hierarchical_value` takes precedence.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit string of the alarm threshold.
               The unit can contain a maximum of `32` characters.
        :param pulumi.Input[_builtins.int] value: Specifies the alarm threshold.
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "suppress_duration", suppress_duration)
        if alarm_level is not None:
            pulumi.set(__self__, "alarm_level", alarm_level)
        if dimension_name is not None:
            pulumi.set(__self__, "dimension_name", dimension_name)
        if hierarchical_value is not None:
            pulumi.set(__self__, "hierarchical_value", hierarchical_value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the comparison conditions for alarm threshold.
        + When `type` is **0**, metric alarm template value options: **>**, **<**, **=**, **>=**, **<=**, **!=**,
        **cycle_decrease**, **cycle_increase**, **cycle_wave**.
        + When `type` is **2**, event alarm template value options: **>**, **<**, **=**, **>=**, **<=**, **!=**.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of consecutive alarm triggering times.
        + For event alarms, the value ranges from **1** to **180**.
        + For metric and website alarms, the value can be **1**, **2**, **3**, **4**, **5**, **10**, **15**, **30**, **60**,
        **90**, **120**, **180**.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the data rollup methods.
        Value options: **average**, **variance**, **min**, **max**, **sum**.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the alarm metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the namespace of the service.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the judgment period of alarm condition.
        Value options: **0**, **1**, **300**, **1200**, **3600**, **14400**, **86400**.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="suppressDuration")
    def suppress_duration(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the alarm suppression cycle. Unit: second.
        Only one alarm is sent when the alarm suppression period is **0**.
        Value options: **0**, **300**, **600**, **900**, **1800**, **3600**, **10800**, **21600**,
        **43200**, **86400**.
        """
        return pulumi.get(self, "suppress_duration")

    @suppress_duration.setter
    def suppress_duration(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "suppress_duration", value)

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the alarm level. It means no level if not set.
        The valid values are as follows:
        + **1**: critical.
        + **2**: major.
        + **3**: minor.
        + **4**: informational.
        """
        return pulumi.get(self, "alarm_level")

    @alarm_level.setter
    def alarm_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_level", value)

    @_builtins.property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the resource dimension.
        The name starts with a letter and separated by commas(,) for multiple dimensions,
        can contain only letters, digits, hyphens (-) and hyphens (-),
        and contain a maximum of `32` characters for each dimension.

        <a name="CesAlarmTemplate_Policy_hierarchical_value"></a>
        The `hierarchical_value` block supports:
        """
        return pulumi.get(self, "dimension_name")

    @dimension_name.setter
    def dimension_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension_name", value)

    @_builtins.property
    @pulumi.getter(name="hierarchicalValue")
    def hierarchical_value(self) -> Optional[pulumi.Input['AlarmTemplatePolicyHierarchicalValueArgs']]:
        """
        Specifies the multiple levels of alarm thresholds.
        The hierarchical_value structure is documented below.

        > When `hierarchical_value` and `value` are used at the same time, `hierarchical_value` takes precedence.
        """
        return pulumi.get(self, "hierarchical_value")

    @hierarchical_value.setter
    def hierarchical_value(self, value: Optional[pulumi.Input['AlarmTemplatePolicyHierarchicalValueArgs']]):
        pulumi.set(self, "hierarchical_value", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit string of the alarm threshold.
        The unit can contain a maximum of `32` characters.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the alarm threshold.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmTemplatePolicyHierarchicalValueArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the threshold for the critical level.
        """
        info: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the threshold for the info level.
        """
        major: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the threshold for the major level.
        """
        minor: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the threshold for the minor level.
        """
elif False:
    AlarmTemplatePolicyHierarchicalValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmTemplatePolicyHierarchicalValueArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input[_builtins.float]] = None,
                 info: Optional[pulumi.Input[_builtins.float]] = None,
                 major: Optional[pulumi.Input[_builtins.float]] = None,
                 minor: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] critical: Specifies the threshold for the critical level.
        :param pulumi.Input[_builtins.float] info: Specifies the threshold for the info level.
        :param pulumi.Input[_builtins.float] major: Specifies the threshold for the major level.
        :param pulumi.Input[_builtins.float] minor: Specifies the threshold for the minor level.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if info is not None:
            pulumi.set(__self__, "info", info)
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)

    @_builtins.property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the threshold for the critical level.
        """
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "critical", value)

    @_builtins.property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the threshold for the info level.
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "info", value)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the threshold for the major level.
        """
        return pulumi.get(self, "major")

    @major.setter
    def major(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "major", value)

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the threshold for the minor level.
        """
        return pulumi.get(self, "minor")

    @minor.setter
    def minor(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "minor", value)


if not MYPY:
    class AlarmruleAlarmActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5. If `type` is set to *notification*, the value of notification_list cannot be empty. If `type` is
        set to *autoscaling*, the value of notification_list must be **[]**
        and the value of namespace must be *SYS.AS*.

        Note: to enable the *autoscaling* alarm rules take effect, you must bind scaling policies.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of action triggered by an alarm. the
        value can be *notification* or *autoscaling*.
        + notification: indicates that a notification will be sent to the user.
        + autoscaling: indicates that a scaling action will be triggered.
        """
elif False:
    AlarmruleAlarmActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleAlarmActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notification_lists: specifies the list of objects to be notified if the alarm status changes, the
               maximum length is 5. If `type` is set to *notification*, the value of notification_list cannot be empty. If `type` is
               set to *autoscaling*, the value of notification_list must be **[]**
               and the value of namespace must be *SYS.AS*.
               
               Note: to enable the *autoscaling* alarm rules take effect, you must bind scaling policies.
        :param pulumi.Input[_builtins.str] type: Specifies the type of action triggered by an alarm. the
               value can be *notification* or *autoscaling*.
               + notification: indicates that a notification will be sent to the user.
               + autoscaling: indicates that a scaling action will be triggered.
        """
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5. If `type` is set to *notification*, the value of notification_list cannot be empty. If `type` is
        set to *autoscaling*, the value of notification_list must be **[]**
        and the value of namespace must be *SYS.AS*.

        Note: to enable the *autoscaling* alarm rules take effect, you must bind scaling policies.
        """
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of action triggered by an alarm. the
        value can be *notification* or *autoscaling*.
        + notification: indicates that a notification will be sent to the user.
        + autoscaling: indicates that a scaling action will be triggered.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmruleConditionArgsDict(TypedDict):
        comparison_operator: pulumi.Input[_builtins.str]
        """
        Specifies the comparison condition of alarm thresholds. The value can be >,
        =, <, >=, or <=.
        """
        count: pulumi.Input[_builtins.int]
        """
        Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
        """
        filter: pulumi.Input[_builtins.str]
        """
        Specifies the data rollup methods. The value can be max, min, average, sum, and variance.
        """
        period: pulumi.Input[_builtins.int]
        """
        Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
        and 86400.

        Note: If period is set to 1, the raw metric data is used to determine whether to generate an alarm. When the value of
        `alarm_type` is **EVENT.SYS** or **EVENT.CUSTOM**, period can be set to 0.
        """
        value: pulumi.Input[_builtins.float]
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
        alarm_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the alarm severity of the condition. The value can be 1, 2, 3 or 4,
        which indicates *critical*, *major*, *minor*, and *informational*, respectively.
        The default value is 2.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Required
        """
        suppress_duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the interval for triggering an alarm if the alarm persists.
        Possible values are as follows:
        + **0**: Cloud Eye triggers the alarm only once;
        + **300**: Cloud Eye triggers the alarm every 5 minutes;
        + **600**: Cloud Eye triggers the alarm every 10 minutes;
        + **900**: Cloud Eye triggers the alarm every 15 minutes;
        + **1800**: Cloud Eye triggers the alarm every 30 minutes;
        + **3600**: Cloud Eye triggers the alarm every hour;
        + **10800**: Cloud Eye triggers the alarm every 3 hours;
        + **21600**: Cloud Eye triggers the alarm every 6 hours;
        + **43200**: Cloud Eye triggers the alarm every 12 hour;
        + **86400**: Cloud Eye triggers the alarm every day.

        The default value is `0`.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the data unit.
        For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
elif False:
    AlarmruleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleConditionArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[_builtins.str],
                 count: pulumi.Input[_builtins.int],
                 filter: pulumi.Input[_builtins.str],
                 period: pulumi.Input[_builtins.int],
                 value: pulumi.Input[_builtins.float],
                 alarm_level: Optional[pulumi.Input[_builtins.int]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] comparison_operator: Specifies the comparison condition of alarm thresholds. The value can be >,
               =, <, >=, or <=.
        :param pulumi.Input[_builtins.int] count: Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
        :param pulumi.Input[_builtins.str] filter: Specifies the data rollup methods. The value can be max, min, average, sum, and variance.
        :param pulumi.Input[_builtins.int] period: Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
               and 86400.
               
               Note: If period is set to 1, the raw metric data is used to determine whether to generate an alarm. When the value of
               `alarm_type` is **EVENT.SYS** or **EVENT.CUSTOM**, period can be set to 0.
        :param pulumi.Input[_builtins.float] value: Specifies the alarm threshold. The value ranges from 0 to Number of
               1.7976931348623157e+108.
        :param pulumi.Input[_builtins.int] alarm_level: Specifies the alarm severity of the condition. The value can be 1, 2, 3 or 4,
               which indicates *critical*, *major*, *minor*, and *informational*, respectively.
               The default value is 2.
        :param pulumi.Input[_builtins.str] metric_name: schema: Required
        :param pulumi.Input[_builtins.int] suppress_duration: Specifies the interval for triggering an alarm if the alarm persists.
               Possible values are as follows:
               + **0**: Cloud Eye triggers the alarm only once;
               + **300**: Cloud Eye triggers the alarm every 5 minutes;
               + **600**: Cloud Eye triggers the alarm every 10 minutes;
               + **900**: Cloud Eye triggers the alarm every 15 minutes;
               + **1800**: Cloud Eye triggers the alarm every 30 minutes;
               + **3600**: Cloud Eye triggers the alarm every hour;
               + **10800**: Cloud Eye triggers the alarm every 3 hours;
               + **21600**: Cloud Eye triggers the alarm every 6 hours;
               + **43200**: Cloud Eye triggers the alarm every 12 hour;
               + **86400**: Cloud Eye triggers the alarm every day.
               
               The default value is `0`.
        :param pulumi.Input[_builtins.str] unit: Specifies the data unit.
               For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "value", value)
        if alarm_level is not None:
            pulumi.set(__self__, "alarm_level", alarm_level)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if suppress_duration is not None:
            pulumi.set(__self__, "suppress_duration", suppress_duration)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the comparison condition of alarm thresholds. The value can be >,
        =, <, >=, or <=.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of consecutive occurrence times. The value ranges from 1 to 5.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the data rollup methods. The value can be max, min, average, sum, and variance.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the alarm checking period in seconds. The value can be 0, 1, 300, 1200, 3600, 14400,
        and 86400.

        Note: If period is set to 1, the raw metric data is used to determine whether to generate an alarm. When the value of
        `alarm_type` is **EVENT.SYS** or **EVENT.CUSTOM**, period can be set to 0.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.float]:
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the alarm severity of the condition. The value can be 1, 2, 3 or 4,
        which indicates *critical*, *major*, *minor*, and *informational*, respectively.
        The default value is 2.
        """
        return pulumi.get(self, "alarm_level")

    @alarm_level.setter
    def alarm_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_level", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Required
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="suppressDuration")
    def suppress_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the interval for triggering an alarm if the alarm persists.
        Possible values are as follows:
        + **0**: Cloud Eye triggers the alarm only once;
        + **300**: Cloud Eye triggers the alarm every 5 minutes;
        + **600**: Cloud Eye triggers the alarm every 10 minutes;
        + **900**: Cloud Eye triggers the alarm every 15 minutes;
        + **1800**: Cloud Eye triggers the alarm every 30 minutes;
        + **3600**: Cloud Eye triggers the alarm every hour;
        + **10800**: Cloud Eye triggers the alarm every 3 hours;
        + **21600**: Cloud Eye triggers the alarm every 6 hours;
        + **43200**: Cloud Eye triggers the alarm every 12 hour;
        + **86400**: Cloud Eye triggers the alarm every day.

        The default value is `0`.
        """
        return pulumi.get(self, "suppress_duration")

    @suppress_duration.setter
    def suppress_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "suppress_duration", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the data unit.
        For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class AlarmruleInsufficientdataActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        type: pulumi.Input[_builtins.str]
elif False:
    AlarmruleInsufficientdataActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleInsufficientdataActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmruleMetricArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the namespace in **service.item** format. **service** and **item**
        each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
        Changing this creates a new resource.
        For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgsDict']]]]
        """
        schema: Deprecated
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Deprecated
        """
elif False:
    AlarmruleMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleMetricArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace: Specifies the namespace in **service.item** format. **service** and **item**
               each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
               Changing this creates a new resource.
               For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        :param pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]] dimensions: schema: Deprecated
        :param pulumi.Input[_builtins.str] metric_name: schema: Deprecated
        """
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the namespace in **service.item** format. **service** and **item**
        each must be a string that starts with a letter and contains only letters, digits, and underscores (_).
        Changing this creates a new resource.
        For details, see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleMetricDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)


if not MYPY:
    class AlarmruleMetricDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension name. The value can be a string of 1 to 32 characters
        that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
elif False:
    AlarmruleMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleMetricDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the dimension name. The value can be a string of 1 to 32 characters
               that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        :param pulumi.Input[_builtins.str] value: Specifies the alarm threshold. The value ranges from 0 to Number of
               1.7976931348623157e+108.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension name. The value can be a string of 1 to 32 characters
        that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmruleOkActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of action triggered by an alarm. the value is notification.
        notification: indicates that a notification will be sent to the user.
        """
elif False:
    AlarmruleOkActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleOkActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notification_lists: specifies the list of objects to be notified if the alarm status changes, the
               maximum length is 5.
        :param pulumi.Input[_builtins.str] type: Specifies the type of action triggered by an alarm. the value is notification.
               notification: indicates that a notification will be sent to the user.
        """
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        specifies the list of objects to be notified if the alarm status changes, the
        maximum length is 5.
        """
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of action triggered by an alarm. the value is notification.
        notification: indicates that a notification will be sent to the user.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmruleResourceArgsDict(TypedDict):
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmruleResourceDimensionArgsDict']]]]
        """
        Specifies the list of metric dimensions. The structure is described below.
        """
elif False:
    AlarmruleResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleResourceArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleResourceDimensionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlarmruleResourceDimensionArgs']]] dimensions: Specifies the list of metric dimensions. The structure is described below.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleResourceDimensionArgs']]]]:
        """
        Specifies the list of metric dimensions. The structure is described below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmruleResourceDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class AlarmruleResourceDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension name. The value can be a string of 1 to 32 characters
        that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
elif False:
    AlarmruleResourceDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmruleResourceDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the dimension name. The value can be a string of 1 to 32 characters
               that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        :param pulumi.Input[_builtins.str] value: Specifies the alarm threshold. The value ranges from 0 to Number of
               1.7976931348623157e+108.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension name. The value can be a string of 1 to 32 characters
        that must start with a letter and contain only letters, digits, underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm threshold. The value ranges from 0 to Number of
        1.7976931348623157e+108.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DashboardExtendInfoArgsDict(TypedDict):
        display_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the display time.
        Values can be as follows:
        + **0**: Using custom time display.
        + **5**: Five minutes.
        + **15**: Fifteen minutes.
        + **30**: Thirty minutes.
        + **60**: One hour.
        + **120**: Two hours.
        + **180**: Three hours.
        + **720**: Twelve hours.
        + **1440**: One day.
        + **10080**: Seven days.
        + **43200**: Thirty days.
        """
        enable_legend: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the legend.
        """
        enable_screen_auto_play: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the monitoring screen switches automatically.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric aggregation method.
        Values can be as follows:
        + **average**: Average value.
        + **min**: Minimum value.
        + **max**: Maximum value.
        + **sum**: Sum.
        """
        from_: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the start time.
        """
        full_screen_widget_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of large screen display views.
        Values can be **1**, **4**, **9**, **16** and **25**.
        """
        period: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric aggregation period.
        Values can be as follows:
        + **1**: Original value.
        + **60**: One minute.
        + **300**: Five minutes.
        + **1200**: Twenty minutes.
        + **3600**: One hour.
        + **14400**: Four hours.
        + **86400**: One day.
        """
        refresh_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the refresh time.
        Values can be as follows:
        + **0**: No refresh.
        + **10**: Ten seconds.
        + **60**: One minute.
        + **300**: Five minutes.
        + **1200**: Twenty minutes.
        """
        screen_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the monitoring screen background color.
        """
        time_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the automatic switching time interval of the monitoring screen.
        Values can be as follows:
        + **10000**: Ten seconds.
        + **30000**: Thirty seconds.
        + **60000**: One minute.
        """
        to: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the end time.
        """
elif False:
    DashboardExtendInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardExtendInfoArgs:
    def __init__(__self__, *,
                 display_time: Optional[pulumi.Input[_builtins.int]] = None,
                 enable_legend: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_screen_auto_play: Optional[pulumi.Input[_builtins.bool]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None,
                 from_: Optional[pulumi.Input[_builtins.int]] = None,
                 full_screen_widget_num: Optional[pulumi.Input[_builtins.int]] = None,
                 period: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_time: Optional[pulumi.Input[_builtins.int]] = None,
                 screen_color: Optional[pulumi.Input[_builtins.str]] = None,
                 time_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 to: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] display_time: Specifies the display time.
               Values can be as follows:
               + **0**: Using custom time display.
               + **5**: Five minutes.
               + **15**: Fifteen minutes.
               + **30**: Thirty minutes.
               + **60**: One hour.
               + **120**: Two hours.
               + **180**: Three hours.
               + **720**: Twelve hours.
               + **1440**: One day.
               + **10080**: Seven days.
               + **43200**: Thirty days.
        :param pulumi.Input[_builtins.bool] enable_legend: Specifies whether to enable the legend.
        :param pulumi.Input[_builtins.bool] enable_screen_auto_play: Specifies whether the monitoring screen switches automatically.
        :param pulumi.Input[_builtins.str] filter: Specifies the metric aggregation method.
               Values can be as follows:
               + **average**: Average value.
               + **min**: Minimum value.
               + **max**: Maximum value.
               + **sum**: Sum.
        :param pulumi.Input[_builtins.int] from_: Specifies the start time.
        :param pulumi.Input[_builtins.int] full_screen_widget_num: Specifies the number of large screen display views.
               Values can be **1**, **4**, **9**, **16** and **25**.
        :param pulumi.Input[_builtins.str] period: Specifies the metric aggregation period.
               Values can be as follows:
               + **1**: Original value.
               + **60**: One minute.
               + **300**: Five minutes.
               + **1200**: Twenty minutes.
               + **3600**: One hour.
               + **14400**: Four hours.
               + **86400**: One day.
        :param pulumi.Input[_builtins.int] refresh_time: Specifies the refresh time.
               Values can be as follows:
               + **0**: No refresh.
               + **10**: Ten seconds.
               + **60**: One minute.
               + **300**: Five minutes.
               + **1200**: Twenty minutes.
        :param pulumi.Input[_builtins.str] screen_color: Specifies the monitoring screen background color.
        :param pulumi.Input[_builtins.int] time_interval: Specifies the automatic switching time interval of the monitoring screen.
               Values can be as follows:
               + **10000**: Ten seconds.
               + **30000**: Thirty seconds.
               + **60000**: One minute.
        :param pulumi.Input[_builtins.int] to: Specifies the end time.
        """
        if display_time is not None:
            pulumi.set(__self__, "display_time", display_time)
        if enable_legend is not None:
            pulumi.set(__self__, "enable_legend", enable_legend)
        if enable_screen_auto_play is not None:
            pulumi.set(__self__, "enable_screen_auto_play", enable_screen_auto_play)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if full_screen_widget_num is not None:
            pulumi.set(__self__, "full_screen_widget_num", full_screen_widget_num)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)
        if screen_color is not None:
            pulumi.set(__self__, "screen_color", screen_color)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="displayTime")
    def display_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the display time.
        Values can be as follows:
        + **0**: Using custom time display.
        + **5**: Five minutes.
        + **15**: Fifteen minutes.
        + **30**: Thirty minutes.
        + **60**: One hour.
        + **120**: Two hours.
        + **180**: Three hours.
        + **720**: Twelve hours.
        + **1440**: One day.
        + **10080**: Seven days.
        + **43200**: Thirty days.
        """
        return pulumi.get(self, "display_time")

    @display_time.setter
    def display_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "display_time", value)

    @_builtins.property
    @pulumi.getter(name="enableLegend")
    def enable_legend(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the legend.
        """
        return pulumi.get(self, "enable_legend")

    @enable_legend.setter
    def enable_legend(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_legend", value)

    @_builtins.property
    @pulumi.getter(name="enableScreenAutoPlay")
    def enable_screen_auto_play(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the monitoring screen switches automatically.
        """
        return pulumi.get(self, "enable_screen_auto_play")

    @enable_screen_auto_play.setter
    def enable_screen_auto_play(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_screen_auto_play", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric aggregation method.
        Values can be as follows:
        + **average**: Average value.
        + **min**: Minimum value.
        + **max**: Maximum value.
        + **sum**: Sum.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the start time.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter(name="fullScreenWidgetNum")
    def full_screen_widget_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of large screen display views.
        Values can be **1**, **4**, **9**, **16** and **25**.
        """
        return pulumi.get(self, "full_screen_widget_num")

    @full_screen_widget_num.setter
    def full_screen_widget_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "full_screen_widget_num", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric aggregation period.
        Values can be as follows:
        + **1**: Original value.
        + **60**: One minute.
        + **300**: Five minutes.
        + **1200**: Twenty minutes.
        + **3600**: One hour.
        + **14400**: Four hours.
        + **86400**: One day.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the refresh time.
        Values can be as follows:
        + **0**: No refresh.
        + **10**: Ten seconds.
        + **60**: One minute.
        + **300**: Five minutes.
        + **1200**: Twenty minutes.
        """
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "refresh_time", value)

    @_builtins.property
    @pulumi.getter(name="screenColor")
    def screen_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the monitoring screen background color.
        """
        return pulumi.get(self, "screen_color")

    @screen_color.setter
    def screen_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "screen_color", value)

    @_builtins.property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the automatic switching time interval of the monitoring screen.
        Values can be as follows:
        + **10000**: Ten seconds.
        + **30000**: Thirty seconds.
        + **60000**: One minute.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "time_interval", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the end time.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DashboardWidgetLocationArgsDict(TypedDict):
        height: pulumi.Input[_builtins.int]
        """
        Specifies the dashboard widget height.

        <a name="Properties"></a>
        The `properties` block supports:
        """
        left: pulumi.Input[_builtins.int]
        """
        Specifies the grids between the widget and the left side of the dashboard.
        """
        top: pulumi.Input[_builtins.int]
        """
        Specifies the grids between the widget and the top of the dashboard.
        """
        width: pulumi.Input[_builtins.int]
        """
        Specifies the dashboard widget width.
        """
elif False:
    DashboardWidgetLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardWidgetLocationArgs:
    def __init__(__self__, *,
                 height: pulumi.Input[_builtins.int],
                 left: pulumi.Input[_builtins.int],
                 top: pulumi.Input[_builtins.int],
                 width: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] height: Specifies the dashboard widget height.
               
               <a name="Properties"></a>
               The `properties` block supports:
        :param pulumi.Input[_builtins.int] left: Specifies the grids between the widget and the left side of the dashboard.
        :param pulumi.Input[_builtins.int] top: Specifies the grids between the widget and the top of the dashboard.
        :param pulumi.Input[_builtins.int] width: Specifies the dashboard widget width.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "top", top)
        pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter
    def height(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the dashboard widget height.

        <a name="Properties"></a>
        The `properties` block supports:
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def left(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the grids between the widget and the left side of the dashboard.
        """
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "left", value)

    @_builtins.property
    @pulumi.getter
    def top(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the grids between the widget and the top of the dashboard.
        """
        return pulumi.get(self, "top")

    @top.setter
    def top(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "top", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the dashboard widget width.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "width", value)


if not MYPY:
    class DashboardWidgetMetricArgsDict(TypedDict):
        dimensions: pulumi.Input['DashboardWidgetMetricDimensionsArgsDict']
        """
        Specifies the dimension list.

        The dimensions structure is documented below.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        Specifies the metric name.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the cloud service dimension.
        """
        aliases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the alias list of metrics.

        <a name="Location"></a>
        The `location` block supports:
        """
elif False:
    DashboardWidgetMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardWidgetMetricArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input['DashboardWidgetMetricDimensionsArgs'],
                 metric_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str],
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['DashboardWidgetMetricDimensionsArgs'] dimensions: Specifies the dimension list.
               
               The dimensions structure is documented below.
        :param pulumi.Input[_builtins.str] metric_name: Specifies the metric name.
        :param pulumi.Input[_builtins.str] namespace: Specifies the cloud service dimension.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] aliases: Specifies the alias list of metrics.
               
               <a name="Location"></a>
               The `location` block supports:
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input['DashboardWidgetMetricDimensionsArgs']:
        """
        Specifies the dimension list.

        The dimensions structure is documented below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input['DashboardWidgetMetricDimensionsArgs']):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the cloud service dimension.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the alias list of metrics.

        <a name="Location"></a>
        The `location` block supports:
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "aliases", value)


if not MYPY:
    class DashboardWidgetMetricDimensionsArgsDict(TypedDict):
        filter_type: pulumi.Input[_builtins.str]
        """
        Specifies the resource type.
        The value can be **all_instances** (all resources) or **specific_instances** (specified resources).
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension name.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the dimension value list.
        """
elif False:
    DashboardWidgetMetricDimensionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardWidgetMetricDimensionsArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] filter_type: Specifies the resource type.
               The value can be **all_instances** (all resources) or **specific_instances** (specified resources).
        :param pulumi.Input[_builtins.str] name: Specifies the dimension name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Specifies the dimension value list.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the resource type.
        The value can be **all_instances** (all resources) or **specific_instances** (specified resources).
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the dimension value list.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardWidgetPropertiesArgsDict(TypedDict):
        top_n: pulumi.Input[_builtins.int]
        """
        Specifies the top n resources sorted by a metric.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how metric data is aggregated.
        The value can only be **topN**.
        """
        order: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how top n resources by a metric are sorted on a dashboard widget.
        The value can be **asc** or **desc**.

        <a name="MetricsDimensions"></a>
        The `dimensions` block supports:
        """
elif False:
    DashboardWidgetPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardWidgetPropertiesArgs:
    def __init__(__self__, *,
                 top_n: pulumi.Input[_builtins.int],
                 filter: Optional[pulumi.Input[_builtins.str]] = None,
                 order: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] top_n: Specifies the top n resources sorted by a metric.
        :param pulumi.Input[_builtins.str] filter: Specifies how metric data is aggregated.
               The value can only be **topN**.
        :param pulumi.Input[_builtins.str] order: Specifies how top n resources by a metric are sorted on a dashboard widget.
               The value can be **asc** or **desc**.
               
               <a name="MetricsDimensions"></a>
               The `dimensions` block supports:
        """
        pulumi.set(__self__, "top_n", top_n)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter(name="topN")
    def top_n(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the top n resources sorted by a metric.
        """
        return pulumi.get(self, "top_n")

    @top_n.setter
    def top_n(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "top_n", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how metric data is aggregated.
        The value can only be **topN**.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how top n resources by a metric are sorted on a dashboard widget.
        The value can be **asc** or **desc**.

        <a name="MetricsDimensions"></a>
        The `dimensions` block supports:
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "order", value)


if not MYPY:
    class EventReportDetailArgsDict(TypedDict):
        level: pulumi.Input[_builtins.str]
        """
        Specifies the event level.
        The value can be **Critical**, **Major**, **Minor**, or **Info**.
        """
        state: pulumi.Input[_builtins.str]
        """
        Specifies the event status.
        The value can be **normal**, **warning**, or **incident**.
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event content.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventReportDetailDimensionArgsDict']]]]
        """
        Specifies the resource dimensions.
        The dimensions structure is documented below.

        <a name="DetailDimensions"></a>
        The `dimensions` block supports:
        """
        group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the group that the event belongs to.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the resource ID.
        """
        resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the resource name.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event type.
        The value can only be **EVENT.CUSTOM**.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event user.
        """
elif False:
    EventReportDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventReportDetailArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[_builtins.str],
                 state: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['EventReportDetailDimensionArgs']]]] = None,
                 group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] level: Specifies the event level.
               The value can be **Critical**, **Major**, **Minor**, or **Info**.
        :param pulumi.Input[_builtins.str] state: Specifies the event status.
               The value can be **normal**, **warning**, or **incident**.
        :param pulumi.Input[_builtins.str] content: Specifies the event content.
        :param pulumi.Input[Sequence[pulumi.Input['EventReportDetailDimensionArgs']]] dimensions: Specifies the resource dimensions.
               The dimensions structure is documented below.
               
               <a name="DetailDimensions"></a>
               The `dimensions` block supports:
        :param pulumi.Input[_builtins.str] group_id: Specifies the group that the event belongs to.
        :param pulumi.Input[_builtins.str] resource_id: Specifies the resource ID.
        :param pulumi.Input[_builtins.str] resource_name: Specifies the resource name.
        :param pulumi.Input[_builtins.str] type: Specifies the event type.
               The value can only be **EVENT.CUSTOM**.
        :param pulumi.Input[_builtins.str] user: Specifies the event user.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "state", state)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def level(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the event level.
        The value can be **Critical**, **Major**, **Minor**, or **Info**.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the event status.
        The value can be **normal**, **warning**, or **incident**.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventReportDetailDimensionArgs']]]]:
        """
        Specifies the resource dimensions.
        The dimensions structure is documented below.

        <a name="DetailDimensions"></a>
        The `dimensions` block supports:
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventReportDetailDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the group that the event belongs to.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the resource ID.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the resource name.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event type.
        The value can only be **EVENT.CUSTOM**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event user.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class EventReportDetailDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The resource dimension name.
        """
        value: pulumi.Input[_builtins.str]
        """
        The resource dimension value.
        """
elif False:
    EventReportDetailDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventReportDetailDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The resource dimension name.
        :param pulumi.Input[_builtins.str] value: The resource dimension value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The resource dimension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The resource dimension value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MetricDataAddMetricArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['MetricDataAddMetricDimensionArgsDict']]]
        """
        Specifies the metric dimension.
        A maximum of four dimensions are supported.

        The dimensions structure is documented below.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        Specifies the metric ID.

        <a name="Dimensions"></a>
        The `dimensions` block supports:
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the customized namespace.
        The namespace must be in the **service.item** format and contain `3` to `32` characters.
        **service** and **item** each must start with a letter and contain only letters, digits, and underscores (_).
        In addition, **service** cannot start with **SYS**, **AGT**, or **SRE**. The namespace cannot be **SERVICE.BMS**,
        because this namespace has been used by the system.
        """
elif False:
    MetricDataAddMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricDataAddMetricArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['MetricDataAddMetricDimensionArgs']]],
                 metric_name: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetricDataAddMetricDimensionArgs']]] dimensions: Specifies the metric dimension.
               A maximum of four dimensions are supported.
               
               The dimensions structure is documented below.
        :param pulumi.Input[_builtins.str] metric_name: Specifies the metric ID.
               
               <a name="Dimensions"></a>
               The `dimensions` block supports:
        :param pulumi.Input[_builtins.str] namespace: Specifies the customized namespace.
               The namespace must be in the **service.item** format and contain `3` to `32` characters.
               **service** and **item** each must start with a letter and contain only letters, digits, and underscores (_).
               In addition, **service** cannot start with **SYS**, **AGT**, or **SRE**. The namespace cannot be **SERVICE.BMS**,
               because this namespace has been used by the system.
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['MetricDataAddMetricDimensionArgs']]]:
        """
        Specifies the metric dimension.
        A maximum of four dimensions are supported.

        The dimensions structure is documented below.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['MetricDataAddMetricDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the metric ID.

        <a name="Dimensions"></a>
        The `dimensions` block supports:
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the customized namespace.
        The namespace must be in the **service.item** format and contain `3` to `32` characters.
        **service** and **item** each must start with a letter and contain only letters, digits, and underscores (_).
        In addition, **service** cannot start with **SYS**, **AGT**, or **SRE**. The namespace cannot be **SERVICE.BMS**,
        because this namespace has been used by the system.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class MetricDataAddMetricDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the dimension value.
        """
elif False:
    MetricDataAddMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricDataAddMetricDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the dimension.
        :param pulumi.Input[_builtins.str] value: Specifies the dimension value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MicroserviceEngineConfigCenterAddressArgsDict(TypedDict):
        private: NotRequired[pulumi.Input[_builtins.str]]
        """
        The internal access address.
        """
        public: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public access address. This address is only set when EIP is bound.
        """
elif False:
    MicroserviceEngineConfigCenterAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicroserviceEngineConfigCenterAddressArgs:
    def __init__(__self__, *,
                 private: Optional[pulumi.Input[_builtins.str]] = None,
                 public: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private: The internal access address.
        :param pulumi.Input[_builtins.str] public: The public access address. This address is only set when EIP is bound.
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @_builtins.property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The internal access address.
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private", value)

    @_builtins.property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public access address. This address is only set when EIP is bound.
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public", value)


if not MYPY:
    class MicroserviceEngineServiceRegistryAddressArgsDict(TypedDict):
        private: NotRequired[pulumi.Input[_builtins.str]]
        """
        The internal access address.
        """
        public: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public access address. This address is only set when EIP is bound.
        """
elif False:
    MicroserviceEngineServiceRegistryAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicroserviceEngineServiceRegistryAddressArgs:
    def __init__(__self__, *,
                 private: Optional[pulumi.Input[_builtins.str]] = None,
                 public: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private: The internal access address.
        :param pulumi.Input[_builtins.str] public: The public access address. This address is only set when EIP is bound.
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @_builtins.property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The internal access address.
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private", value)

    @_builtins.property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public access address. This address is only set when EIP is bound.
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public", value)


if not MYPY:
    class MicroserviceInstanceDataCenterArgsDict(TypedDict):
        availability_zone: pulumi.Input[_builtins.str]
        """
        Specifies the custom availability zone name of the data center.
        Changing this will create a new microservice instance.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the data center name.
        Changing this will create a new microservice instance.
        """
        region: pulumi.Input[_builtins.str]
        """
        Specifies the custom region name of the data center.
        Changing this will create a new microservice instance.
        """
elif False:
    MicroserviceInstanceDataCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicroserviceInstanceDataCenterArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] availability_zone: Specifies the custom availability zone name of the data center.
               Changing this will create a new microservice instance.
        :param pulumi.Input[_builtins.str] name: Specifies the data center name.
               Changing this will create a new microservice instance.
        :param pulumi.Input[_builtins.str] region: Specifies the custom region name of the data center.
               Changing this will create a new microservice instance.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the custom availability zone name of the data center.
        Changing this will create a new microservice instance.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the data center name.
        Changing this will create a new microservice instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the custom region name of the data center.
        Changing this will create a new microservice instance.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class MicroserviceInstanceHealthCheckArgsDict(TypedDict):
        interval: pulumi.Input[_builtins.int]
        """
        Specifies the heartbeat interval. The unit is **s** (second).
        Changing this will create a new microservice instance.
        """
        max_retries: pulumi.Input[_builtins.int]
        """
        Specifies the maximum retries.
        Changing this will create a new microservice instance.
        """
        mode: pulumi.Input[_builtins.str]
        """
        Specifies the heartbeat mode. The valid values are **push** and **pull**.
        Changing this will create a new microservice instance.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the port number.
        Changing this will create a new microservice instance.

        <a name="microservice_instance_data_center"></a>
        The `data_center` block supports:
        """
elif False:
    MicroserviceInstanceHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicroserviceInstanceHealthCheckArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[_builtins.int],
                 max_retries: pulumi.Input[_builtins.int],
                 mode: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] interval: Specifies the heartbeat interval. The unit is **s** (second).
               Changing this will create a new microservice instance.
        :param pulumi.Input[_builtins.int] max_retries: Specifies the maximum retries.
               Changing this will create a new microservice instance.
        :param pulumi.Input[_builtins.str] mode: Specifies the heartbeat mode. The valid values are **push** and **pull**.
               Changing this will create a new microservice instance.
        :param pulumi.Input[_builtins.int] port: Specifies the port number.
               Changing this will create a new microservice instance.
               
               <a name="microservice_instance_data_center"></a>
               The `data_center` block supports:
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "mode", mode)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the heartbeat interval. The unit is **s** (second).
        Changing this will create a new microservice instance.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the maximum retries.
        Changing this will create a new microservice instance.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_retries", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the heartbeat mode. The valid values are **push** and **pull**.
        Changing this will create a new microservice instance.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the port number.
        Changing this will create a new microservice instance.

        <a name="microservice_instance_data_center"></a>
        The `data_center` block supports:
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class NotificationMaskPolicyArgsDict(TypedDict):
        alarm_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        The alarm severity.
        """
        alarm_policy_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The alarm policy ID.
        """
        comparison_operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        The operator.
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive times that alarm conditions are met.
        """
        extra_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NotificationMaskPolicyExtraInfoArgsDict']]]]
        """
        The extended metric information.
        The extra_info structure is documented below.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The data rollup method.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The metric name of a resource.
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The period for determining whether to generate an alarm, in seconds.
        """
        selected_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unit you selected, which is used for subsequent metric data display and calculation.
        """
        suppress_duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        The interval for triggering alarms.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The alarm policy type.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The data unit.
        """
        value: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the value of a resource dimension.
        """
elif False:
    NotificationMaskPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationMaskPolicyArgs:
    def __init__(__self__, *,
                 alarm_level: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 comparison_operator: Optional[pulumi.Input[_builtins.str]] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 extra_infos: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationMaskPolicyExtraInfoArgs']]]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 selected_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] alarm_level: The alarm severity.
        :param pulumi.Input[_builtins.str] alarm_policy_id: The alarm policy ID.
        :param pulumi.Input[_builtins.str] comparison_operator: The operator.
        :param pulumi.Input[_builtins.int] count: The number of consecutive times that alarm conditions are met.
        :param pulumi.Input[Sequence[pulumi.Input['NotificationMaskPolicyExtraInfoArgs']]] extra_infos: The extended metric information.
               The extra_info structure is documented below.
        :param pulumi.Input[_builtins.str] filter: The data rollup method.
        :param pulumi.Input[_builtins.str] metric_name: The metric name of a resource.
        :param pulumi.Input[_builtins.int] period: The period for determining whether to generate an alarm, in seconds.
        :param pulumi.Input[_builtins.str] selected_unit: The unit you selected, which is used for subsequent metric data display and calculation.
        :param pulumi.Input[_builtins.int] suppress_duration: The interval for triggering alarms.
        :param pulumi.Input[_builtins.str] type: The alarm policy type.
        :param pulumi.Input[_builtins.str] unit: The data unit.
        :param pulumi.Input[_builtins.float] value: Specifies the value of a resource dimension.
        """
        if alarm_level is not None:
            pulumi.set(__self__, "alarm_level", alarm_level)
        if alarm_policy_id is not None:
            pulumi.set(__self__, "alarm_policy_id", alarm_policy_id)
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if extra_infos is not None:
            pulumi.set(__self__, "extra_infos", extra_infos)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if selected_unit is not None:
            pulumi.set(__self__, "selected_unit", selected_unit)
        if suppress_duration is not None:
            pulumi.set(__self__, "suppress_duration", suppress_duration)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The alarm severity.
        """
        return pulumi.get(self, "alarm_level")

    @alarm_level.setter
    def alarm_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "alarm_level", value)

    @_builtins.property
    @pulumi.getter(name="alarmPolicyId")
    def alarm_policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The alarm policy ID.
        """
        return pulumi.get(self, "alarm_policy_id")

    @alarm_policy_id.setter
    def alarm_policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_policy_id", value)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The operator.
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comparison_operator", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive times that alarm conditions are met.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="extraInfos")
    def extra_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NotificationMaskPolicyExtraInfoArgs']]]]:
        """
        The extended metric information.
        The extra_info structure is documented below.
        """
        return pulumi.get(self, "extra_infos")

    @extra_infos.setter
    def extra_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NotificationMaskPolicyExtraInfoArgs']]]]):
        pulumi.set(self, "extra_infos", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The data rollup method.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The metric name of a resource.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The period for determining whether to generate an alarm, in seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="selectedUnit")
    def selected_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unit you selected, which is used for subsequent metric data display and calculation.
        """
        return pulumi.get(self, "selected_unit")

    @selected_unit.setter
    def selected_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selected_unit", value)

    @_builtins.property
    @pulumi.getter(name="suppressDuration")
    def suppress_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The interval for triggering alarms.
        """
        return pulumi.get(self, "suppress_duration")

    @suppress_duration.setter
    def suppress_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "suppress_duration", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The alarm policy type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The data unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the value of a resource dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NotificationMaskPolicyExtraInfoArgsDict(TypedDict):
        custom_proc_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of a user process.
        """
        metric_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The metric name prefix.
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The metric type.
        """
        origin_metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The original metric name.
        """
elif False:
    NotificationMaskPolicyExtraInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationMaskPolicyExtraInfoArgs:
    def __init__(__self__, *,
                 custom_proc_name: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_metric_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] custom_proc_name: The name of a user process.
        :param pulumi.Input[_builtins.str] metric_prefix: The metric name prefix.
        :param pulumi.Input[_builtins.str] metric_type: The metric type.
        :param pulumi.Input[_builtins.str] origin_metric_name: The original metric name.
        """
        if custom_proc_name is not None:
            pulumi.set(__self__, "custom_proc_name", custom_proc_name)
        if metric_prefix is not None:
            pulumi.set(__self__, "metric_prefix", metric_prefix)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if origin_metric_name is not None:
            pulumi.set(__self__, "origin_metric_name", origin_metric_name)

    @_builtins.property
    @pulumi.getter(name="customProcName")
    def custom_proc_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of a user process.
        """
        return pulumi.get(self, "custom_proc_name")

    @custom_proc_name.setter
    def custom_proc_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_proc_name", value)

    @_builtins.property
    @pulumi.getter(name="metricPrefix")
    def metric_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The metric name prefix.
        """
        return pulumi.get(self, "metric_prefix")

    @metric_prefix.setter
    def metric_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_prefix", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The metric type.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter(name="originMetricName")
    def origin_metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The original metric name.
        """
        return pulumi.get(self, "origin_metric_name")

    @origin_metric_name.setter
    def origin_metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_metric_name", value)


if not MYPY:
    class NotificationMaskResourceArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['NotificationMaskResourceDimensionArgsDict']]]
        """
        Specifies the resource dimension information.
        The dimensions structure is documented below.

        <a name="ResourcesDimensions"></a>
        The `dimensions` block supports:
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the resource namespace in **service.item** format.
        """
elif False:
    NotificationMaskResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationMaskResourceArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['NotificationMaskResourceDimensionArgs']]],
                 namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NotificationMaskResourceDimensionArgs']]] dimensions: Specifies the resource dimension information.
               The dimensions structure is documented below.
               
               <a name="ResourcesDimensions"></a>
               The `dimensions` block supports:
        :param pulumi.Input[_builtins.str] namespace: Specifies the resource namespace in **service.item** format.
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['NotificationMaskResourceDimensionArgs']]]:
        """
        Specifies the resource dimension information.
        The dimensions structure is documented below.

        <a name="ResourcesDimensions"></a>
        The `dimensions` block supports:
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['NotificationMaskResourceDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the resource namespace in **service.item** format.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class NotificationMaskResourceDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension of a resource.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value of a resource dimension.
        """
elif False:
    NotificationMaskResourceDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationMaskResourceDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the dimension of a resource.
        :param pulumi.Input[_builtins.str] value: Specifies the value of a resource dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension of a resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value of a resource dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OneClickAlarmAlarmNotificationArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of objects to be notified if the alarm status changes.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the notification type.
        The value can be **notification** or **contact**.
        """
elif False:
    OneClickAlarmAlarmNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OneClickAlarmAlarmNotificationArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notification_lists: Specifies the list of objects to be notified if the alarm status changes.
        :param pulumi.Input[_builtins.str] type: Specifies the notification type.
               The value can be **notification** or **contact**.
        """
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of objects to be notified if the alarm status changes.
        """
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification type.
        The value can be **notification** or **contact**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OneClickAlarmDimensionNamesArgsDict(TypedDict):
        event: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the event alarm rules.
        """
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies dimensions in metric alarm rules that have one-click monitoring enabled.

        <a name="Notifications"></a>
        The `alarm_notifications` block or `ok_notifications` block supports:
        """
elif False:
    OneClickAlarmDimensionNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OneClickAlarmDimensionNamesArgs:
    def __init__(__self__, *,
                 event: Optional[pulumi.Input[_builtins.bool]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] event: Specifies whether to enable the event alarm rules.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metrics: Specifies dimensions in metric alarm rules that have one-click monitoring enabled.
               
               <a name="Notifications"></a>
               The `alarm_notifications` block or `ok_notifications` block supports:
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the event alarm rules.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "event", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies dimensions in metric alarm rules that have one-click monitoring enabled.

        <a name="Notifications"></a>
        The `alarm_notifications` block or `ok_notifications` block supports:
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class OneClickAlarmOkNotificationArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of objects to be notified if the alarm status changes.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the notification type.
        The value can be **notification** or **contact**.
        """
elif False:
    OneClickAlarmOkNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OneClickAlarmOkNotificationArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notification_lists: Specifies the list of objects to be notified if the alarm status changes.
        :param pulumi.Input[_builtins.str] type: Specifies the notification type.
               The value can be **notification** or **contact**.
        """
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of objects to be notified if the alarm status changes.
        """
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification type.
        The value can be **notification** or **contact**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceGroupResourceArgsDict(TypedDict):
        dimensions: pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceDimensionArgsDict']]]
        """
        Specifies the list of dimensions.
        The DimensionOpts structure is documented below.

        <a name="ResourceGroup_DimensionOpts"></a>
        The `dimensions` block supports:
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the namespace in **service.item** format.
        **service** and **item** each must be a string that starts with a letter and contains only letters, digits, and
        underscores (_). For details,
        see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
elif False:
    ResourceGroupResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupResourceArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceDimensionArgs']]],
                 namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceDimensionArgs']]] dimensions: Specifies the list of dimensions.
               The DimensionOpts structure is documented below.
               
               <a name="ResourceGroup_DimensionOpts"></a>
               The `dimensions` block supports:
        :param pulumi.Input[_builtins.str] namespace: Specifies the namespace in **service.item** format.
               **service** and **item** each must be a string that starts with a letter and contains only letters, digits, and
               underscores (_). For details,
               see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceDimensionArgs']]]:
        """
        Specifies the list of dimensions.
        The DimensionOpts structure is documented below.

        <a name="ResourceGroup_DimensionOpts"></a>
        The `dimensions` block supports:
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the namespace in **service.item** format.
        **service** and **item** each must be a string that starts with a letter and contains only letters, digits, and
        underscores (_). For details,
        see [Services Interconnected with Cloud Eye](https://support.huaweicloud.com/intl/en-us/api-ces/ces_03_0059.html).
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ResourceGroupResourceDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension name.
        The value can be a string of 1 to 32 characters that must start with a letter
        and contain only letters, digits, underscores (_), and hyphens (-).
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the dimension value.
        The value can be a string of 1 to 64 characters that must start with a letter or a number
        and contain only letters, digits, underscores (_), and hyphens (-).
        """
elif False:
    ResourceGroupResourceDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupResourceDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the dimension name.
               The value can be a string of 1 to 32 characters that must start with a letter
               and contain only letters, digits, underscores (_), and hyphens (-).
        :param pulumi.Input[_builtins.str] value: Specifies the dimension value.
               The value can be a string of 1 to 64 characters that must start with a letter or a number
               and contain only letters, digits, underscores (_), and hyphens (-).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension name.
        The value can be a string of 1 to 32 characters that must start with a letter
        and contain only letters, digits, underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension value.
        The value can be a string of 1 to 64 characters that must start with a letter or a number
        and contain only letters, digits, underscores (_), and hyphens (-).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetMultipleMetricsDataMetricArgsDict(TypedDict):
        dimensions: Sequence['GetMultipleMetricsDataMetricDimensionArgsDict']
        """
        Specifies metric dimensions.
        The dimensions structure is documented below.

        <a name="MetricsDimensions"></a>
        The `dimensions` block supports:
        """
        metric_name: _builtins.str
        """
        Specifies the metric ID.
        """
        namespace: _builtins.str
        """
        Specifies the namespace of a service.
        """
elif False:
    GetMultipleMetricsDataMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMultipleMetricsDataMetricArgs:
    def __init__(__self__, *,
                 dimensions: Sequence['GetMultipleMetricsDataMetricDimensionArgs'],
                 metric_name: _builtins.str,
                 namespace: _builtins.str):
        """
        :param Sequence['GetMultipleMetricsDataMetricDimensionArgs'] dimensions: Specifies metric dimensions.
               The dimensions structure is documented below.
               
               <a name="MetricsDimensions"></a>
               The `dimensions` block supports:
        :param _builtins.str metric_name: Specifies the metric ID.
        :param _builtins.str namespace: Specifies the namespace of a service.
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Sequence['GetMultipleMetricsDataMetricDimensionArgs']:
        """
        Specifies metric dimensions.
        The dimensions structure is documented below.

        <a name="MetricsDimensions"></a>
        The `dimensions` block supports:
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Sequence['GetMultipleMetricsDataMetricDimensionArgs']):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Specifies the metric ID.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: _builtins.str):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        Specifies the namespace of a service.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: _builtins.str):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GetMultipleMetricsDataMetricDimensionArgsDict(TypedDict):
        name: _builtins.str
        """
        Specifies the dimension.
        """
        value: _builtins.str
        """
        Specifies the dimension value.
        """
elif False:
    GetMultipleMetricsDataMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMultipleMetricsDataMetricDimensionArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the dimension.
        :param _builtins.str value: Specifies the dimension value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the dimension.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the dimension value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


