# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BackupImportTaskBackupFilesArgs',
    'BackupImportTaskBackupFilesArgsDict',
    'BackupImportTaskBackupFilesFileArgs',
    'BackupImportTaskBackupFilesFileArgsDict',
    'BackupImportTaskTargetInstanceArgs',
    'BackupImportTaskTargetInstanceArgsDict',
    'BigkeyAnalysisKeyArgs',
    'BigkeyAnalysisKeyArgsDict',
    'CustomTemplateParamArgs',
    'CustomTemplateParamArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListArgs',
    'DiagnosisTaskDiagnosisNodeReportListArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgs',
    'DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgs',
    'DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgs',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgs',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgs',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgs',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgs',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgsDict',
    'HotkeyAnalysisKeyArgs',
    'HotkeyAnalysisKeyArgsDict',
    'InstanceBackupPolicyArgs',
    'InstanceBackupPolicyArgsDict',
    'InstanceBandwidthInfoArgs',
    'InstanceBandwidthInfoArgsDict',
    'InstanceParameterArgs',
    'InstanceParameterArgsDict',
    'InstancePublicAccessElbListenerArgs',
    'InstancePublicAccessElbListenerArgsDict',
    'InstanceV1BackupPolicyArgs',
    'InstanceV1BackupPolicyArgsDict',
    'InstanceV1BandwidthInfoArgs',
    'InstanceV1BandwidthInfoArgsDict',
    'InstanceV1ParameterArgs',
    'InstanceV1ParameterArgsDict',
    'InstanceV1WhitelistArgs',
    'InstanceV1WhitelistArgsDict',
    'InstanceWhitelistArgs',
    'InstanceWhitelistArgsDict',
    'OnlineDataMigrationTaskSourceInstanceArgs',
    'OnlineDataMigrationTaskSourceInstanceArgsDict',
    'OnlineDataMigrationTaskTargetInstanceArgs',
    'OnlineDataMigrationTaskTargetInstanceArgsDict',
    'GetTemplateDetailParamArgs',
    'GetTemplateDetailParamArgsDict',
]

MYPY = False

if not MYPY:
    class BackupImportTaskBackupFilesArgsDict(TypedDict):
        file_source: pulumi.Input[_builtins.str]
        """
        Specifies the data source, which can be an OBS bucket or a backup
        record. Value options:
        + **self_build_obs**: OBS bucket
        + **backup_record**: backup record
        """
        backup_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the backup record ID. It is mandatory when `file_source` is
        **backup_record**.

        <a name="files_struct"></a>
        The `files` block supports:
        """
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OBS bucket name. It is mandatory when `file_source`
        is **self_build_obs**.
        """
        files: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackupImportTaskBackupFilesFileArgsDict']]]]
        """
        Specifies the list of backup files to be imported. It is mandatory when
        `file_source` is **self_build_obs**.
        The files structure is documented below.
        """
elif False:
    BackupImportTaskBackupFilesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupImportTaskBackupFilesArgs:
    def __init__(__self__, *,
                 file_source: pulumi.Input[_builtins.str],
                 backup_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 files: Optional[pulumi.Input[Sequence[pulumi.Input['BackupImportTaskBackupFilesFileArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] file_source: Specifies the data source, which can be an OBS bucket or a backup
               record. Value options:
               + **self_build_obs**: OBS bucket
               + **backup_record**: backup record
        :param pulumi.Input[_builtins.str] backup_id: Specifies the backup record ID. It is mandatory when `file_source` is
               **backup_record**.
               
               <a name="files_struct"></a>
               The `files` block supports:
        :param pulumi.Input[_builtins.str] bucket_name: Specifies the OBS bucket name. It is mandatory when `file_source`
               is **self_build_obs**.
        :param pulumi.Input[Sequence[pulumi.Input['BackupImportTaskBackupFilesFileArgs']]] files: Specifies the list of backup files to be imported. It is mandatory when
               `file_source` is **self_build_obs**.
               The files structure is documented below.
        """
        pulumi.set(__self__, "file_source", file_source)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if files is not None:
            pulumi.set(__self__, "files", files)

    @_builtins.property
    @pulumi.getter(name="fileSource")
    def file_source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the data source, which can be an OBS bucket or a backup
        record. Value options:
        + **self_build_obs**: OBS bucket
        + **backup_record**: backup record
        """
        return pulumi.get(self, "file_source")

    @file_source.setter
    def file_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_source", value)

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the backup record ID. It is mandatory when `file_source` is
        **backup_record**.

        <a name="files_struct"></a>
        The `files` block supports:
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_id", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OBS bucket name. It is mandatory when `file_source`
        is **self_build_obs**.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupImportTaskBackupFilesFileArgs']]]]:
        """
        Specifies the list of backup files to be imported. It is mandatory when
        `file_source` is **self_build_obs**.
        The files structure is documented below.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupImportTaskBackupFilesFileArgs']]]]):
        pulumi.set(self, "files", value)


if not MYPY:
    class BackupImportTaskBackupFilesFileArgsDict(TypedDict):
        file_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of a backup file.
        """
        size: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the file size in bytes.
        """
        update_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time when the file was last modified. The format is
        **YYYY-MM-DDTHH:MM:SS**.

        <a name="target_instance_struct"></a>
        The `target_instance` block supports:
        """
elif False:
    BackupImportTaskBackupFilesFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupImportTaskBackupFilesFileArgs:
    def __init__(__self__, *,
                 file_name: pulumi.Input[_builtins.str],
                 size: Optional[pulumi.Input[_builtins.str]] = None,
                 update_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] file_name: Specifies the name of a backup file.
        :param pulumi.Input[_builtins.str] size: Specifies the file size in bytes.
        :param pulumi.Input[_builtins.str] update_at: Specifies the time when the file was last modified. The format is
               **YYYY-MM-DDTHH:MM:SS**.
               
               <a name="target_instance_struct"></a>
               The `target_instance` block supports:
        """
        pulumi.set(__self__, "file_name", file_name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if update_at is not None:
            pulumi.set(__self__, "update_at", update_at)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of a backup file.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the file size in bytes.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time when the file was last modified. The format is
        **YYYY-MM-DDTHH:MM:SS**.

        <a name="target_instance_struct"></a>
        The `target_instance` block supports:
        """
        return pulumi.get(self, "update_at")

    @update_at.setter
    def update_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_at", value)


if not MYPY:
    class BackupImportTaskTargetInstanceArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the Redis instance ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the Redis name.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Redis password. If a password of the DCS instance is set,
        it is mandatory.
        """
elif False:
    BackupImportTaskTargetInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupImportTaskTargetInstanceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the Redis instance ID.
        :param pulumi.Input[_builtins.str] name: Indicates the Redis name.
        :param pulumi.Input[_builtins.str] password: Specifies the Redis password. If a password of the DCS instance is set,
               it is mandatory.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Redis instance ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the Redis name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Redis password. If a password of the DCS instance is set,
        it is mandatory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class BigkeyAnalysisKeyArgsDict(TypedDict):
        db: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the database where the big key is located.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of the big key.
        """
        shard: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the shard where the big key is located.
        This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the size of the key value.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the type of the big key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the unit of the big key. The value can be:
        + **count**: The number of keys.
        + **byte**: The size of key.
        """
elif False:
    BigkeyAnalysisKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BigkeyAnalysisKeyArgs:
    def __init__(__self__, *,
                 db: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 shard: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] db: Indicates the database where the big key is located.
        :param pulumi.Input[_builtins.str] name: Indicates the name of the big key.
        :param pulumi.Input[_builtins.str] shard: Indicates the shard where the big key is located.
               This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        :param pulumi.Input[_builtins.int] size: Indicates the size of the key value.
        :param pulumi.Input[_builtins.str] type: Indicates the type of the big key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        :param pulumi.Input[_builtins.str] unit: Indicates the unit of the big key. The value can be:
               + **count**: The number of keys.
               + **byte**: The size of key.
        """
        if db is not None:
            pulumi.set(__self__, "db", db)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def db(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the database where the big key is located.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of the big key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def shard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the shard where the big key is located.
        This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        """
        return pulumi.get(self, "shard")

    @shard.setter
    def shard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shard", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the size of the key value.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the type of the big key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the unit of the big key. The value can be:
        + **count**: The number of keys.
        + **byte**: The size of key.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class CustomTemplateParamArgsDict(TypedDict):
        param_name: pulumi.Input[_builtins.str]
        """
        Indicates the name of the param. You can find it through data source
        `dcs_get_template_detail`.
        """
        param_value: pulumi.Input[_builtins.str]
        """
        Indicates the value of the param.
        """
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, String) Indicates the default value of the param.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the template.

        <a name="CustomTemplate_Param"></a>
        The `params` block supports:
        """
        need_restart: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Optional, Bool) Indicates whether the DCS instance need restart.
        """
        param_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, String) Indicates the ID of the param.
        """
        value_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, String) Indicates the value range of the param.
        """
        value_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, String) Indicates the value type of the param.
        """
elif False:
    CustomTemplateParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomTemplateParamArgs:
    def __init__(__self__, *,
                 param_name: pulumi.Input[_builtins.str],
                 param_value: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 need_restart: Optional[pulumi.Input[_builtins.bool]] = None,
                 param_id: Optional[pulumi.Input[_builtins.str]] = None,
                 value_range: Optional[pulumi.Input[_builtins.str]] = None,
                 value_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] param_name: Indicates the name of the param. You can find it through data source
               `dcs_get_template_detail`.
        :param pulumi.Input[_builtins.str] param_value: Indicates the value of the param.
        :param pulumi.Input[_builtins.str] default_value: (Optional, String) Indicates the default value of the param.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the template.
               
               <a name="CustomTemplate_Param"></a>
               The `params` block supports:
        :param pulumi.Input[_builtins.bool] need_restart: (Optional, Bool) Indicates whether the DCS instance need restart.
        :param pulumi.Input[_builtins.str] param_id: (Optional, String) Indicates the ID of the param.
        :param pulumi.Input[_builtins.str] value_range: (Optional, String) Indicates the value range of the param.
        :param pulumi.Input[_builtins.str] value_type: (Optional, String) Indicates the value type of the param.
        """
        pulumi.set(__self__, "param_name", param_name)
        pulumi.set(__self__, "param_value", param_value)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if need_restart is not None:
            pulumi.set(__self__, "need_restart", need_restart)
        if param_id is not None:
            pulumi.set(__self__, "param_id", param_id)
        if value_range is not None:
            pulumi.set(__self__, "value_range", value_range)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter(name="paramName")
    def param_name(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates the name of the param. You can find it through data source
        `dcs_get_template_detail`.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_name", value)

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates the value of the param.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param_value", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, String) Indicates the default value of the param.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the template.

        <a name="CustomTemplate_Param"></a>
        The `params` block supports:
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="needRestart")
    def need_restart(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional, Bool) Indicates whether the DCS instance need restart.
        """
        return pulumi.get(self, "need_restart")

    @need_restart.setter
    def need_restart(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "need_restart", value)

    @_builtins.property
    @pulumi.getter(name="paramId")
    def param_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, String) Indicates the ID of the param.
        """
        return pulumi.get(self, "param_id")

    @param_id.setter
    def param_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "param_id", value)

    @_builtins.property
    @pulumi.getter(name="valueRange")
    def value_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, String) Indicates the value range of the param.
        """
        return pulumi.get(self, "value_range")

    @value_range.setter
    def value_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_range", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, String) Indicates the value type of the param.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListArgsDict(TypedDict):
        abnormal_sum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the total number of abnormal diagnosis items.
        """
        az_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the code of the AZ where the node is.
        """
        command_time_taken_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgsDict']]]]
        """
        Indicates the command execution duration list.
        The command_time_taken_list structure is documented below.
        """
        diagnosis_dimension_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgsDict']]]]
        """
        Indicates the diagnosis dimension list.
        The diagnosis_dimension_list structure is documented below.
        """
        failed_sum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the total number of failed diagnosis items.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of the shard where the node is.
        """
        is_faulted: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the node is faulted.
        """
        node_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the IP address of the node diagnosed.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the node role. The value can be **master** or **slave**.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListArgs:
    def __init__(__self__, *,
                 abnormal_sum: Optional[pulumi.Input[_builtins.int]] = None,
                 az_code: Optional[pulumi.Input[_builtins.str]] = None,
                 command_time_taken_lists: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgs']]]] = None,
                 diagnosis_dimension_lists: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgs']]]] = None,
                 failed_sum: Optional[pulumi.Input[_builtins.int]] = None,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_faulted: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] abnormal_sum: Indicates the total number of abnormal diagnosis items.
        :param pulumi.Input[_builtins.str] az_code: Indicates the code of the AZ where the node is.
        :param pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgs']]] command_time_taken_lists: Indicates the command execution duration list.
               The command_time_taken_list structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgs']]] diagnosis_dimension_lists: Indicates the diagnosis dimension list.
               The diagnosis_dimension_list structure is documented below.
        :param pulumi.Input[_builtins.int] failed_sum: Indicates the total number of failed diagnosis items.
        :param pulumi.Input[_builtins.str] group_name: Indicates the name of the shard where the node is.
        :param pulumi.Input[_builtins.bool] is_faulted: Indicates whether the node is faulted.
        :param pulumi.Input[_builtins.str] node_ip: Indicates the IP address of the node diagnosed.
        :param pulumi.Input[_builtins.str] role: Indicates the node role. The value can be **master** or **slave**.
        """
        if abnormal_sum is not None:
            pulumi.set(__self__, "abnormal_sum", abnormal_sum)
        if az_code is not None:
            pulumi.set(__self__, "az_code", az_code)
        if command_time_taken_lists is not None:
            pulumi.set(__self__, "command_time_taken_lists", command_time_taken_lists)
        if diagnosis_dimension_lists is not None:
            pulumi.set(__self__, "diagnosis_dimension_lists", diagnosis_dimension_lists)
        if failed_sum is not None:
            pulumi.set(__self__, "failed_sum", failed_sum)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if is_faulted is not None:
            pulumi.set(__self__, "is_faulted", is_faulted)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="abnormalSum")
    def abnormal_sum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the total number of abnormal diagnosis items.
        """
        return pulumi.get(self, "abnormal_sum")

    @abnormal_sum.setter
    def abnormal_sum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "abnormal_sum", value)

    @_builtins.property
    @pulumi.getter(name="azCode")
    def az_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the code of the AZ where the node is.
        """
        return pulumi.get(self, "az_code")

    @az_code.setter
    def az_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "az_code", value)

    @_builtins.property
    @pulumi.getter(name="commandTimeTakenLists")
    def command_time_taken_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgs']]]]:
        """
        Indicates the command execution duration list.
        The command_time_taken_list structure is documented below.
        """
        return pulumi.get(self, "command_time_taken_lists")

    @command_time_taken_lists.setter
    def command_time_taken_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgs']]]]):
        pulumi.set(self, "command_time_taken_lists", value)

    @_builtins.property
    @pulumi.getter(name="diagnosisDimensionLists")
    def diagnosis_dimension_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgs']]]]:
        """
        Indicates the diagnosis dimension list.
        The diagnosis_dimension_list structure is documented below.
        """
        return pulumi.get(self, "diagnosis_dimension_lists")

    @diagnosis_dimension_lists.setter
    def diagnosis_dimension_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgs']]]]):
        pulumi.set(self, "diagnosis_dimension_lists", value)

    @_builtins.property
    @pulumi.getter(name="failedSum")
    def failed_sum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the total number of failed diagnosis items.
        """
        return pulumi.get(self, "failed_sum")

    @failed_sum.setter
    def failed_sum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failed_sum", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of the shard where the node is.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="isFaulted")
    def is_faulted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the node is faulted.
        """
        return pulumi.get(self, "is_faulted")

    @is_faulted.setter
    def is_faulted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_faulted", value)

    @_builtins.property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the IP address of the node diagnosed.
        """
        return pulumi.get(self, "node_ip")

    @node_ip.setter
    def node_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_ip", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the node role. The value can be **master** or **slave**.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgsDict(TypedDict):
        command_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgsDict']]]]
        """
        Indicates the command execution latency statistics.
        The command_list structure is documented below.
        """
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error code for the diagnosis item.
        """
        result: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
        total_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the total number of times that commands are executed.
        """
        total_usec_sum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Indicates the total duration of command execution.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgs:
    def __init__(__self__, *,
                 command_lists: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgs']]]] = None,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 result: Optional[pulumi.Input[_builtins.str]] = None,
                 total_num: Optional[pulumi.Input[_builtins.int]] = None,
                 total_usec_sum: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgs']]] command_lists: Indicates the command execution latency statistics.
               The command_list structure is documented below.
        :param pulumi.Input[_builtins.str] error_code: Indicates the error code for the diagnosis item.
        :param pulumi.Input[_builtins.str] result: Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        :param pulumi.Input[_builtins.int] total_num: Indicates the total number of times that commands are executed.
        :param pulumi.Input[_builtins.float] total_usec_sum: Indicates the total duration of command execution.
        """
        if command_lists is not None:
            pulumi.set(__self__, "command_lists", command_lists)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if result is not None:
            pulumi.set(__self__, "result", result)
        if total_num is not None:
            pulumi.set(__self__, "total_num", total_num)
        if total_usec_sum is not None:
            pulumi.set(__self__, "total_usec_sum", total_usec_sum)

    @_builtins.property
    @pulumi.getter(name="commandLists")
    def command_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgs']]]]:
        """
        Indicates the command execution latency statistics.
        The command_list structure is documented below.
        """
        return pulumi.get(self, "command_lists")

    @command_lists.setter
    def command_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgs']]]]):
        pulumi.set(self, "command_lists", value)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error code for the diagnosis item.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)

    @_builtins.property
    @pulumi.getter(name="totalNum")
    def total_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the total number of times that commands are executed.
        """
        return pulumi.get(self, "total_num")

    @total_num.setter
    def total_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_num", value)

    @_builtins.property
    @pulumi.getter(name="totalUsecSum")
    def total_usec_sum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Indicates the total duration of command execution.
        """
        return pulumi.get(self, "total_usec_sum")

    @total_usec_sum.setter
    def total_usec_sum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "total_usec_sum", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgsDict(TypedDict):
        average_usec: NotRequired[pulumi.Input[_builtins.float]]
        """
        Indicates the average duration of calls.
        """
        calls_sum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the number of calls.
        """
        command_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the command name.
        """
        per_usec: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the duration percentage.
        """
        usec_sum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Indicates the total time consumed.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgs:
    def __init__(__self__, *,
                 average_usec: Optional[pulumi.Input[_builtins.float]] = None,
                 calls_sum: Optional[pulumi.Input[_builtins.int]] = None,
                 command_name: Optional[pulumi.Input[_builtins.str]] = None,
                 per_usec: Optional[pulumi.Input[_builtins.str]] = None,
                 usec_sum: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] average_usec: Indicates the average duration of calls.
        :param pulumi.Input[_builtins.int] calls_sum: Indicates the number of calls.
        :param pulumi.Input[_builtins.str] command_name: Indicates the command name.
        :param pulumi.Input[_builtins.str] per_usec: Indicates the duration percentage.
        :param pulumi.Input[_builtins.float] usec_sum: Indicates the total time consumed.
        """
        if average_usec is not None:
            pulumi.set(__self__, "average_usec", average_usec)
        if calls_sum is not None:
            pulumi.set(__self__, "calls_sum", calls_sum)
        if command_name is not None:
            pulumi.set(__self__, "command_name", command_name)
        if per_usec is not None:
            pulumi.set(__self__, "per_usec", per_usec)
        if usec_sum is not None:
            pulumi.set(__self__, "usec_sum", usec_sum)

    @_builtins.property
    @pulumi.getter(name="averageUsec")
    def average_usec(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Indicates the average duration of calls.
        """
        return pulumi.get(self, "average_usec")

    @average_usec.setter
    def average_usec(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "average_usec", value)

    @_builtins.property
    @pulumi.getter(name="callsSum")
    def calls_sum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the number of calls.
        """
        return pulumi.get(self, "calls_sum")

    @calls_sum.setter
    def calls_sum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "calls_sum", value)

    @_builtins.property
    @pulumi.getter(name="commandName")
    def command_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the command name.
        """
        return pulumi.get(self, "command_name")

    @command_name.setter
    def command_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command_name", value)

    @_builtins.property
    @pulumi.getter(name="perUsec")
    def per_usec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the duration percentage.
        """
        return pulumi.get(self, "per_usec")

    @per_usec.setter
    def per_usec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "per_usec", value)

    @_builtins.property
    @pulumi.getter(name="usecSum")
    def usec_sum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Indicates the total time consumed.
        """
        return pulumi.get(self, "usec_sum")

    @usec_sum.setter
    def usec_sum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "usec_sum", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgsDict(TypedDict):
        abnormal_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the total number of abnormal diagnosis items.
        """
        diagnosis_item_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgsDict']]]]
        """
        Indicates the diagnosis items.
        The diagnosis_item_list structure is documented below.
        """
        failed_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the total number of failed diagnosis items.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the diagnosis item name.
        The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
        **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgs:
    def __init__(__self__, *,
                 abnormal_num: Optional[pulumi.Input[_builtins.int]] = None,
                 diagnosis_item_lists: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgs']]]] = None,
                 failed_num: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] abnormal_num: Indicates the total number of abnormal diagnosis items.
        :param pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgs']]] diagnosis_item_lists: Indicates the diagnosis items.
               The diagnosis_item_list structure is documented below.
        :param pulumi.Input[_builtins.int] failed_num: Indicates the total number of failed diagnosis items.
        :param pulumi.Input[_builtins.str] name: Indicates the diagnosis item name.
               The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
               **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
        if abnormal_num is not None:
            pulumi.set(__self__, "abnormal_num", abnormal_num)
        if diagnosis_item_lists is not None:
            pulumi.set(__self__, "diagnosis_item_lists", diagnosis_item_lists)
        if failed_num is not None:
            pulumi.set(__self__, "failed_num", failed_num)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="abnormalNum")
    def abnormal_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the total number of abnormal diagnosis items.
        """
        return pulumi.get(self, "abnormal_num")

    @abnormal_num.setter
    def abnormal_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "abnormal_num", value)

    @_builtins.property
    @pulumi.getter(name="diagnosisItemLists")
    def diagnosis_item_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgs']]]]:
        """
        Indicates the diagnosis items.
        The diagnosis_item_list structure is documented below.
        """
        return pulumi.get(self, "diagnosis_item_lists")

    @diagnosis_item_lists.setter
    def diagnosis_item_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgs']]]]):
        pulumi.set(self, "diagnosis_item_lists", value)

    @_builtins.property
    @pulumi.getter(name="failedNum")
    def failed_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the total number of failed diagnosis items.
        """
        return pulumi.get(self, "failed_num")

    @failed_num.setter
    def failed_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failed_num", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the diagnosis item name.
        The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
        **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgsDict(TypedDict):
        advice_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict']]]]
        """
        Indicates the list of suggestion IDs.
        The advice_ids structure is documented below.
        """
        cause_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict']]]]
        """
        Indicates the list of cause IDs.
        The cause_ids structure is documented below.
        """
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error code for the diagnosis item.
        """
        impact_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgsDict']]]]
        """
        Indicates the list of impact IDs.
        The impact_ids structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the diagnosis item name.
        The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
        **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
        result: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgs:
    def __init__(__self__, *,
                 advice_ids: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]]] = None,
                 cause_ids: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]]] = None,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 impact_ids: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 result: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]] advice_ids: Indicates the list of suggestion IDs.
               The advice_ids structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]] cause_ids: Indicates the list of cause IDs.
               The cause_ids structure is documented below.
        :param pulumi.Input[_builtins.str] error_code: Indicates the error code for the diagnosis item.
        :param pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgs']]] impact_ids: Indicates the list of impact IDs.
               The impact_ids structure is documented below.
        :param pulumi.Input[_builtins.str] name: Indicates the diagnosis item name.
               The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
               **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        :param pulumi.Input[_builtins.str] result: Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
        if advice_ids is not None:
            pulumi.set(__self__, "advice_ids", advice_ids)
        if cause_ids is not None:
            pulumi.set(__self__, "cause_ids", cause_ids)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if impact_ids is not None:
            pulumi.set(__self__, "impact_ids", impact_ids)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter(name="adviceIds")
    def advice_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]]]:
        """
        Indicates the list of suggestion IDs.
        The advice_ids structure is documented below.
        """
        return pulumi.get(self, "advice_ids")

    @advice_ids.setter
    def advice_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]]]):
        pulumi.set(self, "advice_ids", value)

    @_builtins.property
    @pulumi.getter(name="causeIds")
    def cause_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]]]:
        """
        Indicates the list of cause IDs.
        The cause_ids structure is documented below.
        """
        return pulumi.get(self, "cause_ids")

    @cause_ids.setter
    def cause_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]]]):
        pulumi.set(self, "cause_ids", value)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error code for the diagnosis item.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="impactIds")
    def impact_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgs']]]]:
        """
        Indicates the list of impact IDs.
        The impact_ids structure is documented below.
        """
        return pulumi.get(self, "impact_ids")

    @impact_ids.setter
    def impact_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgs']]]]):
        pulumi.set(self, "impact_ids", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the diagnosis item name.
        The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
        **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the conclusion ID.
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Indicates the conclusion parameters.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Indicates the conclusion ID.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Indicates the conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the conclusion ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Indicates the conclusion parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the conclusion ID.
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Indicates the conclusion parameters.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Indicates the conclusion ID.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Indicates the conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the conclusion ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Indicates the conclusion parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)


if not MYPY:
    class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the conclusion ID.
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Indicates the conclusion parameters.
        """
elif False:
    DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Indicates the conclusion ID.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Indicates the conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the conclusion ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Indicates the conclusion parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)


if not MYPY:
    class HotkeyAnalysisKeyArgsDict(TypedDict):
        db: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the database where the hot key is located.
        """
        freq: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the access frequency of a key within a specific period of time.
        The value is the logarithmic access frequency counter. The maximum value is 255, which indicates 1 million access requests.
        After the frequency reaches 255, the value will no longer increase even if access requests continue to increase.
        The value will decrease by 1 for every minute during which the key is not accessed.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of hot key.
        """
        shard: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the shard where the hot key is located.
        This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the size of the key value.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the type of hot key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the unit of hot key. The value can be:
        + **count**: The number of keys.
        + **byte**: The size of key.
        """
elif False:
    HotkeyAnalysisKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HotkeyAnalysisKeyArgs:
    def __init__(__self__, *,
                 db: Optional[pulumi.Input[_builtins.int]] = None,
                 freq: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 shard: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] db: Indicates the database where the hot key is located.
        :param pulumi.Input[_builtins.int] freq: Indicates the access frequency of a key within a specific period of time.
               The value is the logarithmic access frequency counter. The maximum value is 255, which indicates 1 million access requests.
               After the frequency reaches 255, the value will no longer increase even if access requests continue to increase.
               The value will decrease by 1 for every minute during which the key is not accessed.
        :param pulumi.Input[_builtins.str] name: Indicates the name of hot key.
        :param pulumi.Input[_builtins.str] shard: Indicates the shard where the hot key is located.
               This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        :param pulumi.Input[_builtins.int] size: Indicates the size of the key value.
        :param pulumi.Input[_builtins.str] type: Indicates the type of hot key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        :param pulumi.Input[_builtins.str] unit: Indicates the unit of hot key. The value can be:
               + **count**: The number of keys.
               + **byte**: The size of key.
        """
        if db is not None:
            pulumi.set(__self__, "db", db)
        if freq is not None:
            pulumi.set(__self__, "freq", freq)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def db(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the database where the hot key is located.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "db", value)

    @_builtins.property
    @pulumi.getter
    def freq(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the access frequency of a key within a specific period of time.
        The value is the logarithmic access frequency counter. The maximum value is 255, which indicates 1 million access requests.
        After the frequency reaches 255, the value will no longer increase even if access requests continue to increase.
        The value will decrease by 1 for every minute during which the key is not accessed.
        """
        return pulumi.get(self, "freq")

    @freq.setter
    def freq(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "freq", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of hot key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def shard(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the shard where the hot key is located.
        This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        """
        return pulumi.get(self, "shard")

    @shard.setter
    def shard(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shard", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the size of the key value.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the type of hot key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the unit of hot key. The value can be:
        + **count**: The number of keys.
        + **byte**: The size of key.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class InstanceBackupPolicyArgsDict(TypedDict):
        backup_ats: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        Day in a week on which backup starts, the value ranges from `1` to `7`.
        Where: 1 indicates Monday; 7 indicates Sunday.
        """
        begin_at: pulumi.Input[_builtins.str]
        """
        Time at which backup starts.
        Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.

        <a name="DcsInstance_Parameters"></a>
        The `parameters` block supports:
        """
        backup_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Backup type. Default value is `auto`. The valid values are as follows:
        """
        period_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interval at which backup is performed. Default value is `weekly`.
        Currently, only weekly backup is supported.
        """
        save_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Retention time. Unit: day, the value ranges from `1` to `7`.
        This parameter is required if the backup_type is **auto**.
        """
elif False:
    InstanceBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceBackupPolicyArgs:
    def __init__(__self__, *,
                 backup_ats: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 begin_at: pulumi.Input[_builtins.str],
                 backup_type: Optional[pulumi.Input[_builtins.str]] = None,
                 period_type: Optional[pulumi.Input[_builtins.str]] = None,
                 save_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] backup_ats: Day in a week on which backup starts, the value ranges from `1` to `7`.
               Where: 1 indicates Monday; 7 indicates Sunday.
        :param pulumi.Input[_builtins.str] begin_at: Time at which backup starts.
               Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.
               
               <a name="DcsInstance_Parameters"></a>
               The `parameters` block supports:
        :param pulumi.Input[_builtins.str] backup_type: Backup type. Default value is `auto`. The valid values are as follows:
        :param pulumi.Input[_builtins.str] period_type: Interval at which backup is performed. Default value is `weekly`.
               Currently, only weekly backup is supported.
        :param pulumi.Input[_builtins.int] save_days: Retention time. Unit: day, the value ranges from `1` to `7`.
               This parameter is required if the backup_type is **auto**.
        """
        pulumi.set(__self__, "backup_ats", backup_ats)
        pulumi.set(__self__, "begin_at", begin_at)
        if backup_type is not None:
            pulumi.set(__self__, "backup_type", backup_type)
        if period_type is not None:
            pulumi.set(__self__, "period_type", period_type)
        if save_days is not None:
            pulumi.set(__self__, "save_days", save_days)

    @_builtins.property
    @pulumi.getter(name="backupAts")
    def backup_ats(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        Day in a week on which backup starts, the value ranges from `1` to `7`.
        Where: 1 indicates Monday; 7 indicates Sunday.
        """
        return pulumi.get(self, "backup_ats")

    @backup_ats.setter
    def backup_ats(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "backup_ats", value)

    @_builtins.property
    @pulumi.getter(name="beginAt")
    def begin_at(self) -> pulumi.Input[_builtins.str]:
        """
        Time at which backup starts.
        Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.

        <a name="DcsInstance_Parameters"></a>
        The `parameters` block supports:
        """
        return pulumi.get(self, "begin_at")

    @begin_at.setter
    def begin_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "begin_at", value)

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Backup type. Default value is `auto`. The valid values are as follows:
        """
        return pulumi.get(self, "backup_type")

    @backup_type.setter
    def backup_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_type", value)

    @_builtins.property
    @pulumi.getter(name="periodType")
    def period_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interval at which backup is performed. Default value is `weekly`.
        Currently, only weekly backup is supported.
        """
        return pulumi.get(self, "period_type")

    @period_type.setter
    def period_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "period_type", value)

    @_builtins.property
    @pulumi.getter(name="saveDays")
    def save_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Retention time. Unit: day, the value ranges from `1` to `7`.
        This parameter is required if the backup_type is **auto**.
        """
        return pulumi.get(self, "save_days")

    @save_days.setter
    def save_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "save_days", value)


if not MYPY:
    class InstanceBandwidthInfoArgsDict(TypedDict):
        bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the bandwidth size, the unit is **GB**.
        """
        begin_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the begin time of temporary increase.
        """
        current_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the current time.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the end time of temporary increase.
        """
        expand_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the number of increases.
        """
        expand_effect_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the interval between temporary increases, the unit is **ms**.
        """
        expand_interval_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the time interval to the next increase, the unit is **ms**.
        """
        max_expand_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the maximum number of increases.
        """
        next_expand_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the next increase time.
        """
        task_running: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the increase task is running.
        """
elif False:
    InstanceBandwidthInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceBandwidthInfoArgs:
    def __init__(__self__, *,
                 bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 begin_time: Optional[pulumi.Input[_builtins.str]] = None,
                 current_time: Optional[pulumi.Input[_builtins.str]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 expand_count: Optional[pulumi.Input[_builtins.int]] = None,
                 expand_effect_time: Optional[pulumi.Input[_builtins.int]] = None,
                 expand_interval_time: Optional[pulumi.Input[_builtins.int]] = None,
                 max_expand_count: Optional[pulumi.Input[_builtins.int]] = None,
                 next_expand_time: Optional[pulumi.Input[_builtins.str]] = None,
                 task_running: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] bandwidth: Indicates the bandwidth size, the unit is **GB**.
        :param pulumi.Input[_builtins.str] begin_time: Indicates the begin time of temporary increase.
        :param pulumi.Input[_builtins.str] current_time: Indicates the current time.
        :param pulumi.Input[_builtins.str] end_time: Indicates the end time of temporary increase.
        :param pulumi.Input[_builtins.int] expand_count: Indicates the number of increases.
        :param pulumi.Input[_builtins.int] expand_effect_time: Indicates the interval between temporary increases, the unit is **ms**.
        :param pulumi.Input[_builtins.int] expand_interval_time: Indicates the time interval to the next increase, the unit is **ms**.
        :param pulumi.Input[_builtins.int] max_expand_count: Indicates the maximum number of increases.
        :param pulumi.Input[_builtins.str] next_expand_time: Indicates the next increase time.
        :param pulumi.Input[_builtins.bool] task_running: Indicates whether the increase task is running.
        """
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if begin_time is not None:
            pulumi.set(__self__, "begin_time", begin_time)
        if current_time is not None:
            pulumi.set(__self__, "current_time", current_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if expand_count is not None:
            pulumi.set(__self__, "expand_count", expand_count)
        if expand_effect_time is not None:
            pulumi.set(__self__, "expand_effect_time", expand_effect_time)
        if expand_interval_time is not None:
            pulumi.set(__self__, "expand_interval_time", expand_interval_time)
        if max_expand_count is not None:
            pulumi.set(__self__, "max_expand_count", max_expand_count)
        if next_expand_time is not None:
            pulumi.set(__self__, "next_expand_time", next_expand_time)
        if task_running is not None:
            pulumi.set(__self__, "task_running", task_running)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the bandwidth size, the unit is **GB**.
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the begin time of temporary increase.
        """
        return pulumi.get(self, "begin_time")

    @begin_time.setter
    def begin_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "begin_time", value)

    @_builtins.property
    @pulumi.getter(name="currentTime")
    def current_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the current time.
        """
        return pulumi.get(self, "current_time")

    @current_time.setter
    def current_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the end time of temporary increase.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="expandCount")
    def expand_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the number of increases.
        """
        return pulumi.get(self, "expand_count")

    @expand_count.setter
    def expand_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expand_count", value)

    @_builtins.property
    @pulumi.getter(name="expandEffectTime")
    def expand_effect_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the interval between temporary increases, the unit is **ms**.
        """
        return pulumi.get(self, "expand_effect_time")

    @expand_effect_time.setter
    def expand_effect_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expand_effect_time", value)

    @_builtins.property
    @pulumi.getter(name="expandIntervalTime")
    def expand_interval_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the time interval to the next increase, the unit is **ms**.
        """
        return pulumi.get(self, "expand_interval_time")

    @expand_interval_time.setter
    def expand_interval_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expand_interval_time", value)

    @_builtins.property
    @pulumi.getter(name="maxExpandCount")
    def max_expand_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the maximum number of increases.
        """
        return pulumi.get(self, "max_expand_count")

    @max_expand_count.setter
    def max_expand_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_expand_count", value)

    @_builtins.property
    @pulumi.getter(name="nextExpandTime")
    def next_expand_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the next increase time.
        """
        return pulumi.get(self, "next_expand_time")

    @next_expand_time.setter
    def next_expand_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_expand_time", value)

    @_builtins.property
    @pulumi.getter(name="taskRunning")
    def task_running(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the increase task is running.
        """
        return pulumi.get(self, "task_running")

    @task_running.setter
    def task_running(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "task_running", value)


if not MYPY:
    class InstanceParameterArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        A resource ID in UUID format.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of an instance.
        The name must be 4 to 64 characters and start with a letter.
        Only chinese, letters (case-insensitive), digits, underscores (_) ,and hyphens (-) are allowed.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value of the configuration item.
        """
elif False:
    InstanceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceParameterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: A resource ID in UUID format.
        :param pulumi.Input[_builtins.str] name: Specifies the name of an instance.
               The name must be 4 to 64 characters and start with a letter.
               Only chinese, letters (case-insensitive), digits, underscores (_) ,and hyphens (-) are allowed.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the configuration item.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        A resource ID in UUID format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of an instance.
        The name must be 4 to 64 characters and start with a letter.
        Only chinese, letters (case-insensitive), digits, underscores (_) ,and hyphens (-) are allowed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value of the configuration item.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InstancePublicAccessElbListenerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the ID of the listener.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of the listener.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the port of the listener.
        """
elif False:
    InstancePublicAccessElbListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePublicAccessElbListenerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Indicates the ID of the listener.
        :param pulumi.Input[_builtins.str] name: Indicates the name of the listener.
        :param pulumi.Input[_builtins.int] port: Indicates the port of the listener.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the ID of the listener.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of the listener.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the port of the listener.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class InstanceV1BackupPolicyArgsDict(TypedDict):
        backup_ats: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        begin_at: pulumi.Input[_builtins.str]
        backup_type: NotRequired[pulumi.Input[_builtins.str]]
        period_type: NotRequired[pulumi.Input[_builtins.str]]
        save_days: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    InstanceV1BackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceV1BackupPolicyArgs:
    def __init__(__self__, *,
                 backup_ats: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 begin_at: pulumi.Input[_builtins.str],
                 backup_type: Optional[pulumi.Input[_builtins.str]] = None,
                 period_type: Optional[pulumi.Input[_builtins.str]] = None,
                 save_days: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "backup_ats", backup_ats)
        pulumi.set(__self__, "begin_at", begin_at)
        if backup_type is not None:
            pulumi.set(__self__, "backup_type", backup_type)
        if period_type is not None:
            pulumi.set(__self__, "period_type", period_type)
        if save_days is not None:
            pulumi.set(__self__, "save_days", save_days)

    @_builtins.property
    @pulumi.getter(name="backupAts")
    def backup_ats(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "backup_ats")

    @backup_ats.setter
    def backup_ats(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "backup_ats", value)

    @_builtins.property
    @pulumi.getter(name="beginAt")
    def begin_at(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "begin_at")

    @begin_at.setter
    def begin_at(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "begin_at", value)

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "backup_type")

    @backup_type.setter
    def backup_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_type", value)

    @_builtins.property
    @pulumi.getter(name="periodType")
    def period_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "period_type")

    @period_type.setter
    def period_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "period_type", value)

    @_builtins.property
    @pulumi.getter(name="saveDays")
    def save_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "save_days")

    @save_days.setter
    def save_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "save_days", value)


if not MYPY:
    class InstanceV1BandwidthInfoArgsDict(TypedDict):
        bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        begin_time: NotRequired[pulumi.Input[_builtins.str]]
        current_time: NotRequired[pulumi.Input[_builtins.str]]
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        expand_count: NotRequired[pulumi.Input[_builtins.int]]
        expand_effect_time: NotRequired[pulumi.Input[_builtins.int]]
        expand_interval_time: NotRequired[pulumi.Input[_builtins.int]]
        max_expand_count: NotRequired[pulumi.Input[_builtins.int]]
        next_expand_time: NotRequired[pulumi.Input[_builtins.str]]
        task_running: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    InstanceV1BandwidthInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceV1BandwidthInfoArgs:
    def __init__(__self__, *,
                 bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 begin_time: Optional[pulumi.Input[_builtins.str]] = None,
                 current_time: Optional[pulumi.Input[_builtins.str]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 expand_count: Optional[pulumi.Input[_builtins.int]] = None,
                 expand_effect_time: Optional[pulumi.Input[_builtins.int]] = None,
                 expand_interval_time: Optional[pulumi.Input[_builtins.int]] = None,
                 max_expand_count: Optional[pulumi.Input[_builtins.int]] = None,
                 next_expand_time: Optional[pulumi.Input[_builtins.str]] = None,
                 task_running: Optional[pulumi.Input[_builtins.bool]] = None):
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if begin_time is not None:
            pulumi.set(__self__, "begin_time", begin_time)
        if current_time is not None:
            pulumi.set(__self__, "current_time", current_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if expand_count is not None:
            pulumi.set(__self__, "expand_count", expand_count)
        if expand_effect_time is not None:
            pulumi.set(__self__, "expand_effect_time", expand_effect_time)
        if expand_interval_time is not None:
            pulumi.set(__self__, "expand_interval_time", expand_interval_time)
        if max_expand_count is not None:
            pulumi.set(__self__, "max_expand_count", max_expand_count)
        if next_expand_time is not None:
            pulumi.set(__self__, "next_expand_time", next_expand_time)
        if task_running is not None:
            pulumi.set(__self__, "task_running", task_running)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "begin_time")

    @begin_time.setter
    def begin_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "begin_time", value)

    @_builtins.property
    @pulumi.getter(name="currentTime")
    def current_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "current_time")

    @current_time.setter
    def current_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="expandCount")
    def expand_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "expand_count")

    @expand_count.setter
    def expand_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expand_count", value)

    @_builtins.property
    @pulumi.getter(name="expandEffectTime")
    def expand_effect_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "expand_effect_time")

    @expand_effect_time.setter
    def expand_effect_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expand_effect_time", value)

    @_builtins.property
    @pulumi.getter(name="expandIntervalTime")
    def expand_interval_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "expand_interval_time")

    @expand_interval_time.setter
    def expand_interval_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expand_interval_time", value)

    @_builtins.property
    @pulumi.getter(name="maxExpandCount")
    def max_expand_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_expand_count")

    @max_expand_count.setter
    def max_expand_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_expand_count", value)

    @_builtins.property
    @pulumi.getter(name="nextExpandTime")
    def next_expand_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "next_expand_time")

    @next_expand_time.setter
    def next_expand_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_expand_time", value)

    @_builtins.property
    @pulumi.getter(name="taskRunning")
    def task_running(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "task_running")

    @task_running.setter
    def task_running(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "task_running", value)


if not MYPY:
    class InstanceV1ParameterArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    InstanceV1ParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceV1ParameterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InstanceV1WhitelistArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        ip_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    InstanceV1WhitelistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceV1WhitelistArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 ip_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class InstanceWhitelistArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of IP address group.
        """
        ip_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of IP address or CIDR which can be whitelisted for an instance.
        The maximum is 20.
        """
elif False:
    InstanceWhitelistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceWhitelistArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 ip_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] group_name: Specifies the name of IP address group.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_addresses: Specifies the list of IP address or CIDR which can be whitelisted for an instance.
               The maximum is 20.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of IP address group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of IP address or CIDR which can be whitelisted for an instance.
        The maximum is 20.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class OnlineDataMigrationTaskSourceInstanceArgsDict(TypedDict):
        addrs: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Redis address. It is mandatory if `id` is not specified.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the Redis name.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
elif False:
    OnlineDataMigrationTaskSourceInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineDataMigrationTaskSourceInstanceArgs:
    def __init__(__self__, *,
                 addrs: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] addrs: Specifies the Redis address. It is mandatory if `id` is not specified.
        :param pulumi.Input[_builtins.str] id: Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        :param pulumi.Input[_builtins.str] name: Indicates the Redis name.
        :param pulumi.Input[_builtins.str] password: Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        if addrs is not None:
            pulumi.set(__self__, "addrs", addrs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def addrs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Redis address. It is mandatory if `id` is not specified.
        """
        return pulumi.get(self, "addrs")

    @addrs.setter
    def addrs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "addrs", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the Redis name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class OnlineDataMigrationTaskTargetInstanceArgsDict(TypedDict):
        addrs: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Redis address. It is mandatory if `id` is not specified.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the Redis name.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
elif False:
    OnlineDataMigrationTaskTargetInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineDataMigrationTaskTargetInstanceArgs:
    def __init__(__self__, *,
                 addrs: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] addrs: Specifies the Redis address. It is mandatory if `id` is not specified.
        :param pulumi.Input[_builtins.str] id: Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        :param pulumi.Input[_builtins.str] name: Indicates the Redis name.
        :param pulumi.Input[_builtins.str] password: Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        if addrs is not None:
            pulumi.set(__self__, "addrs", addrs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def addrs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Redis address. It is mandatory if `id` is not specified.
        """
        return pulumi.get(self, "addrs")

    @addrs.setter
    def addrs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "addrs", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the Redis name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class GetTemplateDetailParamArgsDict(TypedDict):
        default_value: _builtins.str
        """
        Indicates the default of the param.
        """
        description: _builtins.str
        """
        Indicates the description of the param.
        """
        need_restart: _builtins.bool
        """
        Indicates whether the DCS instance need restart.
        """
        param_id: _builtins.str
        """
        Indicates the ID of the param.
        """
        param_name: _builtins.str
        """
        Specifies the name of the param.
        """
        value_range: _builtins.str
        """
        Indicates the value range of the param.
        """
        value_type: _builtins.str
        """
        Indicates the value type of the param.
        """
elif False:
    GetTemplateDetailParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTemplateDetailParamArgs:
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 description: _builtins.str,
                 need_restart: _builtins.bool,
                 param_id: _builtins.str,
                 param_name: _builtins.str,
                 value_range: _builtins.str,
                 value_type: _builtins.str):
        """
        :param _builtins.str default_value: Indicates the default of the param.
        :param _builtins.str description: Indicates the description of the param.
        :param _builtins.bool need_restart: Indicates whether the DCS instance need restart.
        :param _builtins.str param_id: Indicates the ID of the param.
        :param _builtins.str param_name: Specifies the name of the param.
        :param _builtins.str value_range: Indicates the value range of the param.
        :param _builtins.str value_type: Indicates the value type of the param.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "need_restart", need_restart)
        pulumi.set(__self__, "param_id", param_id)
        pulumi.set(__self__, "param_name", param_name)
        pulumi.set(__self__, "value_range", value_range)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        Indicates the default of the param.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: _builtins.str):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the param.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: _builtins.str):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="needRestart")
    def need_restart(self) -> _builtins.bool:
        """
        Indicates whether the DCS instance need restart.
        """
        return pulumi.get(self, "need_restart")

    @need_restart.setter
    def need_restart(self, value: _builtins.bool):
        pulumi.set(self, "need_restart", value)

    @_builtins.property
    @pulumi.getter(name="paramId")
    def param_id(self) -> _builtins.str:
        """
        Indicates the ID of the param.
        """
        return pulumi.get(self, "param_id")

    @param_id.setter
    def param_id(self, value: _builtins.str):
        pulumi.set(self, "param_id", value)

    @_builtins.property
    @pulumi.getter(name="paramName")
    def param_name(self) -> _builtins.str:
        """
        Specifies the name of the param.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: _builtins.str):
        pulumi.set(self, "param_name", value)

    @_builtins.property
    @pulumi.getter(name="valueRange")
    def value_range(self) -> _builtins.str:
        """
        Indicates the value range of the param.
        """
        return pulumi.get(self, "value_range")

    @value_range.setter
    def value_range(self, value: _builtins.str):
        pulumi.set(self, "value_range", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> _builtins.str:
        """
        Indicates the value type of the param.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: _builtins.str):
        pulumi.set(self, "value_type", value)


