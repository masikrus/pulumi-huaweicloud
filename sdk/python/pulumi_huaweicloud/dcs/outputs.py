# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BackupImportTaskBackupFiles',
    'BackupImportTaskBackupFilesFile',
    'BackupImportTaskTargetInstance',
    'BigkeyAnalysisKey',
    'CustomTemplateParam',
    'DiagnosisTaskDiagnosisNodeReportList',
    'DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenList',
    'DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandList',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionList',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemList',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceId',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseId',
    'DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactId',
    'HotkeyAnalysisKey',
    'InstanceBackupPolicy',
    'InstanceBandwidthInfo',
    'InstanceParameter',
    'InstancePublicAccessElbListener',
    'InstanceV1BackupPolicy',
    'InstanceV1BandwidthInfo',
    'InstanceV1Parameter',
    'InstanceV1Whitelist',
    'InstanceWhitelist',
    'OnlineDataMigrationTaskSourceInstance',
    'OnlineDataMigrationTaskTargetInstance',
    'GetAccountsAccountResult',
    'GetBackupsBackupResult',
    'GetBigkeyAnalysesRecordResult',
    'GetDiagnosisTasksDiagnosisTaskResult',
    'GetFlavorsFlavorResult',
    'GetHotkeyAnalysesRecordResult',
    'GetInstanceExpiredKeyScanHistoriesRecordResult',
    'GetInstanceNodesNodeResult',
    'GetInstanceNodesNodeDimensionResult',
    'GetInstanceShardsGroupListResult',
    'GetInstanceShardsGroupListReplicationListResult',
    'GetInstanceShardsGroupListReplicationListDimensionResult',
    'GetInstancesInstanceResult',
    'GetMigrationTaskLogsMigrationLogResult',
    'GetMigrationTasksMigrationTaskResult',
    'GetQuotasQuotaResult',
    'GetQuotasQuotaResourceResult',
    'GetTemplateDetailParamResult',
    'GetTemplatesTemplateResult',
]

@pulumi.output_type
class BackupImportTaskBackupFiles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSource":
            suggest = "file_source"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupImportTaskBackupFiles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupImportTaskBackupFiles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupImportTaskBackupFiles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_source: _builtins.str,
                 backup_id: Optional[_builtins.str] = None,
                 bucket_name: Optional[_builtins.str] = None,
                 files: Optional[Sequence['outputs.BackupImportTaskBackupFilesFile']] = None):
        """
        :param _builtins.str file_source: Specifies the data source, which can be an OBS bucket or a backup
               record. Value options:
               + **self_build_obs**: OBS bucket
               + **backup_record**: backup record
        :param _builtins.str backup_id: Specifies the backup record ID. It is mandatory when `file_source` is
               **backup_record**.
               
               <a name="files_struct"></a>
               The `files` block supports:
        :param _builtins.str bucket_name: Specifies the OBS bucket name. It is mandatory when `file_source`
               is **self_build_obs**.
        :param Sequence['BackupImportTaskBackupFilesFileArgs'] files: Specifies the list of backup files to be imported. It is mandatory when
               `file_source` is **self_build_obs**.
               The files structure is documented below.
        """
        pulumi.set(__self__, "file_source", file_source)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if files is not None:
            pulumi.set(__self__, "files", files)

    @_builtins.property
    @pulumi.getter(name="fileSource")
    def file_source(self) -> _builtins.str:
        """
        Specifies the data source, which can be an OBS bucket or a backup
        record. Value options:
        + **self_build_obs**: OBS bucket
        + **backup_record**: backup record
        """
        return pulumi.get(self, "file_source")

    @_builtins.property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[_builtins.str]:
        """
        Specifies the backup record ID. It is mandatory when `file_source` is
        **backup_record**.

        <a name="files_struct"></a>
        The `files` block supports:
        """
        return pulumi.get(self, "backup_id")

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        Specifies the OBS bucket name. It is mandatory when `file_source`
        is **self_build_obs**.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[Sequence['outputs.BackupImportTaskBackupFilesFile']]:
        """
        Specifies the list of backup files to be imported. It is mandatory when
        `file_source` is **self_build_obs**.
        The files structure is documented below.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class BackupImportTaskBackupFilesFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"
        elif key == "updateAt":
            suggest = "update_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupImportTaskBackupFilesFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupImportTaskBackupFilesFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupImportTaskBackupFilesFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_name: _builtins.str,
                 size: Optional[_builtins.str] = None,
                 update_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str file_name: Specifies the name of a backup file.
        :param _builtins.str size: Specifies the file size in bytes.
        :param _builtins.str update_at: Specifies the time when the file was last modified. The format is
               **YYYY-MM-DDTHH:MM:SS**.
               
               <a name="target_instance_struct"></a>
               The `target_instance` block supports:
        """
        pulumi.set(__self__, "file_name", file_name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if update_at is not None:
            pulumi.set(__self__, "update_at", update_at)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        """
        Specifies the name of a backup file.
        """
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        Specifies the file size in bytes.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> Optional[_builtins.str]:
        """
        Specifies the time when the file was last modified. The format is
        **YYYY-MM-DDTHH:MM:SS**.

        <a name="target_instance_struct"></a>
        The `target_instance` block supports:
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class BackupImportTaskTargetInstance(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Specifies the Redis instance ID.
        :param _builtins.str name: Indicates the Redis name.
        :param _builtins.str password: Specifies the Redis password. If a password of the DCS instance is set,
               it is mandatory.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Specifies the Redis instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the Redis name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Specifies the Redis password. If a password of the DCS instance is set,
        it is mandatory.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class BigkeyAnalysisKey(dict):
    def __init__(__self__, *,
                 db: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 shard: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.int db: Indicates the database where the big key is located.
        :param _builtins.str name: Indicates the name of the big key.
        :param _builtins.str shard: Indicates the shard where the big key is located.
               This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        :param _builtins.int size: Indicates the size of the key value.
        :param _builtins.str type: Indicates the type of the big key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        :param _builtins.str unit: Indicates the unit of the big key. The value can be:
               + **count**: The number of keys.
               + **byte**: The size of key.
        """
        if db is not None:
            pulumi.set(__self__, "db", db)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def db(self) -> Optional[_builtins.int]:
        """
        Indicates the database where the big key is located.
        """
        return pulumi.get(self, "db")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the name of the big key.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def shard(self) -> Optional[_builtins.str]:
        """
        Indicates the shard where the big key is located.
        This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        """
        return pulumi.get(self, "shard")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Indicates the size of the key value.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Indicates the type of the big key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Indicates the unit of the big key. The value can be:
        + **count**: The number of keys.
        + **byte**: The size of key.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class CustomTemplateParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramName":
            suggest = "param_name"
        elif key == "paramValue":
            suggest = "param_value"
        elif key == "defaultValue":
            suggest = "default_value"
        elif key == "needRestart":
            suggest = "need_restart"
        elif key == "paramId":
            suggest = "param_id"
        elif key == "valueRange":
            suggest = "value_range"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomTemplateParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomTemplateParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomTemplateParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_name: _builtins.str,
                 param_value: _builtins.str,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 need_restart: Optional[_builtins.bool] = None,
                 param_id: Optional[_builtins.str] = None,
                 value_range: Optional[_builtins.str] = None,
                 value_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str param_name: Indicates the name of the param. You can find it through data source
               `dcs_get_template_detail`.
        :param _builtins.str param_value: Indicates the value of the param.
        :param _builtins.str default_value: (Optional, String) Indicates the default value of the param.
        :param _builtins.str description: Specifies the description of the template.
               
               <a name="CustomTemplate_Param"></a>
               The `params` block supports:
        :param _builtins.bool need_restart: (Optional, Bool) Indicates whether the DCS instance need restart.
        :param _builtins.str param_id: (Optional, String) Indicates the ID of the param.
        :param _builtins.str value_range: (Optional, String) Indicates the value range of the param.
        :param _builtins.str value_type: (Optional, String) Indicates the value type of the param.
        """
        pulumi.set(__self__, "param_name", param_name)
        pulumi.set(__self__, "param_value", param_value)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if need_restart is not None:
            pulumi.set(__self__, "need_restart", need_restart)
        if param_id is not None:
            pulumi.set(__self__, "param_id", param_id)
        if value_range is not None:
            pulumi.set(__self__, "value_range", value_range)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter(name="paramName")
    def param_name(self) -> _builtins.str:
        """
        Indicates the name of the param. You can find it through data source
        `dcs_get_template_detail`.
        """
        return pulumi.get(self, "param_name")

    @_builtins.property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> _builtins.str:
        """
        Indicates the value of the param.
        """
        return pulumi.get(self, "param_value")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        """
        (Optional, String) Indicates the default value of the param.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the template.

        <a name="CustomTemplate_Param"></a>
        The `params` block supports:
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="needRestart")
    def need_restart(self) -> Optional[_builtins.bool]:
        """
        (Optional, Bool) Indicates whether the DCS instance need restart.
        """
        return pulumi.get(self, "need_restart")

    @_builtins.property
    @pulumi.getter(name="paramId")
    def param_id(self) -> Optional[_builtins.str]:
        """
        (Optional, String) Indicates the ID of the param.
        """
        return pulumi.get(self, "param_id")

    @_builtins.property
    @pulumi.getter(name="valueRange")
    def value_range(self) -> Optional[_builtins.str]:
        """
        (Optional, String) Indicates the value range of the param.
        """
        return pulumi.get(self, "value_range")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[_builtins.str]:
        """
        (Optional, String) Indicates the value type of the param.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abnormalSum":
            suggest = "abnormal_sum"
        elif key == "azCode":
            suggest = "az_code"
        elif key == "commandTimeTakenLists":
            suggest = "command_time_taken_lists"
        elif key == "diagnosisDimensionLists":
            suggest = "diagnosis_dimension_lists"
        elif key == "failedSum":
            suggest = "failed_sum"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "isFaulted":
            suggest = "is_faulted"
        elif key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosisTaskDiagnosisNodeReportList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosisTaskDiagnosisNodeReportList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosisTaskDiagnosisNodeReportList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abnormal_sum: Optional[_builtins.int] = None,
                 az_code: Optional[_builtins.str] = None,
                 command_time_taken_lists: Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenList']] = None,
                 diagnosis_dimension_lists: Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionList']] = None,
                 failed_sum: Optional[_builtins.int] = None,
                 group_name: Optional[_builtins.str] = None,
                 is_faulted: Optional[_builtins.bool] = None,
                 node_ip: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param _builtins.int abnormal_sum: Indicates the total number of abnormal diagnosis items.
        :param _builtins.str az_code: Indicates the code of the AZ where the node is.
        :param Sequence['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListArgs'] command_time_taken_lists: Indicates the command execution duration list.
               The command_time_taken_list structure is documented below.
        :param Sequence['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListArgs'] diagnosis_dimension_lists: Indicates the diagnosis dimension list.
               The diagnosis_dimension_list structure is documented below.
        :param _builtins.int failed_sum: Indicates the total number of failed diagnosis items.
        :param _builtins.str group_name: Indicates the name of the shard where the node is.
        :param _builtins.bool is_faulted: Indicates whether the node is faulted.
        :param _builtins.str node_ip: Indicates the IP address of the node diagnosed.
        :param _builtins.str role: Indicates the node role. The value can be **master** or **slave**.
        """
        if abnormal_sum is not None:
            pulumi.set(__self__, "abnormal_sum", abnormal_sum)
        if az_code is not None:
            pulumi.set(__self__, "az_code", az_code)
        if command_time_taken_lists is not None:
            pulumi.set(__self__, "command_time_taken_lists", command_time_taken_lists)
        if diagnosis_dimension_lists is not None:
            pulumi.set(__self__, "diagnosis_dimension_lists", diagnosis_dimension_lists)
        if failed_sum is not None:
            pulumi.set(__self__, "failed_sum", failed_sum)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if is_faulted is not None:
            pulumi.set(__self__, "is_faulted", is_faulted)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="abnormalSum")
    def abnormal_sum(self) -> Optional[_builtins.int]:
        """
        Indicates the total number of abnormal diagnosis items.
        """
        return pulumi.get(self, "abnormal_sum")

    @_builtins.property
    @pulumi.getter(name="azCode")
    def az_code(self) -> Optional[_builtins.str]:
        """
        Indicates the code of the AZ where the node is.
        """
        return pulumi.get(self, "az_code")

    @_builtins.property
    @pulumi.getter(name="commandTimeTakenLists")
    def command_time_taken_lists(self) -> Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenList']]:
        """
        Indicates the command execution duration list.
        The command_time_taken_list structure is documented below.
        """
        return pulumi.get(self, "command_time_taken_lists")

    @_builtins.property
    @pulumi.getter(name="diagnosisDimensionLists")
    def diagnosis_dimension_lists(self) -> Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionList']]:
        """
        Indicates the diagnosis dimension list.
        The diagnosis_dimension_list structure is documented below.
        """
        return pulumi.get(self, "diagnosis_dimension_lists")

    @_builtins.property
    @pulumi.getter(name="failedSum")
    def failed_sum(self) -> Optional[_builtins.int]:
        """
        Indicates the total number of failed diagnosis items.
        """
        return pulumi.get(self, "failed_sum")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        Indicates the name of the shard where the node is.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="isFaulted")
    def is_faulted(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the node is faulted.
        """
        return pulumi.get(self, "is_faulted")

    @_builtins.property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[_builtins.str]:
        """
        Indicates the IP address of the node diagnosed.
        """
        return pulumi.get(self, "node_ip")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Indicates the node role. The value can be **master** or **slave**.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandLists":
            suggest = "command_lists"
        elif key == "errorCode":
            suggest = "error_code"
        elif key == "totalNum":
            suggest = "total_num"
        elif key == "totalUsecSum":
            suggest = "total_usec_sum"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_lists: Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandList']] = None,
                 error_code: Optional[_builtins.str] = None,
                 result: Optional[_builtins.str] = None,
                 total_num: Optional[_builtins.int] = None,
                 total_usec_sum: Optional[_builtins.float] = None):
        """
        :param Sequence['DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandListArgs'] command_lists: Indicates the command execution latency statistics.
               The command_list structure is documented below.
        :param _builtins.str error_code: Indicates the error code for the diagnosis item.
        :param _builtins.str result: Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        :param _builtins.int total_num: Indicates the total number of times that commands are executed.
        :param _builtins.float total_usec_sum: Indicates the total duration of command execution.
        """
        if command_lists is not None:
            pulumi.set(__self__, "command_lists", command_lists)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if result is not None:
            pulumi.set(__self__, "result", result)
        if total_num is not None:
            pulumi.set(__self__, "total_num", total_num)
        if total_usec_sum is not None:
            pulumi.set(__self__, "total_usec_sum", total_usec_sum)

    @_builtins.property
    @pulumi.getter(name="commandLists")
    def command_lists(self) -> Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandList']]:
        """
        Indicates the command execution latency statistics.
        The command_list structure is documented below.
        """
        return pulumi.get(self, "command_lists")

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[_builtins.str]:
        """
        Indicates the error code for the diagnosis item.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        """
        Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
        return pulumi.get(self, "result")

    @_builtins.property
    @pulumi.getter(name="totalNum")
    def total_num(self) -> Optional[_builtins.int]:
        """
        Indicates the total number of times that commands are executed.
        """
        return pulumi.get(self, "total_num")

    @_builtins.property
    @pulumi.getter(name="totalUsecSum")
    def total_usec_sum(self) -> Optional[_builtins.float]:
        """
        Indicates the total duration of command execution.
        """
        return pulumi.get(self, "total_usec_sum")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "averageUsec":
            suggest = "average_usec"
        elif key == "callsSum":
            suggest = "calls_sum"
        elif key == "commandName":
            suggest = "command_name"
        elif key == "perUsec":
            suggest = "per_usec"
        elif key == "usecSum":
            suggest = "usec_sum"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosisTaskDiagnosisNodeReportListCommandTimeTakenListCommandList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 average_usec: Optional[_builtins.float] = None,
                 calls_sum: Optional[_builtins.int] = None,
                 command_name: Optional[_builtins.str] = None,
                 per_usec: Optional[_builtins.str] = None,
                 usec_sum: Optional[_builtins.float] = None):
        """
        :param _builtins.float average_usec: Indicates the average duration of calls.
        :param _builtins.int calls_sum: Indicates the number of calls.
        :param _builtins.str command_name: Indicates the command name.
        :param _builtins.str per_usec: Indicates the duration percentage.
        :param _builtins.float usec_sum: Indicates the total time consumed.
        """
        if average_usec is not None:
            pulumi.set(__self__, "average_usec", average_usec)
        if calls_sum is not None:
            pulumi.set(__self__, "calls_sum", calls_sum)
        if command_name is not None:
            pulumi.set(__self__, "command_name", command_name)
        if per_usec is not None:
            pulumi.set(__self__, "per_usec", per_usec)
        if usec_sum is not None:
            pulumi.set(__self__, "usec_sum", usec_sum)

    @_builtins.property
    @pulumi.getter(name="averageUsec")
    def average_usec(self) -> Optional[_builtins.float]:
        """
        Indicates the average duration of calls.
        """
        return pulumi.get(self, "average_usec")

    @_builtins.property
    @pulumi.getter(name="callsSum")
    def calls_sum(self) -> Optional[_builtins.int]:
        """
        Indicates the number of calls.
        """
        return pulumi.get(self, "calls_sum")

    @_builtins.property
    @pulumi.getter(name="commandName")
    def command_name(self) -> Optional[_builtins.str]:
        """
        Indicates the command name.
        """
        return pulumi.get(self, "command_name")

    @_builtins.property
    @pulumi.getter(name="perUsec")
    def per_usec(self) -> Optional[_builtins.str]:
        """
        Indicates the duration percentage.
        """
        return pulumi.get(self, "per_usec")

    @_builtins.property
    @pulumi.getter(name="usecSum")
    def usec_sum(self) -> Optional[_builtins.float]:
        """
        Indicates the total time consumed.
        """
        return pulumi.get(self, "usec_sum")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abnormalNum":
            suggest = "abnormal_num"
        elif key == "diagnosisItemLists":
            suggest = "diagnosis_item_lists"
        elif key == "failedNum":
            suggest = "failed_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abnormal_num: Optional[_builtins.int] = None,
                 diagnosis_item_lists: Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemList']] = None,
                 failed_num: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.int abnormal_num: Indicates the total number of abnormal diagnosis items.
        :param Sequence['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListArgs'] diagnosis_item_lists: Indicates the diagnosis items.
               The diagnosis_item_list structure is documented below.
        :param _builtins.int failed_num: Indicates the total number of failed diagnosis items.
        :param _builtins.str name: Indicates the diagnosis item name.
               The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
               **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
        if abnormal_num is not None:
            pulumi.set(__self__, "abnormal_num", abnormal_num)
        if diagnosis_item_lists is not None:
            pulumi.set(__self__, "diagnosis_item_lists", diagnosis_item_lists)
        if failed_num is not None:
            pulumi.set(__self__, "failed_num", failed_num)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="abnormalNum")
    def abnormal_num(self) -> Optional[_builtins.int]:
        """
        Indicates the total number of abnormal diagnosis items.
        """
        return pulumi.get(self, "abnormal_num")

    @_builtins.property
    @pulumi.getter(name="diagnosisItemLists")
    def diagnosis_item_lists(self) -> Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemList']]:
        """
        Indicates the diagnosis items.
        The diagnosis_item_list structure is documented below.
        """
        return pulumi.get(self, "diagnosis_item_lists")

    @_builtins.property
    @pulumi.getter(name="failedNum")
    def failed_num(self) -> Optional[_builtins.int]:
        """
        Indicates the total number of failed diagnosis items.
        """
        return pulumi.get(self, "failed_num")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the diagnosis item name.
        The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
        **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adviceIds":
            suggest = "advice_ids"
        elif key == "causeIds":
            suggest = "cause_ids"
        elif key == "errorCode":
            suggest = "error_code"
        elif key == "impactIds":
            suggest = "impact_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advice_ids: Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceId']] = None,
                 cause_ids: Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseId']] = None,
                 error_code: Optional[_builtins.str] = None,
                 impact_ids: Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactId']] = None,
                 name: Optional[_builtins.str] = None,
                 result: Optional[_builtins.str] = None):
        """
        :param Sequence['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceIdArgs'] advice_ids: Indicates the list of suggestion IDs.
               The advice_ids structure is documented below.
        :param Sequence['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseIdArgs'] cause_ids: Indicates the list of cause IDs.
               The cause_ids structure is documented below.
        :param _builtins.str error_code: Indicates the error code for the diagnosis item.
        :param Sequence['DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactIdArgs'] impact_ids: Indicates the list of impact IDs.
               The impact_ids structure is documented below.
        :param _builtins.str name: Indicates the diagnosis item name.
               The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
               **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        :param _builtins.str result: Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
        if advice_ids is not None:
            pulumi.set(__self__, "advice_ids", advice_ids)
        if cause_ids is not None:
            pulumi.set(__self__, "cause_ids", cause_ids)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if impact_ids is not None:
            pulumi.set(__self__, "impact_ids", impact_ids)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter(name="adviceIds")
    def advice_ids(self) -> Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceId']]:
        """
        Indicates the list of suggestion IDs.
        The advice_ids structure is documented below.
        """
        return pulumi.get(self, "advice_ids")

    @_builtins.property
    @pulumi.getter(name="causeIds")
    def cause_ids(self) -> Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseId']]:
        """
        Indicates the list of cause IDs.
        The cause_ids structure is documented below.
        """
        return pulumi.get(self, "cause_ids")

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[_builtins.str]:
        """
        Indicates the error code for the diagnosis item.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="impactIds")
    def impact_ids(self) -> Optional[Sequence['outputs.DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactId']]:
        """
        Indicates the list of impact IDs.
        The impact_ids structure is documented below.
        """
        return pulumi.get(self, "impact_ids")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the diagnosis item name.
        The value can be **connection_num**, **rx_controlled**, **persistence**, **centralized_expiration**,
        **inner_memory_fragmentation**, **time_consuming_commands**, **hit_ratio**, **memory_usage** or **cpu_usage**.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        """
        Indicates the diagnosis result. The value can be **failed**, **abnormal** or **normal**.
        """
        return pulumi.get(self, "result")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListAdviceId(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int id: Indicates the conclusion ID.
        :param Mapping[str, _builtins.str] params: Indicates the conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        Indicates the conclusion ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Indicates the conclusion parameters.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListCauseId(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int id: Indicates the conclusion ID.
        :param Mapping[str, _builtins.str] params: Indicates the conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        Indicates the conclusion ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Indicates the conclusion parameters.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class DiagnosisTaskDiagnosisNodeReportListDiagnosisDimensionListDiagnosisItemListImpactId(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int id: Indicates the conclusion ID.
        :param Mapping[str, _builtins.str] params: Indicates the conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        Indicates the conclusion ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Indicates the conclusion parameters.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class HotkeyAnalysisKey(dict):
    def __init__(__self__, *,
                 db: Optional[_builtins.int] = None,
                 freq: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 shard: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.int db: Indicates the database where the hot key is located.
        :param _builtins.int freq: Indicates the access frequency of a key within a specific period of time.
               The value is the logarithmic access frequency counter. The maximum value is 255, which indicates 1 million access requests.
               After the frequency reaches 255, the value will no longer increase even if access requests continue to increase.
               The value will decrease by 1 for every minute during which the key is not accessed.
        :param _builtins.str name: Indicates the name of hot key.
        :param _builtins.str shard: Indicates the shard where the hot key is located.
               This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        :param _builtins.int size: Indicates the size of the key value.
        :param _builtins.str type: Indicates the type of hot key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        :param _builtins.str unit: Indicates the unit of hot key. The value can be:
               + **count**: The number of keys.
               + **byte**: The size of key.
        """
        if db is not None:
            pulumi.set(__self__, "db", db)
        if freq is not None:
            pulumi.set(__self__, "freq", freq)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def db(self) -> Optional[_builtins.int]:
        """
        Indicates the database where the hot key is located.
        """
        return pulumi.get(self, "db")

    @_builtins.property
    @pulumi.getter
    def freq(self) -> Optional[_builtins.int]:
        """
        Indicates the access frequency of a key within a specific period of time.
        The value is the logarithmic access frequency counter. The maximum value is 255, which indicates 1 million access requests.
        After the frequency reaches 255, the value will no longer increase even if access requests continue to increase.
        The value will decrease by 1 for every minute during which the key is not accessed.
        """
        return pulumi.get(self, "freq")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the name of hot key.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def shard(self) -> Optional[_builtins.str]:
        """
        Indicates the shard where the hot key is located.
        This parameter is supported only when the instance type is cluster. The format is **ip:port**.
        """
        return pulumi.get(self, "shard")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Indicates the size of the key value.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Indicates the type of hot key. The value can be **string**, **list**, **set**, **zset**, **hash**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Indicates the unit of hot key. The value can be:
        + **count**: The number of keys.
        + **byte**: The size of key.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class InstanceBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupAts":
            suggest = "backup_ats"
        elif key == "beginAt":
            suggest = "begin_at"
        elif key == "backupType":
            suggest = "backup_type"
        elif key == "periodType":
            suggest = "period_type"
        elif key == "saveDays":
            suggest = "save_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_ats: Sequence[_builtins.int],
                 begin_at: _builtins.str,
                 backup_type: Optional[_builtins.str] = None,
                 period_type: Optional[_builtins.str] = None,
                 save_days: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.int] backup_ats: Day in a week on which backup starts, the value ranges from `1` to `7`.
               Where: 1 indicates Monday; 7 indicates Sunday.
        :param _builtins.str begin_at: Time at which backup starts.
               Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.
               
               <a name="DcsInstance_Parameters"></a>
               The `parameters` block supports:
        :param _builtins.str backup_type: Backup type. Default value is `auto`. The valid values are as follows:
        :param _builtins.str period_type: Interval at which backup is performed. Default value is `weekly`.
               Currently, only weekly backup is supported.
        :param _builtins.int save_days: Retention time. Unit: day, the value ranges from `1` to `7`.
               This parameter is required if the backup_type is **auto**.
        """
        pulumi.set(__self__, "backup_ats", backup_ats)
        pulumi.set(__self__, "begin_at", begin_at)
        if backup_type is not None:
            pulumi.set(__self__, "backup_type", backup_type)
        if period_type is not None:
            pulumi.set(__self__, "period_type", period_type)
        if save_days is not None:
            pulumi.set(__self__, "save_days", save_days)

    @_builtins.property
    @pulumi.getter(name="backupAts")
    def backup_ats(self) -> Sequence[_builtins.int]:
        """
        Day in a week on which backup starts, the value ranges from `1` to `7`.
        Where: 1 indicates Monday; 7 indicates Sunday.
        """
        return pulumi.get(self, "backup_ats")

    @_builtins.property
    @pulumi.getter(name="beginAt")
    def begin_at(self) -> _builtins.str:
        """
        Time at which backup starts.
        Format: `hh24:00-hh24:00`, "00:00-01:00" indicates that backup starts at 00:00:00.

        <a name="DcsInstance_Parameters"></a>
        The `parameters` block supports:
        """
        return pulumi.get(self, "begin_at")

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> Optional[_builtins.str]:
        """
        Backup type. Default value is `auto`. The valid values are as follows:
        """
        return pulumi.get(self, "backup_type")

    @_builtins.property
    @pulumi.getter(name="periodType")
    def period_type(self) -> Optional[_builtins.str]:
        """
        Interval at which backup is performed. Default value is `weekly`.
        Currently, only weekly backup is supported.
        """
        return pulumi.get(self, "period_type")

    @_builtins.property
    @pulumi.getter(name="saveDays")
    def save_days(self) -> Optional[_builtins.int]:
        """
        Retention time. Unit: day, the value ranges from `1` to `7`.
        This parameter is required if the backup_type is **auto**.
        """
        return pulumi.get(self, "save_days")


@pulumi.output_type
class InstanceBandwidthInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginTime":
            suggest = "begin_time"
        elif key == "currentTime":
            suggest = "current_time"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "expandCount":
            suggest = "expand_count"
        elif key == "expandEffectTime":
            suggest = "expand_effect_time"
        elif key == "expandIntervalTime":
            suggest = "expand_interval_time"
        elif key == "maxExpandCount":
            suggest = "max_expand_count"
        elif key == "nextExpandTime":
            suggest = "next_expand_time"
        elif key == "taskRunning":
            suggest = "task_running"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBandwidthInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBandwidthInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBandwidthInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: Optional[_builtins.int] = None,
                 begin_time: Optional[_builtins.str] = None,
                 current_time: Optional[_builtins.str] = None,
                 end_time: Optional[_builtins.str] = None,
                 expand_count: Optional[_builtins.int] = None,
                 expand_effect_time: Optional[_builtins.int] = None,
                 expand_interval_time: Optional[_builtins.int] = None,
                 max_expand_count: Optional[_builtins.int] = None,
                 next_expand_time: Optional[_builtins.str] = None,
                 task_running: Optional[_builtins.bool] = None):
        """
        :param _builtins.int bandwidth: Indicates the bandwidth size, the unit is **GB**.
        :param _builtins.str begin_time: Indicates the begin time of temporary increase.
        :param _builtins.str current_time: Indicates the current time.
        :param _builtins.str end_time: Indicates the end time of temporary increase.
        :param _builtins.int expand_count: Indicates the number of increases.
        :param _builtins.int expand_effect_time: Indicates the interval between temporary increases, the unit is **ms**.
        :param _builtins.int expand_interval_time: Indicates the time interval to the next increase, the unit is **ms**.
        :param _builtins.int max_expand_count: Indicates the maximum number of increases.
        :param _builtins.str next_expand_time: Indicates the next increase time.
        :param _builtins.bool task_running: Indicates whether the increase task is running.
        """
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if begin_time is not None:
            pulumi.set(__self__, "begin_time", begin_time)
        if current_time is not None:
            pulumi.set(__self__, "current_time", current_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if expand_count is not None:
            pulumi.set(__self__, "expand_count", expand_count)
        if expand_effect_time is not None:
            pulumi.set(__self__, "expand_effect_time", expand_effect_time)
        if expand_interval_time is not None:
            pulumi.set(__self__, "expand_interval_time", expand_interval_time)
        if max_expand_count is not None:
            pulumi.set(__self__, "max_expand_count", max_expand_count)
        if next_expand_time is not None:
            pulumi.set(__self__, "next_expand_time", next_expand_time)
        if task_running is not None:
            pulumi.set(__self__, "task_running", task_running)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        """
        Indicates the bandwidth size, the unit is **GB**.
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> Optional[_builtins.str]:
        """
        Indicates the begin time of temporary increase.
        """
        return pulumi.get(self, "begin_time")

    @_builtins.property
    @pulumi.getter(name="currentTime")
    def current_time(self) -> Optional[_builtins.str]:
        """
        Indicates the current time.
        """
        return pulumi.get(self, "current_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Indicates the end time of temporary increase.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="expandCount")
    def expand_count(self) -> Optional[_builtins.int]:
        """
        Indicates the number of increases.
        """
        return pulumi.get(self, "expand_count")

    @_builtins.property
    @pulumi.getter(name="expandEffectTime")
    def expand_effect_time(self) -> Optional[_builtins.int]:
        """
        Indicates the interval between temporary increases, the unit is **ms**.
        """
        return pulumi.get(self, "expand_effect_time")

    @_builtins.property
    @pulumi.getter(name="expandIntervalTime")
    def expand_interval_time(self) -> Optional[_builtins.int]:
        """
        Indicates the time interval to the next increase, the unit is **ms**.
        """
        return pulumi.get(self, "expand_interval_time")

    @_builtins.property
    @pulumi.getter(name="maxExpandCount")
    def max_expand_count(self) -> Optional[_builtins.int]:
        """
        Indicates the maximum number of increases.
        """
        return pulumi.get(self, "max_expand_count")

    @_builtins.property
    @pulumi.getter(name="nextExpandTime")
    def next_expand_time(self) -> Optional[_builtins.str]:
        """
        Indicates the next increase time.
        """
        return pulumi.get(self, "next_expand_time")

    @_builtins.property
    @pulumi.getter(name="taskRunning")
    def task_running(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the increase task is running.
        """
        return pulumi.get(self, "task_running")


@pulumi.output_type
class InstanceParameter(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: A resource ID in UUID format.
        :param _builtins.str name: Specifies the name of an instance.
               The name must be 4 to 64 characters and start with a letter.
               Only chinese, letters (case-insensitive), digits, underscores (_) ,and hyphens (-) are allowed.
        :param _builtins.str value: Specifies the value of the configuration item.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A resource ID in UUID format.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of an instance.
        The name must be 4 to 64 characters and start with a letter.
        Only chinese, letters (case-insensitive), digits, underscores (_) ,and hyphens (-) are allowed.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the configuration item.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstancePublicAccessElbListener(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str id: Indicates the ID of the listener.
        :param _builtins.str name: Indicates the name of the listener.
        :param _builtins.int port: Indicates the port of the listener.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Indicates the ID of the listener.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the name of the listener.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Indicates the port of the listener.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class InstanceV1BackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupAts":
            suggest = "backup_ats"
        elif key == "beginAt":
            suggest = "begin_at"
        elif key == "backupType":
            suggest = "backup_type"
        elif key == "periodType":
            suggest = "period_type"
        elif key == "saveDays":
            suggest = "save_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceV1BackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceV1BackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceV1BackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_ats: Sequence[_builtins.int],
                 begin_at: _builtins.str,
                 backup_type: Optional[_builtins.str] = None,
                 period_type: Optional[_builtins.str] = None,
                 save_days: Optional[_builtins.int] = None):
        pulumi.set(__self__, "backup_ats", backup_ats)
        pulumi.set(__self__, "begin_at", begin_at)
        if backup_type is not None:
            pulumi.set(__self__, "backup_type", backup_type)
        if period_type is not None:
            pulumi.set(__self__, "period_type", period_type)
        if save_days is not None:
            pulumi.set(__self__, "save_days", save_days)

    @_builtins.property
    @pulumi.getter(name="backupAts")
    def backup_ats(self) -> Sequence[_builtins.int]:
        return pulumi.get(self, "backup_ats")

    @_builtins.property
    @pulumi.getter(name="beginAt")
    def begin_at(self) -> _builtins.str:
        return pulumi.get(self, "begin_at")

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "backup_type")

    @_builtins.property
    @pulumi.getter(name="periodType")
    def period_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "period_type")

    @_builtins.property
    @pulumi.getter(name="saveDays")
    def save_days(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "save_days")


@pulumi.output_type
class InstanceV1BandwidthInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginTime":
            suggest = "begin_time"
        elif key == "currentTime":
            suggest = "current_time"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "expandCount":
            suggest = "expand_count"
        elif key == "expandEffectTime":
            suggest = "expand_effect_time"
        elif key == "expandIntervalTime":
            suggest = "expand_interval_time"
        elif key == "maxExpandCount":
            suggest = "max_expand_count"
        elif key == "nextExpandTime":
            suggest = "next_expand_time"
        elif key == "taskRunning":
            suggest = "task_running"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceV1BandwidthInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceV1BandwidthInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceV1BandwidthInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: Optional[_builtins.int] = None,
                 begin_time: Optional[_builtins.str] = None,
                 current_time: Optional[_builtins.str] = None,
                 end_time: Optional[_builtins.str] = None,
                 expand_count: Optional[_builtins.int] = None,
                 expand_effect_time: Optional[_builtins.int] = None,
                 expand_interval_time: Optional[_builtins.int] = None,
                 max_expand_count: Optional[_builtins.int] = None,
                 next_expand_time: Optional[_builtins.str] = None,
                 task_running: Optional[_builtins.bool] = None):
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if begin_time is not None:
            pulumi.set(__self__, "begin_time", begin_time)
        if current_time is not None:
            pulumi.set(__self__, "current_time", current_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if expand_count is not None:
            pulumi.set(__self__, "expand_count", expand_count)
        if expand_effect_time is not None:
            pulumi.set(__self__, "expand_effect_time", expand_effect_time)
        if expand_interval_time is not None:
            pulumi.set(__self__, "expand_interval_time", expand_interval_time)
        if max_expand_count is not None:
            pulumi.set(__self__, "max_expand_count", max_expand_count)
        if next_expand_time is not None:
            pulumi.set(__self__, "next_expand_time", next_expand_time)
        if task_running is not None:
            pulumi.set(__self__, "task_running", task_running)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "begin_time")

    @_builtins.property
    @pulumi.getter(name="currentTime")
    def current_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "current_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="expandCount")
    def expand_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "expand_count")

    @_builtins.property
    @pulumi.getter(name="expandEffectTime")
    def expand_effect_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "expand_effect_time")

    @_builtins.property
    @pulumi.getter(name="expandIntervalTime")
    def expand_interval_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "expand_interval_time")

    @_builtins.property
    @pulumi.getter(name="maxExpandCount")
    def max_expand_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_expand_count")

    @_builtins.property
    @pulumi.getter(name="nextExpandTime")
    def next_expand_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "next_expand_time")

    @_builtins.property
    @pulumi.getter(name="taskRunning")
    def task_running(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "task_running")


@pulumi.output_type
class InstanceV1Parameter(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceV1Whitelist(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceV1Whitelist. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceV1Whitelist.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceV1Whitelist.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class InstanceWhitelist(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceWhitelist. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceWhitelist.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceWhitelist.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: _builtins.str,
                 ip_addresses: Sequence[_builtins.str]):
        """
        :param _builtins.str group_name: Specifies the name of IP address group.
        :param Sequence[_builtins.str] ip_addresses: Specifies the list of IP address or CIDR which can be whitelisted for an instance.
               The maximum is 20.
        """
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Specifies the name of IP address group.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of IP address or CIDR which can be whitelisted for an instance.
        The maximum is 20.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class OnlineDataMigrationTaskSourceInstance(dict):
    def __init__(__self__, *,
                 addrs: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str addrs: Specifies the Redis address. It is mandatory if `id` is not specified.
        :param _builtins.str id: Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        :param _builtins.str name: Indicates the Redis name.
        :param _builtins.str password: Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        if addrs is not None:
            pulumi.set(__self__, "addrs", addrs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def addrs(self) -> Optional[_builtins.str]:
        """
        Specifies the Redis address. It is mandatory if `id` is not specified.
        """
        return pulumi.get(self, "addrs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the Redis name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class OnlineDataMigrationTaskTargetInstance(dict):
    def __init__(__self__, *,
                 addrs: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str addrs: Specifies the Redis address. It is mandatory if `id` is not specified.
        :param _builtins.str id: Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        :param _builtins.str name: Indicates the Redis name.
        :param _builtins.str password: Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        if addrs is not None:
            pulumi.set(__self__, "addrs", addrs)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def addrs(self) -> Optional[_builtins.str]:
        """
        Specifies the Redis address. It is mandatory if `id` is not specified.
        """
        return pulumi.get(self, "addrs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Specifies the Redis instance ID. It is mandatory if `addrs` is not specified.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the Redis name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Specifies the Redis password. If a password of the DCS instance is set, it is mandatory.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetAccountsAccountResult(dict):
    def __init__(__self__, *,
                 account_name: _builtins.str,
                 account_role: _builtins.str,
                 account_type: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str account_name: Specifies the account name.
        :param _builtins.str account_role: Specifies the account role. The value can be **read** or **write**.
        :param _builtins.str account_type: Specifies the account type. The value can be **normal** or **default**.
        :param _builtins.str description: Specifies the account description.
        :param _builtins.str id: Account ID.
        :param _builtins.str status: Specifies the account status.
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "account_role", account_role)
        pulumi.set(__self__, "account_type", account_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> _builtins.str:
        """
        Specifies the account name.
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter(name="accountRole")
    def account_role(self) -> _builtins.str:
        """
        Specifies the account role. The value can be **read** or **write**.
        """
        return pulumi.get(self, "account_role")

    @_builtins.property
    @pulumi.getter(name="accountType")
    def account_type(self) -> _builtins.str:
        """
        Specifies the account type. The value can be **normal** or **default**.
        """
        return pulumi.get(self, "account_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Specifies the account description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Account ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the account status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetBackupsBackupResult(dict):
    def __init__(__self__, *,
                 backup_format: _builtins.str,
                 begin_time: _builtins.str,
                 description: _builtins.str,
                 end_time: _builtins.str,
                 error_code: _builtins.str,
                 id: _builtins.str,
                 instance_id: _builtins.str,
                 is_support_restore: _builtins.str,
                 name: _builtins.str,
                 progress: _builtins.str,
                 size: _builtins.int,
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str backup_format: Specifies the format of the DCS instance backup.
               Value options: **aof**, **rdb**.
        :param _builtins.str begin_time: Specifies the start time (UTC) of DCS backups.
               The format is **yyyymmddhhmmss**, for example, 20231201000000.
        :param _builtins.str description: Indicates the description of the DCS instance backup.
        :param _builtins.str end_time: Specifies the end time (UTC) of DCS backups.
               The format is **yyyymmddhhmmss**, for example, 20231201000000.
        :param _builtins.str error_code: Indicates the error code displayed for a backup failure.
        :param _builtins.str id: Indicates the ID of the DCS instance backup.
        :param _builtins.str instance_id: Specifies the ID of the DCS instance.
        :param _builtins.str is_support_restore: Specifies whether restoration is supported.
               Value Options: **TRUE**, **FALSE**.
        :param _builtins.str name: Specifies the backup name.
        :param _builtins.str progress: Indicates the backup progress.
        :param _builtins.int size: Indicates the size of the backup file (byte).
        :param _builtins.str status: Specifies the backup status.
               Value options: **waiting**, **backuping**, **succeed**, **failed**, **expired**, **deleted**.
        :param _builtins.str type: Specifies the backup type.
               Value options: **manual**, **auto**.
        """
        pulumi.set(__self__, "backup_format", backup_format)
        pulumi.set(__self__, "begin_time", begin_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "is_support_restore", is_support_restore)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "progress", progress)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="backupFormat")
    def backup_format(self) -> _builtins.str:
        """
        Specifies the format of the DCS instance backup.
        Value options: **aof**, **rdb**.
        """
        return pulumi.get(self, "backup_format")

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> _builtins.str:
        """
        Specifies the start time (UTC) of DCS backups.
        The format is **yyyymmddhhmmss**, for example, 20231201000000.
        """
        return pulumi.get(self, "begin_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the DCS instance backup.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Specifies the end time (UTC) of DCS backups.
        The format is **yyyymmddhhmmss**, for example, 20231201000000.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> _builtins.str:
        """
        Indicates the error code displayed for a backup failure.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of the DCS instance backup.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Specifies the ID of the DCS instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="isSupportRestore")
    def is_support_restore(self) -> _builtins.str:
        """
        Specifies whether restoration is supported.
        Value Options: **TRUE**, **FALSE**.
        """
        return pulumi.get(self, "is_support_restore")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the backup name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> _builtins.str:
        """
        Indicates the backup progress.
        """
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Indicates the size of the backup file (byte).
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the backup status.
        Value options: **waiting**, **backuping**, **succeed**, **failed**, **expired**, **deleted**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the backup type.
        Value options: **manual**, **auto**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBigkeyAnalysesRecordResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 id: _builtins.str,
                 scan_type: _builtins.str,
                 started_at: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the creation time of the big key analysis. The value is in UTC format.
        :param _builtins.str finished_at: Indicates the time when the big key analysis ended. The value is in UTC format.
        :param _builtins.str id: Indicates the id of the big key analysis.
        :param _builtins.str scan_type: Specifies the mode of the big key analysis.
               Value options: **manual**, **auto**.
        :param _builtins.str started_at: Indicates the time when the big key analysis started. The value is in UTC format.
        :param _builtins.str status: Specifies the status of the big key analysis.
               Value options: **waiting**, **running**, **success**, **failed**.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "scan_type", scan_type)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the creation time of the big key analysis. The value is in UTC format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Indicates the time when the big key analysis ended. The value is in UTC format.
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the id of the big key analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> _builtins.str:
        """
        Specifies the mode of the big key analysis.
        Value options: **manual**, **auto**.
        """
        return pulumi.get(self, "scan_type")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Indicates the time when the big key analysis started. The value is in UTC format.
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the big key analysis.
        Value options: **waiting**, **running**, **success**, **failed**.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDiagnosisTasksDiagnosisTaskResult(dict):
    def __init__(__self__, *,
                 abnormal_item_sum: _builtins.int,
                 begin_time: _builtins.str,
                 created_at: _builtins.str,
                 end_time: _builtins.str,
                 failed_item_sum: _builtins.int,
                 id: _builtins.str,
                 node_num: _builtins.int,
                 status: _builtins.str):
        """
        :param _builtins.int abnormal_item_sum: Indicates the total number of abnormal diagnosis items.
        :param _builtins.str begin_time: Specifies the start time of the diagnosis task, in RFC3339 format.
        :param _builtins.str created_at: Indicates the time when the diagnosis report is created.
        :param _builtins.str end_time: Specifies the end time of the diagnosis task, in RFC3339 format.
        :param _builtins.int failed_item_sum: Indicates the total number of failed diagnosis items.
        :param _builtins.str id: Indicates the diagnosis task ID.
        :param _builtins.int node_num: Specifies the number of diagnosed nodes.
        :param _builtins.str status: Specifies the status of the diagnosis task.
               Value options: **diagnosing**, **finished**.
        """
        pulumi.set(__self__, "abnormal_item_sum", abnormal_item_sum)
        pulumi.set(__self__, "begin_time", begin_time)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "failed_item_sum", failed_item_sum)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "node_num", node_num)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="abnormalItemSum")
    def abnormal_item_sum(self) -> _builtins.int:
        """
        Indicates the total number of abnormal diagnosis items.
        """
        return pulumi.get(self, "abnormal_item_sum")

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> _builtins.str:
        """
        Specifies the start time of the diagnosis task, in RFC3339 format.
        """
        return pulumi.get(self, "begin_time")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the diagnosis report is created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Specifies the end time of the diagnosis task, in RFC3339 format.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="failedItemSum")
    def failed_item_sum(self) -> _builtins.int:
        """
        Indicates the total number of failed diagnosis items.
        """
        return pulumi.get(self, "failed_item_sum")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the diagnosis task ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="nodeNum")
    def node_num(self) -> _builtins.int:
        """
        Specifies the number of diagnosed nodes.
        """
        return pulumi.get(self, "node_num")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the diagnosis task.
        Value options: **diagnosing**, **finished**.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 available_zones: Sequence[_builtins.str],
                 cache_mode: _builtins.str,
                 capacity: _builtins.float,
                 charging_modes: Sequence[_builtins.str],
                 cpu_architecture: _builtins.str,
                 engine: _builtins.str,
                 engine_versions: _builtins.str,
                 ip_count: _builtins.int,
                 name: _builtins.str):
        """
        :param Sequence[_builtins.str] available_zones: An array of available zones where the cache specification can be used.
        :param _builtins.str cache_mode: The mode of a cache engine. The valid values are as follows:
        :param _builtins.float capacity: The total memory of the cache, in GB.
               + **Redis4.0, Redis5.0 and Redis6.0**: Stand-alone and active/standby type instance values:
               `0.125`, `0.25`, `0.5`, `1`, `2`, `4`, `8`, `16`, `32` and `64`.
               Cluster instance specifications support `4`,`8`,`16`,`24`, `32`, `48`, `64`, `96`, `128`, `192`,
               `256`, `384`, `512`, `768` and `1024`.
               + **Redis3.0**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
               Proxy cluster instance specifications support `64`, `128`, `256`, `512`, and `1024`.
               + **Memcached**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
        :param Sequence[_builtins.str] charging_modes: The charging modes for the specification cache instance.
               + `Hourly` - Pay-per-use.
               + `Monthly` - Pay monthly.
               + `Yearly` - Annual payment.
        :param _builtins.str cpu_architecture: The CPU architecture of cache instance.
               Valid values **x86_64** and **aarch64**.
        :param _builtins.str engine: The engine of the cache instance. Valid values are **Redis** and **Memcached**.
               Default value is **Redis**.
        :param _builtins.str engine_versions: Supported versions of the specification.
        :param _builtins.int ip_count: Number of IP addresses corresponding to the specifications.
        :param _builtins.str name: The flavor name of the cache instance.
        """
        pulumi.set(__self__, "available_zones", available_zones)
        pulumi.set(__self__, "cache_mode", cache_mode)
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "charging_modes", charging_modes)
        pulumi.set(__self__, "cpu_architecture", cpu_architecture)
        pulumi.set(__self__, "engine", engine)
        pulumi.set(__self__, "engine_versions", engine_versions)
        pulumi.set(__self__, "ip_count", ip_count)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="availableZones")
    def available_zones(self) -> Sequence[_builtins.str]:
        """
        An array of available zones where the cache specification can be used.
        """
        return pulumi.get(self, "available_zones")

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> _builtins.str:
        """
        The mode of a cache engine. The valid values are as follows:
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.float:
        """
        The total memory of the cache, in GB.
        + **Redis4.0, Redis5.0 and Redis6.0**: Stand-alone and active/standby type instance values:
        `0.125`, `0.25`, `0.5`, `1`, `2`, `4`, `8`, `16`, `32` and `64`.
        Cluster instance specifications support `4`,`8`,`16`,`24`, `32`, `48`, `64`, `96`, `128`, `192`,
        `256`, `384`, `512`, `768` and `1024`.
        + **Redis3.0**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
        Proxy cluster instance specifications support `64`, `128`, `256`, `512`, and `1024`.
        + **Memcached**: Stand-alone and active/standby type instance values: `2`, `4`, `8`, `16`, `32` and `64`.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="chargingModes")
    def charging_modes(self) -> Sequence[_builtins.str]:
        """
        The charging modes for the specification cache instance.
        + `Hourly` - Pay-per-use.
        + `Monthly` - Pay monthly.
        + `Yearly` - Annual payment.
        """
        return pulumi.get(self, "charging_modes")

    @_builtins.property
    @pulumi.getter(name="cpuArchitecture")
    def cpu_architecture(self) -> _builtins.str:
        """
        The CPU architecture of cache instance.
        Valid values **x86_64** and **aarch64**.
        """
        return pulumi.get(self, "cpu_architecture")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> _builtins.str:
        """
        The engine of the cache instance. Valid values are **Redis** and **Memcached**.
        Default value is **Redis**.
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter(name="engineVersions")
    def engine_versions(self) -> _builtins.str:
        """
        Supported versions of the specification.
        """
        return pulumi.get(self, "engine_versions")

    @_builtins.property
    @pulumi.getter(name="ipCount")
    def ip_count(self) -> _builtins.int:
        """
        Number of IP addresses corresponding to the specifications.
        """
        return pulumi.get(self, "ip_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The flavor name of the cache instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetHotkeyAnalysesRecordResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 id: _builtins.str,
                 scan_type: _builtins.str,
                 started_at: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the time when the hot key analysis started. The value is in UTC format.
        :param _builtins.str finished_at: Indicates the time when the hot key analysis ended. The value is in UTC format.
        :param _builtins.str id: Indicates the id of the hot key analysis.
        :param _builtins.str scan_type: Specifies the mode of the hot key analysis.
               Value options: **manual**, **auto**.
        :param _builtins.str started_at: Indicates the creation time of the hot key analysis. The value is in UTC format.
        :param _builtins.str status: Specifies the status of the hot key analysis.
               Value options: **waiting**, **running**, **success**, **failed**.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "scan_type", scan_type)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the hot key analysis started. The value is in UTC format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Indicates the time when the hot key analysis ended. The value is in UTC format.
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the id of the hot key analysis.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> _builtins.str:
        """
        Specifies the mode of the hot key analysis.
        Value options: **manual**, **auto**.
        """
        return pulumi.get(self, "scan_type")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Indicates the creation time of the hot key analysis. The value is in UTC format.
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the hot key analysis.
        Value options: **waiting**, **running**, **success**, **failed**.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetInstanceExpiredKeyScanHistoriesRecordResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 id: _builtins.str,
                 instance_id: _builtins.str,
                 num: _builtins.int,
                 scan_type: _builtins.str,
                 started_at: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the time when a scan task is created.
        :param _builtins.str finished_at: Indicates the time when a scan task is complete.
        :param _builtins.str id: Indicates the ID of the expired key scan task.
        :param _builtins.str instance_id: Specifies the ID of the DCS instance.
        :param _builtins.int num: Indicates the number of expired keys scanned at a time.
        :param _builtins.str scan_type: Indicates the scan mode.
               The value can be:
               + **auto**: automatic scan
               + **manual**: manual scan
        :param _builtins.str started_at: Indicates the time when a scan task started.
        :param _builtins.str status: Specifies the status of the expired key scan task.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "num", num)
        pulumi.set(__self__, "scan_type", scan_type)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when a scan task is created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Indicates the time when a scan task is complete.
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of the expired key scan task.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Specifies the ID of the DCS instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        Indicates the number of expired keys scanned at a time.
        """
        return pulumi.get(self, "num")

    @_builtins.property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> _builtins.str:
        """
        Indicates the scan mode.
        The value can be:
        + **auto**: automatic scan
        + **manual**: manual scan
        """
        return pulumi.get(self, "scan_type")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Indicates the time when a scan task started.
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the expired key scan task.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetInstanceNodesNodeResult(dict):
    def __init__(__self__, *,
                 az_code: _builtins.str,
                 dimensions: Sequence['outputs.GetInstanceNodesNodeDimensionResult'],
                 group_id: _builtins.str,
                 group_name: _builtins.str,
                 is_access: _builtins.bool,
                 is_remove_ip: _builtins.bool,
                 logical_node_id: _builtins.str,
                 name: _builtins.str,
                 node_id: _builtins.str,
                 node_ip: _builtins.str,
                 node_port: _builtins.str,
                 node_role: _builtins.str,
                 node_type: _builtins.str,
                 priority_weight: _builtins.int,
                 replication_id: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str az_code: Indicates the AZ code.
        :param Sequence['GetInstanceNodesNodeDimensionArgs'] dimensions: Indicates the monitoring metric dimension of the replica.
               It is used to call the Cloud Eye API for querying monitoring metrics.
               + Replica monitoring is multi-dimensional. The returned array contains information about two dimensions. When querying
               monitoring data from Cloud Eye, transfer parameters of multiple dimensions to obtain the metric data.
               + The first dimension is the primary dimension of the replica. The dimension name is dcs_instance_id, and the dimension
               value is the ID of the instance where the Indicates the replica is located.
               + The name of the second dimension is dcs_cluster_redis_node, and the dimension value is the ID of the monitored object
               of the replica, which is different from the replica ID or node ID.
        :param _builtins.str group_id: Indicates the instance shard ID.
        :param _builtins.str group_name: Indicates the instance shard name.
        :param _builtins.bool is_access: Indicates whether the IP address of the node can be directly accessed.
        :param _builtins.bool is_remove_ip: Indicates whether the IP address is removed from the read-only domain name.
        :param _builtins.str logical_node_id: Indicates the logical node ID.
        :param _builtins.str name: Indicates the monitoring dimension name.
               The value can be:
               + **dcs_instance_id**: instance dimension
               + **dcs_cluster_redis_node**: data node dimension
        :param _builtins.str node_id: Indicates the node ID.
        :param _builtins.str node_ip: Indicates the node IP.
        :param _builtins.str node_port: Indicates the node port.
        :param _builtins.str node_role: Indicates the node role.
               The value can be:
               + **redis-server**: server node
               + **redis-proxy**: proxy node
        :param _builtins.str node_type: Indicates  the node master/standby role.
               The value can be:
               + **master**: master node
               + **slave**: standby node
               + **proxy**: node of a Proxy Cluster instance
        :param _builtins.int priority_weight: Indicates  the replica promotion priority.
               The value can be:
               + Priority ranges from **0** to **100** in descending order.
               + **0** indicates that the replica will never be automatically promoted.
               + **1** indicates the highest priority.
               + **100** indicates the lowest priority.
        :param _builtins.str replication_id: Indicates the instance replica ID.
        :param _builtins.str status: Indicates the node status.
               The value can be:
               + **Creating**
               + **Active**
               + **Inactive**
               + **Deleting**
               + **AddSharding**
        """
        pulumi.set(__self__, "az_code", az_code)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "is_access", is_access)
        pulumi.set(__self__, "is_remove_ip", is_remove_ip)
        pulumi.set(__self__, "logical_node_id", logical_node_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_ip", node_ip)
        pulumi.set(__self__, "node_port", node_port)
        pulumi.set(__self__, "node_role", node_role)
        pulumi.set(__self__, "node_type", node_type)
        pulumi.set(__self__, "priority_weight", priority_weight)
        pulumi.set(__self__, "replication_id", replication_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="azCode")
    def az_code(self) -> _builtins.str:
        """
        Indicates the AZ code.
        """
        return pulumi.get(self, "az_code")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetInstanceNodesNodeDimensionResult']:
        """
        Indicates the monitoring metric dimension of the replica.
        It is used to call the Cloud Eye API for querying monitoring metrics.
        + Replica monitoring is multi-dimensional. The returned array contains information about two dimensions. When querying
        monitoring data from Cloud Eye, transfer parameters of multiple dimensions to obtain the metric data.
        + The first dimension is the primary dimension of the replica. The dimension name is dcs_instance_id, and the dimension
        value is the ID of the instance where the Indicates the replica is located.
        + The name of the second dimension is dcs_cluster_redis_node, and the dimension value is the ID of the monitored object
        of the replica, which is different from the replica ID or node ID.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Indicates the instance shard ID.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Indicates the instance shard name.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="isAccess")
    def is_access(self) -> _builtins.bool:
        """
        Indicates whether the IP address of the node can be directly accessed.
        """
        return pulumi.get(self, "is_access")

    @_builtins.property
    @pulumi.getter(name="isRemoveIp")
    def is_remove_ip(self) -> _builtins.bool:
        """
        Indicates whether the IP address is removed from the read-only domain name.
        """
        return pulumi.get(self, "is_remove_ip")

    @_builtins.property
    @pulumi.getter(name="logicalNodeId")
    def logical_node_id(self) -> _builtins.str:
        """
        Indicates the logical node ID.
        """
        return pulumi.get(self, "logical_node_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the monitoring dimension name.
        The value can be:
        + **dcs_instance_id**: instance dimension
        + **dcs_cluster_redis_node**: data node dimension
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        Indicates the node ID.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> _builtins.str:
        """
        Indicates the node IP.
        """
        return pulumi.get(self, "node_ip")

    @_builtins.property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> _builtins.str:
        """
        Indicates the node port.
        """
        return pulumi.get(self, "node_port")

    @_builtins.property
    @pulumi.getter(name="nodeRole")
    def node_role(self) -> _builtins.str:
        """
        Indicates the node role.
        The value can be:
        + **redis-server**: server node
        + **redis-proxy**: proxy node
        """
        return pulumi.get(self, "node_role")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Indicates  the node master/standby role.
        The value can be:
        + **master**: master node
        + **slave**: standby node
        + **proxy**: node of a Proxy Cluster instance
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter(name="priorityWeight")
    def priority_weight(self) -> _builtins.int:
        """
        Indicates  the replica promotion priority.
        The value can be:
        + Priority ranges from **0** to **100** in descending order.
        + **0** indicates that the replica will never be automatically promoted.
        + **1** indicates the highest priority.
        + **100** indicates the lowest priority.
        """
        return pulumi.get(self, "priority_weight")

    @_builtins.property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> _builtins.str:
        """
        Indicates the instance replica ID.
        """
        return pulumi.get(self, "replication_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the node status.
        The value can be:
        + **Creating**
        + **Active**
        + **Inactive**
        + **Deleting**
        + **AddSharding**
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetInstanceNodesNodeDimensionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Indicates the monitoring dimension name.
               The value can be:
               + **dcs_instance_id**: instance dimension
               + **dcs_cluster_redis_node**: data node dimension
        :param _builtins.str value: Indicates the dimension value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the monitoring dimension name.
        The value can be:
        + **dcs_instance_id**: instance dimension
        + **dcs_cluster_redis_node**: data node dimension
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Indicates the dimension value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInstanceShardsGroupListResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 group_name: _builtins.str,
                 replication_lists: Sequence['outputs.GetInstanceShardsGroupListReplicationListResult']):
        """
        :param _builtins.str group_id: Indicates the shard ID.
        :param _builtins.str group_name: Indicates the shard name.
        :param Sequence['GetInstanceShardsGroupListReplicationListArgs'] replication_lists: Indicates the list of replicas in the shard.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "replication_lists", replication_lists)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Indicates the shard ID.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Indicates the shard name.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="replicationLists")
    def replication_lists(self) -> Sequence['outputs.GetInstanceShardsGroupListReplicationListResult']:
        """
        Indicates the list of replicas in the shard.
        """
        return pulumi.get(self, "replication_lists")


@pulumi.output_type
class GetInstanceShardsGroupListReplicationListResult(dict):
    def __init__(__self__, *,
                 az_code: _builtins.str,
                 dimensions: Sequence['outputs.GetInstanceShardsGroupListReplicationListDimensionResult'],
                 is_replication: _builtins.bool,
                 node_id: _builtins.str,
                 replication_id: _builtins.str,
                 replication_ip: _builtins.str,
                 replication_role: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str az_code: Indicates the AZ where the replica is in.
        :param Sequence['GetInstanceShardsGroupListReplicationListDimensionArgs'] dimensions: Indicates the monitoring metric dimension of the replica.
               It is used to call the Cloud Eye API for querying monitoring metrics.
               + Replica monitoring is multi-dimensional. The returned array contains information about two dimensions. When querying
               monitoring data from Cloud Eye, you need to transfer parameters of multiple dimensions to obtain the metric data.
               + The first dimension is the primary dimension of the replica. The dimension name is **dcs_instance_id**, and the
               dimension value corresponds to the ID of the instance to which the replica belongs.
               + The name of the second dimension is **dcs_cluster_redis_node**, and the dimension value is the ID of the monitored
               object of the replica, which is different from the replica ID or node ID.
        :param _builtins.bool is_replication: Indicates whether the replica is a newly added one.
        :param _builtins.str node_id: Indicates the node ID.
        :param _builtins.str replication_id: Indicates the replica ID.
        :param _builtins.str replication_ip: Indicates the replica IP address.
        :param _builtins.str replication_role: Indicates the role of the replica.
               The value can be:
               + **master**: master
               + **slave**: replication
        :param _builtins.str status: Indicates the replica status.
        """
        pulumi.set(__self__, "az_code", az_code)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "is_replication", is_replication)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "replication_id", replication_id)
        pulumi.set(__self__, "replication_ip", replication_ip)
        pulumi.set(__self__, "replication_role", replication_role)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="azCode")
    def az_code(self) -> _builtins.str:
        """
        Indicates the AZ where the replica is in.
        """
        return pulumi.get(self, "az_code")

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.GetInstanceShardsGroupListReplicationListDimensionResult']:
        """
        Indicates the monitoring metric dimension of the replica.
        It is used to call the Cloud Eye API for querying monitoring metrics.
        + Replica monitoring is multi-dimensional. The returned array contains information about two dimensions. When querying
        monitoring data from Cloud Eye, you need to transfer parameters of multiple dimensions to obtain the metric data.
        + The first dimension is the primary dimension of the replica. The dimension name is **dcs_instance_id**, and the
        dimension value corresponds to the ID of the instance to which the replica belongs.
        + The name of the second dimension is **dcs_cluster_redis_node**, and the dimension value is the ID of the monitored
        object of the replica, which is different from the replica ID or node ID.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="isReplication")
    def is_replication(self) -> _builtins.bool:
        """
        Indicates whether the replica is a newly added one.
        """
        return pulumi.get(self, "is_replication")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        Indicates the node ID.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> _builtins.str:
        """
        Indicates the replica ID.
        """
        return pulumi.get(self, "replication_id")

    @_builtins.property
    @pulumi.getter(name="replicationIp")
    def replication_ip(self) -> _builtins.str:
        """
        Indicates the replica IP address.
        """
        return pulumi.get(self, "replication_ip")

    @_builtins.property
    @pulumi.getter(name="replicationRole")
    def replication_role(self) -> _builtins.str:
        """
        Indicates the role of the replica.
        The value can be:
        + **master**: master
        + **slave**: replication
        """
        return pulumi.get(self, "replication_role")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the replica status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetInstanceShardsGroupListReplicationListDimensionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Indicates the monitoring dimension name.
        :param _builtins.str value: Indicates the dimension value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the monitoring dimension name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Indicates the dimension value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 access_user: _builtins.str,
                 availability_zones: Sequence[_builtins.str],
                 capacity: _builtins.float,
                 charging_mode: _builtins.str,
                 description: _builtins.str,
                 domain_name: _builtins.str,
                 engine: _builtins.str,
                 engine_version: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 flavor: _builtins.str,
                 id: _builtins.str,
                 maintain_begin: _builtins.str,
                 maintain_end: _builtins.str,
                 max_memory: _builtins.int,
                 name: _builtins.str,
                 order_id: _builtins.str,
                 port: _builtins.int,
                 private_ip: _builtins.str,
                 security_group_id: _builtins.str,
                 security_group_name: _builtins.str,
                 status: _builtins.str,
                 subnet_id: _builtins.str,
                 subnet_name: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 used_memory: _builtins.int,
                 vpc_id: _builtins.str,
                 vpc_name: _builtins.str):
        """
        :param _builtins.str access_user: Indicates the username used for accessing a DCS Memcached instance.
        :param Sequence[_builtins.str] availability_zones: Specifies the code of the AZ where the cache node resides.
        :param _builtins.float capacity: Specifies the cache capacity. Unit: GB.
        :param _builtins.str charging_mode: Indicates the charging mode of the cache instance.
        :param _builtins.str description: Indicates the description of an instance.
        :param _builtins.str domain_name: Indicates the domain name of the instance.
        :param _builtins.str engine: Indicates a cache engine.
        :param _builtins.str engine_version: Indicates the version of a cache engine.
        :param _builtins.str enterprise_project_id: Indicates the enterprise project id of the dcs instance.
        :param _builtins.str flavor: Indicates the flavor of the cache instance.
        :param _builtins.str id: Indicates the ID of the instance.
        :param _builtins.str maintain_begin: Indicates the time at which the maintenance time window starts.
        :param _builtins.str maintain_end: Indicates the time at which the maintenance time window ends.
        :param _builtins.int max_memory: Indicates the total memory size. Unit: MB.
        :param _builtins.str name: Specifies the name of an instance.
        :param _builtins.str order_id: Indicates the ID of the order that created the instance.
        :param _builtins.int port: Indicates the port of the cache instance.
        :param _builtins.str private_ip: Specifies the subnet Network ID.
        :param _builtins.str security_group_id: Indicates the ID of the security group which the instance belongs to.
        :param _builtins.str security_group_name: Indicates the name of security group which the instance belongs to.
        :param _builtins.str status: Specifies the cache instance status. The valid values are **RUNNING**, **ERROR**,
               **RESTARTING**, **FROZEN**, **EXTENDING**, **RESTORING**, **FLUSHING**.
        :param _builtins.str subnet_id: Indicates the ID of subnet which the instance belongs to.
        :param _builtins.str subnet_name: Indicates the name of subnet which the instance belongs to.
        :param Mapping[str, _builtins.str] tags: Indicates The key/value pairs to associate with the DCS instance.
        :param _builtins.int used_memory: Indicates the size of the used memory. Unit: MB.
        :param _builtins.str vpc_id: Indicates the ID of VPC which the instance belongs to.
        :param _builtins.str vpc_name: Indicates the name of VPC which the instance belongs to.
        """
        pulumi.set(__self__, "access_user", access_user)
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "charging_mode", charging_mode)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "engine", engine)
        pulumi.set(__self__, "engine_version", engine_version)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "maintain_begin", maintain_begin)
        pulumi.set(__self__, "maintain_end", maintain_end)
        pulumi.set(__self__, "max_memory", max_memory)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "order_id", order_id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "security_group_name", security_group_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "used_memory", used_memory)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "vpc_name", vpc_name)

    @_builtins.property
    @pulumi.getter(name="accessUser")
    def access_user(self) -> _builtins.str:
        """
        Indicates the username used for accessing a DCS Memcached instance.
        """
        return pulumi.get(self, "access_user")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        Specifies the code of the AZ where the cache node resides.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.float:
        """
        Specifies the cache capacity. Unit: GB.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> _builtins.str:
        """
        Indicates the charging mode of the cache instance.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of an instance.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Indicates the domain name of the instance.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> _builtins.str:
        """
        Indicates a cache engine.
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> _builtins.str:
        """
        Indicates the version of a cache engine.
        """
        return pulumi.get(self, "engine_version")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Indicates the enterprise project id of the dcs instance.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Indicates the flavor of the cache instance.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of the instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maintainBegin")
    def maintain_begin(self) -> _builtins.str:
        """
        Indicates the time at which the maintenance time window starts.
        """
        return pulumi.get(self, "maintain_begin")

    @_builtins.property
    @pulumi.getter(name="maintainEnd")
    def maintain_end(self) -> _builtins.str:
        """
        Indicates the time at which the maintenance time window ends.
        """
        return pulumi.get(self, "maintain_end")

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> _builtins.int:
        """
        Indicates the total memory size. Unit: MB.
        """
        return pulumi.get(self, "max_memory")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of an instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orderId")
    def order_id(self) -> _builtins.str:
        """
        Indicates the ID of the order that created the instance.
        """
        return pulumi.get(self, "order_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Indicates the port of the cache instance.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> _builtins.str:
        """
        Specifies the subnet Network ID.
        """
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        Indicates the ID of the security group which the instance belongs to.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> _builtins.str:
        """
        Indicates the name of security group which the instance belongs to.
        """
        return pulumi.get(self, "security_group_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the cache instance status. The valid values are **RUNNING**, **ERROR**,
        **RESTARTING**, **FROZEN**, **EXTENDING**, **RESTORING**, **FLUSHING**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Indicates the ID of subnet which the instance belongs to.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        """
        Indicates the name of subnet which the instance belongs to.
        """
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Indicates The key/value pairs to associate with the DCS instance.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="usedMemory")
    def used_memory(self) -> _builtins.int:
        """
        Indicates the size of the used memory. Unit: MB.
        """
        return pulumi.get(self, "used_memory")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Indicates the ID of VPC which the instance belongs to.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="vpcName")
    def vpc_name(self) -> _builtins.str:
        """
        Indicates the name of VPC which the instance belongs to.
        """
        return pulumi.get(self, "vpc_name")


@pulumi.output_type
class GetMigrationTaskLogsMigrationLogResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 keywords: Sequence[_builtins.str],
                 log_code: _builtins.str,
                 log_level: _builtins.str,
                 message: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the time when the migration log is generated.
        :param Sequence[_builtins.str] keywords: Indicates the log keyword.
        :param _builtins.str log_code: Indicates the log code.
        :param _builtins.str log_level: Indicates the log level.
        :param _builtins.str message: Indicates the log information.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "keywords", keywords)
        pulumi.set(__self__, "log_code", log_code)
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the migration log is generated.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def keywords(self) -> Sequence[_builtins.str]:
        """
        Indicates the log keyword.
        """
        return pulumi.get(self, "keywords")

    @_builtins.property
    @pulumi.getter(name="logCode")
    def log_code(self) -> _builtins.str:
        """
        Indicates the log code.
        """
        return pulumi.get(self, "log_code")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> _builtins.str:
        """
        Indicates the log level.
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Indicates the log information.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class GetMigrationTasksMigrationTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 data_source: _builtins.str,
                 description: _builtins.str,
                 ecs_tenant_private_ip: _builtins.str,
                 error_message: _builtins.str,
                 migration_method: _builtins.str,
                 migration_type: _builtins.str,
                 released_at: _builtins.str,
                 resume_mode: _builtins.str,
                 source_instance_id: _builtins.str,
                 source_instance_name: _builtins.str,
                 source_instance_spec_code: _builtins.str,
                 source_instance_status: _builtins.str,
                 source_instance_subnet_id: _builtins.str,
                 status: _builtins.str,
                 supported_features: Sequence[_builtins.str],
                 target_instance_addrs: _builtins.str,
                 target_instance_id: _builtins.str,
                 target_instance_name: _builtins.str,
                 target_instance_spec_code: _builtins.str,
                 target_instance_status: _builtins.str,
                 target_instance_subnet_id: _builtins.str,
                 task_id: _builtins.str,
                 task_name: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the time when the migration task is created.
        :param _builtins.str data_source: Indicates the source Redis address, which is **ip:port** or a bucket name.
        :param _builtins.str description: Indicates the description of a migration task.
        :param _builtins.str ecs_tenant_private_ip: Indicates the private IP address of the migration ECS on the tenant side.
        :param _builtins.str error_message: Indicates the error information.
        :param _builtins.str migration_method: Indicates the type of the migration, which can be **full migration** or **incremental migration**.
        :param _builtins.str migration_type: Indicates the mode of the migration, which can be backup file import or online migration.
        :param _builtins.str released_at: Indicates the time when the migration server is released.
        :param _builtins.str resume_mode: Indicates the operation mode, which can be **auto** or **manual**.
        :param _builtins.str source_instance_id: Indicates the ID of the source instance.
               If the source Redis is self-hosted, this parameter is left blank.
        :param _builtins.str source_instance_name: Indicates the name of the source instance.
               If the source Redis is self-hosted, this parameter is left blank.
        :param _builtins.str source_instance_spec_code: Indicates the source instance specification code.
               If the source Redis is self-hosted, this parameter is left blank.
        :param _builtins.str source_instance_status: Indicates the status of the source instance.
               If the source Redis is self-hosted, this parameter is left blank.
        :param _builtins.str source_instance_subnet_id: Indicates the subnet ID of the source instance.
               If the source Redis is self-hosted, this parameter is left blank.
        :param _builtins.str status: Indicates the migration task status.
               The value can be **SUCCESS**, **FAILED**, **MIGRATING**, or **TERMINATED**.
        :param Sequence[_builtins.str] supported_features: Indicates the supported features.
        :param _builtins.str target_instance_addrs: Indicates the target Redis address. The format is **ip:port**.
        :param _builtins.str target_instance_id: Indicates the target instance ID.
        :param _builtins.str target_instance_name: Indicates the target instance name.
        :param _builtins.str target_instance_spec_code: Indicates the ID of the target instance flavor.
        :param _builtins.str target_instance_status: Indicates the status of the target instance.
        :param _builtins.str target_instance_subnet_id: Indicates the subnet ID of the target instance.
        :param _builtins.str task_id: Indicates the migration task ID.
        :param _builtins.str task_name: Indicates the migration task name.
        :param _builtins.str version: Indicates the version.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ecs_tenant_private_ip", ecs_tenant_private_ip)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "migration_method", migration_method)
        pulumi.set(__self__, "migration_type", migration_type)
        pulumi.set(__self__, "released_at", released_at)
        pulumi.set(__self__, "resume_mode", resume_mode)
        pulumi.set(__self__, "source_instance_id", source_instance_id)
        pulumi.set(__self__, "source_instance_name", source_instance_name)
        pulumi.set(__self__, "source_instance_spec_code", source_instance_spec_code)
        pulumi.set(__self__, "source_instance_status", source_instance_status)
        pulumi.set(__self__, "source_instance_subnet_id", source_instance_subnet_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "supported_features", supported_features)
        pulumi.set(__self__, "target_instance_addrs", target_instance_addrs)
        pulumi.set(__self__, "target_instance_id", target_instance_id)
        pulumi.set(__self__, "target_instance_name", target_instance_name)
        pulumi.set(__self__, "target_instance_spec_code", target_instance_spec_code)
        pulumi.set(__self__, "target_instance_status", target_instance_status)
        pulumi.set(__self__, "target_instance_subnet_id", target_instance_subnet_id)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the migration task is created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> _builtins.str:
        """
        Indicates the source Redis address, which is **ip:port** or a bucket name.
        """
        return pulumi.get(self, "data_source")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of a migration task.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ecsTenantPrivateIp")
    def ecs_tenant_private_ip(self) -> _builtins.str:
        """
        Indicates the private IP address of the migration ECS on the tenant side.
        """
        return pulumi.get(self, "ecs_tenant_private_ip")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        Indicates the error information.
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter(name="migrationMethod")
    def migration_method(self) -> _builtins.str:
        """
        Indicates the type of the migration, which can be **full migration** or **incremental migration**.
        """
        return pulumi.get(self, "migration_method")

    @_builtins.property
    @pulumi.getter(name="migrationType")
    def migration_type(self) -> _builtins.str:
        """
        Indicates the mode of the migration, which can be backup file import or online migration.
        """
        return pulumi.get(self, "migration_type")

    @_builtins.property
    @pulumi.getter(name="releasedAt")
    def released_at(self) -> _builtins.str:
        """
        Indicates the time when the migration server is released.
        """
        return pulumi.get(self, "released_at")

    @_builtins.property
    @pulumi.getter(name="resumeMode")
    def resume_mode(self) -> _builtins.str:
        """
        Indicates the operation mode, which can be **auto** or **manual**.
        """
        return pulumi.get(self, "resume_mode")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceId")
    def source_instance_id(self) -> _builtins.str:
        """
        Indicates the ID of the source instance.
        If the source Redis is self-hosted, this parameter is left blank.
        """
        return pulumi.get(self, "source_instance_id")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceName")
    def source_instance_name(self) -> _builtins.str:
        """
        Indicates the name of the source instance.
        If the source Redis is self-hosted, this parameter is left blank.
        """
        return pulumi.get(self, "source_instance_name")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceSpecCode")
    def source_instance_spec_code(self) -> _builtins.str:
        """
        Indicates the source instance specification code.
        If the source Redis is self-hosted, this parameter is left blank.
        """
        return pulumi.get(self, "source_instance_spec_code")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceStatus")
    def source_instance_status(self) -> _builtins.str:
        """
        Indicates the status of the source instance.
        If the source Redis is self-hosted, this parameter is left blank.
        """
        return pulumi.get(self, "source_instance_status")

    @_builtins.property
    @pulumi.getter(name="sourceInstanceSubnetId")
    def source_instance_subnet_id(self) -> _builtins.str:
        """
        Indicates the subnet ID of the source instance.
        If the source Redis is self-hosted, this parameter is left blank.
        """
        return pulumi.get(self, "source_instance_subnet_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the migration task status.
        The value can be **SUCCESS**, **FAILED**, **MIGRATING**, or **TERMINATED**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="supportedFeatures")
    def supported_features(self) -> Sequence[_builtins.str]:
        """
        Indicates the supported features.
        """
        return pulumi.get(self, "supported_features")

    @_builtins.property
    @pulumi.getter(name="targetInstanceAddrs")
    def target_instance_addrs(self) -> _builtins.str:
        """
        Indicates the target Redis address. The format is **ip:port**.
        """
        return pulumi.get(self, "target_instance_addrs")

    @_builtins.property
    @pulumi.getter(name="targetInstanceId")
    def target_instance_id(self) -> _builtins.str:
        """
        Indicates the target instance ID.
        """
        return pulumi.get(self, "target_instance_id")

    @_builtins.property
    @pulumi.getter(name="targetInstanceName")
    def target_instance_name(self) -> _builtins.str:
        """
        Indicates the target instance name.
        """
        return pulumi.get(self, "target_instance_name")

    @_builtins.property
    @pulumi.getter(name="targetInstanceSpecCode")
    def target_instance_spec_code(self) -> _builtins.str:
        """
        Indicates the ID of the target instance flavor.
        """
        return pulumi.get(self, "target_instance_spec_code")

    @_builtins.property
    @pulumi.getter(name="targetInstanceStatus")
    def target_instance_status(self) -> _builtins.str:
        """
        Indicates the status of the target instance.
        """
        return pulumi.get(self, "target_instance_status")

    @_builtins.property
    @pulumi.getter(name="targetInstanceSubnetId")
    def target_instance_subnet_id(self) -> _builtins.str:
        """
        Indicates the subnet ID of the target instance.
        """
        return pulumi.get(self, "target_instance_subnet_id")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.str:
        """
        Indicates the migration task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Indicates the migration task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Indicates the version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetQuotasQuotaResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetQuotasQuotaResourceResult']):
        """
        :param Sequence['GetQuotasQuotaResourceArgs'] resources: Indicates the list of quotas.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetQuotasQuotaResourceResult']:
        """
        Indicates the list of quotas.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetQuotasQuotaResourceResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int,
                 quota: _builtins.int,
                 type: _builtins.str,
                 unit: _builtins.str,
                 used: _builtins.int):
        """
        :param _builtins.int max: Indicates the maximum limit.
               + It is maximum limit of instance quota when `type` is **instance**.
               + It is maximum limit of memory quota when `type` is **ram**.
        :param _builtins.int min: Indicates the minimum limit.
               + It is minimum limit of instance quota when `type` is **instance**.
               + It is minimum limit of memory quota when `type` is **ram**.
        :param _builtins.int quota: Indicates the max number of instances that can be created and max allowed total memory.
        :param _builtins.str type: Indicates the quota type.
               The value can be **instance** or **ram**.
               + **instances**: instance quota
               + **ram**: memory quota
        :param _builtins.str unit: Indicates the resource unit.
               + When `type` is **instance**, no value is returned.
               + When `type` is **ram**, **GB** is returned.
        :param _builtins.int used: Indicates the number of created instances and used memory.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "quota", quota)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "used", used)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        """
        Indicates the maximum limit.
        + It is maximum limit of instance quota when `type` is **instance**.
        + It is maximum limit of memory quota when `type` is **ram**.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        Indicates the minimum limit.
        + It is minimum limit of instance quota when `type` is **instance**.
        + It is minimum limit of memory quota when `type` is **ram**.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def quota(self) -> _builtins.int:
        """
        Indicates the max number of instances that can be created and max allowed total memory.
        """
        return pulumi.get(self, "quota")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the quota type.
        The value can be **instance** or **ram**.
        + **instances**: instance quota
        + **ram**: memory quota
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        Indicates the resource unit.
        + When `type` is **instance**, no value is returned.
        + When `type` is **ram**, **GB** is returned.
        """
        return pulumi.get(self, "unit")

    @_builtins.property
    @pulumi.getter
    def used(self) -> _builtins.int:
        """
        Indicates the number of created instances and used memory.
        """
        return pulumi.get(self, "used")


@pulumi.output_type
class GetTemplateDetailParamResult(dict):
    def __init__(__self__, *,
                 default_value: _builtins.str,
                 description: _builtins.str,
                 need_restart: _builtins.bool,
                 param_id: _builtins.str,
                 param_name: _builtins.str,
                 value_range: _builtins.str,
                 value_type: _builtins.str):
        """
        :param _builtins.str default_value: Indicates the default of the param.
        :param _builtins.str description: Indicates the description of the param.
        :param _builtins.bool need_restart: Indicates whether the DCS instance need restart.
        :param _builtins.str param_id: Indicates the ID of the param.
        :param _builtins.str param_name: Specifies the name of the param.
        :param _builtins.str value_range: Indicates the value range of the param.
        :param _builtins.str value_type: Indicates the value type of the param.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "need_restart", need_restart)
        pulumi.set(__self__, "param_id", param_id)
        pulumi.set(__self__, "param_name", param_name)
        pulumi.set(__self__, "value_range", value_range)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.str:
        """
        Indicates the default of the param.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the param.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="needRestart")
    def need_restart(self) -> _builtins.bool:
        """
        Indicates whether the DCS instance need restart.
        """
        return pulumi.get(self, "need_restart")

    @_builtins.property
    @pulumi.getter(name="paramId")
    def param_id(self) -> _builtins.str:
        """
        Indicates the ID of the param.
        """
        return pulumi.get(self, "param_id")

    @_builtins.property
    @pulumi.getter(name="paramName")
    def param_name(self) -> _builtins.str:
        """
        Specifies the name of the param.
        """
        return pulumi.get(self, "param_name")

    @_builtins.property
    @pulumi.getter(name="valueRange")
    def value_range(self) -> _builtins.str:
        """
        Indicates the value range of the param.
        """
        return pulumi.get(self, "value_range")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> _builtins.str:
        """
        Indicates the value type of the param.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 cache_mode: _builtins.str,
                 description: _builtins.str,
                 engine: _builtins.str,
                 engine_version: _builtins.str,
                 name: _builtins.str,
                 product_type: _builtins.str,
                 storage_type: _builtins.str,
                 template_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str cache_mode: Specifies the DCS instance type. Value options:
               + **single**: single-node.
               + **ha**: master/standby.
               + **cluster**: Redis Cluster.
               + **proxy**: Proxy Cluster.
               + **ha_rw_split**: read/write splitting.
        :param _builtins.str description: Indicates the description of the template.
        :param _builtins.str engine: Specifies the cache engine. Value options: **Redis**.
        :param _builtins.str engine_version: Specifies the cache engine version. Value options: **4.0**, **5.0**, **6.0**.
        :param _builtins.str name: Specifies the name of the template.
        :param _builtins.str product_type: Specifies the product edition. Value options:
               + **generic**: standard edition.
               + **enterprise**: professional edition.
        :param _builtins.str storage_type: Specifies the storage type. Value options: **DRAM**, **SSD**.
        :param _builtins.str template_id: Specifies the ID of the template.
        :param _builtins.str type: Specifies the type of the template. Value options:
               + **sys**: system template.
               + **user**: custom template.
        """
        pulumi.set(__self__, "cache_mode", cache_mode)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "engine", engine)
        pulumi.set(__self__, "engine_version", engine_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product_type", product_type)
        pulumi.set(__self__, "storage_type", storage_type)
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cacheMode")
    def cache_mode(self) -> _builtins.str:
        """
        Specifies the DCS instance type. Value options:
        + **single**: single-node.
        + **ha**: master/standby.
        + **cluster**: Redis Cluster.
        + **proxy**: Proxy Cluster.
        + **ha_rw_split**: read/write splitting.
        """
        return pulumi.get(self, "cache_mode")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the template.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> _builtins.str:
        """
        Specifies the cache engine. Value options: **Redis**.
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> _builtins.str:
        """
        Specifies the cache engine version. Value options: **4.0**, **5.0**, **6.0**.
        """
        return pulumi.get(self, "engine_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="productType")
    def product_type(self) -> _builtins.str:
        """
        Specifies the product edition. Value options:
        + **generic**: standard edition.
        + **enterprise**: professional edition.
        """
        return pulumi.get(self, "product_type")

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> _builtins.str:
        """
        Specifies the storage type. Value options: **DRAM**, **SSD**.
        """
        return pulumi.get(self, "storage_type")

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        """
        Specifies the ID of the template.
        """
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the template. Value options:
        + **sys**: system template.
        + **user**: custom template.
        """
        return pulumi.get(self, "type")


