# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DomainCacheSettingsArgs',
    'DomainCacheSettingsArgsDict',
    'DomainCacheSettingsRuleArgs',
    'DomainCacheSettingsRuleArgsDict',
    'DomainConfigsArgs',
    'DomainConfigsArgsDict',
    'DomainConfigsAccessAreaFilterArgs',
    'DomainConfigsAccessAreaFilterArgsDict',
    'DomainConfigsBrowserCacheRuleArgs',
    'DomainConfigsBrowserCacheRuleArgsDict',
    'DomainConfigsBrowserCacheRuleConditionArgs',
    'DomainConfigsBrowserCacheRuleConditionArgsDict',
    'DomainConfigsCacheUrlParameterFilterArgs',
    'DomainConfigsCacheUrlParameterFilterArgsDict',
    'DomainConfigsClientCertArgs',
    'DomainConfigsClientCertArgsDict',
    'DomainConfigsCompressArgs',
    'DomainConfigsCompressArgsDict',
    'DomainConfigsErrorCodeCachArgs',
    'DomainConfigsErrorCodeCachArgsDict',
    'DomainConfigsErrorCodeRedirectRuleArgs',
    'DomainConfigsErrorCodeRedirectRuleArgsDict',
    'DomainConfigsFlexibleOriginArgs',
    'DomainConfigsFlexibleOriginArgsDict',
    'DomainConfigsFlexibleOriginBackSourcesArgs',
    'DomainConfigsFlexibleOriginBackSourcesArgsDict',
    'DomainConfigsForceRedirectArgs',
    'DomainConfigsForceRedirectArgsDict',
    'DomainConfigsHstsArgs',
    'DomainConfigsHstsArgsDict',
    'DomainConfigsHttpResponseHeaderArgs',
    'DomainConfigsHttpResponseHeaderArgsDict',
    'DomainConfigsHttpsSettingsArgs',
    'DomainConfigsHttpsSettingsArgsDict',
    'DomainConfigsIpFilterArgs',
    'DomainConfigsIpFilterArgsDict',
    'DomainConfigsIpFrequencyLimitArgs',
    'DomainConfigsIpFrequencyLimitArgsDict',
    'DomainConfigsOriginRequestUrlRewriteArgs',
    'DomainConfigsOriginRequestUrlRewriteArgsDict',
    'DomainConfigsQuicArgs',
    'DomainConfigsQuicArgsDict',
    'DomainConfigsRefererArgs',
    'DomainConfigsRefererArgsDict',
    'DomainConfigsRemoteAuthArgs',
    'DomainConfigsRemoteAuthArgsDict',
    'DomainConfigsRemoteAuthRemoteAuthRulesArgs',
    'DomainConfigsRemoteAuthRemoteAuthRulesArgsDict',
    'DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs',
    'DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict',
    'DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs',
    'DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict',
    'DomainConfigsRequestLimitRuleArgs',
    'DomainConfigsRequestLimitRuleArgsDict',
    'DomainConfigsRequestUrlRewriteArgs',
    'DomainConfigsRequestUrlRewriteArgsDict',
    'DomainConfigsRequestUrlRewriteConditionArgs',
    'DomainConfigsRequestUrlRewriteConditionArgsDict',
    'DomainConfigsRetrievalRequestHeaderArgs',
    'DomainConfigsRetrievalRequestHeaderArgsDict',
    'DomainConfigsSniArgs',
    'DomainConfigsSniArgsDict',
    'DomainConfigsUrlSigningArgs',
    'DomainConfigsUrlSigningArgsDict',
    'DomainConfigsUrlSigningInheritConfigArgs',
    'DomainConfigsUrlSigningInheritConfigArgsDict',
    'DomainConfigsUserAgentFilterArgs',
    'DomainConfigsUserAgentFilterArgsDict',
    'DomainConfigsVideoSeekArgs',
    'DomainConfigsVideoSeekArgsDict',
    'DomainConfigsWebsocketArgs',
    'DomainConfigsWebsocketArgsDict',
    'DomainRuleRuleArgs',
    'DomainRuleRuleArgsDict',
    'DomainRuleRuleActionArgs',
    'DomainRuleRuleActionArgsDict',
    'DomainRuleRuleActionAccessControlArgs',
    'DomainRuleRuleActionAccessControlArgsDict',
    'DomainRuleRuleActionCacheRuleArgs',
    'DomainRuleRuleActionCacheRuleArgsDict',
    'DomainRuleRuleActionFlexibleOriginArgs',
    'DomainRuleRuleActionFlexibleOriginArgsDict',
    'DomainRuleRuleActionHttpResponseHeaderArgs',
    'DomainRuleRuleActionHttpResponseHeaderArgsDict',
    'DomainRuleRuleActionOriginRequestHeaderArgs',
    'DomainRuleRuleActionOriginRequestHeaderArgsDict',
    'DomainRuleRuleActionOriginRequestUrlRewriteArgs',
    'DomainRuleRuleActionOriginRequestUrlRewriteArgsDict',
    'DomainRuleRuleActionRequestUrlRewriteArgs',
    'DomainRuleRuleActionRequestUrlRewriteArgsDict',
    'DomainRuleRuleConditionsArgs',
    'DomainRuleRuleConditionsArgsDict',
    'DomainRuleRuleConditionsMatchArgs',
    'DomainRuleRuleConditionsMatchArgsDict',
    'DomainSourceArgs',
    'DomainSourceArgsDict',
    'DomainV1CacheSettingsArgs',
    'DomainV1CacheSettingsArgsDict',
    'DomainV1CacheSettingsRuleArgs',
    'DomainV1CacheSettingsRuleArgsDict',
    'DomainV1ConfigsArgs',
    'DomainV1ConfigsArgsDict',
    'DomainV1ConfigsAccessAreaFilterArgs',
    'DomainV1ConfigsAccessAreaFilterArgsDict',
    'DomainV1ConfigsBrowserCacheRuleArgs',
    'DomainV1ConfigsBrowserCacheRuleArgsDict',
    'DomainV1ConfigsBrowserCacheRuleConditionArgs',
    'DomainV1ConfigsBrowserCacheRuleConditionArgsDict',
    'DomainV1ConfigsCacheUrlParameterFilterArgs',
    'DomainV1ConfigsCacheUrlParameterFilterArgsDict',
    'DomainV1ConfigsClientCertArgs',
    'DomainV1ConfigsClientCertArgsDict',
    'DomainV1ConfigsCompressArgs',
    'DomainV1ConfigsCompressArgsDict',
    'DomainV1ConfigsErrorCodeCachArgs',
    'DomainV1ConfigsErrorCodeCachArgsDict',
    'DomainV1ConfigsErrorCodeRedirectRuleArgs',
    'DomainV1ConfigsErrorCodeRedirectRuleArgsDict',
    'DomainV1ConfigsFlexibleOriginArgs',
    'DomainV1ConfigsFlexibleOriginArgsDict',
    'DomainV1ConfigsFlexibleOriginBackSourcesArgs',
    'DomainV1ConfigsFlexibleOriginBackSourcesArgsDict',
    'DomainV1ConfigsForceRedirectArgs',
    'DomainV1ConfigsForceRedirectArgsDict',
    'DomainV1ConfigsHstsArgs',
    'DomainV1ConfigsHstsArgsDict',
    'DomainV1ConfigsHttpResponseHeaderArgs',
    'DomainV1ConfigsHttpResponseHeaderArgsDict',
    'DomainV1ConfigsHttpsSettingsArgs',
    'DomainV1ConfigsHttpsSettingsArgsDict',
    'DomainV1ConfigsIpFilterArgs',
    'DomainV1ConfigsIpFilterArgsDict',
    'DomainV1ConfigsIpFrequencyLimitArgs',
    'DomainV1ConfigsIpFrequencyLimitArgsDict',
    'DomainV1ConfigsOriginRequestUrlRewriteArgs',
    'DomainV1ConfigsOriginRequestUrlRewriteArgsDict',
    'DomainV1ConfigsQuicArgs',
    'DomainV1ConfigsQuicArgsDict',
    'DomainV1ConfigsRefererArgs',
    'DomainV1ConfigsRefererArgsDict',
    'DomainV1ConfigsRemoteAuthArgs',
    'DomainV1ConfigsRemoteAuthArgsDict',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesArgs',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesArgsDict',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict',
    'DomainV1ConfigsRequestLimitRuleArgs',
    'DomainV1ConfigsRequestLimitRuleArgsDict',
    'DomainV1ConfigsRequestUrlRewriteArgs',
    'DomainV1ConfigsRequestUrlRewriteArgsDict',
    'DomainV1ConfigsRequestUrlRewriteConditionArgs',
    'DomainV1ConfigsRequestUrlRewriteConditionArgsDict',
    'DomainV1ConfigsRetrievalRequestHeaderArgs',
    'DomainV1ConfigsRetrievalRequestHeaderArgsDict',
    'DomainV1ConfigsSniArgs',
    'DomainV1ConfigsSniArgsDict',
    'DomainV1ConfigsUrlSigningArgs',
    'DomainV1ConfigsUrlSigningArgsDict',
    'DomainV1ConfigsUrlSigningInheritConfigArgs',
    'DomainV1ConfigsUrlSigningInheritConfigArgsDict',
    'DomainV1ConfigsUserAgentFilterArgs',
    'DomainV1ConfigsUserAgentFilterArgsDict',
    'DomainV1ConfigsVideoSeekArgs',
    'DomainV1ConfigsVideoSeekArgsDict',
    'DomainV1ConfigsWebsocketArgs',
    'DomainV1ConfigsWebsocketArgsDict',
    'DomainV1SourceArgs',
    'DomainV1SourceArgsDict',
]

MYPY = False

if not MYPY:
    class DomainCacheSettingsArgsDict(TypedDict):
        follow_origin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable origin cache control. Defaults to **false**.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCacheSettingsRuleArgsDict']]]]
        """
        Specifies the cache rules, which overwrite the previous rule configurations.
        Blank rules are reset to default rules. The rules structure is documented below.

        <a name="rules_object"></a>
        The `rules` block support:
        """
elif False:
    DomainCacheSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCacheSettingsArgs:
    def __init__(__self__, *,
                 follow_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCacheSettingsRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] follow_origin: Specifies whether to enable origin cache control. Defaults to **false**.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCacheSettingsRuleArgs']]] rules: Specifies the cache rules, which overwrite the previous rule configurations.
               Blank rules are reset to default rules. The rules structure is documented below.
               
               <a name="rules_object"></a>
               The `rules` block support:
        """
        if follow_origin is not None:
            pulumi.set(__self__, "follow_origin", follow_origin)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="followOrigin")
    def follow_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable origin cache control. Defaults to **false**.
        """
        return pulumi.get(self, "follow_origin")

    @follow_origin.setter
    def follow_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "follow_origin", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCacheSettingsRuleArgs']]]]:
        """
        Specifies the cache rules, which overwrite the previous rule configurations.
        Blank rules are reset to default rules. The rules structure is documented below.

        <a name="rules_object"></a>
        The `rules` block support:
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCacheSettingsRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class DomainCacheSettingsRuleArgsDict(TypedDict):
        rule_type: pulumi.Input[_builtins.str]
        """
        Specifies the rule type. Possible value are:
        + **all**: All types of files are matched. It is the default value. The cloud will create a cache rule with **all**
        rule type by default.
        + **file_extension**: Files are matched based on their suffixes.
        + **catalog**: Files are matched based on their directories.
        + **full_path**: Files are matched based on their full paths.
        + **home_page**: Files are matched based on their homepage.
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the content that matches `rule_type`.
        + If `rule_type` is set to **all** or **home_page**, keep this parameter empty.
        + If `rule_type` is set to **file_extension**, the value of this parameter is a list of file name
        extensions. A file name extension starts with a period (.). File name extensions are separated by semicolons (;),
        for example, `.jpg;.zip;.exe`. Up to 20 file types are supported.
        + If `rule_type` is set to **catalog**, the value of this parameter is a list of directories. A directory starts with
        a slash (/). Directories are separated by semicolons (;), for example, `/test/folder01;/test/folder02`.
        Up to 20 directories are supported.
        + If `rule_type` is set to **full_path**, the value must start with a slash (/) and cannot end with an asterisk.
        Example: `/test/index.html` or `/test/*.jpg`
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        ttl_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit of the cache age. Possible values:
        + **s**: Second
        + **m**: Minute
        + **h**: Hour
        + **d**: Day
        """
        url_parameter_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URL parameter types. Valid values are as follows:
        + **del_params**: Ignore specific URL parameters.
        + **reserve_params**: Retain specific URL parameters.
        + **ignore_url_params**: Ignore all URL parameters.
        + **full_url**: Retain all URL parameters.

        Defaults to **full_url**.
        """
        url_parameter_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URL parameter values, which are separated by commas (,).
        Up to 10 parameters can be set.
        This parameter is mandatory when `url_parameter_type` is set to **del_params** or **reserve_params**.
        """
elif False:
    DomainCacheSettingsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCacheSettingsRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl_type: Optional[pulumi.Input[_builtins.str]] = None,
                 url_parameter_type: Optional[pulumi.Input[_builtins.str]] = None,
                 url_parameter_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] rule_type: Specifies the rule type. Possible value are:
               + **all**: All types of files are matched. It is the default value. The cloud will create a cache rule with **all**
               rule type by default.
               + **file_extension**: Files are matched based on their suffixes.
               + **catalog**: Files are matched based on their directories.
               + **full_path**: Files are matched based on their full paths.
               + **home_page**: Files are matched based on their homepage.
        :param pulumi.Input[_builtins.str] content: Specifies the content that matches `rule_type`.
               + If `rule_type` is set to **all** or **home_page**, keep this parameter empty.
               + If `rule_type` is set to **file_extension**, the value of this parameter is a list of file name
               extensions. A file name extension starts with a period (.). File name extensions are separated by semicolons (;),
               for example, `.jpg;.zip;.exe`. Up to 20 file types are supported.
               + If `rule_type` is set to **catalog**, the value of this parameter is a list of directories. A directory starts with
               a slash (/). Directories are separated by semicolons (;), for example, `/test/folder01;/test/folder02`.
               Up to 20 directories are supported.
               + If `rule_type` is set to **full_path**, the value must start with a slash (/) and cannot end with an asterisk.
               Example: `/test/index.html` or `/test/*.jpg`
        :param pulumi.Input[_builtins.int] priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param pulumi.Input[_builtins.int] ttl: Specifies the cache age. The maximum cache age is 365 days.
        :param pulumi.Input[_builtins.str] ttl_type: Specifies the unit of the cache age. Possible values:
               + **s**: Second
               + **m**: Minute
               + **h**: Hour
               + **d**: Day
        :param pulumi.Input[_builtins.str] url_parameter_type: Specifies the URL parameter types. Valid values are as follows:
               + **del_params**: Ignore specific URL parameters.
               + **reserve_params**: Retain specific URL parameters.
               + **ignore_url_params**: Ignore all URL parameters.
               + **full_url**: Retain all URL parameters.
               
               Defaults to **full_url**.
        :param pulumi.Input[_builtins.str] url_parameter_value: Specifies the URL parameter values, which are separated by commas (,).
               Up to 10 parameters can be set.
               This parameter is mandatory when `url_parameter_type` is set to **del_params** or **reserve_params**.
        """
        pulumi.set(__self__, "rule_type", rule_type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_type is not None:
            pulumi.set(__self__, "ttl_type", ttl_type)
        if url_parameter_type is not None:
            pulumi.set(__self__, "url_parameter_type", url_parameter_type)
        if url_parameter_value is not None:
            pulumi.set(__self__, "url_parameter_value", url_parameter_value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rule type. Possible value are:
        + **all**: All types of files are matched. It is the default value. The cloud will create a cache rule with **all**
        rule type by default.
        + **file_extension**: Files are matched based on their suffixes.
        + **catalog**: Files are matched based on their directories.
        + **full_path**: Files are matched based on their full paths.
        + **home_page**: Files are matched based on their homepage.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the content that matches `rule_type`.
        + If `rule_type` is set to **all** or **home_page**, keep this parameter empty.
        + If `rule_type` is set to **file_extension**, the value of this parameter is a list of file name
        extensions. A file name extension starts with a period (.). File name extensions are separated by semicolons (;),
        for example, `.jpg;.zip;.exe`. Up to 20 file types are supported.
        + If `rule_type` is set to **catalog**, the value of this parameter is a list of directories. A directory starts with
        a slash (/). Directories are separated by semicolons (;), for example, `/test/folder01;/test/folder02`.
        Up to 20 directories are supported.
        + If `rule_type` is set to **full_path**, the value must start with a slash (/) and cannot end with an asterisk.
        Example: `/test/index.html` or `/test/*.jpg`
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="ttlType")
    def ttl_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit of the cache age. Possible values:
        + **s**: Second
        + **m**: Minute
        + **h**: Hour
        + **d**: Day
        """
        return pulumi.get(self, "ttl_type")

    @ttl_type.setter
    def ttl_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl_type", value)

    @_builtins.property
    @pulumi.getter(name="urlParameterType")
    def url_parameter_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL parameter types. Valid values are as follows:
        + **del_params**: Ignore specific URL parameters.
        + **reserve_params**: Retain specific URL parameters.
        + **ignore_url_params**: Ignore all URL parameters.
        + **full_url**: Retain all URL parameters.

        Defaults to **full_url**.
        """
        return pulumi.get(self, "url_parameter_type")

    @url_parameter_type.setter
    def url_parameter_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_parameter_type", value)

    @_builtins.property
    @pulumi.getter(name="urlParameterValue")
    def url_parameter_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL parameter values, which are separated by commas (,).
        Up to 10 parameters can be set.
        This parameter is mandatory when `url_parameter_type` is set to **del_params** or **reserve_params**.
        """
        return pulumi.get(self, "url_parameter_value")

    @url_parameter_value.setter
    def url_parameter_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_parameter_value", value)


if not MYPY:
    class DomainConfigsArgsDict(TypedDict):
        access_area_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsAccessAreaFilterArgsDict']]]]
        """
        Specifies the geographic access control rules.
        The access_area_filter structure is documented below.

        > 1. Before using this field, you need to submit a work order to activate this function.
        <br/>2. CDN periodically updates the IP address library. The locations of IP address that are not in the library
        cannot be identified. CDN allows requests from such IP addresses and returns resources to the users.
        """
        browser_cache_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsBrowserCacheRuleArgsDict']]]]
        """
        Specifies the browser cache expiration settings.
        The browser_cache_rules structure is documented below.
        """
        cache_url_parameter_filter: NotRequired[pulumi.Input['DomainConfigsCacheUrlParameterFilterArgsDict']]
        """
        schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        client_cert: NotRequired[pulumi.Input['DomainConfigsClientCertArgsDict']]
        """
        Specifies the client certificate configuration.
        The client_cert structure is documented below.

        <a name="https_settings_object"></a>
        The `https_settings` block support:
        """
        compress: NotRequired[pulumi.Input['DomainConfigsCompressArgsDict']]
        """
        Specifies the smart compression. The compress structure
        is documented below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the domain. The value contains up to `200` characters.
        """
        error_code_caches: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeCachArgsDict']]]]
        """
        Specifies the status code cache TTL.
        The error_code_cache structure is documented below.

        > 1. The status code cache TTL cannot be configured for domain names with special configurations.
        <br/>2. Domain names whose service type is whole site acceleration do not support configuring this field.
        <br/>3. By default, CDN caches status codes `400`, `404`, `416`, `500`, `502`, and `504` for `3` seconds and does not
        cache other status codes.
        """
        error_code_redirect_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeRedirectRuleArgsDict']]]]
        """
        Specifies the custom error pages.
        The error_code_redirect_rules structure is documented below.
        """
        flexible_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsFlexibleOriginArgsDict']]]]
        """
        Specifies the advanced origin rules.
        The flexible_origin structure is documented below.

        > Up to 20 advanced origin rules can be configured. When `type` is configured as **wholeSite**, configuring this
        field is not supported.
        """
        force_redirect: NotRequired[pulumi.Input['DomainConfigsForceRedirectArgsDict']]
        """
        Specifies the force redirect.
        The force_redirect structure is documented below.
        """
        hsts: NotRequired[pulumi.Input['DomainConfigsHstsArgsDict']]
        """
        Specifies the HSTS settings. HSTS forces clients (such as browsers) to use HTTPS to access
        your server, improving access security. The hsts structure is documented below.

        > This field can only be used when the HTTPS certificate is enabled.
        """
        http_response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsHttpResponseHeaderArgsDict']]]]
        """
        Specifies the HTTP response header settings.
        The http_response_header structure is documented below.
        """
        https_settings: NotRequired[pulumi.Input['DomainConfigsHttpsSettingsArgsDict']]
        """
        Specifies the certificate configuration. The https_settings
        structure is documented below.
        """
        ip_filter: NotRequired[pulumi.Input['DomainConfigsIpFilterArgsDict']]
        """
        Specifies the IP address blacklist or whitelist.
        The ip_filter structure is documented below.
        """
        ip_frequency_limit: NotRequired[pulumi.Input['DomainConfigsIpFrequencyLimitArgsDict']]
        """
        Specifies the IP access frequency limit.
        The ip_frequency_limit structure is documented below.

        > Restricting the IP access frequency can effectively defend against CC attacks, but it may affect normal access.
        Please set access thresholds carefully. After creating the domain name, please wait a few minutes before configuring
        this field, otherwise the configuration may fail.
        """
        ipv6_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable IPv6.
        """
        origin_follow302_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether to enable redirection from the origin.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **off**.
        """
        origin_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the content retrieval protocol. Possible values:
        + **follow**: Same as user requests.
        + **http**: HTTP, which is the default value.
        + **https**: HTTPS.
        """
        origin_receive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the origin response timeout.
        The value ranges from `5` to `60`, in seconds. Defaults to `30`.
        """
        origin_request_url_rewrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsOriginRequestUrlRewriteArgsDict']]]]
        """
        Specifies the rules of rewriting origin request URLs.
        The origin_request_url_rewrite structure is documented below.

        > Up to 20 rules can be configured.
        """
        quic: NotRequired[pulumi.Input['DomainConfigsQuicArgsDict']]
        """
        Specifies the QUIC protocol. The quic structure is documented below.

        > This field can only be used when the HTTPS certificate is enabled. Disabling the HTTPS certificate will disable QUIC.
        """
        range_based_retrieval_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable range-based retrieval.

        > The prerequisite for enabling range-based retrieval is that your origin site supports Range requests, that is, the
        HTTP request header contains the Range field. Otherwise, the back-to-origin may fail.
        """
        referer: NotRequired[pulumi.Input['DomainConfigsRefererArgsDict']]
        """
        Specifies the referer validation. The referer structure is documented below.

        > You can define referer whitelists and blacklists to control who can access specific domain names.
        """
        remote_auth: NotRequired[pulumi.Input['DomainConfigsRemoteAuthArgsDict']]
        """
        Specifies the remote authentication settings.
        The remote_auth structure is documented below.

        > Configure remote authentication to allow CDN to forward user requests to an authentication server and process the
        requests based on results returned by the authentication server.
        """
        request_limit_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestLimitRuleArgsDict']]]]
        """
        Specifies the request rate limiting rules.
        The request_limit_rules structure is documented below.

        > Up to 60 request limit rules can be configured.
        """
        request_url_rewrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestUrlRewriteArgsDict']]]]
        """
        Specifies the request url rewrite settings. Set access URL rewrite rules to
        redirect user requests to the URLs of cached resources.
        The request_url_rewrite structure is documented below.
        """
        retrieval_request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRetrievalRequestHeaderArgsDict']]]]
        """
        Specifies the retrieval request header settings.
        The retrieval_request_header structure is documented below.
        """
        slice_etag_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether ETag is verified during origin pull.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **on**.
        """
        sni: NotRequired[pulumi.Input['DomainConfigsSniArgsDict']]
        """
        Specifies the origin SNI settings. If your origin server is bound to multiple domains and
        CDN visits the origin server using HTTPS, set the Server Name Indication (SNI) to specify the domain to be accessed.
        The sni structure is documented below.

        > 1. The origin method must be HTTPS or the protocol can be configured for origin SNI.
        <br/>2. When the service type is whole site acceleration, source SNI configuration is not supported.
        <br/>3. Domain names with special configurations in the backend do not support origin SNI configuration.
        <br/>4. CDN node carries SNI information by default when a CDN node uses the HTTPS protocol to return to the source.
        If you do not configure the origin SNI, the origin HOST will be used as the SNI address by default.
        """
        url_signing: NotRequired[pulumi.Input['DomainConfigsUrlSigningArgsDict']]
        """
        Specifies the URL signing.
        The url_signing structure is documented below.
        """
        user_agent_filter: NotRequired[pulumi.Input['DomainConfigsUserAgentFilterArgsDict']]
        """
        Specifies the User-Agent blacklist or whitelist settings.
        The user_agent_filter structure is documented below.
        """
        video_seek: NotRequired[pulumi.Input['DomainConfigsVideoSeekArgsDict']]
        """
        Specifies the video seek settings. The video_seek structure
        is documented below.

        > 1. You need to configure a cache rule for `FLV` and `MP4` files and ignored all URL parameters in `cache_settings`.
        <br/>2. Video seek is valid only when your origin server supports range requests.
        <br/>3. Only `MP4` and `FLV` videos are supported.
        """
        websocket: NotRequired[pulumi.Input['DomainConfigsWebsocketArgsDict']]
        """
        Specifies the websocket settings. This field can only be configured if `type` is
        set to **wholeSite**. The websocket structure is documented below.

        > Websocket and HTTP/2 are incompatible and cannot be both enabled. Websocket will not take effect when
        origin cache control is enabled in the cache configuration.
        """
elif False:
    DomainConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsArgs:
    def __init__(__self__, *,
                 access_area_filters: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsAccessAreaFilterArgs']]]] = None,
                 browser_cache_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsBrowserCacheRuleArgs']]]] = None,
                 cache_url_parameter_filter: Optional[pulumi.Input['DomainConfigsCacheUrlParameterFilterArgs']] = None,
                 client_cert: Optional[pulumi.Input['DomainConfigsClientCertArgs']] = None,
                 compress: Optional[pulumi.Input['DomainConfigsCompressArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 error_code_caches: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeCachArgs']]]] = None,
                 error_code_redirect_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeRedirectRuleArgs']]]] = None,
                 flexible_origins: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsFlexibleOriginArgs']]]] = None,
                 force_redirect: Optional[pulumi.Input['DomainConfigsForceRedirectArgs']] = None,
                 hsts: Optional[pulumi.Input['DomainConfigsHstsArgs']] = None,
                 http_response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsHttpResponseHeaderArgs']]]] = None,
                 https_settings: Optional[pulumi.Input['DomainConfigsHttpsSettingsArgs']] = None,
                 ip_filter: Optional[pulumi.Input['DomainConfigsIpFilterArgs']] = None,
                 ip_frequency_limit: Optional[pulumi.Input['DomainConfigsIpFrequencyLimitArgs']] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin_follow302_status: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_receive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_request_url_rewrites: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsOriginRequestUrlRewriteArgs']]]] = None,
                 quic: Optional[pulumi.Input['DomainConfigsQuicArgs']] = None,
                 range_based_retrieval_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 referer: Optional[pulumi.Input['DomainConfigsRefererArgs']] = None,
                 remote_auth: Optional[pulumi.Input['DomainConfigsRemoteAuthArgs']] = None,
                 request_limit_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestLimitRuleArgs']]]] = None,
                 request_url_rewrites: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestUrlRewriteArgs']]]] = None,
                 retrieval_request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRetrievalRequestHeaderArgs']]]] = None,
                 slice_etag_status: Optional[pulumi.Input[_builtins.str]] = None,
                 sni: Optional[pulumi.Input['DomainConfigsSniArgs']] = None,
                 url_signing: Optional[pulumi.Input['DomainConfigsUrlSigningArgs']] = None,
                 user_agent_filter: Optional[pulumi.Input['DomainConfigsUserAgentFilterArgs']] = None,
                 video_seek: Optional[pulumi.Input['DomainConfigsVideoSeekArgs']] = None,
                 websocket: Optional[pulumi.Input['DomainConfigsWebsocketArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsAccessAreaFilterArgs']]] access_area_filters: Specifies the geographic access control rules.
               The access_area_filter structure is documented below.
               
               > 1. Before using this field, you need to submit a work order to activate this function.
               <br/>2. CDN periodically updates the IP address library. The locations of IP address that are not in the library
               cannot be identified. CDN allows requests from such IP addresses and returns resources to the users.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsBrowserCacheRuleArgs']]] browser_cache_rules: Specifies the browser cache expiration settings.
               The browser_cache_rules structure is documented below.
        :param pulumi.Input['DomainConfigsCacheUrlParameterFilterArgs'] cache_url_parameter_filter: schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        :param pulumi.Input['DomainConfigsClientCertArgs'] client_cert: Specifies the client certificate configuration.
               The client_cert structure is documented below.
               
               <a name="https_settings_object"></a>
               The `https_settings` block support:
        :param pulumi.Input['DomainConfigsCompressArgs'] compress: Specifies the smart compression. The compress structure
               is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the domain. The value contains up to `200` characters.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeCachArgs']]] error_code_caches: Specifies the status code cache TTL.
               The error_code_cache structure is documented below.
               
               > 1. The status code cache TTL cannot be configured for domain names with special configurations.
               <br/>2. Domain names whose service type is whole site acceleration do not support configuring this field.
               <br/>3. By default, CDN caches status codes `400`, `404`, `416`, `500`, `502`, and `504` for `3` seconds and does not
               cache other status codes.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeRedirectRuleArgs']]] error_code_redirect_rules: Specifies the custom error pages.
               The error_code_redirect_rules structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsFlexibleOriginArgs']]] flexible_origins: Specifies the advanced origin rules.
               The flexible_origin structure is documented below.
               
               > Up to 20 advanced origin rules can be configured. When `type` is configured as **wholeSite**, configuring this
               field is not supported.
        :param pulumi.Input['DomainConfigsForceRedirectArgs'] force_redirect: Specifies the force redirect.
               The force_redirect structure is documented below.
        :param pulumi.Input['DomainConfigsHstsArgs'] hsts: Specifies the HSTS settings. HSTS forces clients (such as browsers) to use HTTPS to access
               your server, improving access security. The hsts structure is documented below.
               
               > This field can only be used when the HTTPS certificate is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsHttpResponseHeaderArgs']]] http_response_headers: Specifies the HTTP response header settings.
               The http_response_header structure is documented below.
        :param pulumi.Input['DomainConfigsHttpsSettingsArgs'] https_settings: Specifies the certificate configuration. The https_settings
               structure is documented below.
        :param pulumi.Input['DomainConfigsIpFilterArgs'] ip_filter: Specifies the IP address blacklist or whitelist.
               The ip_filter structure is documented below.
        :param pulumi.Input['DomainConfigsIpFrequencyLimitArgs'] ip_frequency_limit: Specifies the IP access frequency limit.
               The ip_frequency_limit structure is documented below.
               
               > Restricting the IP access frequency can effectively defend against CC attacks, but it may affect normal access.
               Please set access thresholds carefully. After creating the domain name, please wait a few minutes before configuring
               this field, otherwise the configuration may fail.
        :param pulumi.Input[_builtins.bool] ipv6_enable: Specifies whether to enable IPv6.
        :param pulumi.Input[_builtins.str] origin_follow302_status: Specifies whether to enable redirection from the origin.
               Valid values are as follows:
               + **on**: Enable.
               + **off**: Disable.
               
               Defaults to **off**.
        :param pulumi.Input[_builtins.str] origin_protocol: Specifies the content retrieval protocol. Possible values:
               + **follow**: Same as user requests.
               + **http**: HTTP, which is the default value.
               + **https**: HTTPS.
        :param pulumi.Input[_builtins.int] origin_receive_timeout: Specifies the origin response timeout.
               The value ranges from `5` to `60`, in seconds. Defaults to `30`.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsOriginRequestUrlRewriteArgs']]] origin_request_url_rewrites: Specifies the rules of rewriting origin request URLs.
               The origin_request_url_rewrite structure is documented below.
               
               > Up to 20 rules can be configured.
        :param pulumi.Input['DomainConfigsQuicArgs'] quic: Specifies the QUIC protocol. The quic structure is documented below.
               
               > This field can only be used when the HTTPS certificate is enabled. Disabling the HTTPS certificate will disable QUIC.
        :param pulumi.Input[_builtins.bool] range_based_retrieval_enabled: Specifies whether to enable range-based retrieval.
               
               > The prerequisite for enabling range-based retrieval is that your origin site supports Range requests, that is, the
               HTTP request header contains the Range field. Otherwise, the back-to-origin may fail.
        :param pulumi.Input['DomainConfigsRefererArgs'] referer: Specifies the referer validation. The referer structure is documented below.
               
               > You can define referer whitelists and blacklists to control who can access specific domain names.
        :param pulumi.Input['DomainConfigsRemoteAuthArgs'] remote_auth: Specifies the remote authentication settings.
               The remote_auth structure is documented below.
               
               > Configure remote authentication to allow CDN to forward user requests to an authentication server and process the
               requests based on results returned by the authentication server.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestLimitRuleArgs']]] request_limit_rules: Specifies the request rate limiting rules.
               The request_limit_rules structure is documented below.
               
               > Up to 60 request limit rules can be configured.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestUrlRewriteArgs']]] request_url_rewrites: Specifies the request url rewrite settings. Set access URL rewrite rules to
               redirect user requests to the URLs of cached resources.
               The request_url_rewrite structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsRetrievalRequestHeaderArgs']]] retrieval_request_headers: Specifies the retrieval request header settings.
               The retrieval_request_header structure is documented below.
        :param pulumi.Input[_builtins.str] slice_etag_status: Specifies whether ETag is verified during origin pull.
               Valid values are as follows:
               + **on**: Enable.
               + **off**: Disable.
               
               Defaults to **on**.
        :param pulumi.Input['DomainConfigsSniArgs'] sni: Specifies the origin SNI settings. If your origin server is bound to multiple domains and
               CDN visits the origin server using HTTPS, set the Server Name Indication (SNI) to specify the domain to be accessed.
               The sni structure is documented below.
               
               > 1. The origin method must be HTTPS or the protocol can be configured for origin SNI.
               <br/>2. When the service type is whole site acceleration, source SNI configuration is not supported.
               <br/>3. Domain names with special configurations in the backend do not support origin SNI configuration.
               <br/>4. CDN node carries SNI information by default when a CDN node uses the HTTPS protocol to return to the source.
               If you do not configure the origin SNI, the origin HOST will be used as the SNI address by default.
        :param pulumi.Input['DomainConfigsUrlSigningArgs'] url_signing: Specifies the URL signing.
               The url_signing structure is documented below.
        :param pulumi.Input['DomainConfigsUserAgentFilterArgs'] user_agent_filter: Specifies the User-Agent blacklist or whitelist settings.
               The user_agent_filter structure is documented below.
        :param pulumi.Input['DomainConfigsVideoSeekArgs'] video_seek: Specifies the video seek settings. The video_seek structure
               is documented below.
               
               > 1. You need to configure a cache rule for `FLV` and `MP4` files and ignored all URL parameters in `cache_settings`.
               <br/>2. Video seek is valid only when your origin server supports range requests.
               <br/>3. Only `MP4` and `FLV` videos are supported.
        :param pulumi.Input['DomainConfigsWebsocketArgs'] websocket: Specifies the websocket settings. This field can only be configured if `type` is
               set to **wholeSite**. The websocket structure is documented below.
               
               > Websocket and HTTP/2 are incompatible and cannot be both enabled. Websocket will not take effect when
               origin cache control is enabled in the cache configuration.
        """
        if access_area_filters is not None:
            pulumi.set(__self__, "access_area_filters", access_area_filters)
        if browser_cache_rules is not None:
            pulumi.set(__self__, "browser_cache_rules", browser_cache_rules)
        if cache_url_parameter_filter is not None:
            pulumi.set(__self__, "cache_url_parameter_filter", cache_url_parameter_filter)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if error_code_caches is not None:
            pulumi.set(__self__, "error_code_caches", error_code_caches)
        if error_code_redirect_rules is not None:
            pulumi.set(__self__, "error_code_redirect_rules", error_code_redirect_rules)
        if flexible_origins is not None:
            pulumi.set(__self__, "flexible_origins", flexible_origins)
        if force_redirect is not None:
            pulumi.set(__self__, "force_redirect", force_redirect)
        if hsts is not None:
            pulumi.set(__self__, "hsts", hsts)
        if http_response_headers is not None:
            pulumi.set(__self__, "http_response_headers", http_response_headers)
        if https_settings is not None:
            pulumi.set(__self__, "https_settings", https_settings)
        if ip_filter is not None:
            pulumi.set(__self__, "ip_filter", ip_filter)
        if ip_frequency_limit is not None:
            pulumi.set(__self__, "ip_frequency_limit", ip_frequency_limit)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if origin_follow302_status is not None:
            pulumi.set(__self__, "origin_follow302_status", origin_follow302_status)
        if origin_protocol is not None:
            pulumi.set(__self__, "origin_protocol", origin_protocol)
        if origin_receive_timeout is not None:
            pulumi.set(__self__, "origin_receive_timeout", origin_receive_timeout)
        if origin_request_url_rewrites is not None:
            pulumi.set(__self__, "origin_request_url_rewrites", origin_request_url_rewrites)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if range_based_retrieval_enabled is not None:
            pulumi.set(__self__, "range_based_retrieval_enabled", range_based_retrieval_enabled)
        if referer is not None:
            pulumi.set(__self__, "referer", referer)
        if remote_auth is not None:
            pulumi.set(__self__, "remote_auth", remote_auth)
        if request_limit_rules is not None:
            pulumi.set(__self__, "request_limit_rules", request_limit_rules)
        if request_url_rewrites is not None:
            pulumi.set(__self__, "request_url_rewrites", request_url_rewrites)
        if retrieval_request_headers is not None:
            pulumi.set(__self__, "retrieval_request_headers", retrieval_request_headers)
        if slice_etag_status is not None:
            pulumi.set(__self__, "slice_etag_status", slice_etag_status)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if url_signing is not None:
            pulumi.set(__self__, "url_signing", url_signing)
        if user_agent_filter is not None:
            pulumi.set(__self__, "user_agent_filter", user_agent_filter)
        if video_seek is not None:
            pulumi.set(__self__, "video_seek", video_seek)
        if websocket is not None:
            pulumi.set(__self__, "websocket", websocket)

    @_builtins.property
    @pulumi.getter(name="accessAreaFilters")
    def access_area_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsAccessAreaFilterArgs']]]]:
        """
        Specifies the geographic access control rules.
        The access_area_filter structure is documented below.

        > 1. Before using this field, you need to submit a work order to activate this function.
        <br/>2. CDN periodically updates the IP address library. The locations of IP address that are not in the library
        cannot be identified. CDN allows requests from such IP addresses and returns resources to the users.
        """
        return pulumi.get(self, "access_area_filters")

    @access_area_filters.setter
    def access_area_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsAccessAreaFilterArgs']]]]):
        pulumi.set(self, "access_area_filters", value)

    @_builtins.property
    @pulumi.getter(name="browserCacheRules")
    def browser_cache_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsBrowserCacheRuleArgs']]]]:
        """
        Specifies the browser cache expiration settings.
        The browser_cache_rules structure is documented below.
        """
        return pulumi.get(self, "browser_cache_rules")

    @browser_cache_rules.setter
    def browser_cache_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsBrowserCacheRuleArgs']]]]):
        pulumi.set(self, "browser_cache_rules", value)

    @_builtins.property
    @pulumi.getter(name="cacheUrlParameterFilter")
    def cache_url_parameter_filter(self) -> Optional[pulumi.Input['DomainConfigsCacheUrlParameterFilterArgs']]:
        """
        schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        return pulumi.get(self, "cache_url_parameter_filter")

    @cache_url_parameter_filter.setter
    def cache_url_parameter_filter(self, value: Optional[pulumi.Input['DomainConfigsCacheUrlParameterFilterArgs']]):
        pulumi.set(self, "cache_url_parameter_filter", value)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input['DomainConfigsClientCertArgs']]:
        """
        Specifies the client certificate configuration.
        The client_cert structure is documented below.

        <a name="https_settings_object"></a>
        The `https_settings` block support:
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input['DomainConfigsClientCertArgs']]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input['DomainConfigsCompressArgs']]:
        """
        Specifies the smart compression. The compress structure
        is documented below.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input['DomainConfigsCompressArgs']]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the domain. The value contains up to `200` characters.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="errorCodeCaches")
    def error_code_caches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeCachArgs']]]]:
        """
        Specifies the status code cache TTL.
        The error_code_cache structure is documented below.

        > 1. The status code cache TTL cannot be configured for domain names with special configurations.
        <br/>2. Domain names whose service type is whole site acceleration do not support configuring this field.
        <br/>3. By default, CDN caches status codes `400`, `404`, `416`, `500`, `502`, and `504` for `3` seconds and does not
        cache other status codes.
        """
        return pulumi.get(self, "error_code_caches")

    @error_code_caches.setter
    def error_code_caches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeCachArgs']]]]):
        pulumi.set(self, "error_code_caches", value)

    @_builtins.property
    @pulumi.getter(name="errorCodeRedirectRules")
    def error_code_redirect_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeRedirectRuleArgs']]]]:
        """
        Specifies the custom error pages.
        The error_code_redirect_rules structure is documented below.
        """
        return pulumi.get(self, "error_code_redirect_rules")

    @error_code_redirect_rules.setter
    def error_code_redirect_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsErrorCodeRedirectRuleArgs']]]]):
        pulumi.set(self, "error_code_redirect_rules", value)

    @_builtins.property
    @pulumi.getter(name="flexibleOrigins")
    def flexible_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsFlexibleOriginArgs']]]]:
        """
        Specifies the advanced origin rules.
        The flexible_origin structure is documented below.

        > Up to 20 advanced origin rules can be configured. When `type` is configured as **wholeSite**, configuring this
        field is not supported.
        """
        return pulumi.get(self, "flexible_origins")

    @flexible_origins.setter
    def flexible_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsFlexibleOriginArgs']]]]):
        pulumi.set(self, "flexible_origins", value)

    @_builtins.property
    @pulumi.getter(name="forceRedirect")
    def force_redirect(self) -> Optional[pulumi.Input['DomainConfigsForceRedirectArgs']]:
        """
        Specifies the force redirect.
        The force_redirect structure is documented below.
        """
        return pulumi.get(self, "force_redirect")

    @force_redirect.setter
    def force_redirect(self, value: Optional[pulumi.Input['DomainConfigsForceRedirectArgs']]):
        pulumi.set(self, "force_redirect", value)

    @_builtins.property
    @pulumi.getter
    def hsts(self) -> Optional[pulumi.Input['DomainConfigsHstsArgs']]:
        """
        Specifies the HSTS settings. HSTS forces clients (such as browsers) to use HTTPS to access
        your server, improving access security. The hsts structure is documented below.

        > This field can only be used when the HTTPS certificate is enabled.
        """
        return pulumi.get(self, "hsts")

    @hsts.setter
    def hsts(self, value: Optional[pulumi.Input['DomainConfigsHstsArgs']]):
        pulumi.set(self, "hsts", value)

    @_builtins.property
    @pulumi.getter(name="httpResponseHeaders")
    def http_response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsHttpResponseHeaderArgs']]]]:
        """
        Specifies the HTTP response header settings.
        The http_response_header structure is documented below.
        """
        return pulumi.get(self, "http_response_headers")

    @http_response_headers.setter
    def http_response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsHttpResponseHeaderArgs']]]]):
        pulumi.set(self, "http_response_headers", value)

    @_builtins.property
    @pulumi.getter(name="httpsSettings")
    def https_settings(self) -> Optional[pulumi.Input['DomainConfigsHttpsSettingsArgs']]:
        """
        Specifies the certificate configuration. The https_settings
        structure is documented below.
        """
        return pulumi.get(self, "https_settings")

    @https_settings.setter
    def https_settings(self, value: Optional[pulumi.Input['DomainConfigsHttpsSettingsArgs']]):
        pulumi.set(self, "https_settings", value)

    @_builtins.property
    @pulumi.getter(name="ipFilter")
    def ip_filter(self) -> Optional[pulumi.Input['DomainConfigsIpFilterArgs']]:
        """
        Specifies the IP address blacklist or whitelist.
        The ip_filter structure is documented below.
        """
        return pulumi.get(self, "ip_filter")

    @ip_filter.setter
    def ip_filter(self, value: Optional[pulumi.Input['DomainConfigsIpFilterArgs']]):
        pulumi.set(self, "ip_filter", value)

    @_builtins.property
    @pulumi.getter(name="ipFrequencyLimit")
    def ip_frequency_limit(self) -> Optional[pulumi.Input['DomainConfigsIpFrequencyLimitArgs']]:
        """
        Specifies the IP access frequency limit.
        The ip_frequency_limit structure is documented below.

        > Restricting the IP access frequency can effectively defend against CC attacks, but it may affect normal access.
        Please set access thresholds carefully. After creating the domain name, please wait a few minutes before configuring
        this field, otherwise the configuration may fail.
        """
        return pulumi.get(self, "ip_frequency_limit")

    @ip_frequency_limit.setter
    def ip_frequency_limit(self, value: Optional[pulumi.Input['DomainConfigsIpFrequencyLimitArgs']]):
        pulumi.set(self, "ip_frequency_limit", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable IPv6.
        """
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @_builtins.property
    @pulumi.getter(name="originFollow302Status")
    def origin_follow302_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether to enable redirection from the origin.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **off**.
        """
        return pulumi.get(self, "origin_follow302_status")

    @origin_follow302_status.setter
    def origin_follow302_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_follow302_status", value)

    @_builtins.property
    @pulumi.getter(name="originProtocol")
    def origin_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the content retrieval protocol. Possible values:
        + **follow**: Same as user requests.
        + **http**: HTTP, which is the default value.
        + **https**: HTTPS.
        """
        return pulumi.get(self, "origin_protocol")

    @origin_protocol.setter
    def origin_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_protocol", value)

    @_builtins.property
    @pulumi.getter(name="originReceiveTimeout")
    def origin_receive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the origin response timeout.
        The value ranges from `5` to `60`, in seconds. Defaults to `30`.
        """
        return pulumi.get(self, "origin_receive_timeout")

    @origin_receive_timeout.setter
    def origin_receive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_receive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="originRequestUrlRewrites")
    def origin_request_url_rewrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsOriginRequestUrlRewriteArgs']]]]:
        """
        Specifies the rules of rewriting origin request URLs.
        The origin_request_url_rewrite structure is documented below.

        > Up to 20 rules can be configured.
        """
        return pulumi.get(self, "origin_request_url_rewrites")

    @origin_request_url_rewrites.setter
    def origin_request_url_rewrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsOriginRequestUrlRewriteArgs']]]]):
        pulumi.set(self, "origin_request_url_rewrites", value)

    @_builtins.property
    @pulumi.getter
    def quic(self) -> Optional[pulumi.Input['DomainConfigsQuicArgs']]:
        """
        Specifies the QUIC protocol. The quic structure is documented below.

        > This field can only be used when the HTTPS certificate is enabled. Disabling the HTTPS certificate will disable QUIC.
        """
        return pulumi.get(self, "quic")

    @quic.setter
    def quic(self, value: Optional[pulumi.Input['DomainConfigsQuicArgs']]):
        pulumi.set(self, "quic", value)

    @_builtins.property
    @pulumi.getter(name="rangeBasedRetrievalEnabled")
    def range_based_retrieval_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable range-based retrieval.

        > The prerequisite for enabling range-based retrieval is that your origin site supports Range requests, that is, the
        HTTP request header contains the Range field. Otherwise, the back-to-origin may fail.
        """
        return pulumi.get(self, "range_based_retrieval_enabled")

    @range_based_retrieval_enabled.setter
    def range_based_retrieval_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "range_based_retrieval_enabled", value)

    @_builtins.property
    @pulumi.getter
    def referer(self) -> Optional[pulumi.Input['DomainConfigsRefererArgs']]:
        """
        Specifies the referer validation. The referer structure is documented below.

        > You can define referer whitelists and blacklists to control who can access specific domain names.
        """
        return pulumi.get(self, "referer")

    @referer.setter
    def referer(self, value: Optional[pulumi.Input['DomainConfigsRefererArgs']]):
        pulumi.set(self, "referer", value)

    @_builtins.property
    @pulumi.getter(name="remoteAuth")
    def remote_auth(self) -> Optional[pulumi.Input['DomainConfigsRemoteAuthArgs']]:
        """
        Specifies the remote authentication settings.
        The remote_auth structure is documented below.

        > Configure remote authentication to allow CDN to forward user requests to an authentication server and process the
        requests based on results returned by the authentication server.
        """
        return pulumi.get(self, "remote_auth")

    @remote_auth.setter
    def remote_auth(self, value: Optional[pulumi.Input['DomainConfigsRemoteAuthArgs']]):
        pulumi.set(self, "remote_auth", value)

    @_builtins.property
    @pulumi.getter(name="requestLimitRules")
    def request_limit_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestLimitRuleArgs']]]]:
        """
        Specifies the request rate limiting rules.
        The request_limit_rules structure is documented below.

        > Up to 60 request limit rules can be configured.
        """
        return pulumi.get(self, "request_limit_rules")

    @request_limit_rules.setter
    def request_limit_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestLimitRuleArgs']]]]):
        pulumi.set(self, "request_limit_rules", value)

    @_builtins.property
    @pulumi.getter(name="requestUrlRewrites")
    def request_url_rewrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestUrlRewriteArgs']]]]:
        """
        Specifies the request url rewrite settings. Set access URL rewrite rules to
        redirect user requests to the URLs of cached resources.
        The request_url_rewrite structure is documented below.
        """
        return pulumi.get(self, "request_url_rewrites")

    @request_url_rewrites.setter
    def request_url_rewrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRequestUrlRewriteArgs']]]]):
        pulumi.set(self, "request_url_rewrites", value)

    @_builtins.property
    @pulumi.getter(name="retrievalRequestHeaders")
    def retrieval_request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRetrievalRequestHeaderArgs']]]]:
        """
        Specifies the retrieval request header settings.
        The retrieval_request_header structure is documented below.
        """
        return pulumi.get(self, "retrieval_request_headers")

    @retrieval_request_headers.setter
    def retrieval_request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRetrievalRequestHeaderArgs']]]]):
        pulumi.set(self, "retrieval_request_headers", value)

    @_builtins.property
    @pulumi.getter(name="sliceEtagStatus")
    def slice_etag_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether ETag is verified during origin pull.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **on**.
        """
        return pulumi.get(self, "slice_etag_status")

    @slice_etag_status.setter
    def slice_etag_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slice_etag_status", value)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input['DomainConfigsSniArgs']]:
        """
        Specifies the origin SNI settings. If your origin server is bound to multiple domains and
        CDN visits the origin server using HTTPS, set the Server Name Indication (SNI) to specify the domain to be accessed.
        The sni structure is documented below.

        > 1. The origin method must be HTTPS or the protocol can be configured for origin SNI.
        <br/>2. When the service type is whole site acceleration, source SNI configuration is not supported.
        <br/>3. Domain names with special configurations in the backend do not support origin SNI configuration.
        <br/>4. CDN node carries SNI information by default when a CDN node uses the HTTPS protocol to return to the source.
        If you do not configure the origin SNI, the origin HOST will be used as the SNI address by default.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input['DomainConfigsSniArgs']]):
        pulumi.set(self, "sni", value)

    @_builtins.property
    @pulumi.getter(name="urlSigning")
    def url_signing(self) -> Optional[pulumi.Input['DomainConfigsUrlSigningArgs']]:
        """
        Specifies the URL signing.
        The url_signing structure is documented below.
        """
        return pulumi.get(self, "url_signing")

    @url_signing.setter
    def url_signing(self, value: Optional[pulumi.Input['DomainConfigsUrlSigningArgs']]):
        pulumi.set(self, "url_signing", value)

    @_builtins.property
    @pulumi.getter(name="userAgentFilter")
    def user_agent_filter(self) -> Optional[pulumi.Input['DomainConfigsUserAgentFilterArgs']]:
        """
        Specifies the User-Agent blacklist or whitelist settings.
        The user_agent_filter structure is documented below.
        """
        return pulumi.get(self, "user_agent_filter")

    @user_agent_filter.setter
    def user_agent_filter(self, value: Optional[pulumi.Input['DomainConfigsUserAgentFilterArgs']]):
        pulumi.set(self, "user_agent_filter", value)

    @_builtins.property
    @pulumi.getter(name="videoSeek")
    def video_seek(self) -> Optional[pulumi.Input['DomainConfigsVideoSeekArgs']]:
        """
        Specifies the video seek settings. The video_seek structure
        is documented below.

        > 1. You need to configure a cache rule for `FLV` and `MP4` files and ignored all URL parameters in `cache_settings`.
        <br/>2. Video seek is valid only when your origin server supports range requests.
        <br/>3. Only `MP4` and `FLV` videos are supported.
        """
        return pulumi.get(self, "video_seek")

    @video_seek.setter
    def video_seek(self, value: Optional[pulumi.Input['DomainConfigsVideoSeekArgs']]):
        pulumi.set(self, "video_seek", value)

    @_builtins.property
    @pulumi.getter
    def websocket(self) -> Optional[pulumi.Input['DomainConfigsWebsocketArgs']]:
        """
        Specifies the websocket settings. This field can only be configured if `type` is
        set to **wholeSite**. The websocket structure is documented below.

        > Websocket and HTTP/2 are incompatible and cannot be both enabled. Websocket will not take effect when
        origin cache control is enabled in the cache configuration.
        """
        return pulumi.get(self, "websocket")

    @websocket.setter
    def websocket(self, value: Optional[pulumi.Input['DomainConfigsWebsocketArgs']]):
        pulumi.set(self, "websocket", value)


if not MYPY:
    class DomainConfigsAccessAreaFilterArgsDict(TypedDict):
        area: pulumi.Input[_builtins.str]
        """
        Specifies the areas, separated by commas.
        Please refer to [Geographical Location Codes](https://support.huaweicloud.com/intl/en-us/api-cdn/cdn_02_0090.html).
        """
        content_type: pulumi.Input[_builtins.str]
        """
        Specifies the content type. Valid values are:
        + **all**: The rule takes effect for all files.
        + **file_directory**: The rule takes effect for resources in the specified directory.
        + **file_path**: The rule takes effect for resources corresponding to the path.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        content_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the content value. The use of this field has the following restrictions:
        + When `content_type` is set to **all**, make this parameter is empty or not passed.
        + When `content_type` is set to **file_directory**, the value must start with a slash (/) and multiple directories
        are separated by commas (,), for example, **/test/folder01,/test/folder02**. Up to `100` directories can be entered.
        + When `content_type` is set to **file_path**, the value must start with a slash (/) or wildcard (\\*). Up to two
        wildcards (\\*) are allowed and they cannot be consecutive. Multiple paths are separated by commas (,),
        for example, **/test/a.txt,/test/b.txt**. Up to `100` paths can be entered.
        """
        exception_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP addresses exception in access control, separated by commas.

        <a name="client_cert_object"></a>
        The `client_cert` block support:
        """
elif False:
    DomainConfigsAccessAreaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsAccessAreaFilterArgs:
    def __init__(__self__, *,
                 area: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 content_value: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] area: Specifies the areas, separated by commas.
               Please refer to [Geographical Location Codes](https://support.huaweicloud.com/intl/en-us/api-cdn/cdn_02_0090.html).
        :param pulumi.Input[_builtins.str] content_type: Specifies the content type. Valid values are:
               + **all**: The rule takes effect for all files.
               + **file_directory**: The rule takes effect for resources in the specified directory.
               + **file_path**: The rule takes effect for resources corresponding to the path.
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.str] content_value: Specifies the content value. The use of this field has the following restrictions:
               + When `content_type` is set to **all**, make this parameter is empty or not passed.
               + When `content_type` is set to **file_directory**, the value must start with a slash (/) and multiple directories
               are separated by commas (,), for example, **/test/folder01,/test/folder02**. Up to `100` directories can be entered.
               + When `content_type` is set to **file_path**, the value must start with a slash (/) or wildcard (\\*). Up to two
               wildcards (\\*) are allowed and they cannot be consecutive. Multiple paths are separated by commas (,),
               for example, **/test/a.txt,/test/b.txt**. Up to `100` paths can be entered.
        :param pulumi.Input[_builtins.str] exception_ip: Specifies the IP addresses exception in access control, separated by commas.
               
               <a name="client_cert_object"></a>
               The `client_cert` block support:
        """
        pulumi.set(__self__, "area", area)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "type", type)
        if content_value is not None:
            pulumi.set(__self__, "content_value", content_value)
        if exception_ip is not None:
            pulumi.set(__self__, "exception_ip", exception_ip)

    @_builtins.property
    @pulumi.getter
    def area(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the areas, separated by commas.
        Please refer to [Geographical Location Codes](https://support.huaweicloud.com/intl/en-us/api-cdn/cdn_02_0090.html).
        """
        return pulumi.get(self, "area")

    @area.setter
    def area(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "area", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the content type. Valid values are:
        + **all**: The rule takes effect for all files.
        + **file_directory**: The rule takes effect for resources in the specified directory.
        + **file_path**: The rule takes effect for resources corresponding to the path.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="contentValue")
    def content_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the content value. The use of this field has the following restrictions:
        + When `content_type` is set to **all**, make this parameter is empty or not passed.
        + When `content_type` is set to **file_directory**, the value must start with a slash (/) and multiple directories
        are separated by commas (,), for example, **/test/folder01,/test/folder02**. Up to `100` directories can be entered.
        + When `content_type` is set to **file_path**, the value must start with a slash (/) or wildcard (\\*). Up to two
        wildcards (\\*) are allowed and they cannot be consecutive. Multiple paths are separated by commas (,),
        for example, **/test/a.txt,/test/b.txt**. Up to `100` paths can be entered.
        """
        return pulumi.get(self, "content_value")

    @content_value.setter
    def content_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_value", value)

    @_builtins.property
    @pulumi.getter(name="exceptionIp")
    def exception_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP addresses exception in access control, separated by commas.

        <a name="client_cert_object"></a>
        The `client_cert` block support:
        """
        return pulumi.get(self, "exception_ip")

    @exception_ip.setter
    def exception_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exception_ip", value)


if not MYPY:
    class DomainConfigsBrowserCacheRuleArgsDict(TypedDict):
        cache_type: pulumi.Input[_builtins.str]
        """
        Specifies the cache validation type. Valid values are:
        + **follow_origin**: Follow the origin site's cache policy, i.e. the Cache-Control header settings.
        + **ttl**: The browser cache follows the expiration time set by the current rules.
        + **never**: The browser does not cache resources.
        """
        condition: pulumi.Input['DomainConfigsBrowserCacheRuleConditionArgsDict']
        """
        Specifies matching condition.
        The condition structure is documented below.
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        ttl_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cache expiration time unit. Valid values are:
        + **s**: seconds.
        + **m**: minutes.
        + **h**: hours.
        + **d**: days.

        > This field is required when the `cache_type` is set to **ttl**.

        <a name="browser_cache_rules_condition_object"></a>
        The `condition` block support:
        """
elif False:
    DomainConfigsBrowserCacheRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsBrowserCacheRuleArgs:
    def __init__(__self__, *,
                 cache_type: pulumi.Input[_builtins.str],
                 condition: pulumi.Input['DomainConfigsBrowserCacheRuleConditionArgs'],
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl_unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cache_type: Specifies the cache validation type. Valid values are:
               + **follow_origin**: Follow the origin site's cache policy, i.e. the Cache-Control header settings.
               + **ttl**: The browser cache follows the expiration time set by the current rules.
               + **never**: The browser does not cache resources.
        :param pulumi.Input['DomainConfigsBrowserCacheRuleConditionArgs'] condition: Specifies matching condition.
               The condition structure is documented below.
        :param pulumi.Input[_builtins.int] ttl: Specifies the cache age. The maximum cache age is 365 days.
        :param pulumi.Input[_builtins.str] ttl_unit: Specifies the cache expiration time unit. Valid values are:
               + **s**: seconds.
               + **m**: minutes.
               + **h**: hours.
               + **d**: days.
               
               > This field is required when the `cache_type` is set to **ttl**.
               
               <a name="browser_cache_rules_condition_object"></a>
               The `condition` block support:
        """
        pulumi.set(__self__, "cache_type", cache_type)
        pulumi.set(__self__, "condition", condition)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_unit is not None:
            pulumi.set(__self__, "ttl_unit", ttl_unit)

    @_builtins.property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the cache validation type. Valid values are:
        + **follow_origin**: Follow the origin site's cache policy, i.e. the Cache-Control header settings.
        + **ttl**: The browser cache follows the expiration time set by the current rules.
        + **never**: The browser does not cache resources.
        """
        return pulumi.get(self, "cache_type")

    @cache_type.setter
    def cache_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cache_type", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['DomainConfigsBrowserCacheRuleConditionArgs']:
        """
        Specifies matching condition.
        The condition structure is documented below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['DomainConfigsBrowserCacheRuleConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="ttlUnit")
    def ttl_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cache expiration time unit. Valid values are:
        + **s**: seconds.
        + **m**: minutes.
        + **h**: hours.
        + **d**: days.

        > This field is required when the `cache_type` is set to **ttl**.

        <a name="browser_cache_rules_condition_object"></a>
        The `condition` block support:
        """
        return pulumi.get(self, "ttl_unit")

    @ttl_unit.setter
    def ttl_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl_unit", value)


if not MYPY:
    class DomainConfigsBrowserCacheRuleConditionArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        match_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
elif False:
    DomainConfigsBrowserCacheRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsBrowserCacheRuleConditionArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 match_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param pulumi.Input[_builtins.int] priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param pulumi.Input[_builtins.str] match_value: Specifies the cache match settings.
               + When `match_type` is set to **all**, this field does not need to be configured.
               + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
               value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
               not exceed `20`.
               + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
               be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
               exceed `20`.
               + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
               It supports matching specific files in the specified directory or files with a wildcard "*".
               The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
               single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
               + When `match_type` is set to **home_page**, this field does not need to be configured.
               
               <a name="access_area_filter_object"></a>
               The `access_area_filter` block support:
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_value", value)


if not MYPY:
    class DomainConfigsCacheUrlParameterFilterArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
elif False:
    DomainConfigsCacheUrlParameterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsCacheUrlParameterFilterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.str] value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainConfigsClientCertArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        hosts: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the domain name specified in the client CA certificate.

        > 1. CDN will allow all client requests that hold the CA certificate by default.
        <br/>2. A maximum of `100` domain names can be configured. Multiple domain names can be separated by , or |.

        <a name="cache_settings_object"></a>
        The `cache_settings` block support:
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        trusted_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the client CA certificate content, only supports PEM format.
        """
elif False:
    DomainConfigsClientCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsClientCertArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 hosts: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 trusted_cert: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.str] hosts: Specifies the domain name specified in the client CA certificate.
               
               > 1. CDN will allow all client requests that hold the CA certificate by default.
               <br/>2. A maximum of `100` domain names can be configured. Multiple domain names can be separated by , or |.
               
               <a name="cache_settings_object"></a>
               The `cache_settings` block support:
        :param pulumi.Input[_builtins.str] trusted_cert: Specifies the client CA certificate content, only supports PEM format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trusted_cert is not None:
            pulumi.set(__self__, "trusted_cert", trusted_cert)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the domain name specified in the client CA certificate.

        > 1. CDN will allow all client requests that hold the CA certificate by default.
        <br/>2. A maximum of `100` domain names can be configured. Multiple domain names can be separated by , or |.

        <a name="cache_settings_object"></a>
        The `cache_settings` block support:
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="trustedCert")
    def trusted_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the client CA certificate content, only supports PEM format.
        """
        return pulumi.get(self, "trusted_cert")

    @trusted_cert.setter
    def trusted_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trusted_cert", value)


if not MYPY:
    class DomainConfigsCompressArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        file_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the formats of files to be compressed. Enter up to 200 characters.
        Multiple formats are separated by commas (,). Each format contains up to 50 characters.
        Defaults to **.js,.html,.css,.xml,.json,.shtml,.htm**.

        <a name="ip_frequency_limit_object"></a>
        The `ip_frequency_limit` block support:
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
elif False:
    DomainConfigsCompressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsCompressArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 file_type: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.str] file_type: Specifies the formats of files to be compressed. Enter up to 200 characters.
               Multiple formats are separated by commas (,). Each format contains up to 50 characters.
               Defaults to **.js,.html,.css,.xml,.json,.shtml,.htm**.
               
               <a name="ip_frequency_limit_object"></a>
               The `ip_frequency_limit` block support:
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        """
        pulumi.set(__self__, "enabled", enabled)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the formats of files to be compressed. Enter up to 200 characters.
        Multiple formats are separated by commas (,). Each format contains up to 50 characters.
        Defaults to **.js,.html,.css,.xml,.json,.shtml,.htm**.

        <a name="ip_frequency_limit_object"></a>
        The `ip_frequency_limit` block support:
        """
        return pulumi.get(self, "file_type")

    @file_type.setter
    def file_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainConfigsErrorCodeCachArgsDict(TypedDict):
        code: pulumi.Input[_builtins.int]
        """
        Specifies the error code. Valid values are: **301**, **302**, **400**, **403**, **404**,
        **405**, **414**, **500**, **501**, **502**, **503**, and **504**.
        """
        ttl: pulumi.Input[_builtins.int]
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
elif False:
    DomainConfigsErrorCodeCachArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsErrorCodeCachArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.int],
                 ttl: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] code: Specifies the error code. Valid values are: **301**, **302**, **400**, **403**, **404**,
               **405**, **414**, **500**, **501**, **502**, **503**, and **504**.
        :param pulumi.Input[_builtins.int] ttl: Specifies the cache age. The maximum cache age is 365 days.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the error code. Valid values are: **301**, **302**, **400**, **403**, **404**,
        **405**, **414**, **500**, **501**, **502**, **503**, and **504**.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class DomainConfigsErrorCodeRedirectRuleArgsDict(TypedDict):
        error_code: pulumi.Input[_builtins.int]
        """
        Specifies the redirect unique error code. Valid values are: **400**, **403**, **404**,
        **405**, **414**, **416**, **451**, **500**, **501**, **502**, **503**, and **504**.
        """
        target_code: pulumi.Input[_builtins.int]
        """
        Specifies the redirect status code. The value can be **301** or **302**.
        """
        target_link: pulumi.Input[_builtins.str]
        """
        Specifies the destination URL. The value must start with **http://** or **https://**.
        For example: `http://www.example.com`.

        <a name="hsts_object"></a>
        The `hsts` block support:
        """
elif False:
    DomainConfigsErrorCodeRedirectRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsErrorCodeRedirectRuleArgs:
    def __init__(__self__, *,
                 error_code: pulumi.Input[_builtins.int],
                 target_code: pulumi.Input[_builtins.int],
                 target_link: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] error_code: Specifies the redirect unique error code. Valid values are: **400**, **403**, **404**,
               **405**, **414**, **416**, **451**, **500**, **501**, **502**, **503**, and **504**.
        :param pulumi.Input[_builtins.int] target_code: Specifies the redirect status code. The value can be **301** or **302**.
        :param pulumi.Input[_builtins.str] target_link: Specifies the destination URL. The value must start with **http://** or **https://**.
               For example: `http://www.example.com`.
               
               <a name="hsts_object"></a>
               The `hsts` block support:
        """
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "target_code", target_code)
        pulumi.set(__self__, "target_link", target_link)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the redirect unique error code. Valid values are: **400**, **403**, **404**,
        **405**, **414**, **416**, **451**, **500**, **501**, **502**, **503**, and **504**.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="targetCode")
    def target_code(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the redirect status code. The value can be **301** or **302**.
        """
        return pulumi.get(self, "target_code")

    @target_code.setter
    def target_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_code", value)

    @_builtins.property
    @pulumi.getter(name="targetLink")
    def target_link(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the destination URL. The value must start with **http://** or **https://**.
        For example: `http://www.example.com`.

        <a name="hsts_object"></a>
        The `hsts` block support:
        """
        return pulumi.get(self, "target_link")

    @target_link.setter
    def target_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_link", value)


if not MYPY:
    class DomainConfigsFlexibleOriginArgsDict(TypedDict):
        back_sources: pulumi.Input['DomainConfigsFlexibleOriginBackSourcesArgsDict']
        """
        Specifies the back source information. The length of this array field cannot exceed `1`.
        The back_sources structure is documented below.
        """
        match_type: pulumi.Input[_builtins.str]
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        match_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URI match rule. The usage rules are as follows:
        + When `match_type` is set to **all**, set this field to empty.
        + When `match_type` is set to **file_extension**, the value of this field should start with a period (.).
        Enter up to 20 file name extensions and use semicolons (;) to separate them. Example: **.jpg;.zip;.exe**.
        + When `match_type` is set to **file_path**, the value of this field should start with a slash (/).
        Enter up to 20 paths and use semicolons (;) to separate them. Example: **/test/folder01;/test/folder02**.

        <a name="flexible_origin_back_sources_object"></a>
        The `back_sources` block support:
        """
elif False:
    DomainConfigsFlexibleOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsFlexibleOriginArgs:
    def __init__(__self__, *,
                 back_sources: pulumi.Input['DomainConfigsFlexibleOriginBackSourcesArgs'],
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 match_pattern: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['DomainConfigsFlexibleOriginBackSourcesArgs'] back_sources: Specifies the back source information. The length of this array field cannot exceed `1`.
               The back_sources structure is documented below.
        :param pulumi.Input[_builtins.str] match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param pulumi.Input[_builtins.int] priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param pulumi.Input[_builtins.str] match_pattern: Specifies the URI match rule. The usage rules are as follows:
               + When `match_type` is set to **all**, set this field to empty.
               + When `match_type` is set to **file_extension**, the value of this field should start with a period (.).
               Enter up to 20 file name extensions and use semicolons (;) to separate them. Example: **.jpg;.zip;.exe**.
               + When `match_type` is set to **file_path**, the value of this field should start with a slash (/).
               Enter up to 20 paths and use semicolons (;) to separate them. Example: **/test/folder01;/test/folder02**.
               
               <a name="flexible_origin_back_sources_object"></a>
               The `back_sources` block support:
        """
        pulumi.set(__self__, "back_sources", back_sources)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_pattern is not None:
            pulumi.set(__self__, "match_pattern", match_pattern)

    @_builtins.property
    @pulumi.getter(name="backSources")
    def back_sources(self) -> pulumi.Input['DomainConfigsFlexibleOriginBackSourcesArgs']:
        """
        Specifies the back source information. The length of this array field cannot exceed `1`.
        The back_sources structure is documented below.
        """
        return pulumi.get(self, "back_sources")

    @back_sources.setter
    def back_sources(self, value: pulumi.Input['DomainConfigsFlexibleOriginBackSourcesArgs']):
        pulumi.set(self, "back_sources", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URI match rule. The usage rules are as follows:
        + When `match_type` is set to **all**, set this field to empty.
        + When `match_type` is set to **file_extension**, the value of this field should start with a period (.).
        Enter up to 20 file name extensions and use semicolons (;) to separate them. Example: **.jpg;.zip;.exe**.
        + When `match_type` is set to **file_path**, the value of this field should start with a slash (/).
        Enter up to 20 paths and use semicolons (;) to separate them. Example: **/test/folder01;/test/folder02**.

        <a name="flexible_origin_back_sources_object"></a>
        The `back_sources` block support:
        """
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_pattern", value)


if not MYPY:
    class DomainConfigsFlexibleOriginBackSourcesArgsDict(TypedDict):
        ip_or_domain: pulumi.Input[_builtins.str]
        """
        Specifies the IP address or domain name of the origin server.
        + When `sources_type` is set to **ipaddr**, the value of this field can only be set to a valid IPv4 or Ipv6 address.
        + When `sources_type` is set to **domain**, the value of this field can only be set to a domain name.
        + When `sources_type` is set to **obs_bucket**, the value of this field can only be set to an OBS bucket access
        domain name.
        """
        sources_type: pulumi.Input[_builtins.str]
        """
        Specifies the origin server type. Valid values are as follows:
        + **ipaddr**: IP address.
        + **domain**: Domain name.
        + **obs_bucket**: OBS bucket.
        """
        http_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        """
        https_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.

        > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.

        <a name="remote_auth_object"></a>
        The `remote_auth` block support:
        """
        obs_bucket_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        This field is required when `sources_type` is set to **obs_bucket**.
        """
elif False:
    DomainConfigsFlexibleOriginBackSourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsFlexibleOriginBackSourcesArgs:
    def __init__(__self__, *,
                 ip_or_domain: pulumi.Input[_builtins.str],
                 sources_type: pulumi.Input[_builtins.str],
                 http_port: Optional[pulumi.Input[_builtins.int]] = None,
                 https_port: Optional[pulumi.Input[_builtins.int]] = None,
                 obs_bucket_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_or_domain: Specifies the IP address or domain name of the origin server.
               + When `sources_type` is set to **ipaddr**, the value of this field can only be set to a valid IPv4 or Ipv6 address.
               + When `sources_type` is set to **domain**, the value of this field can only be set to a domain name.
               + When `sources_type` is set to **obs_bucket**, the value of this field can only be set to an OBS bucket access
               domain name.
        :param pulumi.Input[_builtins.str] sources_type: Specifies the origin server type. Valid values are as follows:
               + **ipaddr**: IP address.
               + **domain**: Domain name.
               + **obs_bucket**: OBS bucket.
        :param pulumi.Input[_builtins.int] http_port: Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        :param pulumi.Input[_builtins.int] https_port: Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.
               
               > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.
               
               <a name="remote_auth_object"></a>
               The `remote_auth` block support:
        :param pulumi.Input[_builtins.str] obs_bucket_type: Specifies the OBS bucket type. Valid values are **private** and **public**.
               This field is required when `sources_type` is set to **obs_bucket**.
        """
        pulumi.set(__self__, "ip_or_domain", ip_or_domain)
        pulumi.set(__self__, "sources_type", sources_type)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)

    @_builtins.property
    @pulumi.getter(name="ipOrDomain")
    def ip_or_domain(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP address or domain name of the origin server.
        + When `sources_type` is set to **ipaddr**, the value of this field can only be set to a valid IPv4 or Ipv6 address.
        + When `sources_type` is set to **domain**, the value of this field can only be set to a domain name.
        + When `sources_type` is set to **obs_bucket**, the value of this field can only be set to an OBS bucket access
        domain name.
        """
        return pulumi.get(self, "ip_or_domain")

    @ip_or_domain.setter
    def ip_or_domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_or_domain", value)

    @_builtins.property
    @pulumi.getter(name="sourcesType")
    def sources_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the origin server type. Valid values are as follows:
        + **ipaddr**: IP address.
        + **domain**: Domain name.
        + **obs_bucket**: OBS bucket.
        """
        return pulumi.get(self, "sources_type")

    @sources_type.setter
    def sources_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sources_type", value)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.

        > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.

        <a name="remote_auth_object"></a>
        The `remote_auth` block support:
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        This field is required when `sources_type` is set to **obs_bucket**.
        """
        return pulumi.get(self, "obs_bucket_type")

    @obs_bucket_type.setter
    def obs_bucket_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_bucket_type", value)


if not MYPY:
    class DomainConfigsForceRedirectArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        redirect_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the force redirect status code. Valid values are: **301** and **302**.
        Defaults to **302**.

        <a name="compress_object"></a>
        The `compress` blocks support:
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
elif False:
    DomainConfigsForceRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsForceRedirectArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 redirect_code: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.int] redirect_code: Specifies the force redirect status code. Valid values are: **301** and **302**.
               Defaults to **302**.
               
               <a name="compress_object"></a>
               The `compress` blocks support:
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        """
        pulumi.set(__self__, "enabled", enabled)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the force redirect status code. Valid values are: **301** and **302**.
        Defaults to **302**.

        <a name="compress_object"></a>
        The `compress` blocks support:
        """
        return pulumi.get(self, "redirect_code")

    @redirect_code.setter
    def redirect_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redirect_code", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainConfigsHstsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        include_subdomains: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether subdomain names are included.
        The options are **on** (included) and **off** (not included). This field is required when enable HSTS settings.

        <a name="sni_object"></a>
        The `sni` block support:
        """
        max_age: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the expiration time, which means the TTL of the response header
        `Strict-Transport-Security` on the client. The value ranges from `0` to `63,072,000`. The unit is second.
        This field is required when enable HSTS settings.
        """
elif False:
    DomainConfigsHstsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsHstsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 include_subdomains: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.str] include_subdomains: Specifies whether subdomain names are included.
               The options are **on** (included) and **off** (not included). This field is required when enable HSTS settings.
               
               <a name="sni_object"></a>
               The `sni` block support:
        :param pulumi.Input[_builtins.int] max_age: Specifies the expiration time, which means the TTL of the response header
               `Strict-Transport-Security` on the client. The value ranges from `0` to `63,072,000`. The unit is second.
               This field is required when enable HSTS settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether subdomain names are included.
        The options are **on** (included) and **off** (not included). This field is required when enable HSTS settings.

        <a name="sni_object"></a>
        The `sni` block support:
        """
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_subdomains", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the expiration time, which means the TTL of the response header
        `Strict-Transport-Security` on the client. The value ranges from `0` to `63,072,000`. The unit is second.
        This field is required when enable HSTS settings.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class DomainConfigsHttpResponseHeaderArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
        **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
        **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
        and hyphens (-), and starts with a letter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
elif False:
    DomainConfigsHttpResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsHttpResponseHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        :param pulumi.Input[_builtins.str] name: Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
               **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
               **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
               and hyphens (-), and starts with a letter.
        :param pulumi.Input[_builtins.str] value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
        **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
        **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
        and hyphens (-), and starts with a letter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainConfigsHttpsSettingsArgsDict(TypedDict):
        certificate_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the content of the certificate used by the HTTPS protocol.
        This parameter is mandatory when a certificate is configured. The value is in PEM format.
        This field is required when `certificate_source` is set to `0`.
        """
        certificate_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the certificate name. The value contains `3` to `32` characters.
        This parameter is mandatory when a certificate is configured.
        """
        certificate_source: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the certificate source. Valid values are:
        """
        certificate_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the certificate type. Currently, only **server** is supported, which
        means international certificate. Defaults to **server**.
        """
        http2_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether HTTP/2 is used. Defaults to **false**.
        When `https_enabled` is set to **false**, this parameter does not take effect.

        > Currently, this field does not support closing after it is enabled.
        """
        http2_status: NotRequired[pulumi.Input[_builtins.str]]
        https_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable HTTPS. Defaults to **false**.
        """
        https_status: NotRequired[pulumi.Input[_builtins.str]]
        ocsp_stapling_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether online certificate status protocol (OCSP) stapling is enabled.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **off**.

        <a name="retrieval_request_header_object"></a>
        The `retrieval_request_header` block support:
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the private key used by the HTTPS protocol. This parameter is mandatory
        when a certificate is configured. The value is in PEM format.
        This field is required when `certificate_source` is set to `0`.
        """
        scm_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the SCM certificate ID.
        This field is required when `certificate_source` is set to `2`.
        """
        tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the transport Layer Security (TLS). Currently, **TLSv1.0**,
        **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are supported. By default, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are
        enabled. You can enable a single version or consecutive versions. To enable multiple versions, use commas (,) to
        separate versions, for example, **TLSv1.1,TLSv1.2**.
        """
elif False:
    DomainConfigsHttpsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsHttpsSettingsArgs:
    def __init__(__self__, *,
                 certificate_body: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_source: Optional[pulumi.Input[_builtins.int]] = None,
                 certificate_type: Optional[pulumi.Input[_builtins.str]] = None,
                 http2_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 http2_status: Optional[pulumi.Input[_builtins.str]] = None,
                 https_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 https_status: Optional[pulumi.Input[_builtins.str]] = None,
                 ocsp_stapling_status: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 scm_certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_body: Specifies the content of the certificate used by the HTTPS protocol.
               This parameter is mandatory when a certificate is configured. The value is in PEM format.
               This field is required when `certificate_source` is set to `0`.
        :param pulumi.Input[_builtins.str] certificate_name: Specifies the certificate name. The value contains `3` to `32` characters.
               This parameter is mandatory when a certificate is configured.
        :param pulumi.Input[_builtins.int] certificate_source: Specifies the certificate source. Valid values are:
        :param pulumi.Input[_builtins.str] certificate_type: Specifies the certificate type. Currently, only **server** is supported, which
               means international certificate. Defaults to **server**.
        :param pulumi.Input[_builtins.bool] http2_enabled: Specifies whether HTTP/2 is used. Defaults to **false**.
               When `https_enabled` is set to **false**, this parameter does not take effect.
               
               > Currently, this field does not support closing after it is enabled.
        :param pulumi.Input[_builtins.bool] https_enabled: Specifies whether to enable HTTPS. Defaults to **false**.
        :param pulumi.Input[_builtins.str] ocsp_stapling_status: Specifies whether online certificate status protocol (OCSP) stapling is enabled.
               Valid values are as follows:
               + **on**: Enable.
               + **off**: Disable.
               
               Defaults to **off**.
               
               <a name="retrieval_request_header_object"></a>
               The `retrieval_request_header` block support:
        :param pulumi.Input[_builtins.str] private_key: Specifies the private key used by the HTTPS protocol. This parameter is mandatory
               when a certificate is configured. The value is in PEM format.
               This field is required when `certificate_source` is set to `0`.
        :param pulumi.Input[_builtins.str] scm_certificate_id: Specifies the SCM certificate ID.
               This field is required when `certificate_source` is set to `2`.
        :param pulumi.Input[_builtins.str] tls_version: Specifies the transport Layer Security (TLS). Currently, **TLSv1.0**,
               **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are supported. By default, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are
               enabled. You can enable a single version or consecutive versions. To enable multiple versions, use commas (,) to
               separate versions, for example, **TLSv1.1,TLSv1.2**.
        """
        if certificate_body is not None:
            pulumi.set(__self__, "certificate_body", certificate_body)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if http2_status is not None:
            pulumi.set(__self__, "http2_status", http2_status)
        if https_enabled is not None:
            pulumi.set(__self__, "https_enabled", https_enabled)
        if https_status is not None:
            pulumi.set(__self__, "https_status", https_status)
        if ocsp_stapling_status is not None:
            pulumi.set(__self__, "ocsp_stapling_status", ocsp_stapling_status)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if scm_certificate_id is not None:
            pulumi.set(__self__, "scm_certificate_id", scm_certificate_id)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @_builtins.property
    @pulumi.getter(name="certificateBody")
    def certificate_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the content of the certificate used by the HTTPS protocol.
        This parameter is mandatory when a certificate is configured. The value is in PEM format.
        This field is required when `certificate_source` is set to `0`.
        """
        return pulumi.get(self, "certificate_body")

    @certificate_body.setter
    def certificate_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_body", value)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate name. The value contains `3` to `32` characters.
        This parameter is mandatory when a certificate is configured.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the certificate source. Valid values are:
        """
        return pulumi.get(self, "certificate_source")

    @certificate_source.setter
    def certificate_source(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "certificate_source", value)

    @_builtins.property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate type. Currently, only **server** is supported, which
        means international certificate. Defaults to **server**.
        """
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_type", value)

    @_builtins.property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether HTTP/2 is used. Defaults to **false**.
        When `https_enabled` is set to **false**, this parameter does not take effect.

        > Currently, this field does not support closing after it is enabled.
        """
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_enabled", value)

    @_builtins.property
    @pulumi.getter(name="http2Status")
    def http2_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "http2_status")

    @http2_status.setter
    def http2_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http2_status", value)

    @_builtins.property
    @pulumi.getter(name="httpsEnabled")
    def https_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable HTTPS. Defaults to **false**.
        """
        return pulumi.get(self, "https_enabled")

    @https_enabled.setter
    def https_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "https_enabled", value)

    @_builtins.property
    @pulumi.getter(name="httpsStatus")
    def https_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "https_status")

    @https_status.setter
    def https_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "https_status", value)

    @_builtins.property
    @pulumi.getter(name="ocspStaplingStatus")
    def ocsp_stapling_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether online certificate status protocol (OCSP) stapling is enabled.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **off**.

        <a name="retrieval_request_header_object"></a>
        The `retrieval_request_header` block support:
        """
        return pulumi.get(self, "ocsp_stapling_status")

    @ocsp_stapling_status.setter
    def ocsp_stapling_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ocsp_stapling_status", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the private key used by the HTTPS protocol. This parameter is mandatory
        when a certificate is configured. The value is in PEM format.
        This field is required when `certificate_source` is set to `0`.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="scmCertificateId")
    def scm_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the SCM certificate ID.
        This field is required when `certificate_source` is set to `2`.
        """
        return pulumi.get(self, "scm_certificate_id")

    @scm_certificate_id.setter
    def scm_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scm_certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the transport Layer Security (TLS). Currently, **TLSv1.0**,
        **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are supported. By default, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are
        enabled. You can enable a single version or consecutive versions. To enable multiple versions, use commas (,) to
        separate versions, for example, **TLSv1.1,TLSv1.2**.
        """
        return pulumi.get(self, "tls_version")

    @tls_version.setter
    def tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_version", value)


if not MYPY:
    class DomainConfigsIpFilterArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
elif False:
    DomainConfigsIpFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsIpFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.str] value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainConfigsIpFrequencyLimitArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        qps: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the access threshold, in times/second. The value ranges from `1` to `100,000`.
        This field is required when enable IP access frequency.

        <a name="websocket_object"></a>
        The `websocket` block support:
        """
elif False:
    DomainConfigsIpFrequencyLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsIpFrequencyLimitArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 qps: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.int] qps: Specifies the access threshold, in times/second. The value ranges from `1` to `100,000`.
               This field is required when enable IP access frequency.
               
               <a name="websocket_object"></a>
               The `websocket` block support:
        """
        pulumi.set(__self__, "enabled", enabled)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the access threshold, in times/second. The value ranges from `1` to `100,000`.
        This field is required when enable IP access frequency.

        <a name="websocket_object"></a>
        The `websocket` block support:
        """
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qps", value)


if not MYPY:
    class DomainConfigsOriginRequestUrlRewriteArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        target_url: pulumi.Input[_builtins.str]
        """
        Specifies a URI starts with a slash (/) and does not contain `http://`, `https://`,
        or the domain name. The value contains up to `256` characters. The nth wildcard (*) field can be substituted with
        `$n`, where n = 1, 2, 3..., for example, `/newtest/$1/$2.jpg`.
        """
        source_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URI to be rewritten. The URI starts with a slash (/) and does not
        contain `http://`, `https://`, or the domain name. The value contains up to `512` characters.
        Wildcards (*) are supported, for example, `/test/*/*.mp4`. This field is invalid when `match_type` is set to **all**.

        <a name="user_agent_filter_object"></a>
        The `user_agent_filter` block support:
        """
elif False:
    DomainConfigsOriginRequestUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsOriginRequestUrlRewriteArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 target_url: pulumi.Input[_builtins.str],
                 source_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param pulumi.Input[_builtins.int] priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param pulumi.Input[_builtins.str] target_url: Specifies a URI starts with a slash (/) and does not contain `http://`, `https://`,
               or the domain name. The value contains up to `256` characters. The nth wildcard (*) field can be substituted with
               `$n`, where n = 1, 2, 3..., for example, `/newtest/$1/$2.jpg`.
        :param pulumi.Input[_builtins.str] source_url: Specifies the URI to be rewritten. The URI starts with a slash (/) and does not
               contain `http://`, `https://`, or the domain name. The value contains up to `512` characters.
               Wildcards (*) are supported, for example, `/test/*/*.mp4`. This field is invalid when `match_type` is set to **all**.
               
               <a name="user_agent_filter_object"></a>
               The `user_agent_filter` block support:
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "target_url", target_url)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies a URI starts with a slash (/) and does not contain `http://`, `https://`,
        or the domain name. The value contains up to `256` characters. The nth wildcard (*) field can be substituted with
        `$n`, where n = 1, 2, 3..., for example, `/newtest/$1/$2.jpg`.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_url", value)

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URI to be rewritten. The URI starts with a slash (/) and does not
        contain `http://`, `https://`, or the domain name. The value contains up to `512` characters.
        Wildcards (*) are supported, for example, `/test/*/*.mp4`. This field is invalid when `match_type` is set to **all**.

        <a name="user_agent_filter_object"></a>
        The `user_agent_filter` block support:
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_url", value)


if not MYPY:
    class DomainConfigsQuicArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
elif False:
    DomainConfigsQuicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsQuicArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DomainConfigsRefererArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        include_empty: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether empty user agents are included.
        A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
        A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
        Possible values: **true** (included) and **false** (excluded).
        The default value is **false** for a blacklist and **true** for a whitelist.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
elif False:
    DomainConfigsRefererArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRefererArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 include_empty: Optional[pulumi.Input[_builtins.bool]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.bool] include_empty: Specifies whether empty user agents are included.
               A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
               A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
               Possible values: **true** (included) and **false** (excluded).
               The default value is **false** for a blacklist and **true** for a whitelist.
        :param pulumi.Input[_builtins.str] value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether empty user agents are included.
        A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
        A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
        Possible values: **true** (included) and **false** (excluded).
        The default value is **false** for a blacklist and **true** for a whitelist.
        """
        return pulumi.get(self, "include_empty")

    @include_empty.setter
    def include_empty(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_empty", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainConfigsRemoteAuthArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        remote_auth_rules: NotRequired[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesArgsDict']]
        """
        Specifies the remote authentication settings. The length of this array field
        cannot exceed `1`. The remote_auth_rules structure is documented below.

        <a name="remote_auth_rules_object"></a>
        The `remote_auth_rules` block support:
        """
elif False:
    DomainConfigsRemoteAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRemoteAuthArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 remote_auth_rules: Optional[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesArgs'] remote_auth_rules: Specifies the remote authentication settings. The length of this array field
               cannot exceed `1`. The remote_auth_rules structure is documented below.
               
               <a name="remote_auth_rules_object"></a>
               The `remote_auth_rules` block support:
        """
        pulumi.set(__self__, "enabled", enabled)
        if remote_auth_rules is not None:
            pulumi.set(__self__, "remote_auth_rules", remote_auth_rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="remoteAuthRules")
    def remote_auth_rules(self) -> Optional[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesArgs']]:
        """
        Specifies the remote authentication settings. The length of this array field
        cannot exceed `1`. The remote_auth_rules structure is documented below.

        <a name="remote_auth_rules_object"></a>
        The `remote_auth_rules` block support:
        """
        return pulumi.get(self, "remote_auth_rules")

    @remote_auth_rules.setter
    def remote_auth_rules(self, value: Optional[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesArgs']]):
        pulumi.set(self, "remote_auth_rules", value)


if not MYPY:
    class DomainConfigsRemoteAuthRemoteAuthRulesArgsDict(TypedDict):
        auth_failed_status: pulumi.Input[_builtins.str]
        """
        Specifies the status code returned by the remote authentication server
        to CDN nodes when authentication is failed. Value range: **4xx** and **5xx**.
        """
        auth_server: pulumi.Input[_builtins.str]
        """
        Specifies the address of a reachable server. The address must include **http://** or
        **https://**. The address cannot be a local address such as **localhost** or **127.0.0.1**. The address cannot be an
        acceleration domain name added on CDN.
        """
        auth_success_status: pulumi.Input[_builtins.str]
        """
        Specifies the status code returned by the remote authentication server
        to CDN nodes when authentication is successful. Value range: **2xx** and **3xx**.
        """
        file_type_setting: pulumi.Input[_builtins.str]
        """
        Specifies the authentication file type settings. Valid values are:
        + **all**: Requests for all files are authenticated.
        + **specific_file**: Requests for files of specific types are authenticated.
        """
        request_method: pulumi.Input[_builtins.str]
        """
        Specifies the request method supported by the authentication server. Valid values
        are **GET**, **POST**, and **HEAD**.
        """
        reserve_args_setting: pulumi.Input[_builtins.str]
        """
        Specifies the parameters that need to be authenticated in user requests.
        Valid values are as follows:
        + **reserve_all_args**: Retain all URL parameters.
        + **reserve_specific_args**: Retain specified URL parameters.
        + **ignore_all_args**: Ignore all URL parameters.
        """
        reserve_headers_setting: pulumi.Input[_builtins.str]
        """
        Specifies the headers to be authenticated in user requests.
        Valid values are as follows:
        + **reserve_all_headers**: Retain all request headers.
        + **reserve_specific_headers**: Retain specified request headers.
        + **ignore_all_headers**: Ignore all request headers.
        """
        response_status: pulumi.Input[_builtins.str]
        """
        Specifies the status code returned by CDN nodes to users when authentication
        is failed. Value range: **2xx**, **3xx**, **4xx**, and **5xx**.
        """
        timeout: pulumi.Input[_builtins.int]
        """
        Specifies the duration from the time when a CDN node forwards an authentication request
        to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
        ranging from `50` to `3,000`. The unit is millisecond.
        """
        timeout_action: pulumi.Input[_builtins.str]
        """
        Specifies the action of the CDN nodes to process user requests after the
        authentication timeout. Valid values are as follows:
        + **pass**: The user request is allowed and the corresponding resource is returned after the authentication times out.
        + **forbid**: The user request is rejected after the authentication times out and the configured status code is
        returned to the user.
        """
        add_custom_args_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict']]]]
        """
        Specifies the URL validation parameters.
        The add_custom_args_rules structure is documented below.
        """
        add_custom_headers_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict']]]]
        """
        Specifies the request header authentication parameters.
        The add_custom_headers_rules structure is documented below.

        <a name="add_custom_rules_object"></a>
        The `add_custom_args_rules` and `add_custom_headers_rules` block support:
        """
        reserve_args: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the reserve args. Multiple args are separated by vertical bars (|).
        For example: **key1|key2**. This parameter is mandatory when `reserve_args_setting` is set to **reserve_specific_args**.
        In other cases, this parameter is left blank.
        """
        reserve_headers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the reserve headers. Multiple headers are separated by vertical bars (|).
        For example: **key1|key2**. This parameter is mandatory when `reserve_headers_setting` is set to **reserve_specific_headers**.
        In other cases, this parameter is left blank.
        """
        specified_file_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the specific file types. The value contains letters and digits.
        The value contains up to `512` characters. File types are not case-sensitive, and multiple file types are separated
        by vertical bars (|). For example: **jpg|MP4**. This parameter is mandatory when `file_type_setting` is set to
        **specific_file**. In other cases, this parameter is left blank.
        """
elif False:
    DomainConfigsRemoteAuthRemoteAuthRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRemoteAuthRemoteAuthRulesArgs:
    def __init__(__self__, *,
                 auth_failed_status: pulumi.Input[_builtins.str],
                 auth_server: pulumi.Input[_builtins.str],
                 auth_success_status: pulumi.Input[_builtins.str],
                 file_type_setting: pulumi.Input[_builtins.str],
                 request_method: pulumi.Input[_builtins.str],
                 reserve_args_setting: pulumi.Input[_builtins.str],
                 reserve_headers_setting: pulumi.Input[_builtins.str],
                 response_status: pulumi.Input[_builtins.str],
                 timeout: pulumi.Input[_builtins.int],
                 timeout_action: pulumi.Input[_builtins.str],
                 add_custom_args_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs']]]] = None,
                 add_custom_headers_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs']]]] = None,
                 reserve_args: Optional[pulumi.Input[_builtins.str]] = None,
                 reserve_headers: Optional[pulumi.Input[_builtins.str]] = None,
                 specified_file_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_failed_status: Specifies the status code returned by the remote authentication server
               to CDN nodes when authentication is failed. Value range: **4xx** and **5xx**.
        :param pulumi.Input[_builtins.str] auth_server: Specifies the address of a reachable server. The address must include **http://** or
               **https://**. The address cannot be a local address such as **localhost** or **127.0.0.1**. The address cannot be an
               acceleration domain name added on CDN.
        :param pulumi.Input[_builtins.str] auth_success_status: Specifies the status code returned by the remote authentication server
               to CDN nodes when authentication is successful. Value range: **2xx** and **3xx**.
        :param pulumi.Input[_builtins.str] file_type_setting: Specifies the authentication file type settings. Valid values are:
               + **all**: Requests for all files are authenticated.
               + **specific_file**: Requests for files of specific types are authenticated.
        :param pulumi.Input[_builtins.str] request_method: Specifies the request method supported by the authentication server. Valid values
               are **GET**, **POST**, and **HEAD**.
        :param pulumi.Input[_builtins.str] reserve_args_setting: Specifies the parameters that need to be authenticated in user requests.
               Valid values are as follows:
               + **reserve_all_args**: Retain all URL parameters.
               + **reserve_specific_args**: Retain specified URL parameters.
               + **ignore_all_args**: Ignore all URL parameters.
        :param pulumi.Input[_builtins.str] reserve_headers_setting: Specifies the headers to be authenticated in user requests.
               Valid values are as follows:
               + **reserve_all_headers**: Retain all request headers.
               + **reserve_specific_headers**: Retain specified request headers.
               + **ignore_all_headers**: Ignore all request headers.
        :param pulumi.Input[_builtins.str] response_status: Specifies the status code returned by CDN nodes to users when authentication
               is failed. Value range: **2xx**, **3xx**, **4xx**, and **5xx**.
        :param pulumi.Input[_builtins.int] timeout: Specifies the duration from the time when a CDN node forwards an authentication request
               to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
               ranging from `50` to `3,000`. The unit is millisecond.
        :param pulumi.Input[_builtins.str] timeout_action: Specifies the action of the CDN nodes to process user requests after the
               authentication timeout. Valid values are as follows:
               + **pass**: The user request is allowed and the corresponding resource is returned after the authentication times out.
               + **forbid**: The user request is rejected after the authentication times out and the configured status code is
               returned to the user.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs']]] add_custom_args_rules: Specifies the URL validation parameters.
               The add_custom_args_rules structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs']]] add_custom_headers_rules: Specifies the request header authentication parameters.
               The add_custom_headers_rules structure is documented below.
               
               <a name="add_custom_rules_object"></a>
               The `add_custom_args_rules` and `add_custom_headers_rules` block support:
        :param pulumi.Input[_builtins.str] reserve_args: Specifies the reserve args. Multiple args are separated by vertical bars (|).
               For example: **key1|key2**. This parameter is mandatory when `reserve_args_setting` is set to **reserve_specific_args**.
               In other cases, this parameter is left blank.
        :param pulumi.Input[_builtins.str] reserve_headers: Specifies the reserve headers. Multiple headers are separated by vertical bars (|).
               For example: **key1|key2**. This parameter is mandatory when `reserve_headers_setting` is set to **reserve_specific_headers**.
               In other cases, this parameter is left blank.
        :param pulumi.Input[_builtins.str] specified_file_type: Specifies the specific file types. The value contains letters and digits.
               The value contains up to `512` characters. File types are not case-sensitive, and multiple file types are separated
               by vertical bars (|). For example: **jpg|MP4**. This parameter is mandatory when `file_type_setting` is set to
               **specific_file**. In other cases, this parameter is left blank.
        """
        pulumi.set(__self__, "auth_failed_status", auth_failed_status)
        pulumi.set(__self__, "auth_server", auth_server)
        pulumi.set(__self__, "auth_success_status", auth_success_status)
        pulumi.set(__self__, "file_type_setting", file_type_setting)
        pulumi.set(__self__, "request_method", request_method)
        pulumi.set(__self__, "reserve_args_setting", reserve_args_setting)
        pulumi.set(__self__, "reserve_headers_setting", reserve_headers_setting)
        pulumi.set(__self__, "response_status", response_status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "timeout_action", timeout_action)
        if add_custom_args_rules is not None:
            pulumi.set(__self__, "add_custom_args_rules", add_custom_args_rules)
        if add_custom_headers_rules is not None:
            pulumi.set(__self__, "add_custom_headers_rules", add_custom_headers_rules)
        if reserve_args is not None:
            pulumi.set(__self__, "reserve_args", reserve_args)
        if reserve_headers is not None:
            pulumi.set(__self__, "reserve_headers", reserve_headers)
        if specified_file_type is not None:
            pulumi.set(__self__, "specified_file_type", specified_file_type)

    @_builtins.property
    @pulumi.getter(name="authFailedStatus")
    def auth_failed_status(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the status code returned by the remote authentication server
        to CDN nodes when authentication is failed. Value range: **4xx** and **5xx**.
        """
        return pulumi.get(self, "auth_failed_status")

    @auth_failed_status.setter
    def auth_failed_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_failed_status", value)

    @_builtins.property
    @pulumi.getter(name="authServer")
    def auth_server(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the address of a reachable server. The address must include **http://** or
        **https://**. The address cannot be a local address such as **localhost** or **127.0.0.1**. The address cannot be an
        acceleration domain name added on CDN.
        """
        return pulumi.get(self, "auth_server")

    @auth_server.setter
    def auth_server(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_server", value)

    @_builtins.property
    @pulumi.getter(name="authSuccessStatus")
    def auth_success_status(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the status code returned by the remote authentication server
        to CDN nodes when authentication is successful. Value range: **2xx** and **3xx**.
        """
        return pulumi.get(self, "auth_success_status")

    @auth_success_status.setter
    def auth_success_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_success_status", value)

    @_builtins.property
    @pulumi.getter(name="fileTypeSetting")
    def file_type_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the authentication file type settings. Valid values are:
        + **all**: Requests for all files are authenticated.
        + **specific_file**: Requests for files of specific types are authenticated.
        """
        return pulumi.get(self, "file_type_setting")

    @file_type_setting.setter
    def file_type_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_type_setting", value)

    @_builtins.property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the request method supported by the authentication server. Valid values
        are **GET**, **POST**, and **HEAD**.
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_method", value)

    @_builtins.property
    @pulumi.getter(name="reserveArgsSetting")
    def reserve_args_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameters that need to be authenticated in user requests.
        Valid values are as follows:
        + **reserve_all_args**: Retain all URL parameters.
        + **reserve_specific_args**: Retain specified URL parameters.
        + **ignore_all_args**: Ignore all URL parameters.
        """
        return pulumi.get(self, "reserve_args_setting")

    @reserve_args_setting.setter
    def reserve_args_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reserve_args_setting", value)

    @_builtins.property
    @pulumi.getter(name="reserveHeadersSetting")
    def reserve_headers_setting(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the headers to be authenticated in user requests.
        Valid values are as follows:
        + **reserve_all_headers**: Retain all request headers.
        + **reserve_specific_headers**: Retain specified request headers.
        + **ignore_all_headers**: Ignore all request headers.
        """
        return pulumi.get(self, "reserve_headers_setting")

    @reserve_headers_setting.setter
    def reserve_headers_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reserve_headers_setting", value)

    @_builtins.property
    @pulumi.getter(name="responseStatus")
    def response_status(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the status code returned by CDN nodes to users when authentication
        is failed. Value range: **2xx**, **3xx**, **4xx**, and **5xx**.
        """
        return pulumi.get(self, "response_status")

    @response_status.setter
    def response_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "response_status", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the duration from the time when a CDN node forwards an authentication request
        to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
        ranging from `50` to `3,000`. The unit is millisecond.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the action of the CDN nodes to process user requests after the
        authentication timeout. Valid values are as follows:
        + **pass**: The user request is allowed and the corresponding resource is returned after the authentication times out.
        + **forbid**: The user request is rejected after the authentication times out and the configured status code is
        returned to the user.
        """
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "timeout_action", value)

    @_builtins.property
    @pulumi.getter(name="addCustomArgsRules")
    def add_custom_args_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs']]]]:
        """
        Specifies the URL validation parameters.
        The add_custom_args_rules structure is documented below.
        """
        return pulumi.get(self, "add_custom_args_rules")

    @add_custom_args_rules.setter
    def add_custom_args_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs']]]]):
        pulumi.set(self, "add_custom_args_rules", value)

    @_builtins.property
    @pulumi.getter(name="addCustomHeadersRules")
    def add_custom_headers_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs']]]]:
        """
        Specifies the request header authentication parameters.
        The add_custom_headers_rules structure is documented below.

        <a name="add_custom_rules_object"></a>
        The `add_custom_args_rules` and `add_custom_headers_rules` block support:
        """
        return pulumi.get(self, "add_custom_headers_rules")

    @add_custom_headers_rules.setter
    def add_custom_headers_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs']]]]):
        pulumi.set(self, "add_custom_headers_rules", value)

    @_builtins.property
    @pulumi.getter(name="reserveArgs")
    def reserve_args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the reserve args. Multiple args are separated by vertical bars (|).
        For example: **key1|key2**. This parameter is mandatory when `reserve_args_setting` is set to **reserve_specific_args**.
        In other cases, this parameter is left blank.
        """
        return pulumi.get(self, "reserve_args")

    @reserve_args.setter
    def reserve_args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reserve_args", value)

    @_builtins.property
    @pulumi.getter(name="reserveHeaders")
    def reserve_headers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the reserve headers. Multiple headers are separated by vertical bars (|).
        For example: **key1|key2**. This parameter is mandatory when `reserve_headers_setting` is set to **reserve_specific_headers**.
        In other cases, this parameter is left blank.
        """
        return pulumi.get(self, "reserve_headers")

    @reserve_headers.setter
    def reserve_headers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reserve_headers", value)

    @_builtins.property
    @pulumi.getter(name="specifiedFileType")
    def specified_file_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the specific file types. The value contains letters and digits.
        The value contains up to `512` characters. File types are not case-sensitive, and multiple file types are separated
        by vertical bars (|). For example: **jpg|MP4**. This parameter is mandatory when `file_type_setting` is set to
        **specific_file**. In other cases, this parameter is left blank.
        """
        return pulumi.get(self, "specified_file_type")

    @specified_file_type.setter
    def specified_file_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "specified_file_type", value)


if not MYPY:
    class DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
elif False:
    DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the parameter key. The value contains up to `256` characters. The value can be
               composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.str] value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
elif False:
    DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the parameter key. The value contains up to `256` characters. The value can be
               composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.str] value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainConfigsRequestLimitRuleArgsDict(TypedDict):
        limit_rate_after: pulumi.Input[_builtins.int]
        """
        Specifies the rate limiting condition. Unit: byte.
        The value ranges from `0` to `1,073,741,824`.
        """
        limit_rate_value: pulumi.Input[_builtins.int]
        """
        Specifies the rate limiting value, in bit/s.
        The value ranges from `0` to `104,857,600`.

        > The speed is limited to the value of `limit_rate_value` after `limit_rate_after` bytes are transmitted.
        """
        match_type: pulumi.Input[_builtins.str]
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        match_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
elif False:
    DomainConfigsRequestLimitRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRequestLimitRuleArgs:
    def __init__(__self__, *,
                 limit_rate_after: pulumi.Input[_builtins.int],
                 limit_rate_value: pulumi.Input[_builtins.int],
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 match_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] limit_rate_after: Specifies the rate limiting condition. Unit: byte.
               The value ranges from `0` to `1,073,741,824`.
        :param pulumi.Input[_builtins.int] limit_rate_value: Specifies the rate limiting value, in bit/s.
               The value ranges from `0` to `104,857,600`.
               
               > The speed is limited to the value of `limit_rate_value` after `limit_rate_after` bytes are transmitted.
        :param pulumi.Input[_builtins.str] match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param pulumi.Input[_builtins.int] priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.str] match_value: Specifies the cache match settings.
               + When `match_type` is set to **all**, this field does not need to be configured.
               + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
               value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
               not exceed `20`.
               + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
               be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
               exceed `20`.
               + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
               It supports matching specific files in the specified directory or files with a wildcard "*".
               The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
               single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
               + When `match_type` is set to **home_page**, this field does not need to be configured.
               
               <a name="access_area_filter_object"></a>
               The `access_area_filter` block support:
        """
        pulumi.set(__self__, "limit_rate_after", limit_rate_after)
        pulumi.set(__self__, "limit_rate_value", limit_rate_value)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="limitRateAfter")
    def limit_rate_after(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the rate limiting condition. Unit: byte.
        The value ranges from `0` to `1,073,741,824`.
        """
        return pulumi.get(self, "limit_rate_after")

    @limit_rate_after.setter
    def limit_rate_after(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit_rate_after", value)

    @_builtins.property
    @pulumi.getter(name="limitRateValue")
    def limit_rate_value(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the rate limiting value, in bit/s.
        The value ranges from `0` to `104,857,600`.

        > The speed is limited to the value of `limit_rate_value` after `limit_rate_after` bytes are transmitted.
        """
        return pulumi.get(self, "limit_rate_value")

    @limit_rate_value.setter
    def limit_rate_value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit_rate_value", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_value", value)


if not MYPY:
    class DomainConfigsRequestUrlRewriteArgsDict(TypedDict):
        condition: pulumi.Input['DomainConfigsRequestUrlRewriteConditionArgsDict']
        """
        Specifies matching condition.
        The condition structure is documented below.
        """
        execution_mode: pulumi.Input[_builtins.str]
        """
        Specifies the execution mode. Valid values are:
        + **redirect**: If the requested URL matches the current rule, the request will be redirected to the target path.
        After the current rule is executed, if there are other configured rules, the remaining rules will continue to be matched.
        + **break**: If the requested URL matches the current rule, the request will be rewritten to the target path.
        After the current rule is executed, if there are other configured rules, the remaining rules will no longer be matched.
        The redirection host and redirection status code are not supported at this time, and the status code `200` is returned.
        """
        redirect_url: pulumi.Input[_builtins.str]
        """
        Specifies the redirect URL. The redirected URL starts with a forward slash (/)
        and does not contain the http:// header or domain name. Example: **/test/index.html**.
        """
        redirect_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the domain name to redirect client requests.

        > 1. The current domain name will be used by default.
        <br/>2. This field supports a character length of `1`-`255` and must start with http:// or https://.

        <a name="request_url_rewrite_condition_object"></a>
        The `condition` block support:
        """
        redirect_status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the redirect status code. Supports `301`, `302`, `303`, and `307`.
        """
elif False:
    DomainConfigsRequestUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRequestUrlRewriteArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['DomainConfigsRequestUrlRewriteConditionArgs'],
                 execution_mode: pulumi.Input[_builtins.str],
                 redirect_url: pulumi.Input[_builtins.str],
                 redirect_host: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_status_code: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['DomainConfigsRequestUrlRewriteConditionArgs'] condition: Specifies matching condition.
               The condition structure is documented below.
        :param pulumi.Input[_builtins.str] execution_mode: Specifies the execution mode. Valid values are:
               + **redirect**: If the requested URL matches the current rule, the request will be redirected to the target path.
               After the current rule is executed, if there are other configured rules, the remaining rules will continue to be matched.
               + **break**: If the requested URL matches the current rule, the request will be rewritten to the target path.
               After the current rule is executed, if there are other configured rules, the remaining rules will no longer be matched.
               The redirection host and redirection status code are not supported at this time, and the status code `200` is returned.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the redirect URL. The redirected URL starts with a forward slash (/)
               and does not contain the http:// header or domain name. Example: **/test/index.html**.
        :param pulumi.Input[_builtins.str] redirect_host: Specifies the domain name to redirect client requests.
               
               > 1. The current domain name will be used by default.
               <br/>2. This field supports a character length of `1`-`255` and must start with http:// or https://.
               
               <a name="request_url_rewrite_condition_object"></a>
               The `condition` block support:
        :param pulumi.Input[_builtins.int] redirect_status_code: Specifies the redirect status code. Supports `301`, `302`, `303`, and `307`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "execution_mode", execution_mode)
        pulumi.set(__self__, "redirect_url", redirect_url)
        if redirect_host is not None:
            pulumi.set(__self__, "redirect_host", redirect_host)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['DomainConfigsRequestUrlRewriteConditionArgs']:
        """
        Specifies matching condition.
        The condition structure is documented below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['DomainConfigsRequestUrlRewriteConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="executionMode")
    def execution_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the execution mode. Valid values are:
        + **redirect**: If the requested URL matches the current rule, the request will be redirected to the target path.
        After the current rule is executed, if there are other configured rules, the remaining rules will continue to be matched.
        + **break**: If the requested URL matches the current rule, the request will be rewritten to the target path.
        After the current rule is executed, if there are other configured rules, the remaining rules will no longer be matched.
        The redirection host and redirection status code are not supported at this time, and the status code `200` is returned.
        """
        return pulumi.get(self, "execution_mode")

    @execution_mode.setter
    def execution_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_mode", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the redirect URL. The redirected URL starts with a forward slash (/)
        and does not contain the http:// header or domain name. Example: **/test/index.html**.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter(name="redirectHost")
    def redirect_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the domain name to redirect client requests.

        > 1. The current domain name will be used by default.
        <br/>2. This field supports a character length of `1`-`255` and must start with http:// or https://.

        <a name="request_url_rewrite_condition_object"></a>
        The `condition` block support:
        """
        return pulumi.get(self, "redirect_host")

    @redirect_host.setter
    def redirect_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_host", value)

    @_builtins.property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the redirect status code. Supports `301`, `302`, `303`, and `307`.
        """
        return pulumi.get(self, "redirect_status_code")

    @redirect_status_code.setter
    def redirect_status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redirect_status_code", value)


if not MYPY:
    class DomainConfigsRequestUrlRewriteConditionArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        match_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
elif False:
    DomainConfigsRequestUrlRewriteConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRequestUrlRewriteConditionArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 match_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param pulumi.Input[_builtins.int] priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param pulumi.Input[_builtins.str] match_value: Specifies the cache match settings.
               + When `match_type` is set to **all**, this field does not need to be configured.
               + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
               value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
               not exceed `20`.
               + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
               be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
               exceed `20`.
               + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
               It supports matching specific files in the specified directory or files with a wildcard "*".
               The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
               single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
               + When `match_type` is set to **home_page**, this field does not need to be configured.
               
               <a name="access_area_filter_object"></a>
               The `access_area_filter` block support:
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_value", value)


if not MYPY:
    class DomainConfigsRetrievalRequestHeaderArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
        **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
        **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
        and hyphens (-), and starts with a letter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
elif False:
    DomainConfigsRetrievalRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsRetrievalRequestHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        :param pulumi.Input[_builtins.str] name: Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
               **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
               **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
               and hyphens (-), and starts with a letter.
        :param pulumi.Input[_builtins.str] value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
        **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
        **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
        and hyphens (-), and starts with a letter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainConfigsSniArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the origin server domain name that the CDN node needs to access when
        returning to the source.

        > 1. This file is required when enable SNI settings. <br/>2. Wildcard domain names are not supported.
        Only digital, "-", ".", and uppercase and lowercase English characters are supported.

        <a name="request_url_rewrite_object"></a>
        The `request_url_rewrite` block support:
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainConfigsSniArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsSniArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.str] server_name: Specifies the origin server domain name that the CDN node needs to access when
               returning to the source.
               
               > 1. This file is required when enable SNI settings. <br/>2. Wildcard domain names are not supported.
               Only digital, "-", ".", and uppercase and lowercase English characters are supported.
               
               <a name="request_url_rewrite_object"></a>
               The `request_url_rewrite` block support:
        """
        pulumi.set(__self__, "enabled", enabled)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the origin server domain name that the CDN node needs to access when
        returning to the source.

        > 1. This file is required when enable SNI settings. <br/>2. Wildcard domain names are not supported.
        Only digital, "-", ".", and uppercase and lowercase English characters are supported.

        <a name="request_url_rewrite_object"></a>
        The `request_url_rewrite` block support:
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DomainConfigsUrlSigningArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        backup_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the standby authentication key contains `16` to `32` characters,
        including letters and digits.
        """
        expire_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the expiration time. The value ranges from `0` to `31536000`, in seconds.

        <a name="inherit_config_object"></a>
        The `inherit_config` blocks support:
        """
        inherit_config: NotRequired[pulumi.Input['DomainConfigsUrlSigningInheritConfigArgsDict']]
        """
        Specifies the details of the authentication inheritance.
        The inherit_config structure is documented below.

        > Add authentication parameters to TS and MP4 files under M3U8/MPD index files, so that the files can be played
        after authentication succeeds.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        match_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        sign_arg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the authentication parameters. The default value is **auth_key**.
        The valid length is limited from `1` to `100` characters, only letters, digits, and underscores (_) are allowed.
        The value can not start with a digit.
        """
        sign_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the encryption algorithm type for URL authentication.
        The default value is **md5**. The valid values are as following:
        + **md5**
        + **sha256**
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        time_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time format. Possible values are:
        **dec**: Decimal, can be used in Method A, Method B and Method C2.
        **hex**: Hexadecimal, can be used in Method C1 and Method C2.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
elif False:
    DomainConfigsUrlSigningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsUrlSigningArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 backup_key: Optional[pulumi.Input[_builtins.str]] = None,
                 expire_time: Optional[pulumi.Input[_builtins.int]] = None,
                 inherit_config: Optional[pulumi.Input['DomainConfigsUrlSigningInheritConfigArgs']] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_arg: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_method: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_format: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.str] backup_key: Specifies the standby authentication key contains `16` to `32` characters,
               including letters and digits.
        :param pulumi.Input[_builtins.int] expire_time: Specifies the expiration time. The value ranges from `0` to `31536000`, in seconds.
               
               <a name="inherit_config_object"></a>
               The `inherit_config` blocks support:
        :param pulumi.Input['DomainConfigsUrlSigningInheritConfigArgs'] inherit_config: Specifies the details of the authentication inheritance.
               The inherit_config structure is documented below.
               
               > Add authentication parameters to TS and MP4 files under M3U8/MPD index files, so that the files can be played
               after authentication succeeds.
        :param pulumi.Input[_builtins.str] key: Specifies the parameter key. The value contains up to `256` characters. The value can be
               composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        :param pulumi.Input[_builtins.str] match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param pulumi.Input[_builtins.str] sign_arg: Specifies the authentication parameters. The default value is **auth_key**.
               The valid length is limited from `1` to `100` characters, only letters, digits, and underscores (_) are allowed.
               The value can not start with a digit.
        :param pulumi.Input[_builtins.str] sign_method: Specifies the encryption algorithm type for URL authentication.
               The default value is **md5**. The valid values are as following:
               + **md5**
               + **sha256**
        :param pulumi.Input[_builtins.str] time_format: Specifies the time format. Possible values are:
               **dec**: Decimal, can be used in Method A, Method B and Method C2.
               **hex**: Hexadecimal, can be used in Method C1 and Method C2.
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        """
        pulumi.set(__self__, "enabled", enabled)
        if backup_key is not None:
            pulumi.set(__self__, "backup_key", backup_key)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if inherit_config is not None:
            pulumi.set(__self__, "inherit_config", inherit_config)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if sign_arg is not None:
            pulumi.set(__self__, "sign_arg", sign_arg)
        if sign_method is not None:
            pulumi.set(__self__, "sign_method", sign_method)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="backupKey")
    def backup_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the standby authentication key contains `16` to `32` characters,
        including letters and digits.
        """
        return pulumi.get(self, "backup_key")

    @backup_key.setter
    def backup_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_key", value)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the expiration time. The value ranges from `0` to `31536000`, in seconds.

        <a name="inherit_config_object"></a>
        The `inherit_config` blocks support:
        """
        return pulumi.get(self, "expire_time")

    @expire_time.setter
    def expire_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expire_time", value)

    @_builtins.property
    @pulumi.getter(name="inheritConfig")
    def inherit_config(self) -> Optional[pulumi.Input['DomainConfigsUrlSigningInheritConfigArgs']]:
        """
        Specifies the details of the authentication inheritance.
        The inherit_config structure is documented below.

        > Add authentication parameters to TS and MP4 files under M3U8/MPD index files, so that the files can be played
        after authentication succeeds.
        """
        return pulumi.get(self, "inherit_config")

    @inherit_config.setter
    def inherit_config(self, value: Optional[pulumi.Input['DomainConfigsUrlSigningInheritConfigArgs']]):
        pulumi.set(self, "inherit_config", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="signArg")
    def sign_arg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the authentication parameters. The default value is **auth_key**.
        The valid length is limited from `1` to `100` characters, only letters, digits, and underscores (_) are allowed.
        The value can not start with a digit.
        """
        return pulumi.get(self, "sign_arg")

    @sign_arg.setter
    def sign_arg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_arg", value)

    @_builtins.property
    @pulumi.getter(name="signMethod")
    def sign_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the encryption algorithm type for URL authentication.
        The default value is **md5**. The valid values are as following:
        + **md5**
        + **sha256**
        """
        return pulumi.get(self, "sign_method")

    @sign_method.setter
    def sign_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_method", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time format. Possible values are:
        **dec**: Decimal, can be used in Method A, Method B and Method C2.
        **hex**: Hexadecimal, can be used in Method C1 and Method C2.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_format", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainConfigsUrlSigningInheritConfigArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        inherit_time_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time type that inherits authentication settings.
        The valid values are as follows:
        + **sys_time**: The current system time.
        + **parent_url_time**: The time when a user accesses the M3U8/MPD file.

        > This parameter is mandatory when authentication inheritance is enabled.

        <a name="force_redirect_object"></a>
        The `force_redirect` blocks support:
        """
        inherit_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the authentication inheritance configuration.
        The valid values are **m3u8** and **mpd**. Separate multiple values with commas (,). e.g. **m3u8,mpd**.

        > This parameter is mandatory when authentication inheritance is enabled.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainConfigsUrlSigningInheritConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsUrlSigningInheritConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 inherit_time_type: Optional[pulumi.Input[_builtins.str]] = None,
                 inherit_type: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.str] inherit_time_type: Specifies the time type that inherits authentication settings.
               The valid values are as follows:
               + **sys_time**: The current system time.
               + **parent_url_time**: The time when a user accesses the M3U8/MPD file.
               
               > This parameter is mandatory when authentication inheritance is enabled.
               
               <a name="force_redirect_object"></a>
               The `force_redirect` blocks support:
        :param pulumi.Input[_builtins.str] inherit_type: Specifies the authentication inheritance configuration.
               The valid values are **m3u8** and **mpd**. Separate multiple values with commas (,). e.g. **m3u8,mpd**.
               
               > This parameter is mandatory when authentication inheritance is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        if inherit_time_type is not None:
            pulumi.set(__self__, "inherit_time_type", inherit_time_type)
        if inherit_type is not None:
            pulumi.set(__self__, "inherit_type", inherit_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="inheritTimeType")
    def inherit_time_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time type that inherits authentication settings.
        The valid values are as follows:
        + **sys_time**: The current system time.
        + **parent_url_time**: The time when a user accesses the M3U8/MPD file.

        > This parameter is mandatory when authentication inheritance is enabled.

        <a name="force_redirect_object"></a>
        The `force_redirect` blocks support:
        """
        return pulumi.get(self, "inherit_time_type")

    @inherit_time_type.setter
    def inherit_time_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inherit_time_type", value)

    @_builtins.property
    @pulumi.getter(name="inheritType")
    def inherit_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the authentication inheritance configuration.
        The valid values are **m3u8** and **mpd**. Separate multiple values with commas (,). e.g. **m3u8,mpd**.

        > This parameter is mandatory when authentication inheritance is enabled.
        """
        return pulumi.get(self, "inherit_type")

    @inherit_type.setter
    def inherit_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inherit_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DomainConfigsUserAgentFilterArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        include_empty: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether empty user agents are included.
        A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
        A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
        Possible values: **true** (included) and **false** (excluded).
        The default value is **false** for a blacklist and **true** for a whitelist.
        """
        ua_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the User-Agent blacklist or whitelist. This parameter is required when `type`
        is set to **black** or **white**. Up to `10` rules can be configured. A rule contains up to `100` characters.

        <a name="error_code_redirect_rules_object"></a>
        The `error_code_redirect_rules` block support:
        """
elif False:
    DomainConfigsUserAgentFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsUserAgentFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 include_empty: Optional[pulumi.Input[_builtins.str]] = None,
                 ua_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param pulumi.Input[_builtins.str] include_empty: Specifies whether empty user agents are included.
               A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
               A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
               Possible values: **true** (included) and **false** (excluded).
               The default value is **false** for a blacklist and **true** for a whitelist.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ua_lists: Specifies the User-Agent blacklist or whitelist. This parameter is required when `type`
               is set to **black** or **white**. Up to `10` rules can be configured. A rule contains up to `100` characters.
               
               <a name="error_code_redirect_rules_object"></a>
               The `error_code_redirect_rules` block support:
        """
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if ua_lists is not None:
            pulumi.set(__self__, "ua_lists", ua_lists)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether empty user agents are included.
        A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
        A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
        Possible values: **true** (included) and **false** (excluded).
        The default value is **false** for a blacklist and **true** for a whitelist.
        """
        return pulumi.get(self, "include_empty")

    @include_empty.setter
    def include_empty(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_empty", value)

    @_builtins.property
    @pulumi.getter(name="uaLists")
    def ua_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the User-Agent blacklist or whitelist. This parameter is required when `type`
        is set to **black** or **white**. Up to `10` rules can be configured. A rule contains up to `100` characters.

        <a name="error_code_redirect_rules_object"></a>
        The `error_code_redirect_rules` block support:
        """
        return pulumi.get(self, "ua_lists")

    @ua_lists.setter
    def ua_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ua_lists", value)


if not MYPY:
    class DomainConfigsVideoSeekArgsDict(TypedDict):
        enable_video_seek: pulumi.Input[_builtins.bool]
        """
        Specifies the video seek status. **true**: enabled; **false**: disabled.
        """
        enable_flv_by_time_seek: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the time-based `FLV` seek status.
        **true**: enabled; **false**: disabled. Defaults to **false**.
        """
        end_parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the video playback end parameter in user request URLs.
        The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.

        <a name="request_limit_rules_object"></a>
        The `request_limit_rules` block support:
        """
        start_parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the video playback start parameter in user request URLs.
        The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
        """
elif False:
    DomainConfigsVideoSeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsVideoSeekArgs:
    def __init__(__self__, *,
                 enable_video_seek: pulumi.Input[_builtins.bool],
                 enable_flv_by_time_seek: Optional[pulumi.Input[_builtins.bool]] = None,
                 end_parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 start_parameter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_video_seek: Specifies the video seek status. **true**: enabled; **false**: disabled.
        :param pulumi.Input[_builtins.bool] enable_flv_by_time_seek: Specifies the time-based `FLV` seek status.
               **true**: enabled; **false**: disabled. Defaults to **false**.
        :param pulumi.Input[_builtins.str] end_parameter: Specifies the video playback end parameter in user request URLs.
               The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
               
               <a name="request_limit_rules_object"></a>
               The `request_limit_rules` block support:
        :param pulumi.Input[_builtins.str] start_parameter: Specifies the video playback start parameter in user request URLs.
               The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
        """
        pulumi.set(__self__, "enable_video_seek", enable_video_seek)
        if enable_flv_by_time_seek is not None:
            pulumi.set(__self__, "enable_flv_by_time_seek", enable_flv_by_time_seek)
        if end_parameter is not None:
            pulumi.set(__self__, "end_parameter", end_parameter)
        if start_parameter is not None:
            pulumi.set(__self__, "start_parameter", start_parameter)

    @_builtins.property
    @pulumi.getter(name="enableVideoSeek")
    def enable_video_seek(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies the video seek status. **true**: enabled; **false**: disabled.
        """
        return pulumi.get(self, "enable_video_seek")

    @enable_video_seek.setter
    def enable_video_seek(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_video_seek", value)

    @_builtins.property
    @pulumi.getter(name="enableFlvByTimeSeek")
    def enable_flv_by_time_seek(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the time-based `FLV` seek status.
        **true**: enabled; **false**: disabled. Defaults to **false**.
        """
        return pulumi.get(self, "enable_flv_by_time_seek")

    @enable_flv_by_time_seek.setter
    def enable_flv_by_time_seek(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_flv_by_time_seek", value)

    @_builtins.property
    @pulumi.getter(name="endParameter")
    def end_parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the video playback end parameter in user request URLs.
        The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.

        <a name="request_limit_rules_object"></a>
        The `request_limit_rules` block support:
        """
        return pulumi.get(self, "end_parameter")

    @end_parameter.setter
    def end_parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_parameter", value)

    @_builtins.property
    @pulumi.getter(name="startParameter")
    def start_parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the video playback start parameter in user request URLs.
        The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
        """
        return pulumi.get(self, "start_parameter")

    @start_parameter.setter
    def start_parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_parameter", value)


if not MYPY:
    class DomainConfigsWebsocketArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable client cert settings.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the duration from the time when a CDN node forwards an authentication request
        to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
        ranging from `50` to `3,000`. The unit is millisecond.
        """
elif False:
    DomainConfigsWebsocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigsWebsocketArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable client cert settings.
        :param pulumi.Input[_builtins.int] timeout: Specifies the duration from the time when a CDN node forwards an authentication request
               to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
               ranging from `50` to `3,000`. The unit is millisecond.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the duration from the time when a CDN node forwards an authentication request
        to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
        ranging from `50` to `3,000`. The unit is millisecond.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class DomainRuleRuleArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionArgsDict']]]
        """
        Specifies a list of actions to be performed when the rules are met
        """
        conditions: pulumi.Input['DomainRuleRuleConditionsArgsDict']
        name: pulumi.Input[_builtins.str]
        """
        Specifies the rule name. The valid length is limit from `1` to `50`.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Specifies the rule priority. The valid value is limit from 1 to 100.
        """
        status: pulumi.Input[_builtins.str]
        """
        Specifies the rule status. Valid values are **on** and **off**.
        """
        rule_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainRuleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionArgs']]],
                 conditions: pulumi.Input['DomainRuleRuleConditionsArgs'],
                 name: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 status: pulumi.Input[_builtins.str],
                 rule_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionArgs']]] actions: Specifies a list of actions to be performed when the rules are met
        :param pulumi.Input[_builtins.str] name: Specifies the rule name. The valid length is limit from `1` to `50`.
        :param pulumi.Input[_builtins.int] priority: Specifies the rule priority. The valid value is limit from 1 to 100.
        :param pulumi.Input[_builtins.str] status: Specifies the rule status. Valid values are **on** and **off**.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "status", status)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionArgs']]]:
        """
        Specifies a list of actions to be performed when the rules are met
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionArgs']]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input['DomainRuleRuleConditionsArgs']:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input['DomainRuleRuleConditionsArgs']):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rule name. The valid length is limit from `1` to `50`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the rule priority. The valid value is limit from 1 to 100.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rule status. Valid values are **on** and **off**.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_id", value)


if not MYPY:
    class DomainRuleRuleActionArgsDict(TypedDict):
        access_control: NotRequired[pulumi.Input['DomainRuleRuleActionAccessControlArgsDict']]
        cache_rule: NotRequired[pulumi.Input['DomainRuleRuleActionCacheRuleArgsDict']]
        flexible_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionFlexibleOriginArgsDict']]]]
        http_response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionHttpResponseHeaderArgsDict']]]]
        origin_request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionOriginRequestHeaderArgsDict']]]]
        origin_request_url_rewrite: NotRequired[pulumi.Input['DomainRuleRuleActionOriginRequestUrlRewriteArgsDict']]
        request_url_rewrite: NotRequired[pulumi.Input['DomainRuleRuleActionRequestUrlRewriteArgsDict']]
elif False:
    DomainRuleRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionArgs:
    def __init__(__self__, *,
                 access_control: Optional[pulumi.Input['DomainRuleRuleActionAccessControlArgs']] = None,
                 cache_rule: Optional[pulumi.Input['DomainRuleRuleActionCacheRuleArgs']] = None,
                 flexible_origins: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionFlexibleOriginArgs']]]] = None,
                 http_response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionHttpResponseHeaderArgs']]]] = None,
                 origin_request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionOriginRequestHeaderArgs']]]] = None,
                 origin_request_url_rewrite: Optional[pulumi.Input['DomainRuleRuleActionOriginRequestUrlRewriteArgs']] = None,
                 request_url_rewrite: Optional[pulumi.Input['DomainRuleRuleActionRequestUrlRewriteArgs']] = None):
        if access_control is not None:
            pulumi.set(__self__, "access_control", access_control)
        if cache_rule is not None:
            pulumi.set(__self__, "cache_rule", cache_rule)
        if flexible_origins is not None:
            pulumi.set(__self__, "flexible_origins", flexible_origins)
        if http_response_headers is not None:
            pulumi.set(__self__, "http_response_headers", http_response_headers)
        if origin_request_headers is not None:
            pulumi.set(__self__, "origin_request_headers", origin_request_headers)
        if origin_request_url_rewrite is not None:
            pulumi.set(__self__, "origin_request_url_rewrite", origin_request_url_rewrite)
        if request_url_rewrite is not None:
            pulumi.set(__self__, "request_url_rewrite", request_url_rewrite)

    @_builtins.property
    @pulumi.getter(name="accessControl")
    def access_control(self) -> Optional[pulumi.Input['DomainRuleRuleActionAccessControlArgs']]:
        return pulumi.get(self, "access_control")

    @access_control.setter
    def access_control(self, value: Optional[pulumi.Input['DomainRuleRuleActionAccessControlArgs']]):
        pulumi.set(self, "access_control", value)

    @_builtins.property
    @pulumi.getter(name="cacheRule")
    def cache_rule(self) -> Optional[pulumi.Input['DomainRuleRuleActionCacheRuleArgs']]:
        return pulumi.get(self, "cache_rule")

    @cache_rule.setter
    def cache_rule(self, value: Optional[pulumi.Input['DomainRuleRuleActionCacheRuleArgs']]):
        pulumi.set(self, "cache_rule", value)

    @_builtins.property
    @pulumi.getter(name="flexibleOrigins")
    def flexible_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionFlexibleOriginArgs']]]]:
        return pulumi.get(self, "flexible_origins")

    @flexible_origins.setter
    def flexible_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionFlexibleOriginArgs']]]]):
        pulumi.set(self, "flexible_origins", value)

    @_builtins.property
    @pulumi.getter(name="httpResponseHeaders")
    def http_response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionHttpResponseHeaderArgs']]]]:
        return pulumi.get(self, "http_response_headers")

    @http_response_headers.setter
    def http_response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionHttpResponseHeaderArgs']]]]):
        pulumi.set(self, "http_response_headers", value)

    @_builtins.property
    @pulumi.getter(name="originRequestHeaders")
    def origin_request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionOriginRequestHeaderArgs']]]]:
        return pulumi.get(self, "origin_request_headers")

    @origin_request_headers.setter
    def origin_request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainRuleRuleActionOriginRequestHeaderArgs']]]]):
        pulumi.set(self, "origin_request_headers", value)

    @_builtins.property
    @pulumi.getter(name="originRequestUrlRewrite")
    def origin_request_url_rewrite(self) -> Optional[pulumi.Input['DomainRuleRuleActionOriginRequestUrlRewriteArgs']]:
        return pulumi.get(self, "origin_request_url_rewrite")

    @origin_request_url_rewrite.setter
    def origin_request_url_rewrite(self, value: Optional[pulumi.Input['DomainRuleRuleActionOriginRequestUrlRewriteArgs']]):
        pulumi.set(self, "origin_request_url_rewrite", value)

    @_builtins.property
    @pulumi.getter(name="requestUrlRewrite")
    def request_url_rewrite(self) -> Optional[pulumi.Input['DomainRuleRuleActionRequestUrlRewriteArgs']]:
        return pulumi.get(self, "request_url_rewrite")

    @request_url_rewrite.setter
    def request_url_rewrite(self, value: Optional[pulumi.Input['DomainRuleRuleActionRequestUrlRewriteArgs']]):
        pulumi.set(self, "request_url_rewrite", value)


if not MYPY:
    class DomainRuleRuleActionAccessControlArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the access control type. Valid values are **block** and **trust**.
        """
elif False:
    DomainRuleRuleActionAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionAccessControlArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the access control type. Valid values are **block** and **trust**.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the access control type. Valid values are **block** and **trust**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainRuleRuleActionCacheRuleArgsDict(TypedDict):
        follow_origin: pulumi.Input[_builtins.str]
        """
        Specifies the cache expiration time source. Valid values: **off**, **on**, and **min_ttl**
        """
        ttl: pulumi.Input[_builtins.int]
        """
        Specifies the cache expiration time.
        """
        ttl_unit: pulumi.Input[_builtins.str]
        """
        Specifies the cache expiration time unit. Valid values: **s**, **m**, **h**, and **d**
        """
        force_cache: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether to enable forced caching. Valid values are **on** and **off**.
        """
elif False:
    DomainRuleRuleActionCacheRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionCacheRuleArgs:
    def __init__(__self__, *,
                 follow_origin: pulumi.Input[_builtins.str],
                 ttl: pulumi.Input[_builtins.int],
                 ttl_unit: pulumi.Input[_builtins.str],
                 force_cache: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] follow_origin: Specifies the cache expiration time source. Valid values: **off**, **on**, and **min_ttl**
        :param pulumi.Input[_builtins.int] ttl: Specifies the cache expiration time.
        :param pulumi.Input[_builtins.str] ttl_unit: Specifies the cache expiration time unit. Valid values: **s**, **m**, **h**, and **d**
        :param pulumi.Input[_builtins.str] force_cache: Specifies whether to enable forced caching. Valid values are **on** and **off**.
        """
        pulumi.set(__self__, "follow_origin", follow_origin)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "ttl_unit", ttl_unit)
        if force_cache is not None:
            pulumi.set(__self__, "force_cache", force_cache)

    @_builtins.property
    @pulumi.getter(name="followOrigin")
    def follow_origin(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the cache expiration time source. Valid values: **off**, **on**, and **min_ttl**
        """
        return pulumi.get(self, "follow_origin")

    @follow_origin.setter
    def follow_origin(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "follow_origin", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the cache expiration time.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="ttlUnit")
    def ttl_unit(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the cache expiration time unit. Valid values: **s**, **m**, **h**, and **d**
        """
        return pulumi.get(self, "ttl_unit")

    @ttl_unit.setter
    def ttl_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ttl_unit", value)

    @_builtins.property
    @pulumi.getter(name="forceCache")
    def force_cache(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether to enable forced caching. Valid values are **on** and **off**.
        """
        return pulumi.get(self, "force_cache")

    @force_cache.setter
    def force_cache(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "force_cache", value)


if not MYPY:
    class DomainRuleRuleActionFlexibleOriginArgsDict(TypedDict):
        ip_or_domain: pulumi.Input[_builtins.str]
        """
        Specifies the origin IP or domain name.
        """
        origin_protocol: pulumi.Input[_builtins.str]
        """
        Specifies the origin protocol.
        """
        priority: pulumi.Input[_builtins.int]
        """
        Specifies the origin priority. Valid value ranges from `1` to `100`.
        """
        sources_type: pulumi.Input[_builtins.str]
        """
        Specifies the source type. Valid values are: **ipaddr**, **domain**, and **obs_bucket**.
        """
        weight: pulumi.Input[_builtins.int]
        """
        Specifies the weight. Valid value ranges from `1` to `100`.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the host name.
        """
        http_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the HTTP port. Ranges from `1` to `65,535`. Defaults to `80`.
        """
        https_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the HTTPS port. Ranges from `1` to `65,535`. Defaults to `443`.
        """
        obs_bucket_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        """
elif False:
    DomainRuleRuleActionFlexibleOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionFlexibleOriginArgs:
    def __init__(__self__, *,
                 ip_or_domain: pulumi.Input[_builtins.str],
                 origin_protocol: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 sources_type: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.int],
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 http_port: Optional[pulumi.Input[_builtins.int]] = None,
                 https_port: Optional[pulumi.Input[_builtins.int]] = None,
                 obs_bucket_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_or_domain: Specifies the origin IP or domain name.
        :param pulumi.Input[_builtins.str] origin_protocol: Specifies the origin protocol.
        :param pulumi.Input[_builtins.int] priority: Specifies the origin priority. Valid value ranges from `1` to `100`.
        :param pulumi.Input[_builtins.str] sources_type: Specifies the source type. Valid values are: **ipaddr**, **domain**, and **obs_bucket**.
        :param pulumi.Input[_builtins.int] weight: Specifies the weight. Valid value ranges from `1` to `100`.
        :param pulumi.Input[_builtins.str] host_name: Specifies the host name.
        :param pulumi.Input[_builtins.int] http_port: Specifies the HTTP port. Ranges from `1` to `65,535`. Defaults to `80`.
        :param pulumi.Input[_builtins.int] https_port: Specifies the HTTPS port. Ranges from `1` to `65,535`. Defaults to `443`.
        :param pulumi.Input[_builtins.str] obs_bucket_type: Specifies the OBS bucket type. Valid values are **private** and **public**.
        """
        pulumi.set(__self__, "ip_or_domain", ip_or_domain)
        pulumi.set(__self__, "origin_protocol", origin_protocol)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "sources_type", sources_type)
        pulumi.set(__self__, "weight", weight)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)

    @_builtins.property
    @pulumi.getter(name="ipOrDomain")
    def ip_or_domain(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the origin IP or domain name.
        """
        return pulumi.get(self, "ip_or_domain")

    @ip_or_domain.setter
    def ip_or_domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_or_domain", value)

    @_builtins.property
    @pulumi.getter(name="originProtocol")
    def origin_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the origin protocol.
        """
        return pulumi.get(self, "origin_protocol")

    @origin_protocol.setter
    def origin_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_protocol", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the origin priority. Valid value ranges from `1` to `100`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="sourcesType")
    def sources_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the source type. Valid values are: **ipaddr**, **domain**, and **obs_bucket**.
        """
        return pulumi.get(self, "sources_type")

    @sources_type.setter
    def sources_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sources_type", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the weight. Valid value ranges from `1` to `100`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the host name.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the HTTP port. Ranges from `1` to `65,535`. Defaults to `80`.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the HTTPS port. Ranges from `1` to `65,535`. Defaults to `443`.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        """
        return pulumi.get(self, "obs_bucket_type")

    @obs_bucket_type.setter
    def obs_bucket_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_bucket_type", value)


if not MYPY:
    class DomainRuleRuleActionHttpResponseHeaderArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Specifies the operation type of setting HTTP response header.
        Valid values are **set** and **delete**.
        """
        name: pulumi.Input[_builtins.str]
        """
        Set HTTP response header parameters.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set the value of HTTP response header parameters.
        """
elif False:
    DomainRuleRuleActionHttpResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionHttpResponseHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Specifies the operation type of setting HTTP response header.
               Valid values are **set** and **delete**.
        :param pulumi.Input[_builtins.str] name: Set HTTP response header parameters.
        :param pulumi.Input[_builtins.str] value: Set the value of HTTP response header parameters.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the operation type of setting HTTP response header.
        Valid values are **set** and **delete**.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Set HTTP response header parameters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set the value of HTTP response header parameters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainRuleRuleActionOriginRequestHeaderArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Specifies the back-to-origin request header setting type.
        Valid values are **delete** and **set**
        """
        name: pulumi.Input[_builtins.str]
        """
        Set back-to-origin request header parameters.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set the value of the return-to-origin request header parameter.
        """
elif False:
    DomainRuleRuleActionOriginRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionOriginRequestHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Specifies the back-to-origin request header setting type.
               Valid values are **delete** and **set**
        :param pulumi.Input[_builtins.str] name: Set back-to-origin request header parameters.
        :param pulumi.Input[_builtins.str] value: Set the value of the return-to-origin request header parameter.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the back-to-origin request header setting type.
        Valid values are **delete** and **set**
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Set back-to-origin request header parameters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set the value of the return-to-origin request header parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainRuleRuleActionOriginRequestUrlRewriteArgsDict(TypedDict):
        rewrite_type: pulumi.Input[_builtins.str]
        """
        Specifies the rewrite type. Valid values are **simple** and **wildcard**.
        """
        target_url: pulumi.Input[_builtins.str]
        """
        Specifies the target URL.
        """
        source_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URL to be rewritten back to the source.
        """
elif False:
    DomainRuleRuleActionOriginRequestUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionOriginRequestUrlRewriteArgs:
    def __init__(__self__, *,
                 rewrite_type: pulumi.Input[_builtins.str],
                 target_url: pulumi.Input[_builtins.str],
                 source_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] rewrite_type: Specifies the rewrite type. Valid values are **simple** and **wildcard**.
        :param pulumi.Input[_builtins.str] target_url: Specifies the target URL.
        :param pulumi.Input[_builtins.str] source_url: Specifies the URL to be rewritten back to the source.
        """
        pulumi.set(__self__, "rewrite_type", rewrite_type)
        pulumi.set(__self__, "target_url", target_url)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @_builtins.property
    @pulumi.getter(name="rewriteType")
    def rewrite_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rewrite type. Valid values are **simple** and **wildcard**.
        """
        return pulumi.get(self, "rewrite_type")

    @rewrite_type.setter
    def rewrite_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rewrite_type", value)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the target URL.
        """
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_url", value)

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL to be rewritten back to the source.
        """
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_url", value)


if not MYPY:
    class DomainRuleRuleActionRequestUrlRewriteArgsDict(TypedDict):
        execution_mode: pulumi.Input[_builtins.str]
        """
        Specifies the execution mode. Valid values are **redirect** and **break**.
        """
        redirect_url: pulumi.Input[_builtins.str]
        """
        Specifies the redirect URL.
        """
        redirect_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the redirect host.
        """
        redirect_status_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the redirect status code. Valid values are `301`, `302`, `303`, and `307`.
        """
elif False:
    DomainRuleRuleActionRequestUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleActionRequestUrlRewriteArgs:
    def __init__(__self__, *,
                 execution_mode: pulumi.Input[_builtins.str],
                 redirect_url: pulumi.Input[_builtins.str],
                 redirect_host: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_status_code: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] execution_mode: Specifies the execution mode. Valid values are **redirect** and **break**.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the redirect URL.
        :param pulumi.Input[_builtins.str] redirect_host: Specifies the redirect host.
        :param pulumi.Input[_builtins.int] redirect_status_code: Specifies the redirect status code. Valid values are `301`, `302`, `303`, and `307`.
        """
        pulumi.set(__self__, "execution_mode", execution_mode)
        pulumi.set(__self__, "redirect_url", redirect_url)
        if redirect_host is not None:
            pulumi.set(__self__, "redirect_host", redirect_host)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @_builtins.property
    @pulumi.getter(name="executionMode")
    def execution_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the execution mode. Valid values are **redirect** and **break**.
        """
        return pulumi.get(self, "execution_mode")

    @execution_mode.setter
    def execution_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_mode", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the redirect URL.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter(name="redirectHost")
    def redirect_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the redirect host.
        """
        return pulumi.get(self, "redirect_host")

    @redirect_host.setter
    def redirect_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_host", value)

    @_builtins.property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the redirect status code. Valid values are `301`, `302`, `303`, and `307`.
        """
        return pulumi.get(self, "redirect_status_code")

    @redirect_status_code.setter
    def redirect_status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redirect_status_code", value)


if not MYPY:
    class DomainRuleRuleConditionsArgsDict(TypedDict):
        match: pulumi.Input['DomainRuleRuleConditionsMatchArgsDict']
        """
        Specifies the match configuration.
        """
elif False:
    DomainRuleRuleConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleConditionsArgs:
    def __init__(__self__, *,
                 match: pulumi.Input['DomainRuleRuleConditionsMatchArgs']):
        """
        :param pulumi.Input['DomainRuleRuleConditionsMatchArgs'] match: Specifies the match configuration.
        """
        pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input['DomainRuleRuleConditionsMatchArgs']:
        """
        Specifies the match configuration.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['DomainRuleRuleConditionsMatchArgs']):
        pulumi.set(self, "match", value)


if not MYPY:
    class DomainRuleRuleConditionsMatchArgsDict(TypedDict):
        criteria: pulumi.Input[_builtins.str]
        """
        Specifies the match criteria list in JSON format.
        """
        logic: pulumi.Input[_builtins.str]
        """
        Specifies the logical operator. Valid values are **and** and **or**.
        """
elif False:
    DomainRuleRuleConditionsMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleRuleConditionsMatchArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[_builtins.str],
                 logic: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] criteria: Specifies the match criteria list in JSON format.
        :param pulumi.Input[_builtins.str] logic: Specifies the logical operator. Valid values are **and** and **or**.
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "logic", logic)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match criteria list in JSON format.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter
    def logic(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the logical operator. Valid values are **and** and **or**.
        """
        return pulumi.get(self, "logic")

    @logic.setter
    def logic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "logic", value)


if not MYPY:
    class DomainSourceArgsDict(TypedDict):
        origin: pulumi.Input[_builtins.str]
        """
        Specifies the unique domain name or IP address of the origin server.
        + If `origin_type` is set to **ipaddr**, this field can only be set to IPv4 address.
        + If `origin_type` is set to **domain**, this field can only be set to domain name.
        + If `origin_type` is set to **obs_bucket**, this field can only be set to OBS bucket domain name. The OBS bucket
        domain name must end with `.myhuaweicloud.com` or `.myhuaweicloud.cn`.
        """
        origin_type: pulumi.Input[_builtins.str]
        """
        Specifies the origin server type. The valid values are as follows:
        + **ipaddr**: Origin server IP address.
        + **domain**: Origin server domain name.
        + **obs_bucket**: OBS bucket domain name.
        """
        active: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies whether the origin server is primary or standby. Valid values are as follows:
        + **1**: Primary.
        + **0**: Standby.

        Defaults to `1`.
        """
        bucket_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage access key.
        """
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage bucket name.
        """
        bucket_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage bucket region.
        """
        bucket_secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage secret key.
        """
        http_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        """
        https_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.

        > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.

        <a name="remote_auth_object"></a>
        The `remote_auth` block support:
        """
        obs_bucket_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        This field is required when `sources_type` is set to **obs_bucket**.
        """
        obs_web_hosting_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable static website hosting for the OBS bucket.
        This parameter is valid only when the `origin_type` is set to **obs_bucket**. Defaults to **false**.
        """
        retrieval_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the retrieval host. Things to note when using this field are as follows:
        + If `origin_type` is set to **ipaddr** or **domain**, the acceleration domain name will be used by default.
        + If `origin_type` is set to **obs_bucket**, the bucket's domain name will be used by default.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the weight. The value ranges from `1` to `100`. Defaults to `50`.
        A larger value indicates a larger number of times that content is pulled from this IP address.

        > If there are multiple origin servers with the same priority, the weight determines the proportion of content pulled
        from each origin server.
        """
elif False:
    DomainSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSourceArgs:
    def __init__(__self__, *,
                 origin: pulumi.Input[_builtins.str],
                 origin_type: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.int]] = None,
                 bucket_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_region: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 http_port: Optional[pulumi.Input[_builtins.int]] = None,
                 https_port: Optional[pulumi.Input[_builtins.int]] = None,
                 obs_bucket_type: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_web_hosting_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 retrieval_host: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] origin: Specifies the unique domain name or IP address of the origin server.
               + If `origin_type` is set to **ipaddr**, this field can only be set to IPv4 address.
               + If `origin_type` is set to **domain**, this field can only be set to domain name.
               + If `origin_type` is set to **obs_bucket**, this field can only be set to OBS bucket domain name. The OBS bucket
               domain name must end with `.myhuaweicloud.com` or `.myhuaweicloud.cn`.
        :param pulumi.Input[_builtins.str] origin_type: Specifies the origin server type. The valid values are as follows:
               + **ipaddr**: Origin server IP address.
               + **domain**: Origin server domain name.
               + **obs_bucket**: OBS bucket domain name.
        :param pulumi.Input[_builtins.int] active: Specifies whether the origin server is primary or standby. Valid values are as follows:
               + **1**: Primary.
               + **0**: Standby.
               
               Defaults to `1`.
        :param pulumi.Input[_builtins.str] bucket_access_key: Third-party object storage access key.
        :param pulumi.Input[_builtins.str] bucket_name: Third-party object storage bucket name.
        :param pulumi.Input[_builtins.str] bucket_region: Third-party object storage bucket region.
        :param pulumi.Input[_builtins.str] bucket_secret_key: Third-party object storage secret key.
        :param pulumi.Input[_builtins.int] http_port: Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        :param pulumi.Input[_builtins.int] https_port: Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.
               
               > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.
               
               <a name="remote_auth_object"></a>
               The `remote_auth` block support:
        :param pulumi.Input[_builtins.str] obs_bucket_type: Specifies the OBS bucket type. Valid values are **private** and **public**.
               This field is required when `sources_type` is set to **obs_bucket**.
        :param pulumi.Input[_builtins.bool] obs_web_hosting_enabled: Specifies whether to enable static website hosting for the OBS bucket.
               This parameter is valid only when the `origin_type` is set to **obs_bucket**. Defaults to **false**.
        :param pulumi.Input[_builtins.str] retrieval_host: Specifies the retrieval host. Things to note when using this field are as follows:
               + If `origin_type` is set to **ipaddr** or **domain**, the acceleration domain name will be used by default.
               + If `origin_type` is set to **obs_bucket**, the bucket's domain name will be used by default.
        :param pulumi.Input[_builtins.int] weight: Specifies the weight. The value ranges from `1` to `100`. Defaults to `50`.
               A larger value indicates a larger number of times that content is pulled from this IP address.
               
               > If there are multiple origin servers with the same priority, the weight determines the proportion of content pulled
               from each origin server.
        """
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "origin_type", origin_type)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if bucket_access_key is not None:
            pulumi.set(__self__, "bucket_access_key", bucket_access_key)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)
        if bucket_secret_key is not None:
            pulumi.set(__self__, "bucket_secret_key", bucket_secret_key)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)
        if obs_web_hosting_enabled is not None:
            pulumi.set(__self__, "obs_web_hosting_enabled", obs_web_hosting_enabled)
        if retrieval_host is not None:
            pulumi.set(__self__, "retrieval_host", retrieval_host)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the unique domain name or IP address of the origin server.
        + If `origin_type` is set to **ipaddr**, this field can only be set to IPv4 address.
        + If `origin_type` is set to **domain**, this field can only be set to domain name.
        + If `origin_type` is set to **obs_bucket**, this field can only be set to OBS bucket domain name. The OBS bucket
        domain name must end with `.myhuaweicloud.com` or `.myhuaweicloud.cn`.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="originType")
    def origin_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the origin server type. The valid values are as follows:
        + **ipaddr**: Origin server IP address.
        + **domain**: Origin server domain name.
        + **obs_bucket**: OBS bucket domain name.
        """
        return pulumi.get(self, "origin_type")

    @origin_type.setter
    def origin_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_type", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies whether the origin server is primary or standby. Valid values are as follows:
        + **1**: Primary.
        + **0**: Standby.

        Defaults to `1`.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="bucketAccessKey")
    def bucket_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage access key.
        """
        return pulumi.get(self, "bucket_access_key")

    @bucket_access_key.setter
    def bucket_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage bucket region.
        """
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_region", value)

    @_builtins.property
    @pulumi.getter(name="bucketSecretKey")
    def bucket_secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage secret key.
        """
        return pulumi.get(self, "bucket_secret_key")

    @bucket_secret_key.setter
    def bucket_secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_secret_key", value)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.

        > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.

        <a name="remote_auth_object"></a>
        The `remote_auth` block support:
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        This field is required when `sources_type` is set to **obs_bucket**.
        """
        return pulumi.get(self, "obs_bucket_type")

    @obs_bucket_type.setter
    def obs_bucket_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_bucket_type", value)

    @_builtins.property
    @pulumi.getter(name="obsWebHostingEnabled")
    def obs_web_hosting_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable static website hosting for the OBS bucket.
        This parameter is valid only when the `origin_type` is set to **obs_bucket**. Defaults to **false**.
        """
        return pulumi.get(self, "obs_web_hosting_enabled")

    @obs_web_hosting_enabled.setter
    def obs_web_hosting_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "obs_web_hosting_enabled", value)

    @_builtins.property
    @pulumi.getter(name="retrievalHost")
    def retrieval_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the retrieval host. Things to note when using this field are as follows:
        + If `origin_type` is set to **ipaddr** or **domain**, the acceleration domain name will be used by default.
        + If `origin_type` is set to **obs_bucket**, the bucket's domain name will be used by default.
        """
        return pulumi.get(self, "retrieval_host")

    @retrieval_host.setter
    def retrieval_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retrieval_host", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the weight. The value ranges from `1` to `100`. Defaults to `50`.
        A larger value indicates a larger number of times that content is pulled from this IP address.

        > If there are multiple origin servers with the same priority, the weight determines the proportion of content pulled
        from each origin server.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class DomainV1CacheSettingsArgsDict(TypedDict):
        follow_origin: NotRequired[pulumi.Input[_builtins.bool]]
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1CacheSettingsRuleArgsDict']]]]
elif False:
    DomainV1CacheSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1CacheSettingsArgs:
    def __init__(__self__, *,
                 follow_origin: Optional[pulumi.Input[_builtins.bool]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1CacheSettingsRuleArgs']]]] = None):
        if follow_origin is not None:
            pulumi.set(__self__, "follow_origin", follow_origin)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="followOrigin")
    def follow_origin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "follow_origin")

    @follow_origin.setter
    def follow_origin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "follow_origin", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1CacheSettingsRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1CacheSettingsRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class DomainV1CacheSettingsRuleArgsDict(TypedDict):
        rule_type: pulumi.Input[_builtins.str]
        content: NotRequired[pulumi.Input[_builtins.str]]
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Required
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Required
        """
        ttl_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Required
        """
        url_parameter_type: NotRequired[pulumi.Input[_builtins.str]]
        url_parameter_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1CacheSettingsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1CacheSettingsRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl_type: Optional[pulumi.Input[_builtins.str]] = None,
                 url_parameter_type: Optional[pulumi.Input[_builtins.str]] = None,
                 url_parameter_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] priority: schema: Required
        :param pulumi.Input[_builtins.int] ttl: schema: Required
        :param pulumi.Input[_builtins.str] ttl_type: schema: Required
        """
        pulumi.set(__self__, "rule_type", rule_type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_type is not None:
            pulumi.set(__self__, "ttl_type", ttl_type)
        if url_parameter_type is not None:
            pulumi.set(__self__, "url_parameter_type", url_parameter_type)
        if url_parameter_value is not None:
            pulumi.set(__self__, "url_parameter_value", url_parameter_value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule_type", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Required
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Required
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="ttlType")
    def ttl_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Required
        """
        return pulumi.get(self, "ttl_type")

    @ttl_type.setter
    def ttl_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl_type", value)

    @_builtins.property
    @pulumi.getter(name="urlParameterType")
    def url_parameter_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "url_parameter_type")

    @url_parameter_type.setter
    def url_parameter_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_parameter_type", value)

    @_builtins.property
    @pulumi.getter(name="urlParameterValue")
    def url_parameter_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "url_parameter_value")

    @url_parameter_value.setter
    def url_parameter_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url_parameter_value", value)


if not MYPY:
    class DomainV1ConfigsArgsDict(TypedDict):
        access_area_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsAccessAreaFilterArgsDict']]]]
        """
        Specifies the geographic access control rules.
        """
        browser_cache_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsBrowserCacheRuleArgsDict']]]]
        cache_url_parameter_filter: NotRequired[pulumi.Input['DomainV1ConfigsCacheUrlParameterFilterArgsDict']]
        """
        schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        client_cert: NotRequired[pulumi.Input['DomainV1ConfigsClientCertArgsDict']]
        compress: NotRequired[pulumi.Input['DomainV1ConfigsCompressArgsDict']]
        description: NotRequired[pulumi.Input[_builtins.str]]
        error_code_caches: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeCachArgsDict']]]]
        error_code_redirect_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeRedirectRuleArgsDict']]]]
        flexible_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsFlexibleOriginArgsDict']]]]
        force_redirect: NotRequired[pulumi.Input['DomainV1ConfigsForceRedirectArgsDict']]
        hsts: NotRequired[pulumi.Input['DomainV1ConfigsHstsArgsDict']]
        http_response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsHttpResponseHeaderArgsDict']]]]
        https_settings: NotRequired[pulumi.Input['DomainV1ConfigsHttpsSettingsArgsDict']]
        ip_filter: NotRequired[pulumi.Input['DomainV1ConfigsIpFilterArgsDict']]
        ip_frequency_limit: NotRequired[pulumi.Input['DomainV1ConfigsIpFrequencyLimitArgsDict']]
        ipv6_enable: NotRequired[pulumi.Input[_builtins.bool]]
        origin_follow302_status: NotRequired[pulumi.Input[_builtins.str]]
        origin_protocol: NotRequired[pulumi.Input[_builtins.str]]
        origin_receive_timeout: NotRequired[pulumi.Input[_builtins.int]]
        origin_request_url_rewrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsOriginRequestUrlRewriteArgsDict']]]]
        quic: NotRequired[pulumi.Input['DomainV1ConfigsQuicArgsDict']]
        range_based_retrieval_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        referer: NotRequired[pulumi.Input['DomainV1ConfigsRefererArgsDict']]
        remote_auth: NotRequired[pulumi.Input['DomainV1ConfigsRemoteAuthArgsDict']]
        request_limit_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestLimitRuleArgsDict']]]]
        request_url_rewrites: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestUrlRewriteArgsDict']]]]
        retrieval_request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRetrievalRequestHeaderArgsDict']]]]
        slice_etag_status: NotRequired[pulumi.Input[_builtins.str]]
        sni: NotRequired[pulumi.Input['DomainV1ConfigsSniArgsDict']]
        url_signing: NotRequired[pulumi.Input['DomainV1ConfigsUrlSigningArgsDict']]
        user_agent_filter: NotRequired[pulumi.Input['DomainV1ConfigsUserAgentFilterArgsDict']]
        video_seek: NotRequired[pulumi.Input['DomainV1ConfigsVideoSeekArgsDict']]
        websocket: NotRequired[pulumi.Input['DomainV1ConfigsWebsocketArgsDict']]
elif False:
    DomainV1ConfigsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsArgs:
    def __init__(__self__, *,
                 access_area_filters: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsAccessAreaFilterArgs']]]] = None,
                 browser_cache_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsBrowserCacheRuleArgs']]]] = None,
                 cache_url_parameter_filter: Optional[pulumi.Input['DomainV1ConfigsCacheUrlParameterFilterArgs']] = None,
                 client_cert: Optional[pulumi.Input['DomainV1ConfigsClientCertArgs']] = None,
                 compress: Optional[pulumi.Input['DomainV1ConfigsCompressArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 error_code_caches: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeCachArgs']]]] = None,
                 error_code_redirect_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeRedirectRuleArgs']]]] = None,
                 flexible_origins: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsFlexibleOriginArgs']]]] = None,
                 force_redirect: Optional[pulumi.Input['DomainV1ConfigsForceRedirectArgs']] = None,
                 hsts: Optional[pulumi.Input['DomainV1ConfigsHstsArgs']] = None,
                 http_response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsHttpResponseHeaderArgs']]]] = None,
                 https_settings: Optional[pulumi.Input['DomainV1ConfigsHttpsSettingsArgs']] = None,
                 ip_filter: Optional[pulumi.Input['DomainV1ConfigsIpFilterArgs']] = None,
                 ip_frequency_limit: Optional[pulumi.Input['DomainV1ConfigsIpFrequencyLimitArgs']] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 origin_follow302_status: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 origin_receive_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 origin_request_url_rewrites: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsOriginRequestUrlRewriteArgs']]]] = None,
                 quic: Optional[pulumi.Input['DomainV1ConfigsQuicArgs']] = None,
                 range_based_retrieval_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 referer: Optional[pulumi.Input['DomainV1ConfigsRefererArgs']] = None,
                 remote_auth: Optional[pulumi.Input['DomainV1ConfigsRemoteAuthArgs']] = None,
                 request_limit_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestLimitRuleArgs']]]] = None,
                 request_url_rewrites: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestUrlRewriteArgs']]]] = None,
                 retrieval_request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRetrievalRequestHeaderArgs']]]] = None,
                 slice_etag_status: Optional[pulumi.Input[_builtins.str]] = None,
                 sni: Optional[pulumi.Input['DomainV1ConfigsSniArgs']] = None,
                 url_signing: Optional[pulumi.Input['DomainV1ConfigsUrlSigningArgs']] = None,
                 user_agent_filter: Optional[pulumi.Input['DomainV1ConfigsUserAgentFilterArgs']] = None,
                 video_seek: Optional[pulumi.Input['DomainV1ConfigsVideoSeekArgs']] = None,
                 websocket: Optional[pulumi.Input['DomainV1ConfigsWebsocketArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsAccessAreaFilterArgs']]] access_area_filters: Specifies the geographic access control rules.
        :param pulumi.Input['DomainV1ConfigsCacheUrlParameterFilterArgs'] cache_url_parameter_filter: schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        if access_area_filters is not None:
            pulumi.set(__self__, "access_area_filters", access_area_filters)
        if browser_cache_rules is not None:
            pulumi.set(__self__, "browser_cache_rules", browser_cache_rules)
        if cache_url_parameter_filter is not None:
            pulumi.set(__self__, "cache_url_parameter_filter", cache_url_parameter_filter)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if error_code_caches is not None:
            pulumi.set(__self__, "error_code_caches", error_code_caches)
        if error_code_redirect_rules is not None:
            pulumi.set(__self__, "error_code_redirect_rules", error_code_redirect_rules)
        if flexible_origins is not None:
            pulumi.set(__self__, "flexible_origins", flexible_origins)
        if force_redirect is not None:
            pulumi.set(__self__, "force_redirect", force_redirect)
        if hsts is not None:
            pulumi.set(__self__, "hsts", hsts)
        if http_response_headers is not None:
            pulumi.set(__self__, "http_response_headers", http_response_headers)
        if https_settings is not None:
            pulumi.set(__self__, "https_settings", https_settings)
        if ip_filter is not None:
            pulumi.set(__self__, "ip_filter", ip_filter)
        if ip_frequency_limit is not None:
            pulumi.set(__self__, "ip_frequency_limit", ip_frequency_limit)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if origin_follow302_status is not None:
            pulumi.set(__self__, "origin_follow302_status", origin_follow302_status)
        if origin_protocol is not None:
            pulumi.set(__self__, "origin_protocol", origin_protocol)
        if origin_receive_timeout is not None:
            pulumi.set(__self__, "origin_receive_timeout", origin_receive_timeout)
        if origin_request_url_rewrites is not None:
            pulumi.set(__self__, "origin_request_url_rewrites", origin_request_url_rewrites)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if range_based_retrieval_enabled is not None:
            pulumi.set(__self__, "range_based_retrieval_enabled", range_based_retrieval_enabled)
        if referer is not None:
            pulumi.set(__self__, "referer", referer)
        if remote_auth is not None:
            pulumi.set(__self__, "remote_auth", remote_auth)
        if request_limit_rules is not None:
            pulumi.set(__self__, "request_limit_rules", request_limit_rules)
        if request_url_rewrites is not None:
            pulumi.set(__self__, "request_url_rewrites", request_url_rewrites)
        if retrieval_request_headers is not None:
            pulumi.set(__self__, "retrieval_request_headers", retrieval_request_headers)
        if slice_etag_status is not None:
            pulumi.set(__self__, "slice_etag_status", slice_etag_status)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if url_signing is not None:
            pulumi.set(__self__, "url_signing", url_signing)
        if user_agent_filter is not None:
            pulumi.set(__self__, "user_agent_filter", user_agent_filter)
        if video_seek is not None:
            pulumi.set(__self__, "video_seek", video_seek)
        if websocket is not None:
            pulumi.set(__self__, "websocket", websocket)

    @_builtins.property
    @pulumi.getter(name="accessAreaFilters")
    def access_area_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsAccessAreaFilterArgs']]]]:
        """
        Specifies the geographic access control rules.
        """
        return pulumi.get(self, "access_area_filters")

    @access_area_filters.setter
    def access_area_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsAccessAreaFilterArgs']]]]):
        pulumi.set(self, "access_area_filters", value)

    @_builtins.property
    @pulumi.getter(name="browserCacheRules")
    def browser_cache_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsBrowserCacheRuleArgs']]]]:
        return pulumi.get(self, "browser_cache_rules")

    @browser_cache_rules.setter
    def browser_cache_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsBrowserCacheRuleArgs']]]]):
        pulumi.set(self, "browser_cache_rules", value)

    @_builtins.property
    @pulumi.getter(name="cacheUrlParameterFilter")
    def cache_url_parameter_filter(self) -> Optional[pulumi.Input['DomainV1ConfigsCacheUrlParameterFilterArgs']]:
        """
        schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        return pulumi.get(self, "cache_url_parameter_filter")

    @cache_url_parameter_filter.setter
    def cache_url_parameter_filter(self, value: Optional[pulumi.Input['DomainV1ConfigsCacheUrlParameterFilterArgs']]):
        pulumi.set(self, "cache_url_parameter_filter", value)

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input['DomainV1ConfigsClientCertArgs']]:
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input['DomainV1ConfigsClientCertArgs']]):
        pulumi.set(self, "client_cert", value)

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input['DomainV1ConfigsCompressArgs']]:
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input['DomainV1ConfigsCompressArgs']]):
        pulumi.set(self, "compress", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="errorCodeCaches")
    def error_code_caches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeCachArgs']]]]:
        return pulumi.get(self, "error_code_caches")

    @error_code_caches.setter
    def error_code_caches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeCachArgs']]]]):
        pulumi.set(self, "error_code_caches", value)

    @_builtins.property
    @pulumi.getter(name="errorCodeRedirectRules")
    def error_code_redirect_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeRedirectRuleArgs']]]]:
        return pulumi.get(self, "error_code_redirect_rules")

    @error_code_redirect_rules.setter
    def error_code_redirect_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsErrorCodeRedirectRuleArgs']]]]):
        pulumi.set(self, "error_code_redirect_rules", value)

    @_builtins.property
    @pulumi.getter(name="flexibleOrigins")
    def flexible_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsFlexibleOriginArgs']]]]:
        return pulumi.get(self, "flexible_origins")

    @flexible_origins.setter
    def flexible_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsFlexibleOriginArgs']]]]):
        pulumi.set(self, "flexible_origins", value)

    @_builtins.property
    @pulumi.getter(name="forceRedirect")
    def force_redirect(self) -> Optional[pulumi.Input['DomainV1ConfigsForceRedirectArgs']]:
        return pulumi.get(self, "force_redirect")

    @force_redirect.setter
    def force_redirect(self, value: Optional[pulumi.Input['DomainV1ConfigsForceRedirectArgs']]):
        pulumi.set(self, "force_redirect", value)

    @_builtins.property
    @pulumi.getter
    def hsts(self) -> Optional[pulumi.Input['DomainV1ConfigsHstsArgs']]:
        return pulumi.get(self, "hsts")

    @hsts.setter
    def hsts(self, value: Optional[pulumi.Input['DomainV1ConfigsHstsArgs']]):
        pulumi.set(self, "hsts", value)

    @_builtins.property
    @pulumi.getter(name="httpResponseHeaders")
    def http_response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsHttpResponseHeaderArgs']]]]:
        return pulumi.get(self, "http_response_headers")

    @http_response_headers.setter
    def http_response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsHttpResponseHeaderArgs']]]]):
        pulumi.set(self, "http_response_headers", value)

    @_builtins.property
    @pulumi.getter(name="httpsSettings")
    def https_settings(self) -> Optional[pulumi.Input['DomainV1ConfigsHttpsSettingsArgs']]:
        return pulumi.get(self, "https_settings")

    @https_settings.setter
    def https_settings(self, value: Optional[pulumi.Input['DomainV1ConfigsHttpsSettingsArgs']]):
        pulumi.set(self, "https_settings", value)

    @_builtins.property
    @pulumi.getter(name="ipFilter")
    def ip_filter(self) -> Optional[pulumi.Input['DomainV1ConfigsIpFilterArgs']]:
        return pulumi.get(self, "ip_filter")

    @ip_filter.setter
    def ip_filter(self, value: Optional[pulumi.Input['DomainV1ConfigsIpFilterArgs']]):
        pulumi.set(self, "ip_filter", value)

    @_builtins.property
    @pulumi.getter(name="ipFrequencyLimit")
    def ip_frequency_limit(self) -> Optional[pulumi.Input['DomainV1ConfigsIpFrequencyLimitArgs']]:
        return pulumi.get(self, "ip_frequency_limit")

    @ip_frequency_limit.setter
    def ip_frequency_limit(self, value: Optional[pulumi.Input['DomainV1ConfigsIpFrequencyLimitArgs']]):
        pulumi.set(self, "ip_frequency_limit", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @_builtins.property
    @pulumi.getter(name="originFollow302Status")
    def origin_follow302_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_follow302_status")

    @origin_follow302_status.setter
    def origin_follow302_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_follow302_status", value)

    @_builtins.property
    @pulumi.getter(name="originProtocol")
    def origin_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin_protocol")

    @origin_protocol.setter
    def origin_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin_protocol", value)

    @_builtins.property
    @pulumi.getter(name="originReceiveTimeout")
    def origin_receive_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "origin_receive_timeout")

    @origin_receive_timeout.setter
    def origin_receive_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "origin_receive_timeout", value)

    @_builtins.property
    @pulumi.getter(name="originRequestUrlRewrites")
    def origin_request_url_rewrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsOriginRequestUrlRewriteArgs']]]]:
        return pulumi.get(self, "origin_request_url_rewrites")

    @origin_request_url_rewrites.setter
    def origin_request_url_rewrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsOriginRequestUrlRewriteArgs']]]]):
        pulumi.set(self, "origin_request_url_rewrites", value)

    @_builtins.property
    @pulumi.getter
    def quic(self) -> Optional[pulumi.Input['DomainV1ConfigsQuicArgs']]:
        return pulumi.get(self, "quic")

    @quic.setter
    def quic(self, value: Optional[pulumi.Input['DomainV1ConfigsQuicArgs']]):
        pulumi.set(self, "quic", value)

    @_builtins.property
    @pulumi.getter(name="rangeBasedRetrievalEnabled")
    def range_based_retrieval_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "range_based_retrieval_enabled")

    @range_based_retrieval_enabled.setter
    def range_based_retrieval_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "range_based_retrieval_enabled", value)

    @_builtins.property
    @pulumi.getter
    def referer(self) -> Optional[pulumi.Input['DomainV1ConfigsRefererArgs']]:
        return pulumi.get(self, "referer")

    @referer.setter
    def referer(self, value: Optional[pulumi.Input['DomainV1ConfigsRefererArgs']]):
        pulumi.set(self, "referer", value)

    @_builtins.property
    @pulumi.getter(name="remoteAuth")
    def remote_auth(self) -> Optional[pulumi.Input['DomainV1ConfigsRemoteAuthArgs']]:
        return pulumi.get(self, "remote_auth")

    @remote_auth.setter
    def remote_auth(self, value: Optional[pulumi.Input['DomainV1ConfigsRemoteAuthArgs']]):
        pulumi.set(self, "remote_auth", value)

    @_builtins.property
    @pulumi.getter(name="requestLimitRules")
    def request_limit_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestLimitRuleArgs']]]]:
        return pulumi.get(self, "request_limit_rules")

    @request_limit_rules.setter
    def request_limit_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestLimitRuleArgs']]]]):
        pulumi.set(self, "request_limit_rules", value)

    @_builtins.property
    @pulumi.getter(name="requestUrlRewrites")
    def request_url_rewrites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestUrlRewriteArgs']]]]:
        return pulumi.get(self, "request_url_rewrites")

    @request_url_rewrites.setter
    def request_url_rewrites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRequestUrlRewriteArgs']]]]):
        pulumi.set(self, "request_url_rewrites", value)

    @_builtins.property
    @pulumi.getter(name="retrievalRequestHeaders")
    def retrieval_request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRetrievalRequestHeaderArgs']]]]:
        return pulumi.get(self, "retrieval_request_headers")

    @retrieval_request_headers.setter
    def retrieval_request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRetrievalRequestHeaderArgs']]]]):
        pulumi.set(self, "retrieval_request_headers", value)

    @_builtins.property
    @pulumi.getter(name="sliceEtagStatus")
    def slice_etag_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "slice_etag_status")

    @slice_etag_status.setter
    def slice_etag_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slice_etag_status", value)

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input['DomainV1ConfigsSniArgs']]:
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input['DomainV1ConfigsSniArgs']]):
        pulumi.set(self, "sni", value)

    @_builtins.property
    @pulumi.getter(name="urlSigning")
    def url_signing(self) -> Optional[pulumi.Input['DomainV1ConfigsUrlSigningArgs']]:
        return pulumi.get(self, "url_signing")

    @url_signing.setter
    def url_signing(self, value: Optional[pulumi.Input['DomainV1ConfigsUrlSigningArgs']]):
        pulumi.set(self, "url_signing", value)

    @_builtins.property
    @pulumi.getter(name="userAgentFilter")
    def user_agent_filter(self) -> Optional[pulumi.Input['DomainV1ConfigsUserAgentFilterArgs']]:
        return pulumi.get(self, "user_agent_filter")

    @user_agent_filter.setter
    def user_agent_filter(self, value: Optional[pulumi.Input['DomainV1ConfigsUserAgentFilterArgs']]):
        pulumi.set(self, "user_agent_filter", value)

    @_builtins.property
    @pulumi.getter(name="videoSeek")
    def video_seek(self) -> Optional[pulumi.Input['DomainV1ConfigsVideoSeekArgs']]:
        return pulumi.get(self, "video_seek")

    @video_seek.setter
    def video_seek(self, value: Optional[pulumi.Input['DomainV1ConfigsVideoSeekArgs']]):
        pulumi.set(self, "video_seek", value)

    @_builtins.property
    @pulumi.getter
    def websocket(self) -> Optional[pulumi.Input['DomainV1ConfigsWebsocketArgs']]:
        return pulumi.get(self, "websocket")

    @websocket.setter
    def websocket(self, value: Optional[pulumi.Input['DomainV1ConfigsWebsocketArgs']]):
        pulumi.set(self, "websocket", value)


if not MYPY:
    class DomainV1ConfigsAccessAreaFilterArgsDict(TypedDict):
        area: pulumi.Input[_builtins.str]
        """
        Specifies the areas, separated by commas.
        """
        content_type: pulumi.Input[_builtins.str]
        """
        Specifies the content type.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the blacklist and whitelist rule type.
        """
        content_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the content value.
        """
        exception_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP addresses exception in access control, separated by commas.
        """
elif False:
    DomainV1ConfigsAccessAreaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsAccessAreaFilterArgs:
    def __init__(__self__, *,
                 area: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 content_value: Optional[pulumi.Input[_builtins.str]] = None,
                 exception_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] area: Specifies the areas, separated by commas.
        :param pulumi.Input[_builtins.str] content_type: Specifies the content type.
        :param pulumi.Input[_builtins.str] type: Specifies the blacklist and whitelist rule type.
        :param pulumi.Input[_builtins.str] content_value: Specifies the content value.
        :param pulumi.Input[_builtins.str] exception_ip: Specifies the IP addresses exception in access control, separated by commas.
        """
        pulumi.set(__self__, "area", area)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "type", type)
        if content_value is not None:
            pulumi.set(__self__, "content_value", content_value)
        if exception_ip is not None:
            pulumi.set(__self__, "exception_ip", exception_ip)

    @_builtins.property
    @pulumi.getter
    def area(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the areas, separated by commas.
        """
        return pulumi.get(self, "area")

    @area.setter
    def area(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "area", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the content type.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="contentValue")
    def content_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the content value.
        """
        return pulumi.get(self, "content_value")

    @content_value.setter
    def content_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_value", value)

    @_builtins.property
    @pulumi.getter(name="exceptionIp")
    def exception_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP addresses exception in access control, separated by commas.
        """
        return pulumi.get(self, "exception_ip")

    @exception_ip.setter
    def exception_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exception_ip", value)


if not MYPY:
    class DomainV1ConfigsBrowserCacheRuleArgsDict(TypedDict):
        cache_type: pulumi.Input[_builtins.str]
        condition: pulumi.Input['DomainV1ConfigsBrowserCacheRuleConditionArgsDict']
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        ttl_unit: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsBrowserCacheRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsBrowserCacheRuleArgs:
    def __init__(__self__, *,
                 cache_type: pulumi.Input[_builtins.str],
                 condition: pulumi.Input['DomainV1ConfigsBrowserCacheRuleConditionArgs'],
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl_unit: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "cache_type", cache_type)
        pulumi.set(__self__, "condition", condition)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_unit is not None:
            pulumi.set(__self__, "ttl_unit", ttl_unit)

    @_builtins.property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cache_type")

    @cache_type.setter
    def cache_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cache_type", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['DomainV1ConfigsBrowserCacheRuleConditionArgs']:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['DomainV1ConfigsBrowserCacheRuleConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="ttlUnit")
    def ttl_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ttl_unit")

    @ttl_unit.setter
    def ttl_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl_unit", value)


if not MYPY:
    class DomainV1ConfigsBrowserCacheRuleConditionArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        priority: pulumi.Input[_builtins.int]
        match_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsBrowserCacheRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsBrowserCacheRuleConditionArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 match_value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_value", value)


if not MYPY:
    class DomainV1ConfigsCacheUrlParameterFilterArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsCacheUrlParameterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsCacheUrlParameterFilterArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainV1ConfigsClientCertArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        hosts: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        trusted_cert: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsClientCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsClientCertArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 hosts: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 trusted_cert: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trusted_cert is not None:
            pulumi.set(__self__, "trusted_cert", trusted_cert)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="trustedCert")
    def trusted_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trusted_cert")

    @trusted_cert.setter
    def trusted_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trusted_cert", value)


if not MYPY:
    class DomainV1ConfigsCompressArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        file_type: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsCompressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsCompressArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 file_type: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "file_type")

    @file_type.setter
    def file_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainV1ConfigsErrorCodeCachArgsDict(TypedDict):
        code: pulumi.Input[_builtins.int]
        ttl: pulumi.Input[_builtins.int]
elif False:
    DomainV1ConfigsErrorCodeCachArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsErrorCodeCachArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.int],
                 ttl: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class DomainV1ConfigsErrorCodeRedirectRuleArgsDict(TypedDict):
        error_code: pulumi.Input[_builtins.int]
        target_code: pulumi.Input[_builtins.int]
        target_link: pulumi.Input[_builtins.str]
elif False:
    DomainV1ConfigsErrorCodeRedirectRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsErrorCodeRedirectRuleArgs:
    def __init__(__self__, *,
                 error_code: pulumi.Input[_builtins.int],
                 target_code: pulumi.Input[_builtins.int],
                 target_link: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "target_code", target_code)
        pulumi.set(__self__, "target_link", target_link)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="targetCode")
    def target_code(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "target_code")

    @target_code.setter
    def target_code(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_code", value)

    @_builtins.property
    @pulumi.getter(name="targetLink")
    def target_link(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_link")

    @target_link.setter
    def target_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_link", value)


if not MYPY:
    class DomainV1ConfigsFlexibleOriginArgsDict(TypedDict):
        back_sources: pulumi.Input['DomainV1ConfigsFlexibleOriginBackSourcesArgsDict']
        match_type: pulumi.Input[_builtins.str]
        priority: pulumi.Input[_builtins.int]
        match_pattern: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsFlexibleOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsFlexibleOriginArgs:
    def __init__(__self__, *,
                 back_sources: pulumi.Input['DomainV1ConfigsFlexibleOriginBackSourcesArgs'],
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 match_pattern: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "back_sources", back_sources)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_pattern is not None:
            pulumi.set(__self__, "match_pattern", match_pattern)

    @_builtins.property
    @pulumi.getter(name="backSources")
    def back_sources(self) -> pulumi.Input['DomainV1ConfigsFlexibleOriginBackSourcesArgs']:
        return pulumi.get(self, "back_sources")

    @back_sources.setter
    def back_sources(self, value: pulumi.Input['DomainV1ConfigsFlexibleOriginBackSourcesArgs']):
        pulumi.set(self, "back_sources", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_pattern")

    @match_pattern.setter
    def match_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_pattern", value)


if not MYPY:
    class DomainV1ConfigsFlexibleOriginBackSourcesArgsDict(TypedDict):
        ip_or_domain: pulumi.Input[_builtins.str]
        sources_type: pulumi.Input[_builtins.str]
        http_port: NotRequired[pulumi.Input[_builtins.int]]
        https_port: NotRequired[pulumi.Input[_builtins.int]]
        obs_bucket_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsFlexibleOriginBackSourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsFlexibleOriginBackSourcesArgs:
    def __init__(__self__, *,
                 ip_or_domain: pulumi.Input[_builtins.str],
                 sources_type: pulumi.Input[_builtins.str],
                 http_port: Optional[pulumi.Input[_builtins.int]] = None,
                 https_port: Optional[pulumi.Input[_builtins.int]] = None,
                 obs_bucket_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "ip_or_domain", ip_or_domain)
        pulumi.set(__self__, "sources_type", sources_type)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)

    @_builtins.property
    @pulumi.getter(name="ipOrDomain")
    def ip_or_domain(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ip_or_domain")

    @ip_or_domain.setter
    def ip_or_domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_or_domain", value)

    @_builtins.property
    @pulumi.getter(name="sourcesType")
    def sources_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sources_type")

    @sources_type.setter
    def sources_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sources_type", value)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "obs_bucket_type")

    @obs_bucket_type.setter
    def obs_bucket_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_bucket_type", value)


if not MYPY:
    class DomainV1ConfigsForceRedirectArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        redirect_code: NotRequired[pulumi.Input[_builtins.int]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Required
        """
elif False:
    DomainV1ConfigsForceRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsForceRedirectArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 redirect_code: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: schema: Required
        """
        pulumi.set(__self__, "enabled", enabled)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "redirect_code")

    @redirect_code.setter
    def redirect_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redirect_code", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Required
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainV1ConfigsHstsArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        include_subdomains: NotRequired[pulumi.Input[_builtins.str]]
        max_age: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DomainV1ConfigsHstsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsHstsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 include_subdomains: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "include_subdomains")

    @include_subdomains.setter
    def include_subdomains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_subdomains", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class DomainV1ConfigsHttpResponseHeaderArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsHttpResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsHttpResponseHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainV1ConfigsHttpsSettingsArgsDict(TypedDict):
        certificate_body: NotRequired[pulumi.Input[_builtins.str]]
        certificate_name: NotRequired[pulumi.Input[_builtins.str]]
        certificate_source: NotRequired[pulumi.Input[_builtins.int]]
        certificate_type: NotRequired[pulumi.Input[_builtins.str]]
        http2_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        http2_status: NotRequired[pulumi.Input[_builtins.str]]
        https_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        https_status: NotRequired[pulumi.Input[_builtins.str]]
        ocsp_stapling_status: NotRequired[pulumi.Input[_builtins.str]]
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        scm_certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        tls_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsHttpsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsHttpsSettingsArgs:
    def __init__(__self__, *,
                 certificate_body: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_source: Optional[pulumi.Input[_builtins.int]] = None,
                 certificate_type: Optional[pulumi.Input[_builtins.str]] = None,
                 http2_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 http2_status: Optional[pulumi.Input[_builtins.str]] = None,
                 https_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 https_status: Optional[pulumi.Input[_builtins.str]] = None,
                 ocsp_stapling_status: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 scm_certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_version: Optional[pulumi.Input[_builtins.str]] = None):
        if certificate_body is not None:
            pulumi.set(__self__, "certificate_body", certificate_body)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if http2_status is not None:
            pulumi.set(__self__, "http2_status", http2_status)
        if https_enabled is not None:
            pulumi.set(__self__, "https_enabled", https_enabled)
        if https_status is not None:
            pulumi.set(__self__, "https_status", https_status)
        if ocsp_stapling_status is not None:
            pulumi.set(__self__, "ocsp_stapling_status", ocsp_stapling_status)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if scm_certificate_id is not None:
            pulumi.set(__self__, "scm_certificate_id", scm_certificate_id)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @_builtins.property
    @pulumi.getter(name="certificateBody")
    def certificate_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_body")

    @certificate_body.setter
    def certificate_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_body", value)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "certificate_source")

    @certificate_source.setter
    def certificate_source(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "certificate_source", value)

    @_builtins.property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_type", value)

    @_builtins.property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "http2_enabled")

    @http2_enabled.setter
    def http2_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_enabled", value)

    @_builtins.property
    @pulumi.getter(name="http2Status")
    def http2_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "http2_status")

    @http2_status.setter
    def http2_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http2_status", value)

    @_builtins.property
    @pulumi.getter(name="httpsEnabled")
    def https_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "https_enabled")

    @https_enabled.setter
    def https_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "https_enabled", value)

    @_builtins.property
    @pulumi.getter(name="httpsStatus")
    def https_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "https_status")

    @https_status.setter
    def https_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "https_status", value)

    @_builtins.property
    @pulumi.getter(name="ocspStaplingStatus")
    def ocsp_stapling_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ocsp_stapling_status")

    @ocsp_stapling_status.setter
    def ocsp_stapling_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ocsp_stapling_status", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="scmCertificateId")
    def scm_certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scm_certificate_id")

    @scm_certificate_id.setter
    def scm_certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scm_certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tls_version")

    @tls_version.setter
    def tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_version", value)


if not MYPY:
    class DomainV1ConfigsIpFilterArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsIpFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsIpFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainV1ConfigsIpFrequencyLimitArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        qps: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DomainV1ConfigsIpFrequencyLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsIpFrequencyLimitArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 qps: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "qps", value)


if not MYPY:
    class DomainV1ConfigsOriginRequestUrlRewriteArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        priority: pulumi.Input[_builtins.int]
        target_url: pulumi.Input[_builtins.str]
        source_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsOriginRequestUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsOriginRequestUrlRewriteArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 target_url: pulumi.Input[_builtins.str],
                 source_url: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "target_url", target_url)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_url")

    @target_url.setter
    def target_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_url", value)

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_url", value)


if not MYPY:
    class DomainV1ConfigsQuicArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
elif False:
    DomainV1ConfigsQuicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsQuicArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class DomainV1ConfigsRefererArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        include_empty: NotRequired[pulumi.Input[_builtins.bool]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsRefererArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRefererArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 include_empty: Optional[pulumi.Input[_builtins.bool]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "include_empty")

    @include_empty.setter
    def include_empty(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_empty", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainV1ConfigsRemoteAuthArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        remote_auth_rules: NotRequired[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesArgsDict']]
elif False:
    DomainV1ConfigsRemoteAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRemoteAuthArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 remote_auth_rules: Optional[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if remote_auth_rules is not None:
            pulumi.set(__self__, "remote_auth_rules", remote_auth_rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="remoteAuthRules")
    def remote_auth_rules(self) -> Optional[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesArgs']]:
        return pulumi.get(self, "remote_auth_rules")

    @remote_auth_rules.setter
    def remote_auth_rules(self, value: Optional[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesArgs']]):
        pulumi.set(self, "remote_auth_rules", value)


if not MYPY:
    class DomainV1ConfigsRemoteAuthRemoteAuthRulesArgsDict(TypedDict):
        auth_failed_status: pulumi.Input[_builtins.str]
        auth_server: pulumi.Input[_builtins.str]
        auth_success_status: pulumi.Input[_builtins.str]
        file_type_setting: pulumi.Input[_builtins.str]
        request_method: pulumi.Input[_builtins.str]
        reserve_args_setting: pulumi.Input[_builtins.str]
        reserve_headers_setting: pulumi.Input[_builtins.str]
        response_status: pulumi.Input[_builtins.str]
        timeout: pulumi.Input[_builtins.int]
        timeout_action: pulumi.Input[_builtins.str]
        add_custom_args_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict']]]]
        add_custom_headers_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict']]]]
        reserve_args: NotRequired[pulumi.Input[_builtins.str]]
        reserve_headers: NotRequired[pulumi.Input[_builtins.str]]
        specified_file_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsRemoteAuthRemoteAuthRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRemoteAuthRemoteAuthRulesArgs:
    def __init__(__self__, *,
                 auth_failed_status: pulumi.Input[_builtins.str],
                 auth_server: pulumi.Input[_builtins.str],
                 auth_success_status: pulumi.Input[_builtins.str],
                 file_type_setting: pulumi.Input[_builtins.str],
                 request_method: pulumi.Input[_builtins.str],
                 reserve_args_setting: pulumi.Input[_builtins.str],
                 reserve_headers_setting: pulumi.Input[_builtins.str],
                 response_status: pulumi.Input[_builtins.str],
                 timeout: pulumi.Input[_builtins.int],
                 timeout_action: pulumi.Input[_builtins.str],
                 add_custom_args_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs']]]] = None,
                 add_custom_headers_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs']]]] = None,
                 reserve_args: Optional[pulumi.Input[_builtins.str]] = None,
                 reserve_headers: Optional[pulumi.Input[_builtins.str]] = None,
                 specified_file_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "auth_failed_status", auth_failed_status)
        pulumi.set(__self__, "auth_server", auth_server)
        pulumi.set(__self__, "auth_success_status", auth_success_status)
        pulumi.set(__self__, "file_type_setting", file_type_setting)
        pulumi.set(__self__, "request_method", request_method)
        pulumi.set(__self__, "reserve_args_setting", reserve_args_setting)
        pulumi.set(__self__, "reserve_headers_setting", reserve_headers_setting)
        pulumi.set(__self__, "response_status", response_status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "timeout_action", timeout_action)
        if add_custom_args_rules is not None:
            pulumi.set(__self__, "add_custom_args_rules", add_custom_args_rules)
        if add_custom_headers_rules is not None:
            pulumi.set(__self__, "add_custom_headers_rules", add_custom_headers_rules)
        if reserve_args is not None:
            pulumi.set(__self__, "reserve_args", reserve_args)
        if reserve_headers is not None:
            pulumi.set(__self__, "reserve_headers", reserve_headers)
        if specified_file_type is not None:
            pulumi.set(__self__, "specified_file_type", specified_file_type)

    @_builtins.property
    @pulumi.getter(name="authFailedStatus")
    def auth_failed_status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "auth_failed_status")

    @auth_failed_status.setter
    def auth_failed_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_failed_status", value)

    @_builtins.property
    @pulumi.getter(name="authServer")
    def auth_server(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "auth_server")

    @auth_server.setter
    def auth_server(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_server", value)

    @_builtins.property
    @pulumi.getter(name="authSuccessStatus")
    def auth_success_status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "auth_success_status")

    @auth_success_status.setter
    def auth_success_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_success_status", value)

    @_builtins.property
    @pulumi.getter(name="fileTypeSetting")
    def file_type_setting(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "file_type_setting")

    @file_type_setting.setter
    def file_type_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_type_setting", value)

    @_builtins.property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_method", value)

    @_builtins.property
    @pulumi.getter(name="reserveArgsSetting")
    def reserve_args_setting(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "reserve_args_setting")

    @reserve_args_setting.setter
    def reserve_args_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reserve_args_setting", value)

    @_builtins.property
    @pulumi.getter(name="reserveHeadersSetting")
    def reserve_headers_setting(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "reserve_headers_setting")

    @reserve_headers_setting.setter
    def reserve_headers_setting(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reserve_headers_setting", value)

    @_builtins.property
    @pulumi.getter(name="responseStatus")
    def response_status(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "response_status")

    @response_status.setter
    def response_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "response_status", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "timeout_action")

    @timeout_action.setter
    def timeout_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "timeout_action", value)

    @_builtins.property
    @pulumi.getter(name="addCustomArgsRules")
    def add_custom_args_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs']]]]:
        return pulumi.get(self, "add_custom_args_rules")

    @add_custom_args_rules.setter
    def add_custom_args_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs']]]]):
        pulumi.set(self, "add_custom_args_rules", value)

    @_builtins.property
    @pulumi.getter(name="addCustomHeadersRules")
    def add_custom_headers_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs']]]]:
        return pulumi.get(self, "add_custom_headers_rules")

    @add_custom_headers_rules.setter
    def add_custom_headers_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs']]]]):
        pulumi.set(self, "add_custom_headers_rules", value)

    @_builtins.property
    @pulumi.getter(name="reserveArgs")
    def reserve_args(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reserve_args")

    @reserve_args.setter
    def reserve_args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reserve_args", value)

    @_builtins.property
    @pulumi.getter(name="reserveHeaders")
    def reserve_headers(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reserve_headers")

    @reserve_headers.setter
    def reserve_headers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reserve_headers", value)

    @_builtins.property
    @pulumi.getter(name="specifiedFileType")
    def specified_file_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "specified_file_type")

    @specified_file_type.setter
    def specified_file_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "specified_file_type", value)


if not MYPY:
    class DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainV1ConfigsRequestLimitRuleArgsDict(TypedDict):
        limit_rate_after: pulumi.Input[_builtins.int]
        limit_rate_value: pulumi.Input[_builtins.int]
        match_type: pulumi.Input[_builtins.str]
        priority: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        match_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsRequestLimitRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRequestLimitRuleArgs:
    def __init__(__self__, *,
                 limit_rate_after: pulumi.Input[_builtins.int],
                 limit_rate_value: pulumi.Input[_builtins.int],
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 match_value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "limit_rate_after", limit_rate_after)
        pulumi.set(__self__, "limit_rate_value", limit_rate_value)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="limitRateAfter")
    def limit_rate_after(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "limit_rate_after")

    @limit_rate_after.setter
    def limit_rate_after(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit_rate_after", value)

    @_builtins.property
    @pulumi.getter(name="limitRateValue")
    def limit_rate_value(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "limit_rate_value")

    @limit_rate_value.setter
    def limit_rate_value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "limit_rate_value", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_value", value)


if not MYPY:
    class DomainV1ConfigsRequestUrlRewriteArgsDict(TypedDict):
        condition: pulumi.Input['DomainV1ConfigsRequestUrlRewriteConditionArgsDict']
        execution_mode: pulumi.Input[_builtins.str]
        redirect_url: pulumi.Input[_builtins.str]
        redirect_host: NotRequired[pulumi.Input[_builtins.str]]
        redirect_status_code: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DomainV1ConfigsRequestUrlRewriteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRequestUrlRewriteArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['DomainV1ConfigsRequestUrlRewriteConditionArgs'],
                 execution_mode: pulumi.Input[_builtins.str],
                 redirect_url: pulumi.Input[_builtins.str],
                 redirect_host: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_status_code: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "execution_mode", execution_mode)
        pulumi.set(__self__, "redirect_url", redirect_url)
        if redirect_host is not None:
            pulumi.set(__self__, "redirect_host", redirect_host)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['DomainV1ConfigsRequestUrlRewriteConditionArgs']:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['DomainV1ConfigsRequestUrlRewriteConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="executionMode")
    def execution_mode(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "execution_mode")

    @execution_mode.setter
    def execution_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "execution_mode", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter(name="redirectHost")
    def redirect_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "redirect_host")

    @redirect_host.setter
    def redirect_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_host", value)

    @_builtins.property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "redirect_status_code")

    @redirect_status_code.setter
    def redirect_status_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redirect_status_code", value)


if not MYPY:
    class DomainV1ConfigsRequestUrlRewriteConditionArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        priority: pulumi.Input[_builtins.int]
        match_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsRequestUrlRewriteConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRequestUrlRewriteConditionArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 match_value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_value", value)


if not MYPY:
    class DomainV1ConfigsRetrievalRequestHeaderArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsRetrievalRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsRetrievalRequestHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainV1ConfigsSniArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        server_name: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsSniArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsSniArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 server_name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DomainV1ConfigsUrlSigningArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        backup_key: NotRequired[pulumi.Input[_builtins.str]]
        expire_time: NotRequired[pulumi.Input[_builtins.int]]
        inherit_config: NotRequired[pulumi.Input['DomainV1ConfigsUrlSigningInheritConfigArgsDict']]
        key: NotRequired[pulumi.Input[_builtins.str]]
        match_type: NotRequired[pulumi.Input[_builtins.str]]
        sign_arg: NotRequired[pulumi.Input[_builtins.str]]
        sign_method: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        time_format: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsUrlSigningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsUrlSigningArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 backup_key: Optional[pulumi.Input[_builtins.str]] = None,
                 expire_time: Optional[pulumi.Input[_builtins.int]] = None,
                 inherit_config: Optional[pulumi.Input['DomainV1ConfigsUrlSigningInheritConfigArgs']] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_arg: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_method: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 time_format: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if backup_key is not None:
            pulumi.set(__self__, "backup_key", backup_key)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if inherit_config is not None:
            pulumi.set(__self__, "inherit_config", inherit_config)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if sign_arg is not None:
            pulumi.set(__self__, "sign_arg", sign_arg)
        if sign_method is not None:
            pulumi.set(__self__, "sign_method", sign_method)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="backupKey")
    def backup_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "backup_key")

    @backup_key.setter
    def backup_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_key", value)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "expire_time")

    @expire_time.setter
    def expire_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expire_time", value)

    @_builtins.property
    @pulumi.getter(name="inheritConfig")
    def inherit_config(self) -> Optional[pulumi.Input['DomainV1ConfigsUrlSigningInheritConfigArgs']]:
        return pulumi.get(self, "inherit_config")

    @inherit_config.setter
    def inherit_config(self, value: Optional[pulumi.Input['DomainV1ConfigsUrlSigningInheritConfigArgs']]):
        pulumi.set(self, "inherit_config", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="signArg")
    def sign_arg(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sign_arg")

    @sign_arg.setter
    def sign_arg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_arg", value)

    @_builtins.property
    @pulumi.getter(name="signMethod")
    def sign_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sign_method")

    @sign_method.setter
    def sign_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_method", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_format", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DomainV1ConfigsUrlSigningInheritConfigArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        inherit_time_type: NotRequired[pulumi.Input[_builtins.str]]
        inherit_type: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsUrlSigningInheritConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsUrlSigningInheritConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 inherit_time_type: Optional[pulumi.Input[_builtins.str]] = None,
                 inherit_type: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if inherit_time_type is not None:
            pulumi.set(__self__, "inherit_time_type", inherit_time_type)
        if inherit_type is not None:
            pulumi.set(__self__, "inherit_type", inherit_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="inheritTimeType")
    def inherit_time_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "inherit_time_type")

    @inherit_time_type.setter
    def inherit_time_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inherit_time_type", value)

    @_builtins.property
    @pulumi.getter(name="inheritType")
    def inherit_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "inherit_type")

    @inherit_type.setter
    def inherit_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inherit_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DomainV1ConfigsUserAgentFilterArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        include_empty: NotRequired[pulumi.Input[_builtins.str]]
        ua_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DomainV1ConfigsUserAgentFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsUserAgentFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 include_empty: Optional[pulumi.Input[_builtins.str]] = None,
                 ua_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if ua_lists is not None:
            pulumi.set(__self__, "ua_lists", ua_lists)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "include_empty")

    @include_empty.setter
    def include_empty(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_empty", value)

    @_builtins.property
    @pulumi.getter(name="uaLists")
    def ua_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ua_lists")

    @ua_lists.setter
    def ua_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ua_lists", value)


if not MYPY:
    class DomainV1ConfigsVideoSeekArgsDict(TypedDict):
        enable_video_seek: pulumi.Input[_builtins.bool]
        enable_flv_by_time_seek: NotRequired[pulumi.Input[_builtins.bool]]
        end_parameter: NotRequired[pulumi.Input[_builtins.str]]
        start_parameter: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainV1ConfigsVideoSeekArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsVideoSeekArgs:
    def __init__(__self__, *,
                 enable_video_seek: pulumi.Input[_builtins.bool],
                 enable_flv_by_time_seek: Optional[pulumi.Input[_builtins.bool]] = None,
                 end_parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 start_parameter: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "enable_video_seek", enable_video_seek)
        if enable_flv_by_time_seek is not None:
            pulumi.set(__self__, "enable_flv_by_time_seek", enable_flv_by_time_seek)
        if end_parameter is not None:
            pulumi.set(__self__, "end_parameter", end_parameter)
        if start_parameter is not None:
            pulumi.set(__self__, "start_parameter", start_parameter)

    @_builtins.property
    @pulumi.getter(name="enableVideoSeek")
    def enable_video_seek(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enable_video_seek")

    @enable_video_seek.setter
    def enable_video_seek(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_video_seek", value)

    @_builtins.property
    @pulumi.getter(name="enableFlvByTimeSeek")
    def enable_flv_by_time_seek(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enable_flv_by_time_seek")

    @enable_flv_by_time_seek.setter
    def enable_flv_by_time_seek(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_flv_by_time_seek", value)

    @_builtins.property
    @pulumi.getter(name="endParameter")
    def end_parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "end_parameter")

    @end_parameter.setter
    def end_parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_parameter", value)

    @_builtins.property
    @pulumi.getter(name="startParameter")
    def start_parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "start_parameter")

    @start_parameter.setter
    def start_parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_parameter", value)


if not MYPY:
    class DomainV1ConfigsWebsocketArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DomainV1ConfigsWebsocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1ConfigsWebsocketArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class DomainV1SourceArgsDict(TypedDict):
        origin: pulumi.Input[_builtins.str]
        origin_type: pulumi.Input[_builtins.str]
        active: NotRequired[pulumi.Input[_builtins.int]]
        bucket_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage access key.
        """
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage bucket name.
        """
        bucket_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage bucket region.
        """
        bucket_secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Third-party object storage secret key.
        """
        http_port: NotRequired[pulumi.Input[_builtins.int]]
        https_port: NotRequired[pulumi.Input[_builtins.int]]
        obs_bucket_type: NotRequired[pulumi.Input[_builtins.str]]
        obs_web_hosting_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        retrieval_host: NotRequired[pulumi.Input[_builtins.str]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DomainV1SourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainV1SourceArgs:
    def __init__(__self__, *,
                 origin: pulumi.Input[_builtins.str],
                 origin_type: pulumi.Input[_builtins.str],
                 active: Optional[pulumi.Input[_builtins.int]] = None,
                 bucket_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_region: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 http_port: Optional[pulumi.Input[_builtins.int]] = None,
                 https_port: Optional[pulumi.Input[_builtins.int]] = None,
                 obs_bucket_type: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_web_hosting_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 retrieval_host: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_access_key: Third-party object storage access key.
        :param pulumi.Input[_builtins.str] bucket_name: Third-party object storage bucket name.
        :param pulumi.Input[_builtins.str] bucket_region: Third-party object storage bucket region.
        :param pulumi.Input[_builtins.str] bucket_secret_key: Third-party object storage secret key.
        """
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "origin_type", origin_type)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if bucket_access_key is not None:
            pulumi.set(__self__, "bucket_access_key", bucket_access_key)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)
        if bucket_secret_key is not None:
            pulumi.set(__self__, "bucket_secret_key", bucket_secret_key)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)
        if obs_web_hosting_enabled is not None:
            pulumi.set(__self__, "obs_web_hosting_enabled", obs_web_hosting_enabled)
        if retrieval_host is not None:
            pulumi.set(__self__, "retrieval_host", retrieval_host)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter(name="originType")
    def origin_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "origin_type")

    @origin_type.setter
    def origin_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "origin_type", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="bucketAccessKey")
    def bucket_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage access key.
        """
        return pulumi.get(self, "bucket_access_key")

    @bucket_access_key.setter
    def bucket_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage bucket region.
        """
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_region", value)

    @_builtins.property
    @pulumi.getter(name="bucketSecretKey")
    def bucket_secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Third-party object storage secret key.
        """
        return pulumi.get(self, "bucket_secret_key")

    @bucket_secret_key.setter
    def bucket_secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_secret_key", value)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "https_port", value)

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "obs_bucket_type")

    @obs_bucket_type.setter
    def obs_bucket_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_bucket_type", value)

    @_builtins.property
    @pulumi.getter(name="obsWebHostingEnabled")
    def obs_web_hosting_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "obs_web_hosting_enabled")

    @obs_web_hosting_enabled.setter
    def obs_web_hosting_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "obs_web_hosting_enabled", value)

    @_builtins.property
    @pulumi.getter(name="retrievalHost")
    def retrieval_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "retrieval_host")

    @retrieval_host.setter
    def retrieval_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retrieval_host", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


