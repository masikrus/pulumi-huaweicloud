# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'DomainCacheSettings',
    'DomainCacheSettingsRule',
    'DomainConfigs',
    'DomainConfigsAccessAreaFilter',
    'DomainConfigsBrowserCacheRule',
    'DomainConfigsBrowserCacheRuleCondition',
    'DomainConfigsCacheUrlParameterFilter',
    'DomainConfigsClientCert',
    'DomainConfigsCompress',
    'DomainConfigsErrorCodeCach',
    'DomainConfigsErrorCodeRedirectRule',
    'DomainConfigsFlexibleOrigin',
    'DomainConfigsFlexibleOriginBackSources',
    'DomainConfigsForceRedirect',
    'DomainConfigsHsts',
    'DomainConfigsHttpResponseHeader',
    'DomainConfigsHttpsSettings',
    'DomainConfigsIpFilter',
    'DomainConfigsIpFrequencyLimit',
    'DomainConfigsOriginRequestUrlRewrite',
    'DomainConfigsQuic',
    'DomainConfigsReferer',
    'DomainConfigsRemoteAuth',
    'DomainConfigsRemoteAuthRemoteAuthRules',
    'DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule',
    'DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule',
    'DomainConfigsRequestLimitRule',
    'DomainConfigsRequestUrlRewrite',
    'DomainConfigsRequestUrlRewriteCondition',
    'DomainConfigsRetrievalRequestHeader',
    'DomainConfigsSni',
    'DomainConfigsUrlSigning',
    'DomainConfigsUrlSigningInheritConfig',
    'DomainConfigsUserAgentFilter',
    'DomainConfigsVideoSeek',
    'DomainConfigsWebsocket',
    'DomainRuleRule',
    'DomainRuleRuleAction',
    'DomainRuleRuleActionAccessControl',
    'DomainRuleRuleActionCacheRule',
    'DomainRuleRuleActionFlexibleOrigin',
    'DomainRuleRuleActionHttpResponseHeader',
    'DomainRuleRuleActionOriginRequestHeader',
    'DomainRuleRuleActionOriginRequestUrlRewrite',
    'DomainRuleRuleActionRequestUrlRewrite',
    'DomainRuleRuleConditions',
    'DomainRuleRuleConditionsMatch',
    'DomainSource',
    'DomainV1CacheSettings',
    'DomainV1CacheSettingsRule',
    'DomainV1Configs',
    'DomainV1ConfigsAccessAreaFilter',
    'DomainV1ConfigsBrowserCacheRule',
    'DomainV1ConfigsBrowserCacheRuleCondition',
    'DomainV1ConfigsCacheUrlParameterFilter',
    'DomainV1ConfigsClientCert',
    'DomainV1ConfigsCompress',
    'DomainV1ConfigsErrorCodeCach',
    'DomainV1ConfigsErrorCodeRedirectRule',
    'DomainV1ConfigsFlexibleOrigin',
    'DomainV1ConfigsFlexibleOriginBackSources',
    'DomainV1ConfigsForceRedirect',
    'DomainV1ConfigsHsts',
    'DomainV1ConfigsHttpResponseHeader',
    'DomainV1ConfigsHttpsSettings',
    'DomainV1ConfigsIpFilter',
    'DomainV1ConfigsIpFrequencyLimit',
    'DomainV1ConfigsOriginRequestUrlRewrite',
    'DomainV1ConfigsQuic',
    'DomainV1ConfigsReferer',
    'DomainV1ConfigsRemoteAuth',
    'DomainV1ConfigsRemoteAuthRemoteAuthRules',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule',
    'DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule',
    'DomainV1ConfigsRequestLimitRule',
    'DomainV1ConfigsRequestUrlRewrite',
    'DomainV1ConfigsRequestUrlRewriteCondition',
    'DomainV1ConfigsRetrievalRequestHeader',
    'DomainV1ConfigsSni',
    'DomainV1ConfigsUrlSigning',
    'DomainV1ConfigsUrlSigningInheritConfig',
    'DomainV1ConfigsUserAgentFilter',
    'DomainV1ConfigsVideoSeek',
    'DomainV1ConfigsWebsocket',
    'DomainV1Source',
    'GetCacheHistoryTasksTaskResult',
    'GetCacheUrlTasksTaskResult',
    'GetDomainCertificatesDomainCertificateResult',
    'GetDomainsDomainResult',
    'GetDomainsDomainSourceResult',
    'GetLogsLogResult',
]

@pulumi.output_type
class DomainCacheSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "followOrigin":
            suggest = "follow_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCacheSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCacheSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCacheSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 follow_origin: Optional[_builtins.bool] = None,
                 rules: Optional[Sequence['outputs.DomainCacheSettingsRule']] = None):
        """
        :param _builtins.bool follow_origin: Specifies whether to enable origin cache control. Defaults to **false**.
        :param Sequence['DomainCacheSettingsRuleArgs'] rules: Specifies the cache rules, which overwrite the previous rule configurations.
               Blank rules are reset to default rules. The rules structure is documented below.
               
               <a name="rules_object"></a>
               The `rules` block support:
        """
        if follow_origin is not None:
            pulumi.set(__self__, "follow_origin", follow_origin)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="followOrigin")
    def follow_origin(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable origin cache control. Defaults to **false**.
        """
        return pulumi.get(self, "follow_origin")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.DomainCacheSettingsRule']]:
        """
        Specifies the cache rules, which overwrite the previous rule configurations.
        Blank rules are reset to default rules. The rules structure is documented below.

        <a name="rules_object"></a>
        The `rules` block support:
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class DomainCacheSettingsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "ttlType":
            suggest = "ttl_type"
        elif key == "urlParameterType":
            suggest = "url_parameter_type"
        elif key == "urlParameterValue":
            suggest = "url_parameter_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCacheSettingsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCacheSettingsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCacheSettingsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: _builtins.str,
                 content: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 ttl: Optional[_builtins.int] = None,
                 ttl_type: Optional[_builtins.str] = None,
                 url_parameter_type: Optional[_builtins.str] = None,
                 url_parameter_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str rule_type: Specifies the rule type. Possible value are:
               + **all**: All types of files are matched. It is the default value. The cloud will create a cache rule with **all**
               rule type by default.
               + **file_extension**: Files are matched based on their suffixes.
               + **catalog**: Files are matched based on their directories.
               + **full_path**: Files are matched based on their full paths.
               + **home_page**: Files are matched based on their homepage.
        :param _builtins.str content: Specifies the content that matches `rule_type`.
               + If `rule_type` is set to **all** or **home_page**, keep this parameter empty.
               + If `rule_type` is set to **file_extension**, the value of this parameter is a list of file name
               extensions. A file name extension starts with a period (.). File name extensions are separated by semicolons (;),
               for example, `.jpg;.zip;.exe`. Up to 20 file types are supported.
               + If `rule_type` is set to **catalog**, the value of this parameter is a list of directories. A directory starts with
               a slash (/). Directories are separated by semicolons (;), for example, `/test/folder01;/test/folder02`.
               Up to 20 directories are supported.
               + If `rule_type` is set to **full_path**, the value must start with a slash (/) and cannot end with an asterisk.
               Example: `/test/index.html` or `/test/*.jpg`
        :param _builtins.int priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param _builtins.int ttl: Specifies the cache age. The maximum cache age is 365 days.
        :param _builtins.str ttl_type: Specifies the unit of the cache age. Possible values:
               + **s**: Second
               + **m**: Minute
               + **h**: Hour
               + **d**: Day
        :param _builtins.str url_parameter_type: Specifies the URL parameter types. Valid values are as follows:
               + **del_params**: Ignore specific URL parameters.
               + **reserve_params**: Retain specific URL parameters.
               + **ignore_url_params**: Ignore all URL parameters.
               + **full_url**: Retain all URL parameters.
               
               Defaults to **full_url**.
        :param _builtins.str url_parameter_value: Specifies the URL parameter values, which are separated by commas (,).
               Up to 10 parameters can be set.
               This parameter is mandatory when `url_parameter_type` is set to **del_params** or **reserve_params**.
        """
        pulumi.set(__self__, "rule_type", rule_type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_type is not None:
            pulumi.set(__self__, "ttl_type", ttl_type)
        if url_parameter_type is not None:
            pulumi.set(__self__, "url_parameter_type", url_parameter_type)
        if url_parameter_value is not None:
            pulumi.set(__self__, "url_parameter_value", url_parameter_value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        """
        Specifies the rule type. Possible value are:
        + **all**: All types of files are matched. It is the default value. The cloud will create a cache rule with **all**
        rule type by default.
        + **file_extension**: Files are matched based on their suffixes.
        + **catalog**: Files are matched based on their directories.
        + **full_path**: Files are matched based on their full paths.
        + **home_page**: Files are matched based on their homepage.
        """
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Specifies the content that matches `rule_type`.
        + If `rule_type` is set to **all** or **home_page**, keep this parameter empty.
        + If `rule_type` is set to **file_extension**, the value of this parameter is a list of file name
        extensions. A file name extension starts with a period (.). File name extensions are separated by semicolons (;),
        for example, `.jpg;.zip;.exe`. Up to 20 file types are supported.
        + If `rule_type` is set to **catalog**, the value of this parameter is a list of directories. A directory starts with
        a slash (/). Directories are separated by semicolons (;), for example, `/test/folder01;/test/folder02`.
        Up to 20 directories are supported.
        + If `rule_type` is set to **full_path**, the value must start with a slash (/) and cannot end with an asterisk.
        Example: `/test/index.html` or `/test/*.jpg`
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="ttlType")
    def ttl_type(self) -> Optional[_builtins.str]:
        """
        Specifies the unit of the cache age. Possible values:
        + **s**: Second
        + **m**: Minute
        + **h**: Hour
        + **d**: Day
        """
        return pulumi.get(self, "ttl_type")

    @_builtins.property
    @pulumi.getter(name="urlParameterType")
    def url_parameter_type(self) -> Optional[_builtins.str]:
        """
        Specifies the URL parameter types. Valid values are as follows:
        + **del_params**: Ignore specific URL parameters.
        + **reserve_params**: Retain specific URL parameters.
        + **ignore_url_params**: Ignore all URL parameters.
        + **full_url**: Retain all URL parameters.

        Defaults to **full_url**.
        """
        return pulumi.get(self, "url_parameter_type")

    @_builtins.property
    @pulumi.getter(name="urlParameterValue")
    def url_parameter_value(self) -> Optional[_builtins.str]:
        """
        Specifies the URL parameter values, which are separated by commas (,).
        Up to 10 parameters can be set.
        This parameter is mandatory when `url_parameter_type` is set to **del_params** or **reserve_params**.
        """
        return pulumi.get(self, "url_parameter_value")


@pulumi.output_type
class DomainConfigs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessAreaFilters":
            suggest = "access_area_filters"
        elif key == "browserCacheRules":
            suggest = "browser_cache_rules"
        elif key == "cacheUrlParameterFilter":
            suggest = "cache_url_parameter_filter"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "errorCodeCaches":
            suggest = "error_code_caches"
        elif key == "errorCodeRedirectRules":
            suggest = "error_code_redirect_rules"
        elif key == "flexibleOrigins":
            suggest = "flexible_origins"
        elif key == "forceRedirect":
            suggest = "force_redirect"
        elif key == "httpResponseHeaders":
            suggest = "http_response_headers"
        elif key == "httpsSettings":
            suggest = "https_settings"
        elif key == "ipFilter":
            suggest = "ip_filter"
        elif key == "ipFrequencyLimit":
            suggest = "ip_frequency_limit"
        elif key == "ipv6Enable":
            suggest = "ipv6_enable"
        elif key == "originFollow302Status":
            suggest = "origin_follow302_status"
        elif key == "originProtocol":
            suggest = "origin_protocol"
        elif key == "originReceiveTimeout":
            suggest = "origin_receive_timeout"
        elif key == "originRequestUrlRewrites":
            suggest = "origin_request_url_rewrites"
        elif key == "rangeBasedRetrievalEnabled":
            suggest = "range_based_retrieval_enabled"
        elif key == "remoteAuth":
            suggest = "remote_auth"
        elif key == "requestLimitRules":
            suggest = "request_limit_rules"
        elif key == "requestUrlRewrites":
            suggest = "request_url_rewrites"
        elif key == "retrievalRequestHeaders":
            suggest = "retrieval_request_headers"
        elif key == "sliceEtagStatus":
            suggest = "slice_etag_status"
        elif key == "urlSigning":
            suggest = "url_signing"
        elif key == "userAgentFilter":
            suggest = "user_agent_filter"
        elif key == "videoSeek":
            suggest = "video_seek"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_area_filters: Optional[Sequence['outputs.DomainConfigsAccessAreaFilter']] = None,
                 browser_cache_rules: Optional[Sequence['outputs.DomainConfigsBrowserCacheRule']] = None,
                 cache_url_parameter_filter: Optional['outputs.DomainConfigsCacheUrlParameterFilter'] = None,
                 client_cert: Optional['outputs.DomainConfigsClientCert'] = None,
                 compress: Optional['outputs.DomainConfigsCompress'] = None,
                 description: Optional[_builtins.str] = None,
                 error_code_caches: Optional[Sequence['outputs.DomainConfigsErrorCodeCach']] = None,
                 error_code_redirect_rules: Optional[Sequence['outputs.DomainConfigsErrorCodeRedirectRule']] = None,
                 flexible_origins: Optional[Sequence['outputs.DomainConfigsFlexibleOrigin']] = None,
                 force_redirect: Optional['outputs.DomainConfigsForceRedirect'] = None,
                 hsts: Optional['outputs.DomainConfigsHsts'] = None,
                 http_response_headers: Optional[Sequence['outputs.DomainConfigsHttpResponseHeader']] = None,
                 https_settings: Optional['outputs.DomainConfigsHttpsSettings'] = None,
                 ip_filter: Optional['outputs.DomainConfigsIpFilter'] = None,
                 ip_frequency_limit: Optional['outputs.DomainConfigsIpFrequencyLimit'] = None,
                 ipv6_enable: Optional[_builtins.bool] = None,
                 origin_follow302_status: Optional[_builtins.str] = None,
                 origin_protocol: Optional[_builtins.str] = None,
                 origin_receive_timeout: Optional[_builtins.int] = None,
                 origin_request_url_rewrites: Optional[Sequence['outputs.DomainConfigsOriginRequestUrlRewrite']] = None,
                 quic: Optional['outputs.DomainConfigsQuic'] = None,
                 range_based_retrieval_enabled: Optional[_builtins.bool] = None,
                 referer: Optional['outputs.DomainConfigsReferer'] = None,
                 remote_auth: Optional['outputs.DomainConfigsRemoteAuth'] = None,
                 request_limit_rules: Optional[Sequence['outputs.DomainConfigsRequestLimitRule']] = None,
                 request_url_rewrites: Optional[Sequence['outputs.DomainConfigsRequestUrlRewrite']] = None,
                 retrieval_request_headers: Optional[Sequence['outputs.DomainConfigsRetrievalRequestHeader']] = None,
                 slice_etag_status: Optional[_builtins.str] = None,
                 sni: Optional['outputs.DomainConfigsSni'] = None,
                 url_signing: Optional['outputs.DomainConfigsUrlSigning'] = None,
                 user_agent_filter: Optional['outputs.DomainConfigsUserAgentFilter'] = None,
                 video_seek: Optional['outputs.DomainConfigsVideoSeek'] = None,
                 websocket: Optional['outputs.DomainConfigsWebsocket'] = None):
        """
        :param Sequence['DomainConfigsAccessAreaFilterArgs'] access_area_filters: Specifies the geographic access control rules.
               The access_area_filter structure is documented below.
               
               > 1. Before using this field, you need to submit a work order to activate this function.
               <br/>2. CDN periodically updates the IP address library. The locations of IP address that are not in the library
               cannot be identified. CDN allows requests from such IP addresses and returns resources to the users.
        :param Sequence['DomainConfigsBrowserCacheRuleArgs'] browser_cache_rules: Specifies the browser cache expiration settings.
               The browser_cache_rules structure is documented below.
        :param 'DomainConfigsCacheUrlParameterFilterArgs' cache_url_parameter_filter: schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        :param 'DomainConfigsClientCertArgs' client_cert: Specifies the client certificate configuration.
               The client_cert structure is documented below.
               
               <a name="https_settings_object"></a>
               The `https_settings` block support:
        :param 'DomainConfigsCompressArgs' compress: Specifies the smart compression. The compress structure
               is documented below.
        :param _builtins.str description: Specifies the description of the domain. The value contains up to `200` characters.
        :param Sequence['DomainConfigsErrorCodeCachArgs'] error_code_caches: Specifies the status code cache TTL.
               The error_code_cache structure is documented below.
               
               > 1. The status code cache TTL cannot be configured for domain names with special configurations.
               <br/>2. Domain names whose service type is whole site acceleration do not support configuring this field.
               <br/>3. By default, CDN caches status codes `400`, `404`, `416`, `500`, `502`, and `504` for `3` seconds and does not
               cache other status codes.
        :param Sequence['DomainConfigsErrorCodeRedirectRuleArgs'] error_code_redirect_rules: Specifies the custom error pages.
               The error_code_redirect_rules structure is documented below.
        :param Sequence['DomainConfigsFlexibleOriginArgs'] flexible_origins: Specifies the advanced origin rules.
               The flexible_origin structure is documented below.
               
               > Up to 20 advanced origin rules can be configured. When `type` is configured as **wholeSite**, configuring this
               field is not supported.
        :param 'DomainConfigsForceRedirectArgs' force_redirect: Specifies the force redirect.
               The force_redirect structure is documented below.
        :param 'DomainConfigsHstsArgs' hsts: Specifies the HSTS settings. HSTS forces clients (such as browsers) to use HTTPS to access
               your server, improving access security. The hsts structure is documented below.
               
               > This field can only be used when the HTTPS certificate is enabled.
        :param Sequence['DomainConfigsHttpResponseHeaderArgs'] http_response_headers: Specifies the HTTP response header settings.
               The http_response_header structure is documented below.
        :param 'DomainConfigsHttpsSettingsArgs' https_settings: Specifies the certificate configuration. The https_settings
               structure is documented below.
        :param 'DomainConfigsIpFilterArgs' ip_filter: Specifies the IP address blacklist or whitelist.
               The ip_filter structure is documented below.
        :param 'DomainConfigsIpFrequencyLimitArgs' ip_frequency_limit: Specifies the IP access frequency limit.
               The ip_frequency_limit structure is documented below.
               
               > Restricting the IP access frequency can effectively defend against CC attacks, but it may affect normal access.
               Please set access thresholds carefully. After creating the domain name, please wait a few minutes before configuring
               this field, otherwise the configuration may fail.
        :param _builtins.bool ipv6_enable: Specifies whether to enable IPv6.
        :param _builtins.str origin_follow302_status: Specifies whether to enable redirection from the origin.
               Valid values are as follows:
               + **on**: Enable.
               + **off**: Disable.
               
               Defaults to **off**.
        :param _builtins.str origin_protocol: Specifies the content retrieval protocol. Possible values:
               + **follow**: Same as user requests.
               + **http**: HTTP, which is the default value.
               + **https**: HTTPS.
        :param _builtins.int origin_receive_timeout: Specifies the origin response timeout.
               The value ranges from `5` to `60`, in seconds. Defaults to `30`.
        :param Sequence['DomainConfigsOriginRequestUrlRewriteArgs'] origin_request_url_rewrites: Specifies the rules of rewriting origin request URLs.
               The origin_request_url_rewrite structure is documented below.
               
               > Up to 20 rules can be configured.
        :param 'DomainConfigsQuicArgs' quic: Specifies the QUIC protocol. The quic structure is documented below.
               
               > This field can only be used when the HTTPS certificate is enabled. Disabling the HTTPS certificate will disable QUIC.
        :param _builtins.bool range_based_retrieval_enabled: Specifies whether to enable range-based retrieval.
               
               > The prerequisite for enabling range-based retrieval is that your origin site supports Range requests, that is, the
               HTTP request header contains the Range field. Otherwise, the back-to-origin may fail.
        :param 'DomainConfigsRefererArgs' referer: Specifies the referer validation. The referer structure is documented below.
               
               > You can define referer whitelists and blacklists to control who can access specific domain names.
        :param 'DomainConfigsRemoteAuthArgs' remote_auth: Specifies the remote authentication settings.
               The remote_auth structure is documented below.
               
               > Configure remote authentication to allow CDN to forward user requests to an authentication server and process the
               requests based on results returned by the authentication server.
        :param Sequence['DomainConfigsRequestLimitRuleArgs'] request_limit_rules: Specifies the request rate limiting rules.
               The request_limit_rules structure is documented below.
               
               > Up to 60 request limit rules can be configured.
        :param Sequence['DomainConfigsRequestUrlRewriteArgs'] request_url_rewrites: Specifies the request url rewrite settings. Set access URL rewrite rules to
               redirect user requests to the URLs of cached resources.
               The request_url_rewrite structure is documented below.
        :param Sequence['DomainConfigsRetrievalRequestHeaderArgs'] retrieval_request_headers: Specifies the retrieval request header settings.
               The retrieval_request_header structure is documented below.
        :param _builtins.str slice_etag_status: Specifies whether ETag is verified during origin pull.
               Valid values are as follows:
               + **on**: Enable.
               + **off**: Disable.
               
               Defaults to **on**.
        :param 'DomainConfigsSniArgs' sni: Specifies the origin SNI settings. If your origin server is bound to multiple domains and
               CDN visits the origin server using HTTPS, set the Server Name Indication (SNI) to specify the domain to be accessed.
               The sni structure is documented below.
               
               > 1. The origin method must be HTTPS or the protocol can be configured for origin SNI.
               <br/>2. When the service type is whole site acceleration, source SNI configuration is not supported.
               <br/>3. Domain names with special configurations in the backend do not support origin SNI configuration.
               <br/>4. CDN node carries SNI information by default when a CDN node uses the HTTPS protocol to return to the source.
               If you do not configure the origin SNI, the origin HOST will be used as the SNI address by default.
        :param 'DomainConfigsUrlSigningArgs' url_signing: Specifies the URL signing.
               The url_signing structure is documented below.
        :param 'DomainConfigsUserAgentFilterArgs' user_agent_filter: Specifies the User-Agent blacklist or whitelist settings.
               The user_agent_filter structure is documented below.
        :param 'DomainConfigsVideoSeekArgs' video_seek: Specifies the video seek settings. The video_seek structure
               is documented below.
               
               > 1. You need to configure a cache rule for `FLV` and `MP4` files and ignored all URL parameters in `cache_settings`.
               <br/>2. Video seek is valid only when your origin server supports range requests.
               <br/>3. Only `MP4` and `FLV` videos are supported.
        :param 'DomainConfigsWebsocketArgs' websocket: Specifies the websocket settings. This field can only be configured if `type` is
               set to **wholeSite**. The websocket structure is documented below.
               
               > Websocket and HTTP/2 are incompatible and cannot be both enabled. Websocket will not take effect when
               origin cache control is enabled in the cache configuration.
        """
        if access_area_filters is not None:
            pulumi.set(__self__, "access_area_filters", access_area_filters)
        if browser_cache_rules is not None:
            pulumi.set(__self__, "browser_cache_rules", browser_cache_rules)
        if cache_url_parameter_filter is not None:
            pulumi.set(__self__, "cache_url_parameter_filter", cache_url_parameter_filter)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if error_code_caches is not None:
            pulumi.set(__self__, "error_code_caches", error_code_caches)
        if error_code_redirect_rules is not None:
            pulumi.set(__self__, "error_code_redirect_rules", error_code_redirect_rules)
        if flexible_origins is not None:
            pulumi.set(__self__, "flexible_origins", flexible_origins)
        if force_redirect is not None:
            pulumi.set(__self__, "force_redirect", force_redirect)
        if hsts is not None:
            pulumi.set(__self__, "hsts", hsts)
        if http_response_headers is not None:
            pulumi.set(__self__, "http_response_headers", http_response_headers)
        if https_settings is not None:
            pulumi.set(__self__, "https_settings", https_settings)
        if ip_filter is not None:
            pulumi.set(__self__, "ip_filter", ip_filter)
        if ip_frequency_limit is not None:
            pulumi.set(__self__, "ip_frequency_limit", ip_frequency_limit)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if origin_follow302_status is not None:
            pulumi.set(__self__, "origin_follow302_status", origin_follow302_status)
        if origin_protocol is not None:
            pulumi.set(__self__, "origin_protocol", origin_protocol)
        if origin_receive_timeout is not None:
            pulumi.set(__self__, "origin_receive_timeout", origin_receive_timeout)
        if origin_request_url_rewrites is not None:
            pulumi.set(__self__, "origin_request_url_rewrites", origin_request_url_rewrites)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if range_based_retrieval_enabled is not None:
            pulumi.set(__self__, "range_based_retrieval_enabled", range_based_retrieval_enabled)
        if referer is not None:
            pulumi.set(__self__, "referer", referer)
        if remote_auth is not None:
            pulumi.set(__self__, "remote_auth", remote_auth)
        if request_limit_rules is not None:
            pulumi.set(__self__, "request_limit_rules", request_limit_rules)
        if request_url_rewrites is not None:
            pulumi.set(__self__, "request_url_rewrites", request_url_rewrites)
        if retrieval_request_headers is not None:
            pulumi.set(__self__, "retrieval_request_headers", retrieval_request_headers)
        if slice_etag_status is not None:
            pulumi.set(__self__, "slice_etag_status", slice_etag_status)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if url_signing is not None:
            pulumi.set(__self__, "url_signing", url_signing)
        if user_agent_filter is not None:
            pulumi.set(__self__, "user_agent_filter", user_agent_filter)
        if video_seek is not None:
            pulumi.set(__self__, "video_seek", video_seek)
        if websocket is not None:
            pulumi.set(__self__, "websocket", websocket)

    @_builtins.property
    @pulumi.getter(name="accessAreaFilters")
    def access_area_filters(self) -> Optional[Sequence['outputs.DomainConfigsAccessAreaFilter']]:
        """
        Specifies the geographic access control rules.
        The access_area_filter structure is documented below.

        > 1. Before using this field, you need to submit a work order to activate this function.
        <br/>2. CDN periodically updates the IP address library. The locations of IP address that are not in the library
        cannot be identified. CDN allows requests from such IP addresses and returns resources to the users.
        """
        return pulumi.get(self, "access_area_filters")

    @_builtins.property
    @pulumi.getter(name="browserCacheRules")
    def browser_cache_rules(self) -> Optional[Sequence['outputs.DomainConfigsBrowserCacheRule']]:
        """
        Specifies the browser cache expiration settings.
        The browser_cache_rules structure is documented below.
        """
        return pulumi.get(self, "browser_cache_rules")

    @_builtins.property
    @pulumi.getter(name="cacheUrlParameterFilter")
    def cache_url_parameter_filter(self) -> Optional['outputs.DomainConfigsCacheUrlParameterFilter']:
        """
        schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        return pulumi.get(self, "cache_url_parameter_filter")

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional['outputs.DomainConfigsClientCert']:
        """
        Specifies the client certificate configuration.
        The client_cert structure is documented below.

        <a name="https_settings_object"></a>
        The `https_settings` block support:
        """
        return pulumi.get(self, "client_cert")

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional['outputs.DomainConfigsCompress']:
        """
        Specifies the smart compression. The compress structure
        is documented below.
        """
        return pulumi.get(self, "compress")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the domain. The value contains up to `200` characters.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="errorCodeCaches")
    def error_code_caches(self) -> Optional[Sequence['outputs.DomainConfigsErrorCodeCach']]:
        """
        Specifies the status code cache TTL.
        The error_code_cache structure is documented below.

        > 1. The status code cache TTL cannot be configured for domain names with special configurations.
        <br/>2. Domain names whose service type is whole site acceleration do not support configuring this field.
        <br/>3. By default, CDN caches status codes `400`, `404`, `416`, `500`, `502`, and `504` for `3` seconds and does not
        cache other status codes.
        """
        return pulumi.get(self, "error_code_caches")

    @_builtins.property
    @pulumi.getter(name="errorCodeRedirectRules")
    def error_code_redirect_rules(self) -> Optional[Sequence['outputs.DomainConfigsErrorCodeRedirectRule']]:
        """
        Specifies the custom error pages.
        The error_code_redirect_rules structure is documented below.
        """
        return pulumi.get(self, "error_code_redirect_rules")

    @_builtins.property
    @pulumi.getter(name="flexibleOrigins")
    def flexible_origins(self) -> Optional[Sequence['outputs.DomainConfigsFlexibleOrigin']]:
        """
        Specifies the advanced origin rules.
        The flexible_origin structure is documented below.

        > Up to 20 advanced origin rules can be configured. When `type` is configured as **wholeSite**, configuring this
        field is not supported.
        """
        return pulumi.get(self, "flexible_origins")

    @_builtins.property
    @pulumi.getter(name="forceRedirect")
    def force_redirect(self) -> Optional['outputs.DomainConfigsForceRedirect']:
        """
        Specifies the force redirect.
        The force_redirect structure is documented below.
        """
        return pulumi.get(self, "force_redirect")

    @_builtins.property
    @pulumi.getter
    def hsts(self) -> Optional['outputs.DomainConfigsHsts']:
        """
        Specifies the HSTS settings. HSTS forces clients (such as browsers) to use HTTPS to access
        your server, improving access security. The hsts structure is documented below.

        > This field can only be used when the HTTPS certificate is enabled.
        """
        return pulumi.get(self, "hsts")

    @_builtins.property
    @pulumi.getter(name="httpResponseHeaders")
    def http_response_headers(self) -> Optional[Sequence['outputs.DomainConfigsHttpResponseHeader']]:
        """
        Specifies the HTTP response header settings.
        The http_response_header structure is documented below.
        """
        return pulumi.get(self, "http_response_headers")

    @_builtins.property
    @pulumi.getter(name="httpsSettings")
    def https_settings(self) -> Optional['outputs.DomainConfigsHttpsSettings']:
        """
        Specifies the certificate configuration. The https_settings
        structure is documented below.
        """
        return pulumi.get(self, "https_settings")

    @_builtins.property
    @pulumi.getter(name="ipFilter")
    def ip_filter(self) -> Optional['outputs.DomainConfigsIpFilter']:
        """
        Specifies the IP address blacklist or whitelist.
        The ip_filter structure is documented below.
        """
        return pulumi.get(self, "ip_filter")

    @_builtins.property
    @pulumi.getter(name="ipFrequencyLimit")
    def ip_frequency_limit(self) -> Optional['outputs.DomainConfigsIpFrequencyLimit']:
        """
        Specifies the IP access frequency limit.
        The ip_frequency_limit structure is documented below.

        > Restricting the IP access frequency can effectively defend against CC attacks, but it may affect normal access.
        Please set access thresholds carefully. After creating the domain name, please wait a few minutes before configuring
        this field, otherwise the configuration may fail.
        """
        return pulumi.get(self, "ip_frequency_limit")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable IPv6.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="originFollow302Status")
    def origin_follow302_status(self) -> Optional[_builtins.str]:
        """
        Specifies whether to enable redirection from the origin.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **off**.
        """
        return pulumi.get(self, "origin_follow302_status")

    @_builtins.property
    @pulumi.getter(name="originProtocol")
    def origin_protocol(self) -> Optional[_builtins.str]:
        """
        Specifies the content retrieval protocol. Possible values:
        + **follow**: Same as user requests.
        + **http**: HTTP, which is the default value.
        + **https**: HTTPS.
        """
        return pulumi.get(self, "origin_protocol")

    @_builtins.property
    @pulumi.getter(name="originReceiveTimeout")
    def origin_receive_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the origin response timeout.
        The value ranges from `5` to `60`, in seconds. Defaults to `30`.
        """
        return pulumi.get(self, "origin_receive_timeout")

    @_builtins.property
    @pulumi.getter(name="originRequestUrlRewrites")
    def origin_request_url_rewrites(self) -> Optional[Sequence['outputs.DomainConfigsOriginRequestUrlRewrite']]:
        """
        Specifies the rules of rewriting origin request URLs.
        The origin_request_url_rewrite structure is documented below.

        > Up to 20 rules can be configured.
        """
        return pulumi.get(self, "origin_request_url_rewrites")

    @_builtins.property
    @pulumi.getter
    def quic(self) -> Optional['outputs.DomainConfigsQuic']:
        """
        Specifies the QUIC protocol. The quic structure is documented below.

        > This field can only be used when the HTTPS certificate is enabled. Disabling the HTTPS certificate will disable QUIC.
        """
        return pulumi.get(self, "quic")

    @_builtins.property
    @pulumi.getter(name="rangeBasedRetrievalEnabled")
    def range_based_retrieval_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable range-based retrieval.

        > The prerequisite for enabling range-based retrieval is that your origin site supports Range requests, that is, the
        HTTP request header contains the Range field. Otherwise, the back-to-origin may fail.
        """
        return pulumi.get(self, "range_based_retrieval_enabled")

    @_builtins.property
    @pulumi.getter
    def referer(self) -> Optional['outputs.DomainConfigsReferer']:
        """
        Specifies the referer validation. The referer structure is documented below.

        > You can define referer whitelists and blacklists to control who can access specific domain names.
        """
        return pulumi.get(self, "referer")

    @_builtins.property
    @pulumi.getter(name="remoteAuth")
    def remote_auth(self) -> Optional['outputs.DomainConfigsRemoteAuth']:
        """
        Specifies the remote authentication settings.
        The remote_auth structure is documented below.

        > Configure remote authentication to allow CDN to forward user requests to an authentication server and process the
        requests based on results returned by the authentication server.
        """
        return pulumi.get(self, "remote_auth")

    @_builtins.property
    @pulumi.getter(name="requestLimitRules")
    def request_limit_rules(self) -> Optional[Sequence['outputs.DomainConfigsRequestLimitRule']]:
        """
        Specifies the request rate limiting rules.
        The request_limit_rules structure is documented below.

        > Up to 60 request limit rules can be configured.
        """
        return pulumi.get(self, "request_limit_rules")

    @_builtins.property
    @pulumi.getter(name="requestUrlRewrites")
    def request_url_rewrites(self) -> Optional[Sequence['outputs.DomainConfigsRequestUrlRewrite']]:
        """
        Specifies the request url rewrite settings. Set access URL rewrite rules to
        redirect user requests to the URLs of cached resources.
        The request_url_rewrite structure is documented below.
        """
        return pulumi.get(self, "request_url_rewrites")

    @_builtins.property
    @pulumi.getter(name="retrievalRequestHeaders")
    def retrieval_request_headers(self) -> Optional[Sequence['outputs.DomainConfigsRetrievalRequestHeader']]:
        """
        Specifies the retrieval request header settings.
        The retrieval_request_header structure is documented below.
        """
        return pulumi.get(self, "retrieval_request_headers")

    @_builtins.property
    @pulumi.getter(name="sliceEtagStatus")
    def slice_etag_status(self) -> Optional[_builtins.str]:
        """
        Specifies whether ETag is verified during origin pull.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **on**.
        """
        return pulumi.get(self, "slice_etag_status")

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional['outputs.DomainConfigsSni']:
        """
        Specifies the origin SNI settings. If your origin server is bound to multiple domains and
        CDN visits the origin server using HTTPS, set the Server Name Indication (SNI) to specify the domain to be accessed.
        The sni structure is documented below.

        > 1. The origin method must be HTTPS or the protocol can be configured for origin SNI.
        <br/>2. When the service type is whole site acceleration, source SNI configuration is not supported.
        <br/>3. Domain names with special configurations in the backend do not support origin SNI configuration.
        <br/>4. CDN node carries SNI information by default when a CDN node uses the HTTPS protocol to return to the source.
        If you do not configure the origin SNI, the origin HOST will be used as the SNI address by default.
        """
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="urlSigning")
    def url_signing(self) -> Optional['outputs.DomainConfigsUrlSigning']:
        """
        Specifies the URL signing.
        The url_signing structure is documented below.
        """
        return pulumi.get(self, "url_signing")

    @_builtins.property
    @pulumi.getter(name="userAgentFilter")
    def user_agent_filter(self) -> Optional['outputs.DomainConfigsUserAgentFilter']:
        """
        Specifies the User-Agent blacklist or whitelist settings.
        The user_agent_filter structure is documented below.
        """
        return pulumi.get(self, "user_agent_filter")

    @_builtins.property
    @pulumi.getter(name="videoSeek")
    def video_seek(self) -> Optional['outputs.DomainConfigsVideoSeek']:
        """
        Specifies the video seek settings. The video_seek structure
        is documented below.

        > 1. You need to configure a cache rule for `FLV` and `MP4` files and ignored all URL parameters in `cache_settings`.
        <br/>2. Video seek is valid only when your origin server supports range requests.
        <br/>3. Only `MP4` and `FLV` videos are supported.
        """
        return pulumi.get(self, "video_seek")

    @_builtins.property
    @pulumi.getter
    def websocket(self) -> Optional['outputs.DomainConfigsWebsocket']:
        """
        Specifies the websocket settings. This field can only be configured if `type` is
        set to **wholeSite**. The websocket structure is documented below.

        > Websocket and HTTP/2 are incompatible and cannot be both enabled. Websocket will not take effect when
        origin cache control is enabled in the cache configuration.
        """
        return pulumi.get(self, "websocket")


@pulumi.output_type
class DomainConfigsAccessAreaFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "contentValue":
            suggest = "content_value"
        elif key == "exceptionIp":
            suggest = "exception_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsAccessAreaFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsAccessAreaFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsAccessAreaFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area: _builtins.str,
                 content_type: _builtins.str,
                 type: _builtins.str,
                 content_value: Optional[_builtins.str] = None,
                 exception_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str area: Specifies the areas, separated by commas.
               Please refer to [Geographical Location Codes](https://support.huaweicloud.com/intl/en-us/api-cdn/cdn_02_0090.html).
        :param _builtins.str content_type: Specifies the content type. Valid values are:
               + **all**: The rule takes effect for all files.
               + **file_directory**: The rule takes effect for resources in the specified directory.
               + **file_path**: The rule takes effect for resources corresponding to the path.
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.str content_value: Specifies the content value. The use of this field has the following restrictions:
               + When `content_type` is set to **all**, make this parameter is empty or not passed.
               + When `content_type` is set to **file_directory**, the value must start with a slash (/) and multiple directories
               are separated by commas (,), for example, **/test/folder01,/test/folder02**. Up to `100` directories can be entered.
               + When `content_type` is set to **file_path**, the value must start with a slash (/) or wildcard (\\*). Up to two
               wildcards (\\*) are allowed and they cannot be consecutive. Multiple paths are separated by commas (,),
               for example, **/test/a.txt,/test/b.txt**. Up to `100` paths can be entered.
        :param _builtins.str exception_ip: Specifies the IP addresses exception in access control, separated by commas.
               
               <a name="client_cert_object"></a>
               The `client_cert` block support:
        """
        pulumi.set(__self__, "area", area)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "type", type)
        if content_value is not None:
            pulumi.set(__self__, "content_value", content_value)
        if exception_ip is not None:
            pulumi.set(__self__, "exception_ip", exception_ip)

    @_builtins.property
    @pulumi.getter
    def area(self) -> _builtins.str:
        """
        Specifies the areas, separated by commas.
        Please refer to [Geographical Location Codes](https://support.huaweicloud.com/intl/en-us/api-cdn/cdn_02_0090.html).
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        """
        Specifies the content type. Valid values are:
        + **all**: The rule takes effect for all files.
        + **file_directory**: The rule takes effect for resources in the specified directory.
        + **file_path**: The rule takes effect for resources corresponding to the path.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="contentValue")
    def content_value(self) -> Optional[_builtins.str]:
        """
        Specifies the content value. The use of this field has the following restrictions:
        + When `content_type` is set to **all**, make this parameter is empty or not passed.
        + When `content_type` is set to **file_directory**, the value must start with a slash (/) and multiple directories
        are separated by commas (,), for example, **/test/folder01,/test/folder02**. Up to `100` directories can be entered.
        + When `content_type` is set to **file_path**, the value must start with a slash (/) or wildcard (\\*). Up to two
        wildcards (\\*) are allowed and they cannot be consecutive. Multiple paths are separated by commas (,),
        for example, **/test/a.txt,/test/b.txt**. Up to `100` paths can be entered.
        """
        return pulumi.get(self, "content_value")

    @_builtins.property
    @pulumi.getter(name="exceptionIp")
    def exception_ip(self) -> Optional[_builtins.str]:
        """
        Specifies the IP addresses exception in access control, separated by commas.

        <a name="client_cert_object"></a>
        The `client_cert` block support:
        """
        return pulumi.get(self, "exception_ip")


@pulumi.output_type
class DomainConfigsBrowserCacheRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheType":
            suggest = "cache_type"
        elif key == "ttlUnit":
            suggest = "ttl_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsBrowserCacheRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsBrowserCacheRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsBrowserCacheRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_type: _builtins.str,
                 condition: 'outputs.DomainConfigsBrowserCacheRuleCondition',
                 ttl: Optional[_builtins.int] = None,
                 ttl_unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str cache_type: Specifies the cache validation type. Valid values are:
               + **follow_origin**: Follow the origin site's cache policy, i.e. the Cache-Control header settings.
               + **ttl**: The browser cache follows the expiration time set by the current rules.
               + **never**: The browser does not cache resources.
        :param 'DomainConfigsBrowserCacheRuleConditionArgs' condition: Specifies matching condition.
               The condition structure is documented below.
        :param _builtins.int ttl: Specifies the cache age. The maximum cache age is 365 days.
        :param _builtins.str ttl_unit: Specifies the cache expiration time unit. Valid values are:
               + **s**: seconds.
               + **m**: minutes.
               + **h**: hours.
               + **d**: days.
               
               > This field is required when the `cache_type` is set to **ttl**.
               
               <a name="browser_cache_rules_condition_object"></a>
               The `condition` block support:
        """
        pulumi.set(__self__, "cache_type", cache_type)
        pulumi.set(__self__, "condition", condition)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_unit is not None:
            pulumi.set(__self__, "ttl_unit", ttl_unit)

    @_builtins.property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> _builtins.str:
        """
        Specifies the cache validation type. Valid values are:
        + **follow_origin**: Follow the origin site's cache policy, i.e. the Cache-Control header settings.
        + **ttl**: The browser cache follows the expiration time set by the current rules.
        + **never**: The browser does not cache resources.
        """
        return pulumi.get(self, "cache_type")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.DomainConfigsBrowserCacheRuleCondition':
        """
        Specifies matching condition.
        The condition structure is documented below.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="ttlUnit")
    def ttl_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the cache expiration time unit. Valid values are:
        + **s**: seconds.
        + **m**: minutes.
        + **h**: hours.
        + **d**: days.

        > This field is required when the `cache_type` is set to **ttl**.

        <a name="browser_cache_rules_condition_object"></a>
        The `condition` block support:
        """
        return pulumi.get(self, "ttl_unit")


@pulumi.output_type
class DomainConfigsBrowserCacheRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsBrowserCacheRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsBrowserCacheRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsBrowserCacheRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 match_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param _builtins.int priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param _builtins.str match_value: Specifies the cache match settings.
               + When `match_type` is set to **all**, this field does not need to be configured.
               + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
               value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
               not exceed `20`.
               + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
               be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
               exceed `20`.
               + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
               It supports matching specific files in the specified directory or files with a wildcard "*".
               The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
               single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
               + When `match_type` is set to **home_page**, this field does not need to be configured.
               
               <a name="access_area_filter_object"></a>
               The `access_area_filter` block support:
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
        return pulumi.get(self, "match_value")


@pulumi.output_type
class DomainConfigsCacheUrlParameterFilter(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.str value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigsClientCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCert":
            suggest = "trusted_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsClientCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsClientCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsClientCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 hosts: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 trusted_cert: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.str hosts: Specifies the domain name specified in the client CA certificate.
               
               > 1. CDN will allow all client requests that hold the CA certificate by default.
               <br/>2. A maximum of `100` domain names can be configured. Multiple domain names can be separated by “,” or “|”.
               
               <a name="cache_settings_object"></a>
               The `cache_settings` block support:
        :param _builtins.str trusted_cert: Specifies the client CA certificate content, only supports PEM format.
        """
        pulumi.set(__self__, "enabled", enabled)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trusted_cert is not None:
            pulumi.set(__self__, "trusted_cert", trusted_cert)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[_builtins.str]:
        """
        Specifies the domain name specified in the client CA certificate.

        > 1. CDN will allow all client requests that hold the CA certificate by default.
        <br/>2. A maximum of `100` domain names can be configured. Multiple domain names can be separated by “,” or “|”.

        <a name="cache_settings_object"></a>
        The `cache_settings` block support:
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="trustedCert")
    def trusted_cert(self) -> Optional[_builtins.str]:
        """
        Specifies the client CA certificate content, only supports PEM format.
        """
        return pulumi.get(self, "trusted_cert")


@pulumi.output_type
class DomainConfigsCompress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsCompress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsCompress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsCompress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 file_type: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.str file_type: Specifies the formats of files to be compressed. Enter up to 200 characters.
               Multiple formats are separated by commas (,). Each format contains up to 50 characters.
               Defaults to **.js,.html,.css,.xml,.json,.shtml,.htm**.
               
               <a name="ip_frequency_limit_object"></a>
               The `ip_frequency_limit` block support:
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        """
        pulumi.set(__self__, "enabled", enabled)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[_builtins.str]:
        """
        Specifies the formats of files to be compressed. Enter up to 200 characters.
        Multiple formats are separated by commas (,). Each format contains up to 50 characters.
        Defaults to **.js,.html,.css,.xml,.json,.shtml,.htm**.

        <a name="ip_frequency_limit_object"></a>
        The `ip_frequency_limit` block support:
        """
        return pulumi.get(self, "file_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainConfigsErrorCodeCach(dict):
    def __init__(__self__, *,
                 code: _builtins.int,
                 ttl: _builtins.int):
        """
        :param _builtins.int code: Specifies the error code. Valid values are: **301**, **302**, **400**, **403**, **404**,
               **405**, **414**, **500**, **501**, **502**, **503**, and **504**.
        :param _builtins.int ttl: Specifies the cache age. The maximum cache age is 365 days.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.int:
        """
        Specifies the error code. Valid values are: **301**, **302**, **400**, **403**, **404**,
        **405**, **414**, **500**, **501**, **502**, **503**, and **504**.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        Specifies the cache age. The maximum cache age is 365 days.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class DomainConfigsErrorCodeRedirectRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "targetCode":
            suggest = "target_code"
        elif key == "targetLink":
            suggest = "target_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsErrorCodeRedirectRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsErrorCodeRedirectRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsErrorCodeRedirectRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: _builtins.int,
                 target_code: _builtins.int,
                 target_link: _builtins.str):
        """
        :param _builtins.int error_code: Specifies the redirect unique error code. Valid values are: **400**, **403**, **404**,
               **405**, **414**, **416**, **451**, **500**, **501**, **502**, **503**, and **504**.
        :param _builtins.int target_code: Specifies the redirect status code. The value can be **301** or **302**.
        :param _builtins.str target_link: Specifies the destination URL. The value must start with **http://** or **https://**.
               For example: `http://www.example.com`.
               
               <a name="hsts_object"></a>
               The `hsts` block support:
        """
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "target_code", target_code)
        pulumi.set(__self__, "target_link", target_link)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> _builtins.int:
        """
        Specifies the redirect unique error code. Valid values are: **400**, **403**, **404**,
        **405**, **414**, **416**, **451**, **500**, **501**, **502**, **503**, and **504**.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="targetCode")
    def target_code(self) -> _builtins.int:
        """
        Specifies the redirect status code. The value can be **301** or **302**.
        """
        return pulumi.get(self, "target_code")

    @_builtins.property
    @pulumi.getter(name="targetLink")
    def target_link(self) -> _builtins.str:
        """
        Specifies the destination URL. The value must start with **http://** or **https://**.
        For example: `http://www.example.com`.

        <a name="hsts_object"></a>
        The `hsts` block support:
        """
        return pulumi.get(self, "target_link")


@pulumi.output_type
class DomainConfigsFlexibleOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backSources":
            suggest = "back_sources"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "matchPattern":
            suggest = "match_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsFlexibleOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsFlexibleOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsFlexibleOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 back_sources: 'outputs.DomainConfigsFlexibleOriginBackSources',
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 match_pattern: Optional[_builtins.str] = None):
        """
        :param 'DomainConfigsFlexibleOriginBackSourcesArgs' back_sources: Specifies the back source information. The length of this array field cannot exceed `1`.
               The back_sources structure is documented below.
        :param _builtins.str match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param _builtins.int priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param _builtins.str match_pattern: Specifies the URI match rule. The usage rules are as follows:
               + When `match_type` is set to **all**, set this field to empty.
               + When `match_type` is set to **file_extension**, the value of this field should start with a period (.).
               Enter up to 20 file name extensions and use semicolons (;) to separate them. Example: **.jpg;.zip;.exe**.
               + When `match_type` is set to **file_path**, the value of this field should start with a slash (/).
               Enter up to 20 paths and use semicolons (;) to separate them. Example: **/test/folder01;/test/folder02**.
               
               <a name="flexible_origin_back_sources_object"></a>
               The `back_sources` block support:
        """
        pulumi.set(__self__, "back_sources", back_sources)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_pattern is not None:
            pulumi.set(__self__, "match_pattern", match_pattern)

    @_builtins.property
    @pulumi.getter(name="backSources")
    def back_sources(self) -> 'outputs.DomainConfigsFlexibleOriginBackSources':
        """
        Specifies the back source information. The length of this array field cannot exceed `1`.
        The back_sources structure is documented below.
        """
        return pulumi.get(self, "back_sources")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> Optional[_builtins.str]:
        """
        Specifies the URI match rule. The usage rules are as follows:
        + When `match_type` is set to **all**, set this field to empty.
        + When `match_type` is set to **file_extension**, the value of this field should start with a period (.).
        Enter up to 20 file name extensions and use semicolons (;) to separate them. Example: **.jpg;.zip;.exe**.
        + When `match_type` is set to **file_path**, the value of this field should start with a slash (/).
        Enter up to 20 paths and use semicolons (;) to separate them. Example: **/test/folder01;/test/folder02**.

        <a name="flexible_origin_back_sources_object"></a>
        The `back_sources` block support:
        """
        return pulumi.get(self, "match_pattern")


@pulumi.output_type
class DomainConfigsFlexibleOriginBackSources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipOrDomain":
            suggest = "ip_or_domain"
        elif key == "sourcesType":
            suggest = "sources_type"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "obsBucketType":
            suggest = "obs_bucket_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsFlexibleOriginBackSources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsFlexibleOriginBackSources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsFlexibleOriginBackSources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_or_domain: _builtins.str,
                 sources_type: _builtins.str,
                 http_port: Optional[_builtins.int] = None,
                 https_port: Optional[_builtins.int] = None,
                 obs_bucket_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_or_domain: Specifies the IP address or domain name of the origin server.
               + When `sources_type` is set to **ipaddr**, the value of this field can only be set to a valid IPv4 or Ipv6 address.
               + When `sources_type` is set to **domain**, the value of this field can only be set to a domain name.
               + When `sources_type` is set to **obs_bucket**, the value of this field can only be set to an OBS bucket access
               domain name.
        :param _builtins.str sources_type: Specifies the origin server type. Valid values are as follows:
               + **ipaddr**: IP address.
               + **domain**: Domain name.
               + **obs_bucket**: OBS bucket.
        :param _builtins.int http_port: Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        :param _builtins.int https_port: Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.
               
               > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.
               
               <a name="remote_auth_object"></a>
               The `remote_auth` block support:
        :param _builtins.str obs_bucket_type: Specifies the OBS bucket type. Valid values are **private** and **public**.
               This field is required when `sources_type` is set to **obs_bucket**.
        """
        pulumi.set(__self__, "ip_or_domain", ip_or_domain)
        pulumi.set(__self__, "sources_type", sources_type)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)

    @_builtins.property
    @pulumi.getter(name="ipOrDomain")
    def ip_or_domain(self) -> _builtins.str:
        """
        Specifies the IP address or domain name of the origin server.
        + When `sources_type` is set to **ipaddr**, the value of this field can only be set to a valid IPv4 or Ipv6 address.
        + When `sources_type` is set to **domain**, the value of this field can only be set to a domain name.
        + When `sources_type` is set to **obs_bucket**, the value of this field can only be set to an OBS bucket access
        domain name.
        """
        return pulumi.get(self, "ip_or_domain")

    @_builtins.property
    @pulumi.getter(name="sourcesType")
    def sources_type(self) -> _builtins.str:
        """
        Specifies the origin server type. Valid values are as follows:
        + **ipaddr**: IP address.
        + **domain**: Domain name.
        + **obs_bucket**: OBS bucket.
        """
        return pulumi.get(self, "sources_type")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        """
        Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[_builtins.int]:
        """
        Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.

        > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.

        <a name="remote_auth_object"></a>
        The `remote_auth` block support:
        """
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[_builtins.str]:
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        This field is required when `sources_type` is set to **obs_bucket**.
        """
        return pulumi.get(self, "obs_bucket_type")


@pulumi.output_type
class DomainConfigsForceRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectCode":
            suggest = "redirect_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsForceRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsForceRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsForceRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 redirect_code: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.int redirect_code: Specifies the force redirect status code. Valid values are: **301** and **302**.
               Defaults to **302**.
               
               <a name="compress_object"></a>
               The `compress` blocks support:
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        """
        pulumi.set(__self__, "enabled", enabled)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[_builtins.int]:
        """
        Specifies the force redirect status code. Valid values are: **301** and **302**.
        Defaults to **302**.

        <a name="compress_object"></a>
        The `compress` blocks support:
        """
        return pulumi.get(self, "redirect_code")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainConfigsHsts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsHsts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsHsts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsHsts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 include_subdomains: Optional[_builtins.str] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.str include_subdomains: Specifies whether subdomain names are included.
               The options are **on** (included) and **off** (not included). This field is required when enable HSTS settings.
               
               <a name="sni_object"></a>
               The `sni` block support:
        :param _builtins.int max_age: Specifies the expiration time, which means the TTL of the response header
               `Strict-Transport-Security` on the client. The value ranges from `0` to `63,072,000`. The unit is second.
               This field is required when enable HSTS settings.
        """
        pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[_builtins.str]:
        """
        Specifies whether subdomain names are included.
        The options are **on** (included) and **off** (not included). This field is required when enable HSTS settings.

        <a name="sni_object"></a>
        The `sni` block support:
        """
        return pulumi.get(self, "include_subdomains")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies the expiration time, which means the TTL of the response header
        `Strict-Transport-Security` on the client. The value ranges from `0` to `63,072,000`. The unit is second.
        This field is required when enable HSTS settings.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class DomainConfigsHttpResponseHeader(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        :param _builtins.str name: Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
               **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
               **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
               and hyphens (-), and starts with a letter.
        :param _builtins.str value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
        **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
        **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
        and hyphens (-), and starts with a letter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigsHttpsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateBody":
            suggest = "certificate_body"
        elif key == "certificateName":
            suggest = "certificate_name"
        elif key == "certificateSource":
            suggest = "certificate_source"
        elif key == "certificateType":
            suggest = "certificate_type"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "http2Status":
            suggest = "http2_status"
        elif key == "httpsEnabled":
            suggest = "https_enabled"
        elif key == "httpsStatus":
            suggest = "https_status"
        elif key == "ocspStaplingStatus":
            suggest = "ocsp_stapling_status"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "scmCertificateId":
            suggest = "scm_certificate_id"
        elif key == "tlsVersion":
            suggest = "tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsHttpsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsHttpsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsHttpsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_body: Optional[_builtins.str] = None,
                 certificate_name: Optional[_builtins.str] = None,
                 certificate_source: Optional[_builtins.int] = None,
                 certificate_type: Optional[_builtins.str] = None,
                 http2_enabled: Optional[_builtins.bool] = None,
                 http2_status: Optional[_builtins.str] = None,
                 https_enabled: Optional[_builtins.bool] = None,
                 https_status: Optional[_builtins.str] = None,
                 ocsp_stapling_status: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None,
                 scm_certificate_id: Optional[_builtins.str] = None,
                 tls_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_body: Specifies the content of the certificate used by the HTTPS protocol.
               This parameter is mandatory when a certificate is configured. The value is in PEM format.
               This field is required when `certificate_source` is set to `0`.
        :param _builtins.str certificate_name: Specifies the certificate name. The value contains `3` to `32` characters.
               This parameter is mandatory when a certificate is configured.
        :param _builtins.int certificate_source: Specifies the certificate source. Valid values are:
        :param _builtins.str certificate_type: Specifies the certificate type. Currently, only **server** is supported, which
               means international certificate. Defaults to **server**.
        :param _builtins.bool http2_enabled: Specifies whether HTTP/2 is used. Defaults to **false**.
               When `https_enabled` is set to **false**, this parameter does not take effect.
               
               > Currently, this field does not support closing after it is enabled.
        :param _builtins.bool https_enabled: Specifies whether to enable HTTPS. Defaults to **false**.
        :param _builtins.str ocsp_stapling_status: Specifies whether online certificate status protocol (OCSP) stapling is enabled.
               Valid values are as follows:
               + **on**: Enable.
               + **off**: Disable.
               
               Defaults to **off**.
               
               <a name="retrieval_request_header_object"></a>
               The `retrieval_request_header` block support:
        :param _builtins.str private_key: Specifies the private key used by the HTTPS protocol. This parameter is mandatory
               when a certificate is configured. The value is in PEM format.
               This field is required when `certificate_source` is set to `0`.
        :param _builtins.str scm_certificate_id: Specifies the SCM certificate ID.
               This field is required when `certificate_source` is set to `2`.
        :param _builtins.str tls_version: Specifies the transport Layer Security (TLS). Currently, **TLSv1.0**,
               **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are supported. By default, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are
               enabled. You can enable a single version or consecutive versions. To enable multiple versions, use commas (,) to
               separate versions, for example, **TLSv1.1,TLSv1.2**.
        """
        if certificate_body is not None:
            pulumi.set(__self__, "certificate_body", certificate_body)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if http2_status is not None:
            pulumi.set(__self__, "http2_status", http2_status)
        if https_enabled is not None:
            pulumi.set(__self__, "https_enabled", https_enabled)
        if https_status is not None:
            pulumi.set(__self__, "https_status", https_status)
        if ocsp_stapling_status is not None:
            pulumi.set(__self__, "ocsp_stapling_status", ocsp_stapling_status)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if scm_certificate_id is not None:
            pulumi.set(__self__, "scm_certificate_id", scm_certificate_id)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @_builtins.property
    @pulumi.getter(name="certificateBody")
    def certificate_body(self) -> Optional[_builtins.str]:
        """
        Specifies the content of the certificate used by the HTTPS protocol.
        This parameter is mandatory when a certificate is configured. The value is in PEM format.
        This field is required when `certificate_source` is set to `0`.
        """
        return pulumi.get(self, "certificate_body")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[_builtins.str]:
        """
        Specifies the certificate name. The value contains `3` to `32` characters.
        This parameter is mandatory when a certificate is configured.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[_builtins.int]:
        """
        Specifies the certificate source. Valid values are:
        """
        return pulumi.get(self, "certificate_source")

    @_builtins.property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[_builtins.str]:
        """
        Specifies the certificate type. Currently, only **server** is supported, which
        means international certificate. Defaults to **server**.
        """
        return pulumi.get(self, "certificate_type")

    @_builtins.property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether HTTP/2 is used. Defaults to **false**.
        When `https_enabled` is set to **false**, this parameter does not take effect.

        > Currently, this field does not support closing after it is enabled.
        """
        return pulumi.get(self, "http2_enabled")

    @_builtins.property
    @pulumi.getter(name="http2Status")
    def http2_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http2_status")

    @_builtins.property
    @pulumi.getter(name="httpsEnabled")
    def https_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable HTTPS. Defaults to **false**.
        """
        return pulumi.get(self, "https_enabled")

    @_builtins.property
    @pulumi.getter(name="httpsStatus")
    def https_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "https_status")

    @_builtins.property
    @pulumi.getter(name="ocspStaplingStatus")
    def ocsp_stapling_status(self) -> Optional[_builtins.str]:
        """
        Specifies whether online certificate status protocol (OCSP) stapling is enabled.
        Valid values are as follows:
        + **on**: Enable.
        + **off**: Disable.

        Defaults to **off**.

        <a name="retrieval_request_header_object"></a>
        The `retrieval_request_header` block support:
        """
        return pulumi.get(self, "ocsp_stapling_status")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        Specifies the private key used by the HTTPS protocol. This parameter is mandatory
        when a certificate is configured. The value is in PEM format.
        This field is required when `certificate_source` is set to `0`.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="scmCertificateId")
    def scm_certificate_id(self) -> Optional[_builtins.str]:
        """
        Specifies the SCM certificate ID.
        This field is required when `certificate_source` is set to `2`.
        """
        return pulumi.get(self, "scm_certificate_id")

    @_builtins.property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[_builtins.str]:
        """
        Specifies the transport Layer Security (TLS). Currently, **TLSv1.0**,
        **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are supported. By default, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3** are
        enabled. You can enable a single version or consecutive versions. To enable multiple versions, use commas (,) to
        separate versions, for example, **TLSv1.1,TLSv1.2**.
        """
        return pulumi.get(self, "tls_version")


@pulumi.output_type
class DomainConfigsIpFilter(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.str value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigsIpFrequencyLimit(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 qps: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.int qps: Specifies the access threshold, in times/second. The value ranges from `1` to `100,000`.
               This field is required when enable IP access frequency.
               
               <a name="websocket_object"></a>
               The `websocket` block support:
        """
        pulumi.set(__self__, "enabled", enabled)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[_builtins.int]:
        """
        Specifies the access threshold, in times/second. The value ranges from `1` to `100,000`.
        This field is required when enable IP access frequency.

        <a name="websocket_object"></a>
        The `websocket` block support:
        """
        return pulumi.get(self, "qps")


@pulumi.output_type
class DomainConfigsOriginRequestUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "sourceUrl":
            suggest = "source_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsOriginRequestUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsOriginRequestUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsOriginRequestUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 target_url: _builtins.str,
                 source_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param _builtins.int priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param _builtins.str target_url: Specifies a URI starts with a slash (/) and does not contain `http://`, `https://`,
               or the domain name. The value contains up to `256` characters. The nth wildcard (*) field can be substituted with
               `$n`, where n = 1, 2, 3..., for example, `/newtest/$1/$2.jpg`.
        :param _builtins.str source_url: Specifies the URI to be rewritten. The URI starts with a slash (/) and does not
               contain `http://`, `https://`, or the domain name. The value contains up to `512` characters.
               Wildcards (*) are supported, for example, `/test/*/*.mp4`. This field is invalid when `match_type` is set to **all**.
               
               <a name="user_agent_filter_object"></a>
               The `user_agent_filter` block support:
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "target_url", target_url)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        Specifies a URI starts with a slash (/) and does not contain `http://`, `https://`,
        or the domain name. The value contains up to `256` characters. The nth wildcard (*) field can be substituted with
        `$n`, where n = 1, 2, 3..., for example, `/newtest/$1/$2.jpg`.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[_builtins.str]:
        """
        Specifies the URI to be rewritten. The URI starts with a slash (/) and does not
        contain `http://`, `https://`, or the domain name. The value contains up to `512` characters.
        Wildcards (*) are supported, for example, `/test/*/*.mp4`. This field is invalid when `match_type` is set to **all**.

        <a name="user_agent_filter_object"></a>
        The `user_agent_filter` block support:
        """
        return pulumi.get(self, "source_url")


@pulumi.output_type
class DomainConfigsQuic(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainConfigsReferer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeEmpty":
            suggest = "include_empty"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsReferer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsReferer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsReferer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 include_empty: Optional[_builtins.bool] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.bool include_empty: Specifies whether empty user agents are included.
               A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
               A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
               Possible values: **true** (included) and **false** (excluded).
               The default value is **false** for a blacklist and **true** for a whitelist.
        :param _builtins.str value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[_builtins.bool]:
        """
        Specifies whether empty user agents are included.
        A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
        A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
        Possible values: **true** (included) and **false** (excluded).
        The default value is **false** for a blacklist and **true** for a whitelist.
        """
        return pulumi.get(self, "include_empty")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigsRemoteAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteAuthRules":
            suggest = "remote_auth_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsRemoteAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsRemoteAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsRemoteAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 remote_auth_rules: Optional['outputs.DomainConfigsRemoteAuthRemoteAuthRules'] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param 'DomainConfigsRemoteAuthRemoteAuthRulesArgs' remote_auth_rules: Specifies the remote authentication settings. The length of this array field
               cannot exceed `1`. The remote_auth_rules structure is documented below.
               
               <a name="remote_auth_rules_object"></a>
               The `remote_auth_rules` block support:
        """
        pulumi.set(__self__, "enabled", enabled)
        if remote_auth_rules is not None:
            pulumi.set(__self__, "remote_auth_rules", remote_auth_rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="remoteAuthRules")
    def remote_auth_rules(self) -> Optional['outputs.DomainConfigsRemoteAuthRemoteAuthRules']:
        """
        Specifies the remote authentication settings. The length of this array field
        cannot exceed `1`. The remote_auth_rules structure is documented below.

        <a name="remote_auth_rules_object"></a>
        The `remote_auth_rules` block support:
        """
        return pulumi.get(self, "remote_auth_rules")


@pulumi.output_type
class DomainConfigsRemoteAuthRemoteAuthRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authFailedStatus":
            suggest = "auth_failed_status"
        elif key == "authServer":
            suggest = "auth_server"
        elif key == "authSuccessStatus":
            suggest = "auth_success_status"
        elif key == "fileTypeSetting":
            suggest = "file_type_setting"
        elif key == "requestMethod":
            suggest = "request_method"
        elif key == "reserveArgsSetting":
            suggest = "reserve_args_setting"
        elif key == "reserveHeadersSetting":
            suggest = "reserve_headers_setting"
        elif key == "responseStatus":
            suggest = "response_status"
        elif key == "timeoutAction":
            suggest = "timeout_action"
        elif key == "addCustomArgsRules":
            suggest = "add_custom_args_rules"
        elif key == "addCustomHeadersRules":
            suggest = "add_custom_headers_rules"
        elif key == "reserveArgs":
            suggest = "reserve_args"
        elif key == "reserveHeaders":
            suggest = "reserve_headers"
        elif key == "specifiedFileType":
            suggest = "specified_file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsRemoteAuthRemoteAuthRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsRemoteAuthRemoteAuthRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsRemoteAuthRemoteAuthRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_failed_status: _builtins.str,
                 auth_server: _builtins.str,
                 auth_success_status: _builtins.str,
                 file_type_setting: _builtins.str,
                 request_method: _builtins.str,
                 reserve_args_setting: _builtins.str,
                 reserve_headers_setting: _builtins.str,
                 response_status: _builtins.str,
                 timeout: _builtins.int,
                 timeout_action: _builtins.str,
                 add_custom_args_rules: Optional[Sequence['outputs.DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule']] = None,
                 add_custom_headers_rules: Optional[Sequence['outputs.DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule']] = None,
                 reserve_args: Optional[_builtins.str] = None,
                 reserve_headers: Optional[_builtins.str] = None,
                 specified_file_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_failed_status: Specifies the status code returned by the remote authentication server
               to CDN nodes when authentication is failed. Value range: **4xx** and **5xx**.
        :param _builtins.str auth_server: Specifies the address of a reachable server. The address must include **http://** or
               **https://**. The address cannot be a local address such as **localhost** or **127.0.0.1**. The address cannot be an
               acceleration domain name added on CDN.
        :param _builtins.str auth_success_status: Specifies the status code returned by the remote authentication server
               to CDN nodes when authentication is successful. Value range: **2xx** and **3xx**.
        :param _builtins.str file_type_setting: Specifies the authentication file type settings. Valid values are:
               + **all**: Requests for all files are authenticated.
               + **specific_file**: Requests for files of specific types are authenticated.
        :param _builtins.str request_method: Specifies the request method supported by the authentication server. Valid values
               are **GET**, **POST**, and **HEAD**.
        :param _builtins.str reserve_args_setting: Specifies the parameters that need to be authenticated in user requests.
               Valid values are as follows:
               + **reserve_all_args**: Retain all URL parameters.
               + **reserve_specific_args**: Retain specified URL parameters.
               + **ignore_all_args**: Ignore all URL parameters.
        :param _builtins.str reserve_headers_setting: Specifies the headers to be authenticated in user requests.
               Valid values are as follows:
               + **reserve_all_headers**: Retain all request headers.
               + **reserve_specific_headers**: Retain specified request headers.
               + **ignore_all_headers**: Ignore all request headers.
        :param _builtins.str response_status: Specifies the status code returned by CDN nodes to users when authentication
               is failed. Value range: **2xx**, **3xx**, **4xx**, and **5xx**.
        :param _builtins.int timeout: Specifies the duration from the time when a CDN node forwards an authentication request
               to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
               ranging from `50` to `3,000`. The unit is millisecond.
        :param _builtins.str timeout_action: Specifies the action of the CDN nodes to process user requests after the
               authentication timeout. Valid values are as follows:
               + **pass**: The user request is allowed and the corresponding resource is returned after the authentication times out.
               + **forbid**: The user request is rejected after the authentication times out and the configured status code is
               returned to the user.
        :param Sequence['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRuleArgs'] add_custom_args_rules: Specifies the URL validation parameters.
               The add_custom_args_rules structure is documented below.
        :param Sequence['DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRuleArgs'] add_custom_headers_rules: Specifies the request header authentication parameters.
               The add_custom_headers_rules structure is documented below.
               
               <a name="add_custom_rules_object"></a>
               The `add_custom_args_rules` and `add_custom_headers_rules` block support:
        :param _builtins.str reserve_args: Specifies the reserve args. Multiple args are separated by vertical bars (|).
               For example: **key1|key2**. This parameter is mandatory when `reserve_args_setting` is set to **reserve_specific_args**.
               In other cases, this parameter is left blank.
        :param _builtins.str reserve_headers: Specifies the reserve headers. Multiple headers are separated by vertical bars (|).
               For example: **key1|key2**. This parameter is mandatory when `reserve_headers_setting` is set to **reserve_specific_headers**.
               In other cases, this parameter is left blank.
        :param _builtins.str specified_file_type: Specifies the specific file types. The value contains letters and digits.
               The value contains up to `512` characters. File types are not case-sensitive, and multiple file types are separated
               by vertical bars (|). For example: **jpg|MP4**. This parameter is mandatory when `file_type_setting` is set to
               **specific_file**. In other cases, this parameter is left blank.
        """
        pulumi.set(__self__, "auth_failed_status", auth_failed_status)
        pulumi.set(__self__, "auth_server", auth_server)
        pulumi.set(__self__, "auth_success_status", auth_success_status)
        pulumi.set(__self__, "file_type_setting", file_type_setting)
        pulumi.set(__self__, "request_method", request_method)
        pulumi.set(__self__, "reserve_args_setting", reserve_args_setting)
        pulumi.set(__self__, "reserve_headers_setting", reserve_headers_setting)
        pulumi.set(__self__, "response_status", response_status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "timeout_action", timeout_action)
        if add_custom_args_rules is not None:
            pulumi.set(__self__, "add_custom_args_rules", add_custom_args_rules)
        if add_custom_headers_rules is not None:
            pulumi.set(__self__, "add_custom_headers_rules", add_custom_headers_rules)
        if reserve_args is not None:
            pulumi.set(__self__, "reserve_args", reserve_args)
        if reserve_headers is not None:
            pulumi.set(__self__, "reserve_headers", reserve_headers)
        if specified_file_type is not None:
            pulumi.set(__self__, "specified_file_type", specified_file_type)

    @_builtins.property
    @pulumi.getter(name="authFailedStatus")
    def auth_failed_status(self) -> _builtins.str:
        """
        Specifies the status code returned by the remote authentication server
        to CDN nodes when authentication is failed. Value range: **4xx** and **5xx**.
        """
        return pulumi.get(self, "auth_failed_status")

    @_builtins.property
    @pulumi.getter(name="authServer")
    def auth_server(self) -> _builtins.str:
        """
        Specifies the address of a reachable server. The address must include **http://** or
        **https://**. The address cannot be a local address such as **localhost** or **127.0.0.1**. The address cannot be an
        acceleration domain name added on CDN.
        """
        return pulumi.get(self, "auth_server")

    @_builtins.property
    @pulumi.getter(name="authSuccessStatus")
    def auth_success_status(self) -> _builtins.str:
        """
        Specifies the status code returned by the remote authentication server
        to CDN nodes when authentication is successful. Value range: **2xx** and **3xx**.
        """
        return pulumi.get(self, "auth_success_status")

    @_builtins.property
    @pulumi.getter(name="fileTypeSetting")
    def file_type_setting(self) -> _builtins.str:
        """
        Specifies the authentication file type settings. Valid values are:
        + **all**: Requests for all files are authenticated.
        + **specific_file**: Requests for files of specific types are authenticated.
        """
        return pulumi.get(self, "file_type_setting")

    @_builtins.property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> _builtins.str:
        """
        Specifies the request method supported by the authentication server. Valid values
        are **GET**, **POST**, and **HEAD**.
        """
        return pulumi.get(self, "request_method")

    @_builtins.property
    @pulumi.getter(name="reserveArgsSetting")
    def reserve_args_setting(self) -> _builtins.str:
        """
        Specifies the parameters that need to be authenticated in user requests.
        Valid values are as follows:
        + **reserve_all_args**: Retain all URL parameters.
        + **reserve_specific_args**: Retain specified URL parameters.
        + **ignore_all_args**: Ignore all URL parameters.
        """
        return pulumi.get(self, "reserve_args_setting")

    @_builtins.property
    @pulumi.getter(name="reserveHeadersSetting")
    def reserve_headers_setting(self) -> _builtins.str:
        """
        Specifies the headers to be authenticated in user requests.
        Valid values are as follows:
        + **reserve_all_headers**: Retain all request headers.
        + **reserve_specific_headers**: Retain specified request headers.
        + **ignore_all_headers**: Ignore all request headers.
        """
        return pulumi.get(self, "reserve_headers_setting")

    @_builtins.property
    @pulumi.getter(name="responseStatus")
    def response_status(self) -> _builtins.str:
        """
        Specifies the status code returned by CDN nodes to users when authentication
        is failed. Value range: **2xx**, **3xx**, **4xx**, and **5xx**.
        """
        return pulumi.get(self, "response_status")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        Specifies the duration from the time when a CDN node forwards an authentication request
        to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
        ranging from `50` to `3,000`. The unit is millisecond.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> _builtins.str:
        """
        Specifies the action of the CDN nodes to process user requests after the
        authentication timeout. Valid values are as follows:
        + **pass**: The user request is allowed and the corresponding resource is returned after the authentication times out.
        + **forbid**: The user request is rejected after the authentication times out and the configured status code is
        returned to the user.
        """
        return pulumi.get(self, "timeout_action")

    @_builtins.property
    @pulumi.getter(name="addCustomArgsRules")
    def add_custom_args_rules(self) -> Optional[Sequence['outputs.DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule']]:
        """
        Specifies the URL validation parameters.
        The add_custom_args_rules structure is documented below.
        """
        return pulumi.get(self, "add_custom_args_rules")

    @_builtins.property
    @pulumi.getter(name="addCustomHeadersRules")
    def add_custom_headers_rules(self) -> Optional[Sequence['outputs.DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule']]:
        """
        Specifies the request header authentication parameters.
        The add_custom_headers_rules structure is documented below.

        <a name="add_custom_rules_object"></a>
        The `add_custom_args_rules` and `add_custom_headers_rules` block support:
        """
        return pulumi.get(self, "add_custom_headers_rules")

    @_builtins.property
    @pulumi.getter(name="reserveArgs")
    def reserve_args(self) -> Optional[_builtins.str]:
        """
        Specifies the reserve args. Multiple args are separated by vertical bars (|).
        For example: **key1|key2**. This parameter is mandatory when `reserve_args_setting` is set to **reserve_specific_args**.
        In other cases, this parameter is left blank.
        """
        return pulumi.get(self, "reserve_args")

    @_builtins.property
    @pulumi.getter(name="reserveHeaders")
    def reserve_headers(self) -> Optional[_builtins.str]:
        """
        Specifies the reserve headers. Multiple headers are separated by vertical bars (|).
        For example: **key1|key2**. This parameter is mandatory when `reserve_headers_setting` is set to **reserve_specific_headers**.
        In other cases, this parameter is left blank.
        """
        return pulumi.get(self, "reserve_headers")

    @_builtins.property
    @pulumi.getter(name="specifiedFileType")
    def specified_file_type(self) -> Optional[_builtins.str]:
        """
        Specifies the specific file types. The value contains letters and digits.
        The value contains up to `512` characters. File types are not case-sensitive, and multiple file types are separated
        by vertical bars (|). For example: **jpg|MP4**. This parameter is mandatory when `file_type_setting` is set to
        **specific_file**. In other cases, this parameter is left blank.
        """
        return pulumi.get(self, "specified_file_type")


@pulumi.output_type
class DomainConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the parameter key. The value contains up to `256` characters. The value can be
               composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.str value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the parameter key. The value contains up to `256` characters. The value can be
               composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.str value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigsRequestLimitRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitRateAfter":
            suggest = "limit_rate_after"
        elif key == "limitRateValue":
            suggest = "limit_rate_value"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsRequestLimitRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsRequestLimitRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsRequestLimitRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_rate_after: _builtins.int,
                 limit_rate_value: _builtins.int,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 type: _builtins.str,
                 match_value: Optional[_builtins.str] = None):
        """
        :param _builtins.int limit_rate_after: Specifies the rate limiting condition. Unit: byte.
               The value ranges from `0` to `1,073,741,824`.
        :param _builtins.int limit_rate_value: Specifies the rate limiting value, in bit/s.
               The value ranges from `0` to `104,857,600`.
               
               > The speed is limited to the value of `limit_rate_value` after `limit_rate_after` bytes are transmitted.
        :param _builtins.str match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param _builtins.int priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.str match_value: Specifies the cache match settings.
               + When `match_type` is set to **all**, this field does not need to be configured.
               + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
               value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
               not exceed `20`.
               + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
               be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
               exceed `20`.
               + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
               It supports matching specific files in the specified directory or files with a wildcard "*".
               The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
               single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
               + When `match_type` is set to **home_page**, this field does not need to be configured.
               
               <a name="access_area_filter_object"></a>
               The `access_area_filter` block support:
        """
        pulumi.set(__self__, "limit_rate_after", limit_rate_after)
        pulumi.set(__self__, "limit_rate_value", limit_rate_value)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="limitRateAfter")
    def limit_rate_after(self) -> _builtins.int:
        """
        Specifies the rate limiting condition. Unit: byte.
        The value ranges from `0` to `1,073,741,824`.
        """
        return pulumi.get(self, "limit_rate_after")

    @_builtins.property
    @pulumi.getter(name="limitRateValue")
    def limit_rate_value(self) -> _builtins.int:
        """
        Specifies the rate limiting value, in bit/s.
        The value ranges from `0` to `104,857,600`.

        > The speed is limited to the value of `limit_rate_value` after `limit_rate_after` bytes are transmitted.
        """
        return pulumi.get(self, "limit_rate_value")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
        return pulumi.get(self, "match_value")


@pulumi.output_type
class DomainConfigsRequestUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionMode":
            suggest = "execution_mode"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "redirectHost":
            suggest = "redirect_host"
        elif key == "redirectStatusCode":
            suggest = "redirect_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsRequestUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsRequestUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsRequestUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.DomainConfigsRequestUrlRewriteCondition',
                 execution_mode: _builtins.str,
                 redirect_url: _builtins.str,
                 redirect_host: Optional[_builtins.str] = None,
                 redirect_status_code: Optional[_builtins.int] = None):
        """
        :param 'DomainConfigsRequestUrlRewriteConditionArgs' condition: Specifies matching condition.
               The condition structure is documented below.
        :param _builtins.str execution_mode: Specifies the execution mode. Valid values are:
               + **redirect**: If the requested URL matches the current rule, the request will be redirected to the target path.
               After the current rule is executed, if there are other configured rules, the remaining rules will continue to be matched.
               + **break**: If the requested URL matches the current rule, the request will be rewritten to the target path.
               After the current rule is executed, if there are other configured rules, the remaining rules will no longer be matched.
               The redirection host and redirection status code are not supported at this time, and the status code `200` is returned.
        :param _builtins.str redirect_url: Specifies the redirect URL. The redirected URL starts with a forward slash (/)
               and does not contain the http:// header or domain name. Example: **/test/index.html**.
        :param _builtins.str redirect_host: Specifies the domain name to redirect client requests.
               
               > 1. The current domain name will be used by default.
               <br/>2. This field supports a character length of `1`-`255` and must start with http:// or https://.
               
               <a name="request_url_rewrite_condition_object"></a>
               The `condition` block support:
        :param _builtins.int redirect_status_code: Specifies the redirect status code. Supports `301`, `302`, `303`, and `307`.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "execution_mode", execution_mode)
        pulumi.set(__self__, "redirect_url", redirect_url)
        if redirect_host is not None:
            pulumi.set(__self__, "redirect_host", redirect_host)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.DomainConfigsRequestUrlRewriteCondition':
        """
        Specifies matching condition.
        The condition structure is documented below.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter(name="executionMode")
    def execution_mode(self) -> _builtins.str:
        """
        Specifies the execution mode. Valid values are:
        + **redirect**: If the requested URL matches the current rule, the request will be redirected to the target path.
        After the current rule is executed, if there are other configured rules, the remaining rules will continue to be matched.
        + **break**: If the requested URL matches the current rule, the request will be rewritten to the target path.
        After the current rule is executed, if there are other configured rules, the remaining rules will no longer be matched.
        The redirection host and redirection status code are not supported at this time, and the status code `200` is returned.
        """
        return pulumi.get(self, "execution_mode")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> _builtins.str:
        """
        Specifies the redirect URL. The redirected URL starts with a forward slash (/)
        and does not contain the http:// header or domain name. Example: **/test/index.html**.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="redirectHost")
    def redirect_host(self) -> Optional[_builtins.str]:
        """
        Specifies the domain name to redirect client requests.

        > 1. The current domain name will be used by default.
        <br/>2. This field supports a character length of `1`-`255` and must start with http:// or https://.

        <a name="request_url_rewrite_condition_object"></a>
        The `condition` block support:
        """
        return pulumi.get(self, "redirect_host")

    @_builtins.property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[_builtins.int]:
        """
        Specifies the redirect status code. Supports `301`, `302`, `303`, and `307`.
        """
        return pulumi.get(self, "redirect_status_code")


@pulumi.output_type
class DomainConfigsRequestUrlRewriteCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsRequestUrlRewriteCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsRequestUrlRewriteCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsRequestUrlRewriteCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 match_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param _builtins.int priority: Specifies the priority weight of this rule. The default value is 1.
               A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        :param _builtins.str match_value: Specifies the cache match settings.
               + When `match_type` is set to **all**, this field does not need to be configured.
               + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
               value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
               not exceed `20`.
               + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
               be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
               exceed `20`.
               + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
               It supports matching specific files in the specified directory or files with a wildcard "*".
               The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
               single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
               + When `match_type` is set to **home_page**, this field does not need to be configured.
               
               <a name="access_area_filter_object"></a>
               The `access_area_filter` block support:
        """
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Specifies the priority weight of this rule. The default value is 1.
        A larger value indicates a higher priority. The value ranges from 1 to 100. The weight values must be unique.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        """
        Specifies the cache match settings.
        + When `match_type` is set to **all**, this field does not need to be configured.
        + When `match_type` is set to **file_extension**, this field value is the file suffix. The first character of the
        value is "." and separated by "," such as **.jpg,.zip,.exe**. The total number of file name suffixes entered should
        not exceed `20`.
        + When `match_type` is set to **catalog**, the value of this field is a directory. The value must start with "/" and
        be separated by "," such as **/test/folder01,/test/folder02**. The total number of directory paths entered must not
        exceed `20`.
        + When `match_type` is set to **full_path**, the value of this field is a full path. The value must start with "/".
        It supports matching specific files in the specified directory or files with a wildcard "*".
        The position of "*" must be after the last "/" and cannot end with "*". Only one full path can be configured in a
        single full path cache rule, such as **/test/index.html** or ***/test/*.jpg**.
        + When `match_type` is set to **home_page**, this field does not need to be configured.

        <a name="access_area_filter_object"></a>
        The `access_area_filter` block support:
        """
        return pulumi.get(self, "match_value")


@pulumi.output_type
class DomainConfigsRetrievalRequestHeader(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        :param _builtins.str name: Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
               **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
               **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
               and hyphens (-), and starts with a letter.
        :param _builtins.str value: Specifies the IP address blacklist or whitelist. This field is required when `type` is
               set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
               by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
               Addresses with wildcard characters are not supported, for example, `192.168.0.*`.
               
               <a name="origin_request_url_rewrite_object"></a>
               The `origin_request_url_rewrite` block support:
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Specifies the operation type of the HTTP response header. The value can be **set** or **delete**.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the HTTP response header. Valid values are **Content-Disposition**, **Content-Language**,
        **Access-Control-Allow-Origin**, **Access-Control-Allow-Methods**, **Access-Control-Max-Age**, **Access-Control-Expose-Headers**,
        **Access-Control-Allow-Headers** or custom headers. A header contains `1` to `100` characters, including letters, digits,
        and hyphens (-), and starts with a letter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the IP address blacklist or whitelist. This field is required when `type` is
        set to **black** or **white**. A list contains up to `500` IP addresses and IP address segments, which are separated
        by commas (,). IPv6 addresses are supported. Duplicate IP addresses and IP address segments will be removed.
        Addresses with wildcard characters are not supported, for example, `192.168.0.*`.

        <a name="origin_request_url_rewrite_object"></a>
        The `origin_request_url_rewrite` block support:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigsSni(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsSni. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsSni.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsSni.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 server_name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.str server_name: Specifies the origin server domain name that the CDN node needs to access when
               returning to the source.
               
               > 1. This file is required when enable SNI settings. <br/>2. Wildcard domain names are not supported.
               Only digital, "-", ".", and uppercase and lowercase English characters are supported.
               
               <a name="request_url_rewrite_object"></a>
               The `request_url_rewrite` block support:
        """
        pulumi.set(__self__, "enabled", enabled)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        """
        Specifies the origin server domain name that the CDN node needs to access when
        returning to the source.

        > 1. This file is required when enable SNI settings. <br/>2. Wildcard domain names are not supported.
        Only digital, "-", ".", and uppercase and lowercase English characters are supported.

        <a name="request_url_rewrite_object"></a>
        The `request_url_rewrite` block support:
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class DomainConfigsUrlSigning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupKey":
            suggest = "backup_key"
        elif key == "expireTime":
            suggest = "expire_time"
        elif key == "inheritConfig":
            suggest = "inherit_config"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "signArg":
            suggest = "sign_arg"
        elif key == "signMethod":
            suggest = "sign_method"
        elif key == "timeFormat":
            suggest = "time_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsUrlSigning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsUrlSigning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsUrlSigning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 backup_key: Optional[_builtins.str] = None,
                 expire_time: Optional[_builtins.int] = None,
                 inherit_config: Optional['outputs.DomainConfigsUrlSigningInheritConfig'] = None,
                 key: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 sign_arg: Optional[_builtins.str] = None,
                 sign_method: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 time_format: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.str backup_key: Specifies the standby authentication key contains `16` to `32` characters,
               including letters and digits.
        :param _builtins.int expire_time: Specifies the expiration time. The value ranges from `0` to `31536000`, in seconds.
               
               <a name="inherit_config_object"></a>
               The `inherit_config` blocks support:
        :param 'DomainConfigsUrlSigningInheritConfigArgs' inherit_config: Specifies the details of the authentication inheritance.
               The inherit_config structure is documented below.
               
               > Add authentication parameters to TS and MP4 files under M3U8/MPD index files, so that the files can be played
               after authentication succeeds.
        :param _builtins.str key: Specifies the parameter key. The value contains up to `256` characters. The value can be
               composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        :param _builtins.str match_type: Specifies the match type. Valid values are:
               + **all**: Match all files.
               + **file_extension**: Match by file suffix.
               + **catalog**: Match by directory.
               + **full_path**: Full path matching.
               + **home_page**: Match by homepage.
        :param _builtins.str sign_arg: Specifies the authentication parameters. The default value is **auth_key**.
               The valid length is limited from `1` to `100` characters, only letters, digits, and underscores (_) are allowed.
               The value can not start with a digit.
        :param _builtins.str sign_method: Specifies the encryption algorithm type for URL authentication.
               The default value is **md5**. The valid values are as following:
               + **md5**
               + **sha256**
        :param _builtins.str time_format: Specifies the time format. Possible values are:
               **dec**: Decimal, can be used in Method A, Method B and Method C2.
               **hex**: Hexadecimal, can be used in Method C1 and Method C2.
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        """
        pulumi.set(__self__, "enabled", enabled)
        if backup_key is not None:
            pulumi.set(__self__, "backup_key", backup_key)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if inherit_config is not None:
            pulumi.set(__self__, "inherit_config", inherit_config)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if sign_arg is not None:
            pulumi.set(__self__, "sign_arg", sign_arg)
        if sign_method is not None:
            pulumi.set(__self__, "sign_method", sign_method)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="backupKey")
    def backup_key(self) -> Optional[_builtins.str]:
        """
        Specifies the standby authentication key contains `16` to `32` characters,
        including letters and digits.
        """
        return pulumi.get(self, "backup_key")

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[_builtins.int]:
        """
        Specifies the expiration time. The value ranges from `0` to `31536000`, in seconds.

        <a name="inherit_config_object"></a>
        The `inherit_config` blocks support:
        """
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter(name="inheritConfig")
    def inherit_config(self) -> Optional['outputs.DomainConfigsUrlSigningInheritConfig']:
        """
        Specifies the details of the authentication inheritance.
        The inherit_config structure is documented below.

        > Add authentication parameters to TS and MP4 files under M3U8/MPD index files, so that the files can be played
        after authentication succeeds.
        """
        return pulumi.get(self, "inherit_config")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Specifies the parameter key. The value contains up to `256` characters. The value can be
        composed of digits, uppercase letters, lowercase letters, and special characters (._-*#%|+^@?=).
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        Specifies the match type. Valid values are:
        + **all**: Match all files.
        + **file_extension**: Match by file suffix.
        + **catalog**: Match by directory.
        + **full_path**: Full path matching.
        + **home_page**: Match by homepage.
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="signArg")
    def sign_arg(self) -> Optional[_builtins.str]:
        """
        Specifies the authentication parameters. The default value is **auth_key**.
        The valid length is limited from `1` to `100` characters, only letters, digits, and underscores (_) are allowed.
        The value can not start with a digit.
        """
        return pulumi.get(self, "sign_arg")

    @_builtins.property
    @pulumi.getter(name="signMethod")
    def sign_method(self) -> Optional[_builtins.str]:
        """
        Specifies the encryption algorithm type for URL authentication.
        The default value is **md5**. The valid values are as following:
        + **md5**
        + **sha256**
        """
        return pulumi.get(self, "sign_method")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        """
        Specifies the time format. Possible values are:
        **dec**: Decimal, can be used in Method A, Method B and Method C2.
        **hex**: Hexadecimal, can be used in Method C1 and Method C2.
        """
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainConfigsUrlSigningInheritConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inheritTimeType":
            suggest = "inherit_time_type"
        elif key == "inheritType":
            suggest = "inherit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsUrlSigningInheritConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsUrlSigningInheritConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsUrlSigningInheritConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 inherit_time_type: Optional[_builtins.str] = None,
                 inherit_type: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.str inherit_time_type: Specifies the time type that inherits authentication settings.
               The valid values are as follows:
               + **sys_time**: The current system time.
               + **parent_url_time**: The time when a user accesses the M3U8/MPD file.
               
               > This parameter is mandatory when authentication inheritance is enabled.
               
               <a name="force_redirect_object"></a>
               The `force_redirect` blocks support:
        :param _builtins.str inherit_type: Specifies the authentication inheritance configuration.
               The valid values are **m3u8** and **mpd**. Separate multiple values with commas (,). e.g. **m3u8,mpd**.
               
               > This parameter is mandatory when authentication inheritance is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        if inherit_time_type is not None:
            pulumi.set(__self__, "inherit_time_type", inherit_time_type)
        if inherit_type is not None:
            pulumi.set(__self__, "inherit_type", inherit_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="inheritTimeType")
    def inherit_time_type(self) -> Optional[_builtins.str]:
        """
        Specifies the time type that inherits authentication settings.
        The valid values are as follows:
        + **sys_time**: The current system time.
        + **parent_url_time**: The time when a user accesses the M3U8/MPD file.

        > This parameter is mandatory when authentication inheritance is enabled.

        <a name="force_redirect_object"></a>
        The `force_redirect` blocks support:
        """
        return pulumi.get(self, "inherit_time_type")

    @_builtins.property
    @pulumi.getter(name="inheritType")
    def inherit_type(self) -> Optional[_builtins.str]:
        """
        Specifies the authentication inheritance configuration.
        The valid values are **m3u8** and **mpd**. Separate multiple values with commas (,). e.g. **m3u8,mpd**.

        > This parameter is mandatory when authentication inheritance is enabled.
        """
        return pulumi.get(self, "inherit_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class DomainConfigsUserAgentFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeEmpty":
            suggest = "include_empty"
        elif key == "uaLists":
            suggest = "ua_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsUserAgentFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsUserAgentFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsUserAgentFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 include_empty: Optional[_builtins.str] = None,
                 ua_lists: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: Specifies the blacklist and whitelist rule type. Valid values are:
               + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
               returned.
               + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
               returned for other users.
        :param _builtins.str include_empty: Specifies whether empty user agents are included.
               A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
               A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
               Possible values: **true** (included) and **false** (excluded).
               The default value is **false** for a blacklist and **true** for a whitelist.
        :param Sequence[_builtins.str] ua_lists: Specifies the User-Agent blacklist or whitelist. This parameter is required when `type`
               is set to **black** or **white**. Up to `10` rules can be configured. A rule contains up to `100` characters.
               
               <a name="error_code_redirect_rules_object"></a>
               The `error_code_redirect_rules` block support:
        """
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if ua_lists is not None:
            pulumi.set(__self__, "ua_lists", ua_lists)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type. Valid values are:
        + **black**: Blacklist. Users in regions specified in the blacklist cannot access resources and status code `403` is
        returned.
        + **white**: Whitelist. Only users in regions specified in the whitelist can access resources. Status code `403` is
        returned for other users.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[_builtins.str]:
        """
        Specifies whether empty user agents are included.
        A User-Agent blacklist including empty user agents indicates that requests without a user agent are rejected.
        A User-Agent whitelist including empty user agents indicates that requests without a user agent are accepted.
        Possible values: **true** (included) and **false** (excluded).
        The default value is **false** for a blacklist and **true** for a whitelist.
        """
        return pulumi.get(self, "include_empty")

    @_builtins.property
    @pulumi.getter(name="uaLists")
    def ua_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the User-Agent blacklist or whitelist. This parameter is required when `type`
        is set to **black** or **white**. Up to `10` rules can be configured. A rule contains up to `100` characters.

        <a name="error_code_redirect_rules_object"></a>
        The `error_code_redirect_rules` block support:
        """
        return pulumi.get(self, "ua_lists")


@pulumi.output_type
class DomainConfigsVideoSeek(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableVideoSeek":
            suggest = "enable_video_seek"
        elif key == "enableFlvByTimeSeek":
            suggest = "enable_flv_by_time_seek"
        elif key == "endParameter":
            suggest = "end_parameter"
        elif key == "startParameter":
            suggest = "start_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigsVideoSeek. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigsVideoSeek.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigsVideoSeek.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_video_seek: _builtins.bool,
                 enable_flv_by_time_seek: Optional[_builtins.bool] = None,
                 end_parameter: Optional[_builtins.str] = None,
                 start_parameter: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable_video_seek: Specifies the video seek status. **true**: enabled; **false**: disabled.
        :param _builtins.bool enable_flv_by_time_seek: Specifies the time-based `FLV` seek status.
               **true**: enabled; **false**: disabled. Defaults to **false**.
        :param _builtins.str end_parameter: Specifies the video playback end parameter in user request URLs.
               The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
               
               <a name="request_limit_rules_object"></a>
               The `request_limit_rules` block support:
        :param _builtins.str start_parameter: Specifies the video playback start parameter in user request URLs.
               The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
        """
        pulumi.set(__self__, "enable_video_seek", enable_video_seek)
        if enable_flv_by_time_seek is not None:
            pulumi.set(__self__, "enable_flv_by_time_seek", enable_flv_by_time_seek)
        if end_parameter is not None:
            pulumi.set(__self__, "end_parameter", end_parameter)
        if start_parameter is not None:
            pulumi.set(__self__, "start_parameter", start_parameter)

    @_builtins.property
    @pulumi.getter(name="enableVideoSeek")
    def enable_video_seek(self) -> _builtins.bool:
        """
        Specifies the video seek status. **true**: enabled; **false**: disabled.
        """
        return pulumi.get(self, "enable_video_seek")

    @_builtins.property
    @pulumi.getter(name="enableFlvByTimeSeek")
    def enable_flv_by_time_seek(self) -> Optional[_builtins.bool]:
        """
        Specifies the time-based `FLV` seek status.
        **true**: enabled; **false**: disabled. Defaults to **false**.
        """
        return pulumi.get(self, "enable_flv_by_time_seek")

    @_builtins.property
    @pulumi.getter(name="endParameter")
    def end_parameter(self) -> Optional[_builtins.str]:
        """
        Specifies the video playback end parameter in user request URLs.
        The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.

        <a name="request_limit_rules_object"></a>
        The `request_limit_rules` block support:
        """
        return pulumi.get(self, "end_parameter")

    @_builtins.property
    @pulumi.getter(name="startParameter")
    def start_parameter(self) -> Optional[_builtins.str]:
        """
        Specifies the video playback start parameter in user request URLs.
        The value contains up to `64` characters. Only letters, digits, and underscores (_) are allowed.
        """
        return pulumi.get(self, "start_parameter")


@pulumi.output_type
class DomainConfigsWebsocket(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Specifies whether to enable client cert settings.
        :param _builtins.int timeout: Specifies the duration from the time when a CDN node forwards an authentication request
               to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
               ranging from `50` to `3,000`. The unit is millisecond.
        """
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable client cert settings.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the duration from the time when a CDN node forwards an authentication request
        to the time when the CDN node receives the result returned by the remote authentication server. Enter `0` or a value
        ranging from `50` to `3,000`. The unit is millisecond.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainRuleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Sequence['outputs.DomainRuleRuleAction'],
                 conditions: 'outputs.DomainRuleRuleConditions',
                 name: _builtins.str,
                 priority: _builtins.int,
                 status: _builtins.str,
                 rule_id: Optional[_builtins.str] = None):
        """
        :param Sequence['DomainRuleRuleActionArgs'] actions: Specifies a list of actions to be performed when the rules are met
        :param _builtins.str name: Specifies the rule name. The valid length is limit from `1` to `50`.
        :param _builtins.int priority: Specifies the rule priority. The valid value is limit from 1 to 100.
        :param _builtins.str status: Specifies the rule status. Valid values are **on** and **off**.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "status", status)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.DomainRuleRuleAction']:
        """
        Specifies a list of actions to be performed when the rules are met
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> 'outputs.DomainRuleRuleConditions':
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the rule name. The valid length is limit from `1` to `50`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Specifies the rule priority. The valid value is limit from 1 to 100.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the rule status. Valid values are **on** and **off**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_id")


@pulumi.output_type
class DomainRuleRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessControl":
            suggest = "access_control"
        elif key == "cacheRule":
            suggest = "cache_rule"
        elif key == "flexibleOrigins":
            suggest = "flexible_origins"
        elif key == "httpResponseHeaders":
            suggest = "http_response_headers"
        elif key == "originRequestHeaders":
            suggest = "origin_request_headers"
        elif key == "originRequestUrlRewrite":
            suggest = "origin_request_url_rewrite"
        elif key == "requestUrlRewrite":
            suggest = "request_url_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_control: Optional['outputs.DomainRuleRuleActionAccessControl'] = None,
                 cache_rule: Optional['outputs.DomainRuleRuleActionCacheRule'] = None,
                 flexible_origins: Optional[Sequence['outputs.DomainRuleRuleActionFlexibleOrigin']] = None,
                 http_response_headers: Optional[Sequence['outputs.DomainRuleRuleActionHttpResponseHeader']] = None,
                 origin_request_headers: Optional[Sequence['outputs.DomainRuleRuleActionOriginRequestHeader']] = None,
                 origin_request_url_rewrite: Optional['outputs.DomainRuleRuleActionOriginRequestUrlRewrite'] = None,
                 request_url_rewrite: Optional['outputs.DomainRuleRuleActionRequestUrlRewrite'] = None):
        if access_control is not None:
            pulumi.set(__self__, "access_control", access_control)
        if cache_rule is not None:
            pulumi.set(__self__, "cache_rule", cache_rule)
        if flexible_origins is not None:
            pulumi.set(__self__, "flexible_origins", flexible_origins)
        if http_response_headers is not None:
            pulumi.set(__self__, "http_response_headers", http_response_headers)
        if origin_request_headers is not None:
            pulumi.set(__self__, "origin_request_headers", origin_request_headers)
        if origin_request_url_rewrite is not None:
            pulumi.set(__self__, "origin_request_url_rewrite", origin_request_url_rewrite)
        if request_url_rewrite is not None:
            pulumi.set(__self__, "request_url_rewrite", request_url_rewrite)

    @_builtins.property
    @pulumi.getter(name="accessControl")
    def access_control(self) -> Optional['outputs.DomainRuleRuleActionAccessControl']:
        return pulumi.get(self, "access_control")

    @_builtins.property
    @pulumi.getter(name="cacheRule")
    def cache_rule(self) -> Optional['outputs.DomainRuleRuleActionCacheRule']:
        return pulumi.get(self, "cache_rule")

    @_builtins.property
    @pulumi.getter(name="flexibleOrigins")
    def flexible_origins(self) -> Optional[Sequence['outputs.DomainRuleRuleActionFlexibleOrigin']]:
        return pulumi.get(self, "flexible_origins")

    @_builtins.property
    @pulumi.getter(name="httpResponseHeaders")
    def http_response_headers(self) -> Optional[Sequence['outputs.DomainRuleRuleActionHttpResponseHeader']]:
        return pulumi.get(self, "http_response_headers")

    @_builtins.property
    @pulumi.getter(name="originRequestHeaders")
    def origin_request_headers(self) -> Optional[Sequence['outputs.DomainRuleRuleActionOriginRequestHeader']]:
        return pulumi.get(self, "origin_request_headers")

    @_builtins.property
    @pulumi.getter(name="originRequestUrlRewrite")
    def origin_request_url_rewrite(self) -> Optional['outputs.DomainRuleRuleActionOriginRequestUrlRewrite']:
        return pulumi.get(self, "origin_request_url_rewrite")

    @_builtins.property
    @pulumi.getter(name="requestUrlRewrite")
    def request_url_rewrite(self) -> Optional['outputs.DomainRuleRuleActionRequestUrlRewrite']:
        return pulumi.get(self, "request_url_rewrite")


@pulumi.output_type
class DomainRuleRuleActionAccessControl(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Specifies the access control type. Valid values are **block** and **trust**.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the access control type. Valid values are **block** and **trust**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainRuleRuleActionCacheRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "followOrigin":
            suggest = "follow_origin"
        elif key == "ttlUnit":
            suggest = "ttl_unit"
        elif key == "forceCache":
            suggest = "force_cache"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleRuleActionCacheRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleRuleActionCacheRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleRuleActionCacheRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 follow_origin: _builtins.str,
                 ttl: _builtins.int,
                 ttl_unit: _builtins.str,
                 force_cache: Optional[_builtins.str] = None):
        """
        :param _builtins.str follow_origin: Specifies the cache expiration time source. Valid values: **off**, **on**, and **min_ttl**
        :param _builtins.int ttl: Specifies the cache expiration time.
        :param _builtins.str ttl_unit: Specifies the cache expiration time unit. Valid values: **s**, **m**, **h**, and **d**
        :param _builtins.str force_cache: Specifies whether to enable forced caching. Valid values are **on** and **off**.
        """
        pulumi.set(__self__, "follow_origin", follow_origin)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "ttl_unit", ttl_unit)
        if force_cache is not None:
            pulumi.set(__self__, "force_cache", force_cache)

    @_builtins.property
    @pulumi.getter(name="followOrigin")
    def follow_origin(self) -> _builtins.str:
        """
        Specifies the cache expiration time source. Valid values: **off**, **on**, and **min_ttl**
        """
        return pulumi.get(self, "follow_origin")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        Specifies the cache expiration time.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="ttlUnit")
    def ttl_unit(self) -> _builtins.str:
        """
        Specifies the cache expiration time unit. Valid values: **s**, **m**, **h**, and **d**
        """
        return pulumi.get(self, "ttl_unit")

    @_builtins.property
    @pulumi.getter(name="forceCache")
    def force_cache(self) -> Optional[_builtins.str]:
        """
        Specifies whether to enable forced caching. Valid values are **on** and **off**.
        """
        return pulumi.get(self, "force_cache")


@pulumi.output_type
class DomainRuleRuleActionFlexibleOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipOrDomain":
            suggest = "ip_or_domain"
        elif key == "originProtocol":
            suggest = "origin_protocol"
        elif key == "sourcesType":
            suggest = "sources_type"
        elif key == "hostName":
            suggest = "host_name"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "obsBucketType":
            suggest = "obs_bucket_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleRuleActionFlexibleOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleRuleActionFlexibleOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleRuleActionFlexibleOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_or_domain: _builtins.str,
                 origin_protocol: _builtins.str,
                 priority: _builtins.int,
                 sources_type: _builtins.str,
                 weight: _builtins.int,
                 host_name: Optional[_builtins.str] = None,
                 http_port: Optional[_builtins.int] = None,
                 https_port: Optional[_builtins.int] = None,
                 obs_bucket_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_or_domain: Specifies the origin IP or domain name.
        :param _builtins.str origin_protocol: Specifies the origin protocol.
        :param _builtins.int priority: Specifies the origin priority. Valid value ranges from `1` to `100`.
        :param _builtins.str sources_type: Specifies the source type. Valid values are: **ipaddr**, **domain**, and **obs_bucket**.
        :param _builtins.int weight: Specifies the weight. Valid value ranges from `1` to `100`.
        :param _builtins.str host_name: Specifies the host name.
        :param _builtins.int http_port: Specifies the HTTP port. Ranges from `1` to `65,535`. Defaults to `80`.
        :param _builtins.int https_port: Specifies the HTTPS port. Ranges from `1` to `65,535`. Defaults to `443`.
        :param _builtins.str obs_bucket_type: Specifies the OBS bucket type. Valid values are **private** and **public**.
        """
        pulumi.set(__self__, "ip_or_domain", ip_or_domain)
        pulumi.set(__self__, "origin_protocol", origin_protocol)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "sources_type", sources_type)
        pulumi.set(__self__, "weight", weight)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)

    @_builtins.property
    @pulumi.getter(name="ipOrDomain")
    def ip_or_domain(self) -> _builtins.str:
        """
        Specifies the origin IP or domain name.
        """
        return pulumi.get(self, "ip_or_domain")

    @_builtins.property
    @pulumi.getter(name="originProtocol")
    def origin_protocol(self) -> _builtins.str:
        """
        Specifies the origin protocol.
        """
        return pulumi.get(self, "origin_protocol")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Specifies the origin priority. Valid value ranges from `1` to `100`.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="sourcesType")
    def sources_type(self) -> _builtins.str:
        """
        Specifies the source type. Valid values are: **ipaddr**, **domain**, and **obs_bucket**.
        """
        return pulumi.get(self, "sources_type")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Specifies the weight. Valid value ranges from `1` to `100`.
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[_builtins.str]:
        """
        Specifies the host name.
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        """
        Specifies the HTTP port. Ranges from `1` to `65,535`. Defaults to `80`.
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[_builtins.int]:
        """
        Specifies the HTTPS port. Ranges from `1` to `65,535`. Defaults to `443`.
        """
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[_builtins.str]:
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        """
        return pulumi.get(self, "obs_bucket_type")


@pulumi.output_type
class DomainRuleRuleActionHttpResponseHeader(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Specifies the operation type of setting HTTP response header.
               Valid values are **set** and **delete**.
        :param _builtins.str name: Set HTTP response header parameters.
        :param _builtins.str value: Set the value of HTTP response header parameters.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Specifies the operation type of setting HTTP response header.
        Valid values are **set** and **delete**.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Set HTTP response header parameters.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Set the value of HTTP response header parameters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainRuleRuleActionOriginRequestHeader(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Specifies the back-to-origin request header setting type.
               Valid values are **delete** and **set**
        :param _builtins.str name: Set back-to-origin request header parameters.
        :param _builtins.str value: Set the value of the return-to-origin request header parameter.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Specifies the back-to-origin request header setting type.
        Valid values are **delete** and **set**
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Set back-to-origin request header parameters.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Set the value of the return-to-origin request header parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainRuleRuleActionOriginRequestUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rewriteType":
            suggest = "rewrite_type"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "sourceUrl":
            suggest = "source_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleRuleActionOriginRequestUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleRuleActionOriginRequestUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleRuleActionOriginRequestUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rewrite_type: _builtins.str,
                 target_url: _builtins.str,
                 source_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str rewrite_type: Specifies the rewrite type. Valid values are **simple** and **wildcard**.
        :param _builtins.str target_url: Specifies the target URL.
        :param _builtins.str source_url: Specifies the URL to be rewritten back to the source.
        """
        pulumi.set(__self__, "rewrite_type", rewrite_type)
        pulumi.set(__self__, "target_url", target_url)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @_builtins.property
    @pulumi.getter(name="rewriteType")
    def rewrite_type(self) -> _builtins.str:
        """
        Specifies the rewrite type. Valid values are **simple** and **wildcard**.
        """
        return pulumi.get(self, "rewrite_type")

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        """
        Specifies the target URL.
        """
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[_builtins.str]:
        """
        Specifies the URL to be rewritten back to the source.
        """
        return pulumi.get(self, "source_url")


@pulumi.output_type
class DomainRuleRuleActionRequestUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionMode":
            suggest = "execution_mode"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "redirectHost":
            suggest = "redirect_host"
        elif key == "redirectStatusCode":
            suggest = "redirect_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleRuleActionRequestUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleRuleActionRequestUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleRuleActionRequestUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_mode: _builtins.str,
                 redirect_url: _builtins.str,
                 redirect_host: Optional[_builtins.str] = None,
                 redirect_status_code: Optional[_builtins.int] = None):
        """
        :param _builtins.str execution_mode: Specifies the execution mode. Valid values are **redirect** and **break**.
        :param _builtins.str redirect_url: Specifies the redirect URL.
        :param _builtins.str redirect_host: Specifies the redirect host.
        :param _builtins.int redirect_status_code: Specifies the redirect status code. Valid values are `301`, `302`, `303`, and `307`.
        """
        pulumi.set(__self__, "execution_mode", execution_mode)
        pulumi.set(__self__, "redirect_url", redirect_url)
        if redirect_host is not None:
            pulumi.set(__self__, "redirect_host", redirect_host)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @_builtins.property
    @pulumi.getter(name="executionMode")
    def execution_mode(self) -> _builtins.str:
        """
        Specifies the execution mode. Valid values are **redirect** and **break**.
        """
        return pulumi.get(self, "execution_mode")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> _builtins.str:
        """
        Specifies the redirect URL.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="redirectHost")
    def redirect_host(self) -> Optional[_builtins.str]:
        """
        Specifies the redirect host.
        """
        return pulumi.get(self, "redirect_host")

    @_builtins.property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[_builtins.int]:
        """
        Specifies the redirect status code. Valid values are `301`, `302`, `303`, and `307`.
        """
        return pulumi.get(self, "redirect_status_code")


@pulumi.output_type
class DomainRuleRuleConditions(dict):
    def __init__(__self__, *,
                 match: 'outputs.DomainRuleRuleConditionsMatch'):
        """
        :param 'DomainRuleRuleConditionsMatchArgs' match: Specifies the match configuration.
        """
        pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def match(self) -> 'outputs.DomainRuleRuleConditionsMatch':
        """
        Specifies the match configuration.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class DomainRuleRuleConditionsMatch(dict):
    def __init__(__self__, *,
                 criteria: _builtins.str,
                 logic: _builtins.str):
        """
        :param _builtins.str criteria: Specifies the match criteria list in JSON format.
        :param _builtins.str logic: Specifies the logical operator. Valid values are **and** and **or**.
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "logic", logic)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> _builtins.str:
        """
        Specifies the match criteria list in JSON format.
        """
        return pulumi.get(self, "criteria")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        Specifies the logical operator. Valid values are **and** and **or**.
        """
        return pulumi.get(self, "logic")


@pulumi.output_type
class DomainSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originType":
            suggest = "origin_type"
        elif key == "bucketAccessKey":
            suggest = "bucket_access_key"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketRegion":
            suggest = "bucket_region"
        elif key == "bucketSecretKey":
            suggest = "bucket_secret_key"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "obsBucketType":
            suggest = "obs_bucket_type"
        elif key == "obsWebHostingEnabled":
            suggest = "obs_web_hosting_enabled"
        elif key == "retrievalHost":
            suggest = "retrieval_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin: _builtins.str,
                 origin_type: _builtins.str,
                 active: Optional[_builtins.int] = None,
                 bucket_access_key: Optional[_builtins.str] = None,
                 bucket_name: Optional[_builtins.str] = None,
                 bucket_region: Optional[_builtins.str] = None,
                 bucket_secret_key: Optional[_builtins.str] = None,
                 http_port: Optional[_builtins.int] = None,
                 https_port: Optional[_builtins.int] = None,
                 obs_bucket_type: Optional[_builtins.str] = None,
                 obs_web_hosting_enabled: Optional[_builtins.bool] = None,
                 retrieval_host: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str origin: Specifies the unique domain name or IP address of the origin server.
               + If `origin_type` is set to **ipaddr**, this field can only be set to IPv4 address.
               + If `origin_type` is set to **domain**, this field can only be set to domain name.
               + If `origin_type` is set to **obs_bucket**, this field can only be set to OBS bucket domain name. The OBS bucket
               domain name must end with `.myhuaweicloud.com` or `.myhuaweicloud.cn`.
        :param _builtins.str origin_type: Specifies the origin server type. The valid values are as follows:
               + **ipaddr**: Origin server IP address.
               + **domain**: Origin server domain name.
               + **obs_bucket**: OBS bucket domain name.
        :param _builtins.int active: Specifies whether the origin server is primary or standby. Valid values are as follows:
               + **1**: Primary.
               + **0**: Standby.
               
               Defaults to `1`.
        :param _builtins.str bucket_access_key: Third-party object storage access key.
        :param _builtins.str bucket_name: Third-party object storage bucket name.
        :param _builtins.str bucket_region: Third-party object storage bucket region.
        :param _builtins.str bucket_secret_key: Third-party object storage secret key.
        :param _builtins.int http_port: Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        :param _builtins.int https_port: Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.
               
               > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.
               
               <a name="remote_auth_object"></a>
               The `remote_auth` block support:
        :param _builtins.str obs_bucket_type: Specifies the OBS bucket type. Valid values are **private** and **public**.
               This field is required when `sources_type` is set to **obs_bucket**.
        :param _builtins.bool obs_web_hosting_enabled: Specifies whether to enable static website hosting for the OBS bucket.
               This parameter is valid only when the `origin_type` is set to **obs_bucket**. Defaults to **false**.
        :param _builtins.str retrieval_host: Specifies the retrieval host. Things to note when using this field are as follows:
               + If `origin_type` is set to **ipaddr** or **domain**, the acceleration domain name will be used by default.
               + If `origin_type` is set to **obs_bucket**, the bucket's domain name will be used by default.
        :param _builtins.int weight: Specifies the weight. The value ranges from `1` to `100`. Defaults to `50`.
               A larger value indicates a larger number of times that content is pulled from this IP address.
               
               > If there are multiple origin servers with the same priority, the weight determines the proportion of content pulled
               from each origin server.
        """
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "origin_type", origin_type)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if bucket_access_key is not None:
            pulumi.set(__self__, "bucket_access_key", bucket_access_key)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)
        if bucket_secret_key is not None:
            pulumi.set(__self__, "bucket_secret_key", bucket_secret_key)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)
        if obs_web_hosting_enabled is not None:
            pulumi.set(__self__, "obs_web_hosting_enabled", obs_web_hosting_enabled)
        if retrieval_host is not None:
            pulumi.set(__self__, "retrieval_host", retrieval_host)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        """
        Specifies the unique domain name or IP address of the origin server.
        + If `origin_type` is set to **ipaddr**, this field can only be set to IPv4 address.
        + If `origin_type` is set to **domain**, this field can only be set to domain name.
        + If `origin_type` is set to **obs_bucket**, this field can only be set to OBS bucket domain name. The OBS bucket
        domain name must end with `.myhuaweicloud.com` or `.myhuaweicloud.cn`.
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="originType")
    def origin_type(self) -> _builtins.str:
        """
        Specifies the origin server type. The valid values are as follows:
        + **ipaddr**: Origin server IP address.
        + **domain**: Origin server domain name.
        + **obs_bucket**: OBS bucket domain name.
        """
        return pulumi.get(self, "origin_type")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.int]:
        """
        Specifies whether the origin server is primary or standby. Valid values are as follows:
        + **1**: Primary.
        + **0**: Standby.

        Defaults to `1`.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="bucketAccessKey")
    def bucket_access_key(self) -> Optional[_builtins.str]:
        """
        Third-party object storage access key.
        """
        return pulumi.get(self, "bucket_access_key")

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        Third-party object storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[_builtins.str]:
        """
        Third-party object storage bucket region.
        """
        return pulumi.get(self, "bucket_region")

    @_builtins.property
    @pulumi.getter(name="bucketSecretKey")
    def bucket_secret_key(self) -> Optional[_builtins.str]:
        """
        Third-party object storage secret key.
        """
        return pulumi.get(self, "bucket_secret_key")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        """
        Specifies the HTTP port, ranging from `1` to `65,535`. Defaults to **80**.
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[_builtins.int]:
        """
        Specifies the HTTPS port, ranging from `1` to `65,535`. Defaults to **443**.

        > Fields `http_port` and `https_port` do not support editing when `sources_type` is set to **obs_bucket**.

        <a name="remote_auth_object"></a>
        The `remote_auth` block support:
        """
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[_builtins.str]:
        """
        Specifies the OBS bucket type. Valid values are **private** and **public**.
        This field is required when `sources_type` is set to **obs_bucket**.
        """
        return pulumi.get(self, "obs_bucket_type")

    @_builtins.property
    @pulumi.getter(name="obsWebHostingEnabled")
    def obs_web_hosting_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable static website hosting for the OBS bucket.
        This parameter is valid only when the `origin_type` is set to **obs_bucket**. Defaults to **false**.
        """
        return pulumi.get(self, "obs_web_hosting_enabled")

    @_builtins.property
    @pulumi.getter(name="retrievalHost")
    def retrieval_host(self) -> Optional[_builtins.str]:
        """
        Specifies the retrieval host. Things to note when using this field are as follows:
        + If `origin_type` is set to **ipaddr** or **domain**, the acceleration domain name will be used by default.
        + If `origin_type` is set to **obs_bucket**, the bucket's domain name will be used by default.
        """
        return pulumi.get(self, "retrieval_host")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Specifies the weight. The value ranges from `1` to `100`. Defaults to `50`.
        A larger value indicates a larger number of times that content is pulled from this IP address.

        > If there are multiple origin servers with the same priority, the weight determines the proportion of content pulled
        from each origin server.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DomainV1CacheSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "followOrigin":
            suggest = "follow_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1CacheSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1CacheSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1CacheSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 follow_origin: Optional[_builtins.bool] = None,
                 rules: Optional[Sequence['outputs.DomainV1CacheSettingsRule']] = None):
        if follow_origin is not None:
            pulumi.set(__self__, "follow_origin", follow_origin)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="followOrigin")
    def follow_origin(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "follow_origin")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.DomainV1CacheSettingsRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class DomainV1CacheSettingsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "ttlType":
            suggest = "ttl_type"
        elif key == "urlParameterType":
            suggest = "url_parameter_type"
        elif key == "urlParameterValue":
            suggest = "url_parameter_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1CacheSettingsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1CacheSettingsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1CacheSettingsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: _builtins.str,
                 content: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 ttl: Optional[_builtins.int] = None,
                 ttl_type: Optional[_builtins.str] = None,
                 url_parameter_type: Optional[_builtins.str] = None,
                 url_parameter_value: Optional[_builtins.str] = None):
        """
        :param _builtins.int priority: schema: Required
        :param _builtins.int ttl: schema: Required
        :param _builtins.str ttl_type: schema: Required
        """
        pulumi.set(__self__, "rule_type", rule_type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_type is not None:
            pulumi.set(__self__, "ttl_type", ttl_type)
        if url_parameter_type is not None:
            pulumi.set(__self__, "url_parameter_type", url_parameter_type)
        if url_parameter_value is not None:
            pulumi.set(__self__, "url_parameter_value", url_parameter_value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> _builtins.str:
        return pulumi.get(self, "rule_type")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        schema: Required
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        schema: Required
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="ttlType")
    def ttl_type(self) -> Optional[_builtins.str]:
        """
        schema: Required
        """
        return pulumi.get(self, "ttl_type")

    @_builtins.property
    @pulumi.getter(name="urlParameterType")
    def url_parameter_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "url_parameter_type")

    @_builtins.property
    @pulumi.getter(name="urlParameterValue")
    def url_parameter_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "url_parameter_value")


@pulumi.output_type
class DomainV1Configs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessAreaFilters":
            suggest = "access_area_filters"
        elif key == "browserCacheRules":
            suggest = "browser_cache_rules"
        elif key == "cacheUrlParameterFilter":
            suggest = "cache_url_parameter_filter"
        elif key == "clientCert":
            suggest = "client_cert"
        elif key == "errorCodeCaches":
            suggest = "error_code_caches"
        elif key == "errorCodeRedirectRules":
            suggest = "error_code_redirect_rules"
        elif key == "flexibleOrigins":
            suggest = "flexible_origins"
        elif key == "forceRedirect":
            suggest = "force_redirect"
        elif key == "httpResponseHeaders":
            suggest = "http_response_headers"
        elif key == "httpsSettings":
            suggest = "https_settings"
        elif key == "ipFilter":
            suggest = "ip_filter"
        elif key == "ipFrequencyLimit":
            suggest = "ip_frequency_limit"
        elif key == "ipv6Enable":
            suggest = "ipv6_enable"
        elif key == "originFollow302Status":
            suggest = "origin_follow302_status"
        elif key == "originProtocol":
            suggest = "origin_protocol"
        elif key == "originReceiveTimeout":
            suggest = "origin_receive_timeout"
        elif key == "originRequestUrlRewrites":
            suggest = "origin_request_url_rewrites"
        elif key == "rangeBasedRetrievalEnabled":
            suggest = "range_based_retrieval_enabled"
        elif key == "remoteAuth":
            suggest = "remote_auth"
        elif key == "requestLimitRules":
            suggest = "request_limit_rules"
        elif key == "requestUrlRewrites":
            suggest = "request_url_rewrites"
        elif key == "retrievalRequestHeaders":
            suggest = "retrieval_request_headers"
        elif key == "sliceEtagStatus":
            suggest = "slice_etag_status"
        elif key == "urlSigning":
            suggest = "url_signing"
        elif key == "userAgentFilter":
            suggest = "user_agent_filter"
        elif key == "videoSeek":
            suggest = "video_seek"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1Configs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1Configs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1Configs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_area_filters: Optional[Sequence['outputs.DomainV1ConfigsAccessAreaFilter']] = None,
                 browser_cache_rules: Optional[Sequence['outputs.DomainV1ConfigsBrowserCacheRule']] = None,
                 cache_url_parameter_filter: Optional['outputs.DomainV1ConfigsCacheUrlParameterFilter'] = None,
                 client_cert: Optional['outputs.DomainV1ConfigsClientCert'] = None,
                 compress: Optional['outputs.DomainV1ConfigsCompress'] = None,
                 description: Optional[_builtins.str] = None,
                 error_code_caches: Optional[Sequence['outputs.DomainV1ConfigsErrorCodeCach']] = None,
                 error_code_redirect_rules: Optional[Sequence['outputs.DomainV1ConfigsErrorCodeRedirectRule']] = None,
                 flexible_origins: Optional[Sequence['outputs.DomainV1ConfigsFlexibleOrigin']] = None,
                 force_redirect: Optional['outputs.DomainV1ConfigsForceRedirect'] = None,
                 hsts: Optional['outputs.DomainV1ConfigsHsts'] = None,
                 http_response_headers: Optional[Sequence['outputs.DomainV1ConfigsHttpResponseHeader']] = None,
                 https_settings: Optional['outputs.DomainV1ConfigsHttpsSettings'] = None,
                 ip_filter: Optional['outputs.DomainV1ConfigsIpFilter'] = None,
                 ip_frequency_limit: Optional['outputs.DomainV1ConfigsIpFrequencyLimit'] = None,
                 ipv6_enable: Optional[_builtins.bool] = None,
                 origin_follow302_status: Optional[_builtins.str] = None,
                 origin_protocol: Optional[_builtins.str] = None,
                 origin_receive_timeout: Optional[_builtins.int] = None,
                 origin_request_url_rewrites: Optional[Sequence['outputs.DomainV1ConfigsOriginRequestUrlRewrite']] = None,
                 quic: Optional['outputs.DomainV1ConfigsQuic'] = None,
                 range_based_retrieval_enabled: Optional[_builtins.bool] = None,
                 referer: Optional['outputs.DomainV1ConfigsReferer'] = None,
                 remote_auth: Optional['outputs.DomainV1ConfigsRemoteAuth'] = None,
                 request_limit_rules: Optional[Sequence['outputs.DomainV1ConfigsRequestLimitRule']] = None,
                 request_url_rewrites: Optional[Sequence['outputs.DomainV1ConfigsRequestUrlRewrite']] = None,
                 retrieval_request_headers: Optional[Sequence['outputs.DomainV1ConfigsRetrievalRequestHeader']] = None,
                 slice_etag_status: Optional[_builtins.str] = None,
                 sni: Optional['outputs.DomainV1ConfigsSni'] = None,
                 url_signing: Optional['outputs.DomainV1ConfigsUrlSigning'] = None,
                 user_agent_filter: Optional['outputs.DomainV1ConfigsUserAgentFilter'] = None,
                 video_seek: Optional['outputs.DomainV1ConfigsVideoSeek'] = None,
                 websocket: Optional['outputs.DomainV1ConfigsWebsocket'] = None):
        """
        :param Sequence['DomainV1ConfigsAccessAreaFilterArgs'] access_area_filters: Specifies the geographic access control rules.
        :param 'DomainV1ConfigsCacheUrlParameterFilterArgs' cache_url_parameter_filter: schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        if access_area_filters is not None:
            pulumi.set(__self__, "access_area_filters", access_area_filters)
        if browser_cache_rules is not None:
            pulumi.set(__self__, "browser_cache_rules", browser_cache_rules)
        if cache_url_parameter_filter is not None:
            pulumi.set(__self__, "cache_url_parameter_filter", cache_url_parameter_filter)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if error_code_caches is not None:
            pulumi.set(__self__, "error_code_caches", error_code_caches)
        if error_code_redirect_rules is not None:
            pulumi.set(__self__, "error_code_redirect_rules", error_code_redirect_rules)
        if flexible_origins is not None:
            pulumi.set(__self__, "flexible_origins", flexible_origins)
        if force_redirect is not None:
            pulumi.set(__self__, "force_redirect", force_redirect)
        if hsts is not None:
            pulumi.set(__self__, "hsts", hsts)
        if http_response_headers is not None:
            pulumi.set(__self__, "http_response_headers", http_response_headers)
        if https_settings is not None:
            pulumi.set(__self__, "https_settings", https_settings)
        if ip_filter is not None:
            pulumi.set(__self__, "ip_filter", ip_filter)
        if ip_frequency_limit is not None:
            pulumi.set(__self__, "ip_frequency_limit", ip_frequency_limit)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if origin_follow302_status is not None:
            pulumi.set(__self__, "origin_follow302_status", origin_follow302_status)
        if origin_protocol is not None:
            pulumi.set(__self__, "origin_protocol", origin_protocol)
        if origin_receive_timeout is not None:
            pulumi.set(__self__, "origin_receive_timeout", origin_receive_timeout)
        if origin_request_url_rewrites is not None:
            pulumi.set(__self__, "origin_request_url_rewrites", origin_request_url_rewrites)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if range_based_retrieval_enabled is not None:
            pulumi.set(__self__, "range_based_retrieval_enabled", range_based_retrieval_enabled)
        if referer is not None:
            pulumi.set(__self__, "referer", referer)
        if remote_auth is not None:
            pulumi.set(__self__, "remote_auth", remote_auth)
        if request_limit_rules is not None:
            pulumi.set(__self__, "request_limit_rules", request_limit_rules)
        if request_url_rewrites is not None:
            pulumi.set(__self__, "request_url_rewrites", request_url_rewrites)
        if retrieval_request_headers is not None:
            pulumi.set(__self__, "retrieval_request_headers", retrieval_request_headers)
        if slice_etag_status is not None:
            pulumi.set(__self__, "slice_etag_status", slice_etag_status)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if url_signing is not None:
            pulumi.set(__self__, "url_signing", url_signing)
        if user_agent_filter is not None:
            pulumi.set(__self__, "user_agent_filter", user_agent_filter)
        if video_seek is not None:
            pulumi.set(__self__, "video_seek", video_seek)
        if websocket is not None:
            pulumi.set(__self__, "websocket", websocket)

    @_builtins.property
    @pulumi.getter(name="accessAreaFilters")
    def access_area_filters(self) -> Optional[Sequence['outputs.DomainV1ConfigsAccessAreaFilter']]:
        """
        Specifies the geographic access control rules.
        """
        return pulumi.get(self, "access_area_filters")

    @_builtins.property
    @pulumi.getter(name="browserCacheRules")
    def browser_cache_rules(self) -> Optional[Sequence['outputs.DomainV1ConfigsBrowserCacheRule']]:
        return pulumi.get(self, "browser_cache_rules")

    @_builtins.property
    @pulumi.getter(name="cacheUrlParameterFilter")
    def cache_url_parameter_filter(self) -> Optional['outputs.DomainV1ConfigsCacheUrlParameterFilter']:
        """
        schema: Deprecated; Field `cache_url_parameter_filter` will be offline soon, use `cache_settings` instead
        """
        return pulumi.get(self, "cache_url_parameter_filter")

    @_builtins.property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional['outputs.DomainV1ConfigsClientCert']:
        return pulumi.get(self, "client_cert")

    @_builtins.property
    @pulumi.getter
    def compress(self) -> Optional['outputs.DomainV1ConfigsCompress']:
        return pulumi.get(self, "compress")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="errorCodeCaches")
    def error_code_caches(self) -> Optional[Sequence['outputs.DomainV1ConfigsErrorCodeCach']]:
        return pulumi.get(self, "error_code_caches")

    @_builtins.property
    @pulumi.getter(name="errorCodeRedirectRules")
    def error_code_redirect_rules(self) -> Optional[Sequence['outputs.DomainV1ConfigsErrorCodeRedirectRule']]:
        return pulumi.get(self, "error_code_redirect_rules")

    @_builtins.property
    @pulumi.getter(name="flexibleOrigins")
    def flexible_origins(self) -> Optional[Sequence['outputs.DomainV1ConfigsFlexibleOrigin']]:
        return pulumi.get(self, "flexible_origins")

    @_builtins.property
    @pulumi.getter(name="forceRedirect")
    def force_redirect(self) -> Optional['outputs.DomainV1ConfigsForceRedirect']:
        return pulumi.get(self, "force_redirect")

    @_builtins.property
    @pulumi.getter
    def hsts(self) -> Optional['outputs.DomainV1ConfigsHsts']:
        return pulumi.get(self, "hsts")

    @_builtins.property
    @pulumi.getter(name="httpResponseHeaders")
    def http_response_headers(self) -> Optional[Sequence['outputs.DomainV1ConfigsHttpResponseHeader']]:
        return pulumi.get(self, "http_response_headers")

    @_builtins.property
    @pulumi.getter(name="httpsSettings")
    def https_settings(self) -> Optional['outputs.DomainV1ConfigsHttpsSettings']:
        return pulumi.get(self, "https_settings")

    @_builtins.property
    @pulumi.getter(name="ipFilter")
    def ip_filter(self) -> Optional['outputs.DomainV1ConfigsIpFilter']:
        return pulumi.get(self, "ip_filter")

    @_builtins.property
    @pulumi.getter(name="ipFrequencyLimit")
    def ip_frequency_limit(self) -> Optional['outputs.DomainV1ConfigsIpFrequencyLimit']:
        return pulumi.get(self, "ip_frequency_limit")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="originFollow302Status")
    def origin_follow302_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_follow302_status")

    @_builtins.property
    @pulumi.getter(name="originProtocol")
    def origin_protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "origin_protocol")

    @_builtins.property
    @pulumi.getter(name="originReceiveTimeout")
    def origin_receive_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "origin_receive_timeout")

    @_builtins.property
    @pulumi.getter(name="originRequestUrlRewrites")
    def origin_request_url_rewrites(self) -> Optional[Sequence['outputs.DomainV1ConfigsOriginRequestUrlRewrite']]:
        return pulumi.get(self, "origin_request_url_rewrites")

    @_builtins.property
    @pulumi.getter
    def quic(self) -> Optional['outputs.DomainV1ConfigsQuic']:
        return pulumi.get(self, "quic")

    @_builtins.property
    @pulumi.getter(name="rangeBasedRetrievalEnabled")
    def range_based_retrieval_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "range_based_retrieval_enabled")

    @_builtins.property
    @pulumi.getter
    def referer(self) -> Optional['outputs.DomainV1ConfigsReferer']:
        return pulumi.get(self, "referer")

    @_builtins.property
    @pulumi.getter(name="remoteAuth")
    def remote_auth(self) -> Optional['outputs.DomainV1ConfigsRemoteAuth']:
        return pulumi.get(self, "remote_auth")

    @_builtins.property
    @pulumi.getter(name="requestLimitRules")
    def request_limit_rules(self) -> Optional[Sequence['outputs.DomainV1ConfigsRequestLimitRule']]:
        return pulumi.get(self, "request_limit_rules")

    @_builtins.property
    @pulumi.getter(name="requestUrlRewrites")
    def request_url_rewrites(self) -> Optional[Sequence['outputs.DomainV1ConfigsRequestUrlRewrite']]:
        return pulumi.get(self, "request_url_rewrites")

    @_builtins.property
    @pulumi.getter(name="retrievalRequestHeaders")
    def retrieval_request_headers(self) -> Optional[Sequence['outputs.DomainV1ConfigsRetrievalRequestHeader']]:
        return pulumi.get(self, "retrieval_request_headers")

    @_builtins.property
    @pulumi.getter(name="sliceEtagStatus")
    def slice_etag_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "slice_etag_status")

    @_builtins.property
    @pulumi.getter
    def sni(self) -> Optional['outputs.DomainV1ConfigsSni']:
        return pulumi.get(self, "sni")

    @_builtins.property
    @pulumi.getter(name="urlSigning")
    def url_signing(self) -> Optional['outputs.DomainV1ConfigsUrlSigning']:
        return pulumi.get(self, "url_signing")

    @_builtins.property
    @pulumi.getter(name="userAgentFilter")
    def user_agent_filter(self) -> Optional['outputs.DomainV1ConfigsUserAgentFilter']:
        return pulumi.get(self, "user_agent_filter")

    @_builtins.property
    @pulumi.getter(name="videoSeek")
    def video_seek(self) -> Optional['outputs.DomainV1ConfigsVideoSeek']:
        return pulumi.get(self, "video_seek")

    @_builtins.property
    @pulumi.getter
    def websocket(self) -> Optional['outputs.DomainV1ConfigsWebsocket']:
        return pulumi.get(self, "websocket")


@pulumi.output_type
class DomainV1ConfigsAccessAreaFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "contentValue":
            suggest = "content_value"
        elif key == "exceptionIp":
            suggest = "exception_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsAccessAreaFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsAccessAreaFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsAccessAreaFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 area: _builtins.str,
                 content_type: _builtins.str,
                 type: _builtins.str,
                 content_value: Optional[_builtins.str] = None,
                 exception_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str area: Specifies the areas, separated by commas.
        :param _builtins.str content_type: Specifies the content type.
        :param _builtins.str type: Specifies the blacklist and whitelist rule type.
        :param _builtins.str content_value: Specifies the content value.
        :param _builtins.str exception_ip: Specifies the IP addresses exception in access control, separated by commas.
        """
        pulumi.set(__self__, "area", area)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "type", type)
        if content_value is not None:
            pulumi.set(__self__, "content_value", content_value)
        if exception_ip is not None:
            pulumi.set(__self__, "exception_ip", exception_ip)

    @_builtins.property
    @pulumi.getter
    def area(self) -> _builtins.str:
        """
        Specifies the areas, separated by commas.
        """
        return pulumi.get(self, "area")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> _builtins.str:
        """
        Specifies the content type.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the blacklist and whitelist rule type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="contentValue")
    def content_value(self) -> Optional[_builtins.str]:
        """
        Specifies the content value.
        """
        return pulumi.get(self, "content_value")

    @_builtins.property
    @pulumi.getter(name="exceptionIp")
    def exception_ip(self) -> Optional[_builtins.str]:
        """
        Specifies the IP addresses exception in access control, separated by commas.
        """
        return pulumi.get(self, "exception_ip")


@pulumi.output_type
class DomainV1ConfigsBrowserCacheRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheType":
            suggest = "cache_type"
        elif key == "ttlUnit":
            suggest = "ttl_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsBrowserCacheRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsBrowserCacheRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsBrowserCacheRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_type: _builtins.str,
                 condition: 'outputs.DomainV1ConfigsBrowserCacheRuleCondition',
                 ttl: Optional[_builtins.int] = None,
                 ttl_unit: Optional[_builtins.str] = None):
        pulumi.set(__self__, "cache_type", cache_type)
        pulumi.set(__self__, "condition", condition)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if ttl_unit is not None:
            pulumi.set(__self__, "ttl_unit", ttl_unit)

    @_builtins.property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> _builtins.str:
        return pulumi.get(self, "cache_type")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.DomainV1ConfigsBrowserCacheRuleCondition':
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="ttlUnit")
    def ttl_unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ttl_unit")


@pulumi.output_type
class DomainV1ConfigsBrowserCacheRuleCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsBrowserCacheRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsBrowserCacheRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsBrowserCacheRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 match_value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_value")


@pulumi.output_type
class DomainV1ConfigsCacheUrlParameterFilter(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainV1ConfigsClientCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedCert":
            suggest = "trusted_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsClientCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsClientCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsClientCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 hosts: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 trusted_cert: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trusted_cert is not None:
            pulumi.set(__self__, "trusted_cert", trusted_cert)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="trustedCert")
    def trusted_cert(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trusted_cert")


@pulumi.output_type
class DomainV1ConfigsCompress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileType":
            suggest = "file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsCompress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsCompress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsCompress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 file_type: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if file_type is not None:
            pulumi.set(__self__, "file_type", file_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "file_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainV1ConfigsErrorCodeCach(dict):
    def __init__(__self__, *,
                 code: _builtins.int,
                 ttl: _builtins.int):
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.int:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class DomainV1ConfigsErrorCodeRedirectRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "targetCode":
            suggest = "target_code"
        elif key == "targetLink":
            suggest = "target_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsErrorCodeRedirectRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsErrorCodeRedirectRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsErrorCodeRedirectRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: _builtins.int,
                 target_code: _builtins.int,
                 target_link: _builtins.str):
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "target_code", target_code)
        pulumi.set(__self__, "target_link", target_link)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> _builtins.int:
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="targetCode")
    def target_code(self) -> _builtins.int:
        return pulumi.get(self, "target_code")

    @_builtins.property
    @pulumi.getter(name="targetLink")
    def target_link(self) -> _builtins.str:
        return pulumi.get(self, "target_link")


@pulumi.output_type
class DomainV1ConfigsFlexibleOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backSources":
            suggest = "back_sources"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "matchPattern":
            suggest = "match_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsFlexibleOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsFlexibleOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsFlexibleOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 back_sources: 'outputs.DomainV1ConfigsFlexibleOriginBackSources',
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 match_pattern: Optional[_builtins.str] = None):
        pulumi.set(__self__, "back_sources", back_sources)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_pattern is not None:
            pulumi.set(__self__, "match_pattern", match_pattern)

    @_builtins.property
    @pulumi.getter(name="backSources")
    def back_sources(self) -> 'outputs.DomainV1ConfigsFlexibleOriginBackSources':
        return pulumi.get(self, "back_sources")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="matchPattern")
    def match_pattern(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_pattern")


@pulumi.output_type
class DomainV1ConfigsFlexibleOriginBackSources(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipOrDomain":
            suggest = "ip_or_domain"
        elif key == "sourcesType":
            suggest = "sources_type"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "obsBucketType":
            suggest = "obs_bucket_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsFlexibleOriginBackSources. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsFlexibleOriginBackSources.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsFlexibleOriginBackSources.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_or_domain: _builtins.str,
                 sources_type: _builtins.str,
                 http_port: Optional[_builtins.int] = None,
                 https_port: Optional[_builtins.int] = None,
                 obs_bucket_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "ip_or_domain", ip_or_domain)
        pulumi.set(__self__, "sources_type", sources_type)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)

    @_builtins.property
    @pulumi.getter(name="ipOrDomain")
    def ip_or_domain(self) -> _builtins.str:
        return pulumi.get(self, "ip_or_domain")

    @_builtins.property
    @pulumi.getter(name="sourcesType")
    def sources_type(self) -> _builtins.str:
        return pulumi.get(self, "sources_type")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "obs_bucket_type")


@pulumi.output_type
class DomainV1ConfigsForceRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectCode":
            suggest = "redirect_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsForceRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsForceRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsForceRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 redirect_code: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: schema: Required
        """
        pulumi.set(__self__, "enabled", enabled)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "redirect_code")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        schema: Required
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainV1ConfigsHsts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeSubdomains":
            suggest = "include_subdomains"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsHsts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsHsts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsHsts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 include_subdomains: Optional[_builtins.str] = None,
                 max_age: Optional[_builtins.int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if include_subdomains is not None:
            pulumi.set(__self__, "include_subdomains", include_subdomains)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="includeSubdomains")
    def include_subdomains(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "include_subdomains")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class DomainV1ConfigsHttpResponseHeader(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainV1ConfigsHttpsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateBody":
            suggest = "certificate_body"
        elif key == "certificateName":
            suggest = "certificate_name"
        elif key == "certificateSource":
            suggest = "certificate_source"
        elif key == "certificateType":
            suggest = "certificate_type"
        elif key == "http2Enabled":
            suggest = "http2_enabled"
        elif key == "http2Status":
            suggest = "http2_status"
        elif key == "httpsEnabled":
            suggest = "https_enabled"
        elif key == "httpsStatus":
            suggest = "https_status"
        elif key == "ocspStaplingStatus":
            suggest = "ocsp_stapling_status"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "scmCertificateId":
            suggest = "scm_certificate_id"
        elif key == "tlsVersion":
            suggest = "tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsHttpsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsHttpsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsHttpsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_body: Optional[_builtins.str] = None,
                 certificate_name: Optional[_builtins.str] = None,
                 certificate_source: Optional[_builtins.int] = None,
                 certificate_type: Optional[_builtins.str] = None,
                 http2_enabled: Optional[_builtins.bool] = None,
                 http2_status: Optional[_builtins.str] = None,
                 https_enabled: Optional[_builtins.bool] = None,
                 https_status: Optional[_builtins.str] = None,
                 ocsp_stapling_status: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None,
                 scm_certificate_id: Optional[_builtins.str] = None,
                 tls_version: Optional[_builtins.str] = None):
        if certificate_body is not None:
            pulumi.set(__self__, "certificate_body", certificate_body)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if certificate_source is not None:
            pulumi.set(__self__, "certificate_source", certificate_source)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if http2_enabled is not None:
            pulumi.set(__self__, "http2_enabled", http2_enabled)
        if http2_status is not None:
            pulumi.set(__self__, "http2_status", http2_status)
        if https_enabled is not None:
            pulumi.set(__self__, "https_enabled", https_enabled)
        if https_status is not None:
            pulumi.set(__self__, "https_status", https_status)
        if ocsp_stapling_status is not None:
            pulumi.set(__self__, "ocsp_stapling_status", ocsp_stapling_status)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if scm_certificate_id is not None:
            pulumi.set(__self__, "scm_certificate_id", scm_certificate_id)
        if tls_version is not None:
            pulumi.set(__self__, "tls_version", tls_version)

    @_builtins.property
    @pulumi.getter(name="certificateBody")
    def certificate_body(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_body")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "certificate_source")

    @_builtins.property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_type")

    @_builtins.property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "http2_enabled")

    @_builtins.property
    @pulumi.getter(name="http2Status")
    def http2_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "http2_status")

    @_builtins.property
    @pulumi.getter(name="httpsEnabled")
    def https_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "https_enabled")

    @_builtins.property
    @pulumi.getter(name="httpsStatus")
    def https_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "https_status")

    @_builtins.property
    @pulumi.getter(name="ocspStaplingStatus")
    def ocsp_stapling_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ocsp_stapling_status")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="scmCertificateId")
    def scm_certificate_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scm_certificate_id")

    @_builtins.property
    @pulumi.getter(name="tlsVersion")
    def tls_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tls_version")


@pulumi.output_type
class DomainV1ConfigsIpFilter(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainV1ConfigsIpFrequencyLimit(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 qps: Optional[_builtins.int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def qps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "qps")


@pulumi.output_type
class DomainV1ConfigsOriginRequestUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "targetUrl":
            suggest = "target_url"
        elif key == "sourceUrl":
            suggest = "source_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsOriginRequestUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsOriginRequestUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsOriginRequestUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 target_url: _builtins.str,
                 source_url: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "target_url", target_url)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="targetUrl")
    def target_url(self) -> _builtins.str:
        return pulumi.get(self, "target_url")

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_url")


@pulumi.output_type
class DomainV1ConfigsQuic(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DomainV1ConfigsReferer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeEmpty":
            suggest = "include_empty"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsReferer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsReferer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsReferer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 include_empty: Optional[_builtins.bool] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_empty")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainV1ConfigsRemoteAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteAuthRules":
            suggest = "remote_auth_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsRemoteAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsRemoteAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsRemoteAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 remote_auth_rules: Optional['outputs.DomainV1ConfigsRemoteAuthRemoteAuthRules'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if remote_auth_rules is not None:
            pulumi.set(__self__, "remote_auth_rules", remote_auth_rules)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="remoteAuthRules")
    def remote_auth_rules(self) -> Optional['outputs.DomainV1ConfigsRemoteAuthRemoteAuthRules']:
        return pulumi.get(self, "remote_auth_rules")


@pulumi.output_type
class DomainV1ConfigsRemoteAuthRemoteAuthRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authFailedStatus":
            suggest = "auth_failed_status"
        elif key == "authServer":
            suggest = "auth_server"
        elif key == "authSuccessStatus":
            suggest = "auth_success_status"
        elif key == "fileTypeSetting":
            suggest = "file_type_setting"
        elif key == "requestMethod":
            suggest = "request_method"
        elif key == "reserveArgsSetting":
            suggest = "reserve_args_setting"
        elif key == "reserveHeadersSetting":
            suggest = "reserve_headers_setting"
        elif key == "responseStatus":
            suggest = "response_status"
        elif key == "timeoutAction":
            suggest = "timeout_action"
        elif key == "addCustomArgsRules":
            suggest = "add_custom_args_rules"
        elif key == "addCustomHeadersRules":
            suggest = "add_custom_headers_rules"
        elif key == "reserveArgs":
            suggest = "reserve_args"
        elif key == "reserveHeaders":
            suggest = "reserve_headers"
        elif key == "specifiedFileType":
            suggest = "specified_file_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsRemoteAuthRemoteAuthRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsRemoteAuthRemoteAuthRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsRemoteAuthRemoteAuthRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_failed_status: _builtins.str,
                 auth_server: _builtins.str,
                 auth_success_status: _builtins.str,
                 file_type_setting: _builtins.str,
                 request_method: _builtins.str,
                 reserve_args_setting: _builtins.str,
                 reserve_headers_setting: _builtins.str,
                 response_status: _builtins.str,
                 timeout: _builtins.int,
                 timeout_action: _builtins.str,
                 add_custom_args_rules: Optional[Sequence['outputs.DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule']] = None,
                 add_custom_headers_rules: Optional[Sequence['outputs.DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule']] = None,
                 reserve_args: Optional[_builtins.str] = None,
                 reserve_headers: Optional[_builtins.str] = None,
                 specified_file_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "auth_failed_status", auth_failed_status)
        pulumi.set(__self__, "auth_server", auth_server)
        pulumi.set(__self__, "auth_success_status", auth_success_status)
        pulumi.set(__self__, "file_type_setting", file_type_setting)
        pulumi.set(__self__, "request_method", request_method)
        pulumi.set(__self__, "reserve_args_setting", reserve_args_setting)
        pulumi.set(__self__, "reserve_headers_setting", reserve_headers_setting)
        pulumi.set(__self__, "response_status", response_status)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "timeout_action", timeout_action)
        if add_custom_args_rules is not None:
            pulumi.set(__self__, "add_custom_args_rules", add_custom_args_rules)
        if add_custom_headers_rules is not None:
            pulumi.set(__self__, "add_custom_headers_rules", add_custom_headers_rules)
        if reserve_args is not None:
            pulumi.set(__self__, "reserve_args", reserve_args)
        if reserve_headers is not None:
            pulumi.set(__self__, "reserve_headers", reserve_headers)
        if specified_file_type is not None:
            pulumi.set(__self__, "specified_file_type", specified_file_type)

    @_builtins.property
    @pulumi.getter(name="authFailedStatus")
    def auth_failed_status(self) -> _builtins.str:
        return pulumi.get(self, "auth_failed_status")

    @_builtins.property
    @pulumi.getter(name="authServer")
    def auth_server(self) -> _builtins.str:
        return pulumi.get(self, "auth_server")

    @_builtins.property
    @pulumi.getter(name="authSuccessStatus")
    def auth_success_status(self) -> _builtins.str:
        return pulumi.get(self, "auth_success_status")

    @_builtins.property
    @pulumi.getter(name="fileTypeSetting")
    def file_type_setting(self) -> _builtins.str:
        return pulumi.get(self, "file_type_setting")

    @_builtins.property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> _builtins.str:
        return pulumi.get(self, "request_method")

    @_builtins.property
    @pulumi.getter(name="reserveArgsSetting")
    def reserve_args_setting(self) -> _builtins.str:
        return pulumi.get(self, "reserve_args_setting")

    @_builtins.property
    @pulumi.getter(name="reserveHeadersSetting")
    def reserve_headers_setting(self) -> _builtins.str:
        return pulumi.get(self, "reserve_headers_setting")

    @_builtins.property
    @pulumi.getter(name="responseStatus")
    def response_status(self) -> _builtins.str:
        return pulumi.get(self, "response_status")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> _builtins.str:
        return pulumi.get(self, "timeout_action")

    @_builtins.property
    @pulumi.getter(name="addCustomArgsRules")
    def add_custom_args_rules(self) -> Optional[Sequence['outputs.DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule']]:
        return pulumi.get(self, "add_custom_args_rules")

    @_builtins.property
    @pulumi.getter(name="addCustomHeadersRules")
    def add_custom_headers_rules(self) -> Optional[Sequence['outputs.DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule']]:
        return pulumi.get(self, "add_custom_headers_rules")

    @_builtins.property
    @pulumi.getter(name="reserveArgs")
    def reserve_args(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "reserve_args")

    @_builtins.property
    @pulumi.getter(name="reserveHeaders")
    def reserve_headers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "reserve_headers")

    @_builtins.property
    @pulumi.getter(name="specifiedFileType")
    def specified_file_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "specified_file_type")


@pulumi.output_type
class DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomArgsRule(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainV1ConfigsRemoteAuthRemoteAuthRulesAddCustomHeadersRule(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainV1ConfigsRequestLimitRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitRateAfter":
            suggest = "limit_rate_after"
        elif key == "limitRateValue":
            suggest = "limit_rate_value"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsRequestLimitRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsRequestLimitRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsRequestLimitRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_rate_after: _builtins.int,
                 limit_rate_value: _builtins.int,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 type: _builtins.str,
                 match_value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "limit_rate_after", limit_rate_after)
        pulumi.set(__self__, "limit_rate_value", limit_rate_value)
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "type", type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="limitRateAfter")
    def limit_rate_after(self) -> _builtins.int:
        return pulumi.get(self, "limit_rate_after")

    @_builtins.property
    @pulumi.getter(name="limitRateValue")
    def limit_rate_value(self) -> _builtins.int:
        return pulumi.get(self, "limit_rate_value")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_value")


@pulumi.output_type
class DomainV1ConfigsRequestUrlRewrite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionMode":
            suggest = "execution_mode"
        elif key == "redirectUrl":
            suggest = "redirect_url"
        elif key == "redirectHost":
            suggest = "redirect_host"
        elif key == "redirectStatusCode":
            suggest = "redirect_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsRequestUrlRewrite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsRequestUrlRewrite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsRequestUrlRewrite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: 'outputs.DomainV1ConfigsRequestUrlRewriteCondition',
                 execution_mode: _builtins.str,
                 redirect_url: _builtins.str,
                 redirect_host: Optional[_builtins.str] = None,
                 redirect_status_code: Optional[_builtins.int] = None):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "execution_mode", execution_mode)
        pulumi.set(__self__, "redirect_url", redirect_url)
        if redirect_host is not None:
            pulumi.set(__self__, "redirect_host", redirect_host)
        if redirect_status_code is not None:
            pulumi.set(__self__, "redirect_status_code", redirect_status_code)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.DomainV1ConfigsRequestUrlRewriteCondition':
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter(name="executionMode")
    def execution_mode(self) -> _builtins.str:
        return pulumi.get(self, "execution_mode")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> _builtins.str:
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter(name="redirectHost")
    def redirect_host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "redirect_host")

    @_builtins.property
    @pulumi.getter(name="redirectStatusCode")
    def redirect_status_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "redirect_status_code")


@pulumi.output_type
class DomainV1ConfigsRequestUrlRewriteCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "matchValue":
            suggest = "match_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsRequestUrlRewriteCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsRequestUrlRewriteCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsRequestUrlRewriteCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 priority: _builtins.int,
                 match_value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "match_type", match_type)
        pulumi.set(__self__, "priority", priority)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_value")


@pulumi.output_type
class DomainV1ConfigsRetrievalRequestHeader(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainV1ConfigsSni(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsSni. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsSni.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsSni.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 server_name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class DomainV1ConfigsUrlSigning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupKey":
            suggest = "backup_key"
        elif key == "expireTime":
            suggest = "expire_time"
        elif key == "inheritConfig":
            suggest = "inherit_config"
        elif key == "matchType":
            suggest = "match_type"
        elif key == "signArg":
            suggest = "sign_arg"
        elif key == "signMethod":
            suggest = "sign_method"
        elif key == "timeFormat":
            suggest = "time_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsUrlSigning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsUrlSigning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsUrlSigning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 backup_key: Optional[_builtins.str] = None,
                 expire_time: Optional[_builtins.int] = None,
                 inherit_config: Optional['outputs.DomainV1ConfigsUrlSigningInheritConfig'] = None,
                 key: Optional[_builtins.str] = None,
                 match_type: Optional[_builtins.str] = None,
                 sign_arg: Optional[_builtins.str] = None,
                 sign_method: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 time_format: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if backup_key is not None:
            pulumi.set(__self__, "backup_key", backup_key)
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if inherit_config is not None:
            pulumi.set(__self__, "inherit_config", inherit_config)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if sign_arg is not None:
            pulumi.set(__self__, "sign_arg", sign_arg)
        if sign_method is not None:
            pulumi.set(__self__, "sign_method", sign_method)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="backupKey")
    def backup_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "backup_key")

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "expire_time")

    @_builtins.property
    @pulumi.getter(name="inheritConfig")
    def inherit_config(self) -> Optional['outputs.DomainV1ConfigsUrlSigningInheritConfig']:
        return pulumi.get(self, "inherit_config")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="signArg")
    def sign_arg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sign_arg")

    @_builtins.property
    @pulumi.getter(name="signMethod")
    def sign_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sign_method")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "time_format")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainV1ConfigsUrlSigningInheritConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inheritTimeType":
            suggest = "inherit_time_type"
        elif key == "inheritType":
            suggest = "inherit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsUrlSigningInheritConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsUrlSigningInheritConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsUrlSigningInheritConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 inherit_time_type: Optional[_builtins.str] = None,
                 inherit_type: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if inherit_time_type is not None:
            pulumi.set(__self__, "inherit_time_type", inherit_time_type)
        if inherit_type is not None:
            pulumi.set(__self__, "inherit_type", inherit_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="inheritTimeType")
    def inherit_time_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherit_time_type")

    @_builtins.property
    @pulumi.getter(name="inheritType")
    def inherit_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherit_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")


@pulumi.output_type
class DomainV1ConfigsUserAgentFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeEmpty":
            suggest = "include_empty"
        elif key == "uaLists":
            suggest = "ua_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsUserAgentFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsUserAgentFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsUserAgentFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 include_empty: Optional[_builtins.str] = None,
                 ua_lists: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if include_empty is not None:
            pulumi.set(__self__, "include_empty", include_empty)
        if ua_lists is not None:
            pulumi.set(__self__, "ua_lists", ua_lists)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="includeEmpty")
    def include_empty(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "include_empty")

    @_builtins.property
    @pulumi.getter(name="uaLists")
    def ua_lists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ua_lists")


@pulumi.output_type
class DomainV1ConfigsVideoSeek(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableVideoSeek":
            suggest = "enable_video_seek"
        elif key == "enableFlvByTimeSeek":
            suggest = "enable_flv_by_time_seek"
        elif key == "endParameter":
            suggest = "end_parameter"
        elif key == "startParameter":
            suggest = "start_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1ConfigsVideoSeek. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1ConfigsVideoSeek.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1ConfigsVideoSeek.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_video_seek: _builtins.bool,
                 enable_flv_by_time_seek: Optional[_builtins.bool] = None,
                 end_parameter: Optional[_builtins.str] = None,
                 start_parameter: Optional[_builtins.str] = None):
        pulumi.set(__self__, "enable_video_seek", enable_video_seek)
        if enable_flv_by_time_seek is not None:
            pulumi.set(__self__, "enable_flv_by_time_seek", enable_flv_by_time_seek)
        if end_parameter is not None:
            pulumi.set(__self__, "end_parameter", end_parameter)
        if start_parameter is not None:
            pulumi.set(__self__, "start_parameter", start_parameter)

    @_builtins.property
    @pulumi.getter(name="enableVideoSeek")
    def enable_video_seek(self) -> _builtins.bool:
        return pulumi.get(self, "enable_video_seek")

    @_builtins.property
    @pulumi.getter(name="enableFlvByTimeSeek")
    def enable_flv_by_time_seek(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_flv_by_time_seek")

    @_builtins.property
    @pulumi.getter(name="endParameter")
    def end_parameter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end_parameter")

    @_builtins.property
    @pulumi.getter(name="startParameter")
    def start_parameter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "start_parameter")


@pulumi.output_type
class DomainV1ConfigsWebsocket(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 timeout: Optional[_builtins.int] = None):
        pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class DomainV1Source(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originType":
            suggest = "origin_type"
        elif key == "bucketAccessKey":
            suggest = "bucket_access_key"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketRegion":
            suggest = "bucket_region"
        elif key == "bucketSecretKey":
            suggest = "bucket_secret_key"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "obsBucketType":
            suggest = "obs_bucket_type"
        elif key == "obsWebHostingEnabled":
            suggest = "obs_web_hosting_enabled"
        elif key == "retrievalHost":
            suggest = "retrieval_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainV1Source. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainV1Source.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainV1Source.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin: _builtins.str,
                 origin_type: _builtins.str,
                 active: Optional[_builtins.int] = None,
                 bucket_access_key: Optional[_builtins.str] = None,
                 bucket_name: Optional[_builtins.str] = None,
                 bucket_region: Optional[_builtins.str] = None,
                 bucket_secret_key: Optional[_builtins.str] = None,
                 http_port: Optional[_builtins.int] = None,
                 https_port: Optional[_builtins.int] = None,
                 obs_bucket_type: Optional[_builtins.str] = None,
                 obs_web_hosting_enabled: Optional[_builtins.bool] = None,
                 retrieval_host: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str bucket_access_key: Third-party object storage access key.
        :param _builtins.str bucket_name: Third-party object storage bucket name.
        :param _builtins.str bucket_region: Third-party object storage bucket region.
        :param _builtins.str bucket_secret_key: Third-party object storage secret key.
        """
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "origin_type", origin_type)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if bucket_access_key is not None:
            pulumi.set(__self__, "bucket_access_key", bucket_access_key)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_region is not None:
            pulumi.set(__self__, "bucket_region", bucket_region)
        if bucket_secret_key is not None:
            pulumi.set(__self__, "bucket_secret_key", bucket_secret_key)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if obs_bucket_type is not None:
            pulumi.set(__self__, "obs_bucket_type", obs_bucket_type)
        if obs_web_hosting_enabled is not None:
            pulumi.set(__self__, "obs_web_hosting_enabled", obs_web_hosting_enabled)
        if retrieval_host is not None:
            pulumi.set(__self__, "retrieval_host", retrieval_host)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="originType")
    def origin_type(self) -> _builtins.str:
        return pulumi.get(self, "origin_type")

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="bucketAccessKey")
    def bucket_access_key(self) -> Optional[_builtins.str]:
        """
        Third-party object storage access key.
        """
        return pulumi.get(self, "bucket_access_key")

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        Third-party object storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> Optional[_builtins.str]:
        """
        Third-party object storage bucket region.
        """
        return pulumi.get(self, "bucket_region")

    @_builtins.property
    @pulumi.getter(name="bucketSecretKey")
    def bucket_secret_key(self) -> Optional[_builtins.str]:
        """
        Third-party object storage secret key.
        """
        return pulumi.get(self, "bucket_secret_key")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="obsBucketType")
    def obs_bucket_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "obs_bucket_type")

    @_builtins.property
    @pulumi.getter(name="obsWebHostingEnabled")
    def obs_web_hosting_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "obs_web_hosting_enabled")

    @_builtins.property
    @pulumi.getter(name="retrievalHost")
    def retrieval_host(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "retrieval_host")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetCacheHistoryTasksTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 failed: _builtins.int,
                 file_type: _builtins.str,
                 id: _builtins.str,
                 processing: _builtins.int,
                 status: _builtins.str,
                 succeed: _builtins.int,
                 task_type: _builtins.str,
                 total: _builtins.int):
        """
        :param _builtins.str created_at: Indicates the time when the task was created.
        :param _builtins.int failed: Indicates the number of URLs that failed to be processed.
        :param _builtins.str file_type: Specifies the file type. Possible values: **file** and **directory**.
        :param _builtins.str id: Indicates the task ID.
        :param _builtins.int processing: Indicates the number of URLs that are being processed.
        :param _builtins.str status: Specifies the task status. Valid values are as follows:
               + **task_inprocess**: The task is being processed.
               + **task_done**: The task is completed.
        :param _builtins.int succeed: Indicates the number of URLs processed.
        :param _builtins.str task_type: Specifies the task type. Possible values: **refresh** (cache refresh) and
               **preheating** (cache preheat).
        :param _builtins.int total: Indicates the total number of URLs in the task.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "failed", failed)
        pulumi.set(__self__, "file_type", file_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "processing", processing)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "succeed", succeed)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the task was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def failed(self) -> _builtins.int:
        """
        Indicates the number of URLs that failed to be processed.
        """
        return pulumi.get(self, "failed")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> _builtins.str:
        """
        Specifies the file type. Possible values: **file** and **directory**.
        """
        return pulumi.get(self, "file_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the task ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def processing(self) -> _builtins.int:
        """
        Indicates the number of URLs that are being processed.
        """
        return pulumi.get(self, "processing")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the task status. Valid values are as follows:
        + **task_inprocess**: The task is being processed.
        + **task_done**: The task is completed.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def succeed(self) -> _builtins.int:
        """
        Indicates the number of URLs processed.
        """
        return pulumi.get(self, "succeed")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Specifies the task type. Possible values: **refresh** (cache refresh) and
        **preheating** (cache preheat).
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Indicates the total number of URLs in the task.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class GetCacheUrlTasksTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 file_type: _builtins.str,
                 id: _builtins.int,
                 mode: _builtins.str,
                 modify_time: _builtins.str,
                 status: _builtins.str,
                 task_id: _builtins.int,
                 task_type: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the creation time.
        :param _builtins.str file_type: Specifies the file type. Possible values: **file** and **directory**.
        :param _builtins.int id: Indicates the URL ID.
        :param _builtins.str mode: Indicates the directory refresh mode. Possible values: **all** (refresh all resources in the directory) and
               **detect_modify_refresh** (refresh changed resources in the directory).
        :param _builtins.str modify_time: Indicates the modification time.
        :param _builtins.str status: Specifies the URL status. Possible values: **processing**, **succeed**, **failed**,
               **waiting**, **refreshing**, and **preheating**.
        :param _builtins.int task_id: Indicates the task ID.
        :param _builtins.str task_type: Specifies the task type. Possible values: **REFRESH** (cache refresh) and
               **PREHEATING** (cache preheat).
        :param _builtins.str url: Specifies the refresh or preheat URL.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "file_type", file_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "modify_time", modify_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_id", task_id)
        pulumi.set(__self__, "task_type", task_type)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the creation time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> _builtins.str:
        """
        Specifies the file type. Possible values: **file** and **directory**.
        """
        return pulumi.get(self, "file_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        Indicates the URL ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Indicates the directory refresh mode. Possible values: **all** (refresh all resources in the directory) and
        **detect_modify_refresh** (refresh changed resources in the directory).
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> _builtins.str:
        """
        Indicates the modification time.
        """
        return pulumi.get(self, "modify_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the URL status. Possible values: **processing**, **succeed**, **failed**,
        **waiting**, **refreshing**, and **preheating**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskId")
    def task_id(self) -> _builtins.int:
        """
        Indicates the task ID.
        """
        return pulumi.get(self, "task_id")

    @_builtins.property
    @pulumi.getter(name="taskType")
    def task_type(self) -> _builtins.str:
        """
        Specifies the task type. Possible values: **REFRESH** (cache refresh) and
        **PREHEATING** (cache preheat).
        """
        return pulumi.get(self, "task_type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the refresh or preheat URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetDomainCertificatesDomainCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_body: _builtins.str,
                 certificate_name: _builtins.str,
                 certificate_source: _builtins.int,
                 domain_id: _builtins.str,
                 domain_name: _builtins.str,
                 expire_at: _builtins.str,
                 force_redirect_https: _builtins.int,
                 http2_enabled: _builtins.int,
                 https_status: _builtins.int):
        """
        :param _builtins.str certificate_body: The content of the certificate used by the HTTPS protocol.
        :param _builtins.str certificate_name: The certificate name.
        :param _builtins.int certificate_source: The certificate type. The value can be:
               + **1**: Huawei-managed certificate.
               + **0**: Your own certificate.
        :param _builtins.str domain_id: The ID of the CDN domain.
        :param _builtins.str domain_name: The acceleration domain name.
        :param _builtins.str expire_at: The expiration time.
        :param _builtins.int force_redirect_https: Whether client requests are forced to be redirected. The value can be：
               + **0**: Client requests will not be forced to redirect.
               + **1**: Client requests will be forced to redirect.
               + **2**: Client requests will be forced to jump to HTTP.
        :param _builtins.int http2_enabled: Whether HTTP2.0 is used. The value can be：
               + **0**: Not use HTTP2.0.
               + **1**: Use HTTP2.0.
        :param _builtins.int https_status: The status of the https. The value can be:
               + **0**: Do not enable HTTPS certificates.
               + **1**: Enable HTTPS acceleration and protocol follow back to origin.
               + **2**: Enable HTTPS acceleration and HTTP back to origin.
        """
        pulumi.set(__self__, "certificate_body", certificate_body)
        pulumi.set(__self__, "certificate_name", certificate_name)
        pulumi.set(__self__, "certificate_source", certificate_source)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "expire_at", expire_at)
        pulumi.set(__self__, "force_redirect_https", force_redirect_https)
        pulumi.set(__self__, "http2_enabled", http2_enabled)
        pulumi.set(__self__, "https_status", https_status)

    @_builtins.property
    @pulumi.getter(name="certificateBody")
    def certificate_body(self) -> _builtins.str:
        """
        The content of the certificate used by the HTTPS protocol.
        """
        return pulumi.get(self, "certificate_body")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> _builtins.str:
        """
        The certificate name.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> _builtins.int:
        """
        The certificate type. The value can be:
        + **1**: Huawei-managed certificate.
        + **0**: Your own certificate.
        """
        return pulumi.get(self, "certificate_source")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        """
        The ID of the CDN domain.
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        The acceleration domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="expireAt")
    def expire_at(self) -> _builtins.str:
        """
        The expiration time.
        """
        return pulumi.get(self, "expire_at")

    @_builtins.property
    @pulumi.getter(name="forceRedirectHttps")
    def force_redirect_https(self) -> _builtins.int:
        """
        Whether client requests are forced to be redirected. The value can be：
        + **0**: Client requests will not be forced to redirect.
        + **1**: Client requests will be forced to redirect.
        + **2**: Client requests will be forced to jump to HTTP.
        """
        return pulumi.get(self, "force_redirect_https")

    @_builtins.property
    @pulumi.getter(name="http2Enabled")
    def http2_enabled(self) -> _builtins.int:
        """
        Whether HTTP2.0 is used. The value can be：
        + **0**: Not use HTTP2.0.
        + **1**: Use HTTP2.0.
        """
        return pulumi.get(self, "http2_enabled")

    @_builtins.property
    @pulumi.getter(name="httpsStatus")
    def https_status(self) -> _builtins.int:
        """
        The status of the https. The value can be:
        + **0**: Do not enable HTTPS certificates.
        + **1**: Enable HTTPS acceleration and protocol follow back to origin.
        + **2**: Enable HTTPS acceleration and HTTP back to origin.
        """
        return pulumi.get(self, "https_status")


@pulumi.output_type
class GetDomainsDomainResult(dict):
    def __init__(__self__, *,
                 auto_refresh_preheat: _builtins.int,
                 banned_reason: _builtins.str,
                 cname: _builtins.str,
                 created_at: _builtins.str,
                 disabled: _builtins.int,
                 domain_origin_host: Mapping[str, _builtins.str],
                 domain_status: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 follow_status: _builtins.str,
                 https_status: _builtins.int,
                 id: _builtins.str,
                 locked: _builtins.int,
                 locked_reason: _builtins.str,
                 name: _builtins.str,
                 origin_status: _builtins.str,
                 range_based_retrieval_enabled: _builtins.bool,
                 service_area: _builtins.str,
                 sources: Sequence['outputs.GetDomainsDomainSourceResult'],
                 tags: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.int auto_refresh_preheat: Whether to automatically refresh preheating. The valid values are as follows:
               + **0**: Auto_refresh_preheat is off.
               + **1**: Auto_refresh_preheat is on.
        :param _builtins.str banned_reason: The reason why the domain was banned.
        :param _builtins.str cname: The CNAME of the accelerate domain.
        :param _builtins.str created_at: The creation time of accelerate domain.
        :param _builtins.int disabled: Ban status. The valid values are as follows:
               + **0**: The domain is not banned.
               + **1**: The domain is banned.
        :param Mapping[str, _builtins.str] domain_origin_host: The back-to-origin HOST configuration of accelerate domain.
               The domain_origin_host structure is documented below.
        :param _builtins.str domain_status: Specifies the status of accelerate domain.
               The valid value can be **online**, **offline**, **configuring**, **configuring_failed**, **checking**,
               **check_failed** or **deleting**.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID of the CDN domain.
               When the user turns on the enterprise project function, this parameter takes effect,
               indicating that the project to which the resource belongs is queried.
               "all" indicates all projects.
        :param _builtins.str follow_status: The status of back-to-source following.
               The valid value can be **on** or **off**.
        :param _builtins.int https_status: The status of the https. The valid values are as follows:
               + **0**: Disable HTTPS acceleration.
               + **1**: Turn on HTTPS acceleration.
        :param _builtins.str id: The ID of CDN domain.
        :param _builtins.int locked: Lock status. The valid values are as follows:
               + **0**: The domain is not locked
               + **1**: The domain is locked.
        :param _builtins.str locked_reason: The reason why the domain was locked.
        :param _builtins.str name: Specifies the name of accelerate domain, using fuzzy matching.
               The valid length is limited from `1` to `255`.
        :param _builtins.str origin_status: Whether to pause origin site return to origin.
               The valid value can be **on** or **off**.
        :param _builtins.bool range_based_retrieval_enabled: Whether to enable range-based retrieval.
               The valid value can be **true** or **false**.
        :param _builtins.str service_area: Specifies the area covered by the accelerate service.
               The valid value can be **mainland_china**, **outside_mainland_china** or **global**.
        :param Sequence['GetDomainsDomainSourceArgs'] sources: An array of one or more objects specifies the domain of the origin server.
               The sources structure is documented below.
        :param Mapping[str, _builtins.str] tags: The key/value pairs to associate with the domain.
        :param _builtins.str type: Specifies the business type of accelerate domain.
               The valid values are as follows;
               + **web**: Accelerate for the website.
               + **download**: Accelerate for file downloads.
               + **video**: Accelerate for on-demand.
               + **wholeSite**: Accelerate for the entire site.
        :param _builtins.str updated_at: The update time of accelerate domain.
        """
        pulumi.set(__self__, "auto_refresh_preheat", auto_refresh_preheat)
        pulumi.set(__self__, "banned_reason", banned_reason)
        pulumi.set(__self__, "cname", cname)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "domain_origin_host", domain_origin_host)
        pulumi.set(__self__, "domain_status", domain_status)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "follow_status", follow_status)
        pulumi.set(__self__, "https_status", https_status)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "locked", locked)
        pulumi.set(__self__, "locked_reason", locked_reason)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "origin_status", origin_status)
        pulumi.set(__self__, "range_based_retrieval_enabled", range_based_retrieval_enabled)
        pulumi.set(__self__, "service_area", service_area)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="autoRefreshPreheat")
    def auto_refresh_preheat(self) -> _builtins.int:
        """
        Whether to automatically refresh preheating. The valid values are as follows:
        + **0**: Auto_refresh_preheat is off.
        + **1**: Auto_refresh_preheat is on.
        """
        return pulumi.get(self, "auto_refresh_preheat")

    @_builtins.property
    @pulumi.getter(name="bannedReason")
    def banned_reason(self) -> _builtins.str:
        """
        The reason why the domain was banned.
        """
        return pulumi.get(self, "banned_reason")

    @_builtins.property
    @pulumi.getter
    def cname(self) -> _builtins.str:
        """
        The CNAME of the accelerate domain.
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of accelerate domain.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.int:
        """
        Ban status. The valid values are as follows:
        + **0**: The domain is not banned.
        + **1**: The domain is banned.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="domainOriginHost")
    def domain_origin_host(self) -> Mapping[str, _builtins.str]:
        """
        The back-to-origin HOST configuration of accelerate domain.
        The domain_origin_host structure is documented below.
        """
        return pulumi.get(self, "domain_origin_host")

    @_builtins.property
    @pulumi.getter(name="domainStatus")
    def domain_status(self) -> _builtins.str:
        """
        Specifies the status of accelerate domain.
        The valid value can be **online**, **offline**, **configuring**, **configuring_failed**, **checking**,
        **check_failed** or **deleting**.
        """
        return pulumi.get(self, "domain_status")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID of the CDN domain.
        When the user turns on the enterprise project function, this parameter takes effect,
        indicating that the project to which the resource belongs is queried.
        "all" indicates all projects.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="followStatus")
    def follow_status(self) -> _builtins.str:
        """
        The status of back-to-source following.
        The valid value can be **on** or **off**.
        """
        return pulumi.get(self, "follow_status")

    @_builtins.property
    @pulumi.getter(name="httpsStatus")
    def https_status(self) -> _builtins.int:
        """
        The status of the https. The valid values are as follows:
        + **0**: Disable HTTPS acceleration.
        + **1**: Turn on HTTPS acceleration.
        """
        return pulumi.get(self, "https_status")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of CDN domain.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> _builtins.int:
        """
        Lock status. The valid values are as follows:
        + **0**: The domain is not locked
        + **1**: The domain is locked.
        """
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter(name="lockedReason")
    def locked_reason(self) -> _builtins.str:
        """
        The reason why the domain was locked.
        """
        return pulumi.get(self, "locked_reason")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of accelerate domain, using fuzzy matching.
        The valid length is limited from `1` to `255`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="originStatus")
    def origin_status(self) -> _builtins.str:
        """
        Whether to pause origin site return to origin.
        The valid value can be **on** or **off**.
        """
        return pulumi.get(self, "origin_status")

    @_builtins.property
    @pulumi.getter(name="rangeBasedRetrievalEnabled")
    def range_based_retrieval_enabled(self) -> _builtins.bool:
        """
        Whether to enable range-based retrieval.
        The valid value can be **true** or **false**.
        """
        return pulumi.get(self, "range_based_retrieval_enabled")

    @_builtins.property
    @pulumi.getter(name="serviceArea")
    def service_area(self) -> _builtins.str:
        """
        Specifies the area covered by the accelerate service.
        The valid value can be **mainland_china**, **outside_mainland_china** or **global**.
        """
        return pulumi.get(self, "service_area")

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetDomainsDomainSourceResult']:
        """
        An array of one or more objects specifies the domain of the origin server.
        The sources structure is documented below.
        """
        return pulumi.get(self, "sources")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to associate with the domain.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the business type of accelerate domain.
        The valid values are as follows;
        + **web**: Accelerate for the website.
        + **download**: Accelerate for file downloads.
        + **video**: Accelerate for on-demand.
        + **wholeSite**: Accelerate for the entire site.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The update time of accelerate domain.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetDomainsDomainSourceResult(dict):
    def __init__(__self__, *,
                 active: _builtins.int,
                 obs_web_hosting_enabled: _builtins.bool,
                 origin: _builtins.str,
                 origin_type: _builtins.str):
        """
        :param _builtins.int active: Whether an origin server is active or standby. The valid values are ad follows:
               + **1**: The origin source is primary source site.
               + **0**: The origin source is backup source site.
        :param _builtins.bool obs_web_hosting_enabled: Whether to enable static website hosting for the OBS bucket.
               The valid value can be **true** or **false**.
        :param _builtins.str origin: The domain name or IP address of the origin server.
        :param _builtins.str origin_type: The origin server type. The valid values can be **ipaddr**, **domain** or **obs_bucket**.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "obs_web_hosting_enabled", obs_web_hosting_enabled)
        pulumi.set(__self__, "origin", origin)
        pulumi.set(__self__, "origin_type", origin_type)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.int:
        """
        Whether an origin server is active or standby. The valid values are ad follows:
        + **1**: The origin source is primary source site.
        + **0**: The origin source is backup source site.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter(name="obsWebHostingEnabled")
    def obs_web_hosting_enabled(self) -> _builtins.bool:
        """
        Whether to enable static website hosting for the OBS bucket.
        The valid value can be **true** or **false**.
        """
        return pulumi.get(self, "obs_web_hosting_enabled")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> _builtins.str:
        """
        The domain name or IP address of the origin server.
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter(name="originType")
    def origin_type(self) -> _builtins.str:
        """
        The origin server type. The valid values can be **ipaddr**, **domain** or **obs_bucket**.
        """
        return pulumi.get(self, "origin_type")


@pulumi.output_type
class GetLogsLogResult(dict):
    def __init__(__self__, *,
                 domain_name: _builtins.str,
                 end_time: _builtins.int,
                 link: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.int,
                 start_time: _builtins.int):
        """
        :param _builtins.str domain_name: Specifies the domain name to which the logs belong.
        :param _builtins.int end_time: Specifies the end time for querying logs (excluding the end time point).
               The value is the millisecond timestamp of the hour. The maximum time span between the start time and
               end time is 30 days.
               If this parameter is left empty, the start time plus one day is used by default.
        :param _builtins.str link: The log file download link.
        :param _builtins.str name: The name of the log file.
        :param _builtins.int size: The size of the log file, in KB.
        :param _builtins.int start_time: Specifies the start time for querying logs.
               The value is the millisecond timestamp of the hour.
               If this parameter is left empty, **00:00:00** of the current day is used by default.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "link", link)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Specifies the domain name to which the logs belong.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.int:
        """
        Specifies the end time for querying logs (excluding the end time point).
        The value is the millisecond timestamp of the hour. The maximum time span between the start time and
        end time is 30 days.
        If this parameter is left empty, the start time plus one day is used by default.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def link(self) -> _builtins.str:
        """
        The log file download link.
        """
        return pulumi.get(self, "link")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the log file.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The size of the log file, in KB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.int:
        """
        Specifies the start time for querying logs.
        The value is the millisecond timestamp of the hour.
        If this parameter is left empty, **00:00:00** of the current day is used by default.
        """
        return pulumi.get(self, "start_time")


