# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'KafkaInstanceCrossVpcAccess',
    'KafkaInstanceParameter',
    'KafkaInstancePortProtocol',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionList',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemList',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceId',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseId',
    'KafkaMessageProducePropertyList',
    'KafkaPartitionReassignReassignment',
    'KafkaPartitionReassignReassignmentAssignment',
    'KafkaPermissionsPolicy',
    'KafkaTopicConfig',
    'Kafkav2SmartConnectTaskDestinationTask',
    'Kafkav2SmartConnectTaskSourceTask',
    'RabbitmqExchangeBinding',
    'RabbitmqQueueConsumerDetail',
    'RabbitmqQueueConsumerDetailChannelDetail',
    'RabbitmqQueueQueueBinding',
    'RabbitmqUserVhost',
    'RocketmqConsumptionVerifyResendResult',
    'RocketmqDeadLetterResendResendResult',
    'RocketmqInstanceConfig',
    'RocketmqInstanceCrossVpcAccess',
    'RocketmqMessageSendPropertyList',
    'RocketmqMigrationTaskBinding',
    'RocketmqMigrationTaskExchange',
    'RocketmqMigrationTaskQueue',
    'RocketmqMigrationTaskSubscriptionGroup',
    'RocketmqMigrationTaskTopicConfig',
    'RocketmqMigrationTaskVhost',
    'RocketmqTopicBroker',
    'RocketmqTopicQueue',
    'RocketmqUserGroupPerm',
    'RocketmqUserTopicPerm',
    'GetFlavorsFlavorResult',
    'GetFlavorsFlavorIoResult',
    'GetFlavorsFlavorPropertyResult',
    'GetFlavorsFlavorSupportFeatureResult',
    'GetFlavorsFlavorSupportFeaturePropertyResult',
    'GetInstancesInstanceResult',
    'GetInstancesInstanceCrossVpcAccessResult',
    'GetKafkaBackgroundTasksTaskResult',
    'GetKafkaConsumerGroupsGroupResult',
    'GetKafkaConsumerGroupsGroupGroupMessageOffsetResult',
    'GetKafkaConsumerGroupsGroupMemberResult',
    'GetKafkaConsumerGroupsGroupMemberAssignmentResult',
    'GetKafkaExtendFlavorsFlavorResult',
    'GetKafkaExtendFlavorsFlavorIoResult',
    'GetKafkaExtendFlavorsFlavorPropertyResult',
    'GetKafkaExtendFlavorsFlavorSupportFeatureResult',
    'GetKafkaMessageDiagnosisTasksReportListResult',
    'GetKafkaMessagesMessageResult',
    'GetKafkaSmartConnectTasksTaskResult',
    'GetKafkaTopicPartitionsPartitionResult',
    'GetKafkaTopicProducersProducerResult',
    'GetKafkaTopicsTopicResult',
    'GetKafkaTopicsTopicConfigResult',
    'GetKafkaUserClientQuotasQuotaResult',
    'GetKafkaUsersUserResult',
    'GetKafkav2SmartConnectTasksTaskResult',
    'GetKafkav2SmartConnectTasksTaskDestinationTaskResult',
    'GetKafkav2SmartConnectTasksTaskSourceTaskResult',
    'GetRabbitmqBackgroundTasksTaskResult',
    'GetRabbitmqExchangesExchangeResult',
    'GetRabbitmqExtendFlavorsFlavorResult',
    'GetRabbitmqExtendFlavorsFlavorIoResult',
    'GetRabbitmqExtendFlavorsFlavorPropertyResult',
    'GetRabbitmqExtendFlavorsFlavorSupportFeatureResult',
    'GetRabbitmqFlavorsFlavorResult',
    'GetRabbitmqFlavorsFlavorIoResult',
    'GetRabbitmqFlavorsFlavorPropertyResult',
    'GetRabbitmqFlavorsFlavorSupportFeatureResult',
    'GetRabbitmqFlavorsFlavorSupportFeaturePropertyResult',
    'GetRabbitmqInstancesInstanceResult',
    'GetRabbitmqPluginsPluginResult',
    'GetRabbitmqQueuesQueueResult',
    'GetRabbitmqUsersUserResult',
    'GetRabbitmqUsersUserVhostResult',
    'GetRabbitmqVhostsVhostResult',
    'GetRocketmqAvailabilityZonesAvailabilityZoneResult',
    'GetRocketmqBackgroundTasksTaskResult',
    'GetRocketmqConsumerGroupAccessUsersPolicyResult',
    'GetRocketmqConsumerGroupsGroupResult',
    'GetRocketmqConsumersClientResult',
    'GetRocketmqConsumersClientSubscriptionResult',
    'GetRocketmqDeadLetterMessagesMessageResult',
    'GetRocketmqDeadLetterMessagesMessagePropertyListResult',
    'GetRocketmqExtendFlavorsFlavorResult',
    'GetRocketmqExtendFlavorsFlavorIoResult',
    'GetRocketmqExtendFlavorsFlavorPropertyResult',
    'GetRocketmqExtendFlavorsFlavorSupportFeatureResult',
    'GetRocketmqFlavorsFlavorResult',
    'GetRocketmqFlavorsFlavorIoResult',
    'GetRocketmqFlavorsFlavorPropertyResult',
    'GetRocketmqFlavorsFlavorSupportFeatureResult',
    'GetRocketmqFlavorsFlavorSupportFeaturePropertyResult',
    'GetRocketmqInstanceNodesNodeResult',
    'GetRocketmqInstancesInstanceResult',
    'GetRocketmqInstancesInstanceCrossVpcAccessResult',
    'GetRocketmqMessageTracesTraceResult',
    'GetRocketmqMessagesMessageResult',
    'GetRocketmqMessagesMessagePropertyListResult',
    'GetRocketmqMigrationTasksTaskResult',
    'GetRocketmqTagsTagResult',
    'GetRocketmqTopicAccessUsersPolicyResult',
    'GetRocketmqTopicsTopicResult',
    'GetRocketmqTopicsTopicBrokerResult',
    'GetRocketmqUsersUserResult',
    'GetRocketmqUsersUserGroupPermResult',
    'GetRocketmqUsersUserTopicPermResult',
]

@pulumi.output_type
class KafkaInstanceCrossVpcAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedIp":
            suggest = "advertised_ip"
        elif key == "lisenterIp":
            suggest = "lisenter_ip"
        elif key == "listenerIp":
            suggest = "listener_ip"
        elif key == "portId":
            suggest = "port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaInstanceCrossVpcAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaInstanceCrossVpcAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaInstanceCrossVpcAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_ip: Optional[_builtins.str] = None,
                 lisenter_ip: Optional[_builtins.str] = None,
                 listener_ip: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str advertised_ip: The advertised IP Address or domain name.
               
               <a name="dms_parameters"></a>
               The `parameters` block supports:
        :param _builtins.str listener_ip: The listener IP address.
        :param _builtins.int port: The port number.
        :param _builtins.str port_id: The port ID associated with the address.
        """
        if advertised_ip is not None:
            pulumi.set(__self__, "advertised_ip", advertised_ip)
        if lisenter_ip is not None:
            pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        if listener_ip is not None:
            pulumi.set(__self__, "listener_ip", listener_ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> Optional[_builtins.str]:
        """
        The advertised IP Address or domain name.

        <a name="dms_parameters"></a>
        The `parameters` block supports:
        """
        return pulumi.get(self, "advertised_ip")

    @_builtins.property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lisenter_ip")

    @_builtins.property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> Optional[_builtins.str]:
        """
        The listener IP address.
        """
        return pulumi.get(self, "listener_ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[_builtins.str]:
        """
        The port ID associated with the address.
        """
        return pulumi.get(self, "port_id")


@pulumi.output_type
class KafkaInstanceParameter(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the parameter name. Static parameter needs to restart the instance to take effect.
        :param _builtins.str value: Specifies the parameter value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the parameter name. Static parameter needs to restart the instance to take effect.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the parameter value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaInstancePortProtocol(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privatePlainAddress":
            suggest = "private_plain_address"
        elif key == "privatePlainDomainName":
            suggest = "private_plain_domain_name"
        elif key == "privatePlainEnable":
            suggest = "private_plain_enable"
        elif key == "privateSaslPlaintextAddress":
            suggest = "private_sasl_plaintext_address"
        elif key == "privateSaslPlaintextDomainName":
            suggest = "private_sasl_plaintext_domain_name"
        elif key == "privateSaslPlaintextEnable":
            suggest = "private_sasl_plaintext_enable"
        elif key == "privateSaslSslAddress":
            suggest = "private_sasl_ssl_address"
        elif key == "privateSaslSslDomainName":
            suggest = "private_sasl_ssl_domain_name"
        elif key == "privateSaslSslEnable":
            suggest = "private_sasl_ssl_enable"
        elif key == "publicPlainAddress":
            suggest = "public_plain_address"
        elif key == "publicPlainDomainName":
            suggest = "public_plain_domain_name"
        elif key == "publicPlainEnable":
            suggest = "public_plain_enable"
        elif key == "publicSaslPlaintextAddress":
            suggest = "public_sasl_plaintext_address"
        elif key == "publicSaslPlaintextDomainName":
            suggest = "public_sasl_plaintext_domain_name"
        elif key == "publicSaslPlaintextEnable":
            suggest = "public_sasl_plaintext_enable"
        elif key == "publicSaslSslAddress":
            suggest = "public_sasl_ssl_address"
        elif key == "publicSaslSslDomainName":
            suggest = "public_sasl_ssl_domain_name"
        elif key == "publicSaslSslEnable":
            suggest = "public_sasl_ssl_enable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaInstancePortProtocol. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaInstancePortProtocol.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaInstancePortProtocol.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_plain_address: Optional[_builtins.str] = None,
                 private_plain_domain_name: Optional[_builtins.str] = None,
                 private_plain_enable: Optional[_builtins.bool] = None,
                 private_sasl_plaintext_address: Optional[_builtins.str] = None,
                 private_sasl_plaintext_domain_name: Optional[_builtins.str] = None,
                 private_sasl_plaintext_enable: Optional[_builtins.bool] = None,
                 private_sasl_ssl_address: Optional[_builtins.str] = None,
                 private_sasl_ssl_domain_name: Optional[_builtins.str] = None,
                 private_sasl_ssl_enable: Optional[_builtins.bool] = None,
                 public_plain_address: Optional[_builtins.str] = None,
                 public_plain_domain_name: Optional[_builtins.str] = None,
                 public_plain_enable: Optional[_builtins.bool] = None,
                 public_sasl_plaintext_address: Optional[_builtins.str] = None,
                 public_sasl_plaintext_domain_name: Optional[_builtins.str] = None,
                 public_sasl_plaintext_enable: Optional[_builtins.bool] = None,
                 public_sasl_ssl_address: Optional[_builtins.str] = None,
                 public_sasl_ssl_domain_name: Optional[_builtins.str] = None,
                 public_sasl_ssl_enable: Optional[_builtins.bool] = None):
        """
        :param _builtins.str private_plain_address: The private plain address.
        :param _builtins.str private_plain_domain_name: The private plain domain name.
        :param _builtins.bool private_plain_enable: Whether the private plain enabled.
        :param _builtins.str private_sasl_plaintext_address: The private sasl plaintext address.
        :param _builtins.str private_sasl_plaintext_domain_name: The private sasl plaintext domain name.
        :param _builtins.bool private_sasl_plaintext_enable: Whether the private sasl plaintext enabled.
        :param _builtins.str private_sasl_ssl_address: The private sasl ssl address.
        :param _builtins.str private_sasl_ssl_domain_name: The private sasl ssl domain name.
        :param _builtins.bool private_sasl_ssl_enable: Whether the private sasl ssl enabled.
        :param _builtins.str public_plain_address: The public plain address.
        :param _builtins.str public_plain_domain_name: The public plain domain name.
        :param _builtins.bool public_plain_enable: Whether the public plain enabled.
        :param _builtins.str public_sasl_plaintext_address: The public sasl plaintext address.
        :param _builtins.str public_sasl_plaintext_domain_name: The public sasl plaintext domain name.
        :param _builtins.bool public_sasl_plaintext_enable: Whether the public sasl plaintext enabled.
        :param _builtins.str public_sasl_ssl_address: The public sasl ssl address.
        :param _builtins.str public_sasl_ssl_domain_name: The public sasl ssl domain name.
        :param _builtins.bool public_sasl_ssl_enable: Whether the public sasl ssl enabled.
        """
        if private_plain_address is not None:
            pulumi.set(__self__, "private_plain_address", private_plain_address)
        if private_plain_domain_name is not None:
            pulumi.set(__self__, "private_plain_domain_name", private_plain_domain_name)
        if private_plain_enable is not None:
            pulumi.set(__self__, "private_plain_enable", private_plain_enable)
        if private_sasl_plaintext_address is not None:
            pulumi.set(__self__, "private_sasl_plaintext_address", private_sasl_plaintext_address)
        if private_sasl_plaintext_domain_name is not None:
            pulumi.set(__self__, "private_sasl_plaintext_domain_name", private_sasl_plaintext_domain_name)
        if private_sasl_plaintext_enable is not None:
            pulumi.set(__self__, "private_sasl_plaintext_enable", private_sasl_plaintext_enable)
        if private_sasl_ssl_address is not None:
            pulumi.set(__self__, "private_sasl_ssl_address", private_sasl_ssl_address)
        if private_sasl_ssl_domain_name is not None:
            pulumi.set(__self__, "private_sasl_ssl_domain_name", private_sasl_ssl_domain_name)
        if private_sasl_ssl_enable is not None:
            pulumi.set(__self__, "private_sasl_ssl_enable", private_sasl_ssl_enable)
        if public_plain_address is not None:
            pulumi.set(__self__, "public_plain_address", public_plain_address)
        if public_plain_domain_name is not None:
            pulumi.set(__self__, "public_plain_domain_name", public_plain_domain_name)
        if public_plain_enable is not None:
            pulumi.set(__self__, "public_plain_enable", public_plain_enable)
        if public_sasl_plaintext_address is not None:
            pulumi.set(__self__, "public_sasl_plaintext_address", public_sasl_plaintext_address)
        if public_sasl_plaintext_domain_name is not None:
            pulumi.set(__self__, "public_sasl_plaintext_domain_name", public_sasl_plaintext_domain_name)
        if public_sasl_plaintext_enable is not None:
            pulumi.set(__self__, "public_sasl_plaintext_enable", public_sasl_plaintext_enable)
        if public_sasl_ssl_address is not None:
            pulumi.set(__self__, "public_sasl_ssl_address", public_sasl_ssl_address)
        if public_sasl_ssl_domain_name is not None:
            pulumi.set(__self__, "public_sasl_ssl_domain_name", public_sasl_ssl_domain_name)
        if public_sasl_ssl_enable is not None:
            pulumi.set(__self__, "public_sasl_ssl_enable", public_sasl_ssl_enable)

    @_builtins.property
    @pulumi.getter(name="privatePlainAddress")
    def private_plain_address(self) -> Optional[_builtins.str]:
        """
        The private plain address.
        """
        return pulumi.get(self, "private_plain_address")

    @_builtins.property
    @pulumi.getter(name="privatePlainDomainName")
    def private_plain_domain_name(self) -> Optional[_builtins.str]:
        """
        The private plain domain name.
        """
        return pulumi.get(self, "private_plain_domain_name")

    @_builtins.property
    @pulumi.getter(name="privatePlainEnable")
    def private_plain_enable(self) -> Optional[_builtins.bool]:
        """
        Whether the private plain enabled.
        """
        return pulumi.get(self, "private_plain_enable")

    @_builtins.property
    @pulumi.getter(name="privateSaslPlaintextAddress")
    def private_sasl_plaintext_address(self) -> Optional[_builtins.str]:
        """
        The private sasl plaintext address.
        """
        return pulumi.get(self, "private_sasl_plaintext_address")

    @_builtins.property
    @pulumi.getter(name="privateSaslPlaintextDomainName")
    def private_sasl_plaintext_domain_name(self) -> Optional[_builtins.str]:
        """
        The private sasl plaintext domain name.
        """
        return pulumi.get(self, "private_sasl_plaintext_domain_name")

    @_builtins.property
    @pulumi.getter(name="privateSaslPlaintextEnable")
    def private_sasl_plaintext_enable(self) -> Optional[_builtins.bool]:
        """
        Whether the private sasl plaintext enabled.
        """
        return pulumi.get(self, "private_sasl_plaintext_enable")

    @_builtins.property
    @pulumi.getter(name="privateSaslSslAddress")
    def private_sasl_ssl_address(self) -> Optional[_builtins.str]:
        """
        The private sasl ssl address.
        """
        return pulumi.get(self, "private_sasl_ssl_address")

    @_builtins.property
    @pulumi.getter(name="privateSaslSslDomainName")
    def private_sasl_ssl_domain_name(self) -> Optional[_builtins.str]:
        """
        The private sasl ssl domain name.
        """
        return pulumi.get(self, "private_sasl_ssl_domain_name")

    @_builtins.property
    @pulumi.getter(name="privateSaslSslEnable")
    def private_sasl_ssl_enable(self) -> Optional[_builtins.bool]:
        """
        Whether the private sasl ssl enabled.
        """
        return pulumi.get(self, "private_sasl_ssl_enable")

    @_builtins.property
    @pulumi.getter(name="publicPlainAddress")
    def public_plain_address(self) -> Optional[_builtins.str]:
        """
        The public plain address.
        """
        return pulumi.get(self, "public_plain_address")

    @_builtins.property
    @pulumi.getter(name="publicPlainDomainName")
    def public_plain_domain_name(self) -> Optional[_builtins.str]:
        """
        The public plain domain name.
        """
        return pulumi.get(self, "public_plain_domain_name")

    @_builtins.property
    @pulumi.getter(name="publicPlainEnable")
    def public_plain_enable(self) -> Optional[_builtins.bool]:
        """
        Whether the public plain enabled.
        """
        return pulumi.get(self, "public_plain_enable")

    @_builtins.property
    @pulumi.getter(name="publicSaslPlaintextAddress")
    def public_sasl_plaintext_address(self) -> Optional[_builtins.str]:
        """
        The public sasl plaintext address.
        """
        return pulumi.get(self, "public_sasl_plaintext_address")

    @_builtins.property
    @pulumi.getter(name="publicSaslPlaintextDomainName")
    def public_sasl_plaintext_domain_name(self) -> Optional[_builtins.str]:
        """
        The public sasl plaintext domain name.
        """
        return pulumi.get(self, "public_sasl_plaintext_domain_name")

    @_builtins.property
    @pulumi.getter(name="publicSaslPlaintextEnable")
    def public_sasl_plaintext_enable(self) -> Optional[_builtins.bool]:
        """
        Whether the public sasl plaintext enabled.
        """
        return pulumi.get(self, "public_sasl_plaintext_enable")

    @_builtins.property
    @pulumi.getter(name="publicSaslSslAddress")
    def public_sasl_ssl_address(self) -> Optional[_builtins.str]:
        """
        The public sasl ssl address.
        """
        return pulumi.get(self, "public_sasl_ssl_address")

    @_builtins.property
    @pulumi.getter(name="publicSaslSslDomainName")
    def public_sasl_ssl_domain_name(self) -> Optional[_builtins.str]:
        """
        The public sasl ssl domain name.
        """
        return pulumi.get(self, "public_sasl_ssl_domain_name")

    @_builtins.property
    @pulumi.getter(name="publicSaslSslEnable")
    def public_sasl_ssl_enable(self) -> Optional[_builtins.bool]:
        """
        Whether the public sasl ssl enabled.
        """
        return pulumi.get(self, "public_sasl_ssl_enable")


@pulumi.output_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abnormalNum":
            suggest = "abnormal_num"
        elif key == "diagnosisItemLists":
            suggest = "diagnosis_item_lists"
        elif key == "failedNum":
            suggest = "failed_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMessageDiagnosisTaskDiagnosisDimensionList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMessageDiagnosisTaskDiagnosisDimensionList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMessageDiagnosisTaskDiagnosisDimensionList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 abnormal_num: Optional[_builtins.int] = None,
                 diagnosis_item_lists: Optional[Sequence['outputs.KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemList']] = None,
                 failed_num: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.int abnormal_num: Indicates the total number of abnormal items in this diagnosis dimension.
        :param Sequence['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgs'] diagnosis_item_lists: Indicates the diagnosis items.
               The diagnosis_item_list structure is documented below.
        :param _builtins.int failed_num: Indicates the total number of failed items in this diagnosis dimension.
        :param _builtins.str name: Indicates the diagnosis item name.
        """
        if abnormal_num is not None:
            pulumi.set(__self__, "abnormal_num", abnormal_num)
        if diagnosis_item_lists is not None:
            pulumi.set(__self__, "diagnosis_item_lists", diagnosis_item_lists)
        if failed_num is not None:
            pulumi.set(__self__, "failed_num", failed_num)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="abnormalNum")
    def abnormal_num(self) -> Optional[_builtins.int]:
        """
        Indicates the total number of abnormal items in this diagnosis dimension.
        """
        return pulumi.get(self, "abnormal_num")

    @_builtins.property
    @pulumi.getter(name="diagnosisItemLists")
    def diagnosis_item_lists(self) -> Optional[Sequence['outputs.KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemList']]:
        """
        Indicates the diagnosis items.
        The diagnosis_item_list structure is documented below.
        """
        return pulumi.get(self, "diagnosis_item_lists")

    @_builtins.property
    @pulumi.getter(name="failedNum")
    def failed_num(self) -> Optional[_builtins.int]:
        """
        Indicates the total number of failed items in this diagnosis dimension.
        """
        return pulumi.get(self, "failed_num")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the diagnosis item name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adviceIds":
            suggest = "advice_ids"
        elif key == "brokerIds":
            suggest = "broker_ids"
        elif key == "causeIds":
            suggest = "cause_ids"
        elif key == "failedPartitions":
            suggest = "failed_partitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advice_ids: Optional[Sequence['outputs.KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceId']] = None,
                 broker_ids: Optional[Sequence[_builtins.int]] = None,
                 cause_ids: Optional[Sequence['outputs.KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseId']] = None,
                 failed_partitions: Optional[Sequence[_builtins.int]] = None,
                 name: Optional[_builtins.str] = None,
                 partitions: Optional[Sequence[_builtins.int]] = None,
                 result: Optional[_builtins.str] = None):
        """
        :param Sequence['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgs'] advice_ids: Indicates the suggestions for diagnosis exceptions.
               The conclusion structure is documented below.
        :param Sequence[_builtins.int] broker_ids: Indicates the brokers affected by the diagnosis exceptions.
        :param Sequence['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgs'] cause_ids: Indicates the diagnosis exception causes.
               The conclusion structure is documented below.
        :param Sequence[_builtins.int] failed_partitions: Indicates the partitions that failed to be diagnosed.
        :param _builtins.str name: Indicates the diagnosis item name.
        :param Sequence[_builtins.int] partitions: Indicates the partitions affected by the diagnosis exceptions.
        :param _builtins.str result: Indicates the diagnosis result.
        """
        if advice_ids is not None:
            pulumi.set(__self__, "advice_ids", advice_ids)
        if broker_ids is not None:
            pulumi.set(__self__, "broker_ids", broker_ids)
        if cause_ids is not None:
            pulumi.set(__self__, "cause_ids", cause_ids)
        if failed_partitions is not None:
            pulumi.set(__self__, "failed_partitions", failed_partitions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter(name="adviceIds")
    def advice_ids(self) -> Optional[Sequence['outputs.KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceId']]:
        """
        Indicates the suggestions for diagnosis exceptions.
        The conclusion structure is documented below.
        """
        return pulumi.get(self, "advice_ids")

    @_builtins.property
    @pulumi.getter(name="brokerIds")
    def broker_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        Indicates the brokers affected by the diagnosis exceptions.
        """
        return pulumi.get(self, "broker_ids")

    @_builtins.property
    @pulumi.getter(name="causeIds")
    def cause_ids(self) -> Optional[Sequence['outputs.KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseId']]:
        """
        Indicates the diagnosis exception causes.
        The conclusion structure is documented below.
        """
        return pulumi.get(self, "cause_ids")

    @_builtins.property
    @pulumi.getter(name="failedPartitions")
    def failed_partitions(self) -> Optional[Sequence[_builtins.int]]:
        """
        Indicates the partitions that failed to be diagnosed.
        """
        return pulumi.get(self, "failed_partitions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the diagnosis item name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence[_builtins.int]]:
        """
        Indicates the partitions affected by the diagnosis exceptions.
        """
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        """
        Indicates the diagnosis result.
        """
        return pulumi.get(self, "result")


@pulumi.output_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceId(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int id: Indicates the diagnosis conclusion ID.
        :param Mapping[str, _builtins.str] params: Indicates the diagnosis conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        Indicates the diagnosis conclusion ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Indicates the diagnosis conclusion parameters.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseId(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.int] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int id: Indicates the diagnosis conclusion ID.
        :param Mapping[str, _builtins.str] params: Indicates the diagnosis conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        Indicates the diagnosis conclusion ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Indicates the diagnosis conclusion parameters.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class KafkaMessageProducePropertyList(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the feature name.
               + **KEY**: Specifies the message key.
               + **PARTITION** : Specifies the partition to which the message will be sent.
               Changing this creates a new resource.
        :param _builtins.str value: Specifies the feature value.
               Changing this creates a new resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the feature name.
        + **KEY**: Specifies the message key.
        + **PARTITION** : Specifies the partition to which the message will be sent.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the feature value.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KafkaPartitionReassignReassignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationFactor":
            suggest = "replication_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaPartitionReassignReassignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaPartitionReassignReassignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaPartitionReassignReassignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic: _builtins.str,
                 assignments: Optional[Sequence['outputs.KafkaPartitionReassignReassignmentAssignment']] = None,
                 brokers: Optional[Sequence[_builtins.int]] = None,
                 replication_factor: Optional[_builtins.int] = None):
        """
        :param _builtins.str topic: Specifies the topic name. Changing this creates a new resource.
        :param Sequence['KafkaPartitionReassignReassignmentAssignmentArgs'] assignments: Specifies the manually specified assignment plan.
               It's **required** in **manually** specified assignment. Changing this creates a new resource.
               The assignment structure is documented below.
               
               > If manually specified assignment and automatic assignment are both specified, only **manually** specified assignment
               will take effect.
               
               <a name="reassignments_assignment_struct"></a>
               The `assignment` block supports:
        :param Sequence[_builtins.int] brokers: Specifies the integer list of brokers to which partitions are reassigned.
               It's **required** in **automatic** assignment. Changing this creates a new resource.
        :param _builtins.int replication_factor: Specifies the replication factor, which can be specified in
               **automatic** assignment. Changing this creates a new resource.
        """
        pulumi.set(__self__, "topic", topic)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)
        if replication_factor is not None:
            pulumi.set(__self__, "replication_factor", replication_factor)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[Sequence['outputs.KafkaPartitionReassignReassignmentAssignment']]:
        """
        Specifies the manually specified assignment plan.
        It's **required** in **manually** specified assignment. Changing this creates a new resource.
        The assignment structure is documented below.

        > If manually specified assignment and automatic assignment are both specified, only **manually** specified assignment
        will take effect.

        <a name="reassignments_assignment_struct"></a>
        The `assignment` block supports:
        """
        return pulumi.get(self, "assignments")

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> Optional[Sequence[_builtins.int]]:
        """
        Specifies the integer list of brokers to which partitions are reassigned.
        It's **required** in **automatic** assignment. Changing this creates a new resource.
        """
        return pulumi.get(self, "brokers")

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> Optional[_builtins.int]:
        """
        Specifies the replication factor, which can be specified in
        **automatic** assignment. Changing this creates a new resource.
        """
        return pulumi.get(self, "replication_factor")


@pulumi.output_type
class KafkaPartitionReassignReassignmentAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionBrokers":
            suggest = "partition_brokers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaPartitionReassignReassignmentAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaPartitionReassignReassignmentAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaPartitionReassignReassignmentAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition: Optional[_builtins.int] = None,
                 partition_brokers: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int partition: Specifies the partition number in manual assignment.
               It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        :param Sequence[_builtins.int] partition_brokers: Specifies the integer list of brokers to be assigned to a partition in
               manual assignment. It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if partition_brokers is not None:
            pulumi.set(__self__, "partition_brokers", partition_brokers)

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.int]:
        """
        Specifies the partition number in manual assignment.
        It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="partitionBrokers")
    def partition_brokers(self) -> Optional[Sequence[_builtins.int]]:
        """
        Specifies the integer list of brokers to be assigned to a partition in
        manual assignment. It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
        return pulumi.get(self, "partition_brokers")


@pulumi.output_type
class KafkaPermissionsPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicy":
            suggest = "access_policy"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaPermissionsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaPermissionsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaPermissionsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policy: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str access_policy: Specifies the permissions type. The value can be:
               + **all**: publish and subscribe permissions.
               + **pub**: publish permissions.
               + **sub**: subscribe permissions.
        :param _builtins.str user_name: Specifies the username.
        """
        pulumi.set(__self__, "access_policy", access_policy)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="accessPolicy")
    def access_policy(self) -> _builtins.str:
        """
        Specifies the permissions type. The value can be:
        + **all**: publish and subscribe permissions.
        + **pub**: publish permissions.
        + **sub**: subscribe permissions.
        """
        return pulumi.get(self, "access_policy")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Specifies the username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class KafkaTopicConfig(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the configuration name.
        :param _builtins.str value: Specifies the configuration value.
               
               > When `name` is **max.message.bytes**, `value` ranges from `0` to `10,485,760`.
               When `name` is **message.timestamp.type**, `value` can be **LogAppendTime** and **CreateTime**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the configuration name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the configuration value.

        > When `name` is **max.message.bytes**, `value` ranges from `0` to `10,485,760`.
        When `name` is **message.timestamp.type**, `value` can be **LogAppendTime** and **CreateTime**.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class Kafkav2SmartConnectTaskDestinationTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "agencyName":
            suggest = "agency_name"
        elif key == "consumerStrategy":
            suggest = "consumer_strategy"
        elif key == "deliverTimeInterval":
            suggest = "deliver_time_interval"
        elif key == "destinationFileType":
            suggest = "destination_file_type"
        elif key == "flushSize":
            suggest = "flush_size"
        elif key == "keyConverter":
            suggest = "key_converter"
        elif key == "kvDelimiter":
            suggest = "kv_delimiter"
        elif key == "obsBucketName":
            suggest = "obs_bucket_name"
        elif key == "obsPartSize":
            suggest = "obs_part_size"
        elif key == "obsPath":
            suggest = "obs_path"
        elif key == "partitionFormat":
            suggest = "partition_format"
        elif key == "partitionerClass":
            suggest = "partitioner_class"
        elif key == "recordDelimiter":
            suggest = "record_delimiter"
        elif key == "schemaGeneratorClass":
            suggest = "schema_generator_class"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "storeKeys":
            suggest = "store_keys"
        elif key == "valueConverter":
            suggest = "value_converter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Kafkav2SmartConnectTaskDestinationTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Kafkav2SmartConnectTaskDestinationTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Kafkav2SmartConnectTaskDestinationTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[_builtins.str] = None,
                 agency_name: Optional[_builtins.str] = None,
                 consumer_strategy: Optional[_builtins.str] = None,
                 deliver_time_interval: Optional[_builtins.int] = None,
                 destination_file_type: Optional[_builtins.str] = None,
                 flush_size: Optional[_builtins.int] = None,
                 key_converter: Optional[_builtins.str] = None,
                 kv_delimiter: Optional[_builtins.str] = None,
                 obs_bucket_name: Optional[_builtins.str] = None,
                 obs_part_size: Optional[_builtins.int] = None,
                 obs_path: Optional[_builtins.str] = None,
                 partition_format: Optional[_builtins.str] = None,
                 partitioner_class: Optional[_builtins.str] = None,
                 record_delimiter: Optional[_builtins.str] = None,
                 schema_generator_class: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 store_keys: Optional[_builtins.bool] = None,
                 timezone: Optional[_builtins.str] = None,
                 value_converter: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key: Specifies the access key used to access the OBS bucket.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param _builtins.str agency_name: schema: Internal
        :param _builtins.str consumer_strategy: Specifies the consumer strategy of the smart connect task.
               Value options:
               + **latest**: Read the latest data.
               + **earliest**: Read the earliest data.
               
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param _builtins.int deliver_time_interval: Specifies the deliver time interval of the smart connect task.
               It's **required** when `destination_type` is **OBS_SINK**.
               The value should be between `30` and `900`. Changing this parameter will create a new resource.
        :param _builtins.str destination_file_type: Specifies the destination file type of the smart connect task.
               Only **TEXT** is supported. Changing this parameter will create a new resource.
        :param _builtins.int flush_size: Indicates the flush size.
        :param _builtins.str key_converter: Indicates the key converter.
        :param _builtins.str kv_delimiter: Indicates the kv delimiter.
        :param _builtins.str obs_bucket_name: Specifies the obs bucket name of the smart connect task.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param _builtins.int obs_part_size: Indicates the size of each file to be uploaded.
        :param _builtins.str obs_path: Specifies the obs path of the smart connect task.
               Obs path is separated by a slash. Changing this parameter will create a new resource.
        :param _builtins.str partition_format: Specifies the time directory format of the smart connect task.
               Value options: **yyyy**, **yyyy/MM**, **yyyy/MM/dd**, **yyyy/MM/dd/HH**, **yyyy/MM/dd/HH/mm**.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param _builtins.str partitioner_class: Indicates the partitioner class.
        :param _builtins.str record_delimiter: Specifies the record delimiter of the smart connect task.
               Value options: **,**, **;**, **|**, **\\n**.
               Changing this parameter will create a new resource.
        :param _builtins.str schema_generator_class: Indicates the schema generator class.
        :param _builtins.str secret_key: Specifies the secret access key used to access the OBS bucket.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param _builtins.bool store_keys: Specifies whether to dump keys.
               Changing this parameter will create a new resource.
        :param _builtins.str timezone: Indicates the time zone.
        :param _builtins.str value_converter: Indicates the value converter.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if consumer_strategy is not None:
            pulumi.set(__self__, "consumer_strategy", consumer_strategy)
        if deliver_time_interval is not None:
            pulumi.set(__self__, "deliver_time_interval", deliver_time_interval)
        if destination_file_type is not None:
            pulumi.set(__self__, "destination_file_type", destination_file_type)
        if flush_size is not None:
            pulumi.set(__self__, "flush_size", flush_size)
        if key_converter is not None:
            pulumi.set(__self__, "key_converter", key_converter)
        if kv_delimiter is not None:
            pulumi.set(__self__, "kv_delimiter", kv_delimiter)
        if obs_bucket_name is not None:
            pulumi.set(__self__, "obs_bucket_name", obs_bucket_name)
        if obs_part_size is not None:
            pulumi.set(__self__, "obs_part_size", obs_part_size)
        if obs_path is not None:
            pulumi.set(__self__, "obs_path", obs_path)
        if partition_format is not None:
            pulumi.set(__self__, "partition_format", partition_format)
        if partitioner_class is not None:
            pulumi.set(__self__, "partitioner_class", partitioner_class)
        if record_delimiter is not None:
            pulumi.set(__self__, "record_delimiter", record_delimiter)
        if schema_generator_class is not None:
            pulumi.set(__self__, "schema_generator_class", schema_generator_class)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if store_keys is not None:
            pulumi.set(__self__, "store_keys", store_keys)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if value_converter is not None:
            pulumi.set(__self__, "value_converter", value_converter)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Specifies the access key used to access the OBS bucket.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[_builtins.str]:
        """
        schema: Internal
        """
        return pulumi.get(self, "agency_name")

    @_builtins.property
    @pulumi.getter(name="consumerStrategy")
    def consumer_strategy(self) -> Optional[_builtins.str]:
        """
        Specifies the consumer strategy of the smart connect task.
        Value options:
        + **latest**: Read the latest data.
        + **earliest**: Read the earliest data.

        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "consumer_strategy")

    @_builtins.property
    @pulumi.getter(name="deliverTimeInterval")
    def deliver_time_interval(self) -> Optional[_builtins.int]:
        """
        Specifies the deliver time interval of the smart connect task.
        It's **required** when `destination_type` is **OBS_SINK**.
        The value should be between `30` and `900`. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "deliver_time_interval")

    @_builtins.property
    @pulumi.getter(name="destinationFileType")
    def destination_file_type(self) -> Optional[_builtins.str]:
        """
        Specifies the destination file type of the smart connect task.
        Only **TEXT** is supported. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "destination_file_type")

    @_builtins.property
    @pulumi.getter(name="flushSize")
    def flush_size(self) -> Optional[_builtins.int]:
        """
        Indicates the flush size.
        """
        return pulumi.get(self, "flush_size")

    @_builtins.property
    @pulumi.getter(name="keyConverter")
    def key_converter(self) -> Optional[_builtins.str]:
        """
        Indicates the key converter.
        """
        return pulumi.get(self, "key_converter")

    @_builtins.property
    @pulumi.getter(name="kvDelimiter")
    def kv_delimiter(self) -> Optional[_builtins.str]:
        """
        Indicates the kv delimiter.
        """
        return pulumi.get(self, "kv_delimiter")

    @_builtins.property
    @pulumi.getter(name="obsBucketName")
    def obs_bucket_name(self) -> Optional[_builtins.str]:
        """
        Specifies the obs bucket name of the smart connect task.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "obs_bucket_name")

    @_builtins.property
    @pulumi.getter(name="obsPartSize")
    def obs_part_size(self) -> Optional[_builtins.int]:
        """
        Indicates the size of each file to be uploaded.
        """
        return pulumi.get(self, "obs_part_size")

    @_builtins.property
    @pulumi.getter(name="obsPath")
    def obs_path(self) -> Optional[_builtins.str]:
        """
        Specifies the obs path of the smart connect task.
        Obs path is separated by a slash. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "obs_path")

    @_builtins.property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> Optional[_builtins.str]:
        """
        Specifies the time directory format of the smart connect task.
        Value options: **yyyy**, **yyyy/MM**, **yyyy/MM/dd**, **yyyy/MM/dd/HH**, **yyyy/MM/dd/HH/mm**.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "partition_format")

    @_builtins.property
    @pulumi.getter(name="partitionerClass")
    def partitioner_class(self) -> Optional[_builtins.str]:
        """
        Indicates the partitioner class.
        """
        return pulumi.get(self, "partitioner_class")

    @_builtins.property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> Optional[_builtins.str]:
        """
        Specifies the record delimiter of the smart connect task.
        Value options: **,**, **;**, **|**, **\\n**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "record_delimiter")

    @_builtins.property
    @pulumi.getter(name="schemaGeneratorClass")
    def schema_generator_class(self) -> Optional[_builtins.str]:
        """
        Indicates the schema generator class.
        """
        return pulumi.get(self, "schema_generator_class")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Specifies the secret access key used to access the OBS bucket.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="storeKeys")
    def store_keys(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to dump keys.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "store_keys")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Indicates the time zone.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="valueConverter")
    def value_converter(self) -> Optional[_builtins.str]:
        """
        Indicates the value converter.
        """
        return pulumi.get(self, "value_converter")


@pulumi.output_type
class Kafkav2SmartConnectTaskSourceTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"
        elif key == "consumerStrategy":
            suggest = "consumer_strategy"
        elif key == "currentInstanceAlias":
            suggest = "current_instance_alias"
        elif key == "peerInstanceAddresses":
            suggest = "peer_instance_addresses"
        elif key == "peerInstanceAlias":
            suggest = "peer_instance_alias"
        elif key == "peerInstanceId":
            suggest = "peer_instance_id"
        elif key == "provenanceHeaderEnabled":
            suggest = "provenance_header_enabled"
        elif key == "renameTopicEnabled":
            suggest = "rename_topic_enabled"
        elif key == "replicationFactor":
            suggest = "replication_factor"
        elif key == "saslMechanism":
            suggest = "sasl_mechanism"
        elif key == "securityProtocol":
            suggest = "security_protocol"
        elif key == "syncConsumerOffsetsEnabled":
            suggest = "sync_consumer_offsets_enabled"
        elif key == "taskNum":
            suggest = "task_num"
        elif key == "topicsMappings":
            suggest = "topics_mappings"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Kafkav2SmartConnectTaskSourceTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Kafkav2SmartConnectTaskSourceTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Kafkav2SmartConnectTaskSourceTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[_builtins.str] = None,
                 consumer_strategy: Optional[_builtins.str] = None,
                 current_instance_alias: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 peer_instance_addresses: Optional[Sequence[_builtins.str]] = None,
                 peer_instance_alias: Optional[_builtins.str] = None,
                 peer_instance_id: Optional[_builtins.str] = None,
                 provenance_header_enabled: Optional[_builtins.bool] = None,
                 rename_topic_enabled: Optional[_builtins.bool] = None,
                 replication_factor: Optional[_builtins.int] = None,
                 sasl_mechanism: Optional[_builtins.str] = None,
                 security_protocol: Optional[_builtins.str] = None,
                 sync_consumer_offsets_enabled: Optional[_builtins.bool] = None,
                 task_num: Optional[_builtins.int] = None,
                 topics_mappings: Optional[Sequence[_builtins.str]] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str compression_type: Specifies the compression algorithm to use for copying messages.
               Valid values are **none**, **gzip**, **snappy**, **lz4** and **zstd**.
               Changing this parameter will create a new resource.
               
               <a name="dms_destination_task"></a>
               The `destination_task` block supports:
        :param _builtins.str consumer_strategy: Specifies the consumer strategy of the smart connect task.
               Value options:
               + **latest**: Read the latest data.
               + **earliest**: Read the earliest data.
               
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param _builtins.str current_instance_alias: Specifies the current Kafka instance alias.
               Changing this parameter will create a new resource.
        :param _builtins.str direction: Specifies the sync direction. Valid values are:
               + **pull**: Copy the data of the peer Kafka instance to the current Kafka instance.
               + **push**: Copy the data of the current Kafka instance to the peer Kafka instance.
               + **two-way**: Copy the data of the Kafka instances at both ends in both directions.
               
               Changing this parameter will create a new resource.
        :param _builtins.str password: Specifies the peer Kafka user password.
               It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        :param Sequence[_builtins.str] peer_instance_addresses: Specifies the peer Kafka instance address list.
               Changing this parameter will create a new resource.
               
               > Exactly one of `peer_instance_id` and `peer_instance_address` should be specified.
        :param _builtins.str peer_instance_alias: Specifies the peer Kafka instance alias.
               Changing this parameter will create a new resource.
        :param _builtins.str peer_instance_id: Specifies the peer Kafka instance ID.
               Changing this parameter will create a new resource.
        :param _builtins.bool provenance_header_enabled: Specifies whether the message header contains the message source.
               Changing this parameter will create a new resource.
        :param _builtins.bool rename_topic_enabled: Specifies whether to rename the topic. If true, will add the
               alias of the source Kafka instance before the target topic name to form a new name of the target topic.
               Changing this parameter will create a new resource.
        :param _builtins.int replication_factor: Specifies the number of topic replicas. The value of this parameter
               cannot exceed the number of brokers in the peer instance. Changing this parameter will create a new resource.
        :param _builtins.str sasl_mechanism: Specifies the peer Kafka authentication mode.
               Changing this parameter will create a new resource.
        :param _builtins.str security_protocol: Specifies the peer Kafka authentication. Valid values are:
               + **SASL_SSL**: SASL_SSL is enabled.
               + **PLAINTEXT**: SASL_SSL is disabled.
               
               Changing this parameter will create a new resource.
        :param _builtins.bool sync_consumer_offsets_enabled: Specifies whether to sync the consumption progress.
               Changing this parameter will create a new resource.
        :param _builtins.int task_num: Specifies the number of data replication tasks.
               If the `direction` is set to **two-way**, the actual number of tasks will be twice the number of tasks you configure here.
               Changing this parameter will create a new resource.
        :param Sequence[_builtins.str] topics_mappings: Specifies the topic mapping string list, which is used to customize
               the target topic name, e.g., topic-sc-1:topic-sc-2. Changing this parameter will create a new resource.
               
               > When `rename_topic_enabled` is true, `topics_mapping` can not be specified.
        :param _builtins.str user_name: Specifies the peer Kafka user name.
               It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if consumer_strategy is not None:
            pulumi.set(__self__, "consumer_strategy", consumer_strategy)
        if current_instance_alias is not None:
            pulumi.set(__self__, "current_instance_alias", current_instance_alias)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if peer_instance_addresses is not None:
            pulumi.set(__self__, "peer_instance_addresses", peer_instance_addresses)
        if peer_instance_alias is not None:
            pulumi.set(__self__, "peer_instance_alias", peer_instance_alias)
        if peer_instance_id is not None:
            pulumi.set(__self__, "peer_instance_id", peer_instance_id)
        if provenance_header_enabled is not None:
            pulumi.set(__self__, "provenance_header_enabled", provenance_header_enabled)
        if rename_topic_enabled is not None:
            pulumi.set(__self__, "rename_topic_enabled", rename_topic_enabled)
        if replication_factor is not None:
            pulumi.set(__self__, "replication_factor", replication_factor)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if sync_consumer_offsets_enabled is not None:
            pulumi.set(__self__, "sync_consumer_offsets_enabled", sync_consumer_offsets_enabled)
        if task_num is not None:
            pulumi.set(__self__, "task_num", task_num)
        if topics_mappings is not None:
            pulumi.set(__self__, "topics_mappings", topics_mappings)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[_builtins.str]:
        """
        Specifies the compression algorithm to use for copying messages.
        Valid values are **none**, **gzip**, **snappy**, **lz4** and **zstd**.
        Changing this parameter will create a new resource.

        <a name="dms_destination_task"></a>
        The `destination_task` block supports:
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="consumerStrategy")
    def consumer_strategy(self) -> Optional[_builtins.str]:
        """
        Specifies the consumer strategy of the smart connect task.
        Value options:
        + **latest**: Read the latest data.
        + **earliest**: Read the earliest data.

        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "consumer_strategy")

    @_builtins.property
    @pulumi.getter(name="currentInstanceAlias")
    def current_instance_alias(self) -> Optional[_builtins.str]:
        """
        Specifies the current Kafka instance alias.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "current_instance_alias")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        Specifies the sync direction. Valid values are:
        + **pull**: Copy the data of the peer Kafka instance to the current Kafka instance.
        + **push**: Copy the data of the current Kafka instance to the peer Kafka instance.
        + **two-way**: Copy the data of the Kafka instances at both ends in both directions.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Specifies the peer Kafka user password.
        It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="peerInstanceAddresses")
    def peer_instance_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the peer Kafka instance address list.
        Changing this parameter will create a new resource.

        > Exactly one of `peer_instance_id` and `peer_instance_address` should be specified.
        """
        return pulumi.get(self, "peer_instance_addresses")

    @_builtins.property
    @pulumi.getter(name="peerInstanceAlias")
    def peer_instance_alias(self) -> Optional[_builtins.str]:
        """
        Specifies the peer Kafka instance alias.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "peer_instance_alias")

    @_builtins.property
    @pulumi.getter(name="peerInstanceId")
    def peer_instance_id(self) -> Optional[_builtins.str]:
        """
        Specifies the peer Kafka instance ID.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "peer_instance_id")

    @_builtins.property
    @pulumi.getter(name="provenanceHeaderEnabled")
    def provenance_header_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the message header contains the message source.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "provenance_header_enabled")

    @_builtins.property
    @pulumi.getter(name="renameTopicEnabled")
    def rename_topic_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to rename the topic. If true, will add the
        alias of the source Kafka instance before the target topic name to form a new name of the target topic.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "rename_topic_enabled")

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> Optional[_builtins.int]:
        """
        Specifies the number of topic replicas. The value of this parameter
        cannot exceed the number of brokers in the peer instance. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[_builtins.str]:
        """
        Specifies the peer Kafka authentication mode.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[_builtins.str]:
        """
        Specifies the peer Kafka authentication. Valid values are:
        + **SASL_SSL**: SASL_SSL is enabled.
        + **PLAINTEXT**: SASL_SSL is disabled.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "security_protocol")

    @_builtins.property
    @pulumi.getter(name="syncConsumerOffsetsEnabled")
    def sync_consumer_offsets_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to sync the consumption progress.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sync_consumer_offsets_enabled")

    @_builtins.property
    @pulumi.getter(name="taskNum")
    def task_num(self) -> Optional[_builtins.int]:
        """
        Specifies the number of data replication tasks.
        If the `direction` is set to **two-way**, the actual number of tasks will be twice the number of tasks you configure here.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "task_num")

    @_builtins.property
    @pulumi.getter(name="topicsMappings")
    def topics_mappings(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the topic mapping string list, which is used to customize
        the target topic name, e.g., topic-sc-1:topic-sc-2. Changing this parameter will create a new resource.

        > When `rename_topic_enabled` is true, `topics_mapping` can not be specified.
        """
        return pulumi.get(self, "topics_mappings")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Specifies the peer Kafka user name.
        It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class RabbitmqExchangeBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "propertiesKey":
            suggest = "properties_key"
        elif key == "routingKey":
            suggest = "routing_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RabbitmqExchangeBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RabbitmqExchangeBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RabbitmqExchangeBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 destination_type: Optional[_builtins.str] = None,
                 properties_key: Optional[_builtins.str] = None,
                 routing_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: Indicates the destination.
        :param _builtins.str destination_type: Indicates the destination type.
        :param _builtins.str properties_key: Indicates the properties key.
        :param _builtins.str routing_key: Indicates the routin key.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if properties_key is not None:
            pulumi.set(__self__, "properties_key", properties_key)
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Indicates the destination.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[_builtins.str]:
        """
        Indicates the destination type.
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="propertiesKey")
    def properties_key(self) -> Optional[_builtins.str]:
        """
        Indicates the properties key.
        """
        return pulumi.get(self, "properties_key")

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[_builtins.str]:
        """
        Indicates the routin key.
        """
        return pulumi.get(self, "routing_key")


@pulumi.output_type
class RabbitmqQueueConsumerDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackRequired":
            suggest = "ack_required"
        elif key == "channelDetails":
            suggest = "channel_details"
        elif key == "consumerTag":
            suggest = "consumer_tag"
        elif key == "prefetchCount":
            suggest = "prefetch_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RabbitmqQueueConsumerDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RabbitmqQueueConsumerDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RabbitmqQueueConsumerDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_required: Optional[_builtins.bool] = None,
                 channel_details: Optional[Sequence['outputs.RabbitmqQueueConsumerDetailChannelDetail']] = None,
                 consumer_tag: Optional[_builtins.str] = None,
                 prefetch_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool ack_required: Indicates whether manual acknowledgement is enabled on the consumer client.
        :param Sequence['RabbitmqQueueConsumerDetailChannelDetailArgs'] channel_details: Indicates the consumer connections.
               The channel_details structure is documented below.
        :param _builtins.str consumer_tag: Indicates the consumer tag.
        :param _builtins.int prefetch_count: Indicates the consumer client preset value.
        """
        if ack_required is not None:
            pulumi.set(__self__, "ack_required", ack_required)
        if channel_details is not None:
            pulumi.set(__self__, "channel_details", channel_details)
        if consumer_tag is not None:
            pulumi.set(__self__, "consumer_tag", consumer_tag)
        if prefetch_count is not None:
            pulumi.set(__self__, "prefetch_count", prefetch_count)

    @_builtins.property
    @pulumi.getter(name="ackRequired")
    def ack_required(self) -> Optional[_builtins.bool]:
        """
        Indicates whether manual acknowledgement is enabled on the consumer client.
        """
        return pulumi.get(self, "ack_required")

    @_builtins.property
    @pulumi.getter(name="channelDetails")
    def channel_details(self) -> Optional[Sequence['outputs.RabbitmqQueueConsumerDetailChannelDetail']]:
        """
        Indicates the consumer connections.
        The channel_details structure is documented below.
        """
        return pulumi.get(self, "channel_details")

    @_builtins.property
    @pulumi.getter(name="consumerTag")
    def consumer_tag(self) -> Optional[_builtins.str]:
        """
        Indicates the consumer tag.
        """
        return pulumi.get(self, "consumer_tag")

    @_builtins.property
    @pulumi.getter(name="prefetchCount")
    def prefetch_count(self) -> Optional[_builtins.int]:
        """
        Indicates the consumer client preset value.
        """
        return pulumi.get(self, "prefetch_count")


@pulumi.output_type
class RabbitmqQueueConsumerDetailChannelDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "peerHost":
            suggest = "peer_host"
        elif key == "peerPort":
            suggest = "peer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RabbitmqQueueConsumerDetailChannelDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RabbitmqQueueConsumerDetailChannelDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RabbitmqQueueConsumerDetailChannelDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 number: Optional[_builtins.int] = None,
                 peer_host: Optional[_builtins.str] = None,
                 peer_port: Optional[_builtins.int] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection_name: Indicates the connection details.
        :param _builtins.str name: Specifies the queue name.
               Changing this creates a new resource.
        :param _builtins.int number: Indicates the channel quantity.
        :param _builtins.str peer_host: Indicates the IP address of the connected consumer.
        :param _builtins.int peer_port: Indicates the port of the process of the connected consumer.
        :param _builtins.str user: Indicates the consumer username. If ACL is enabled, the real username will be returned, otherwise null will
               be returned.
        """
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if peer_host is not None:
            pulumi.set(__self__, "peer_host", peer_host)
        if peer_port is not None:
            pulumi.set(__self__, "peer_port", peer_port)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        """
        Indicates the connection details.
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the queue name.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[_builtins.int]:
        """
        Indicates the channel quantity.
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="peerHost")
    def peer_host(self) -> Optional[_builtins.str]:
        """
        Indicates the IP address of the connected consumer.
        """
        return pulumi.get(self, "peer_host")

    @_builtins.property
    @pulumi.getter(name="peerPort")
    def peer_port(self) -> Optional[_builtins.int]:
        """
        Indicates the port of the process of the connected consumer.
        """
        return pulumi.get(self, "peer_port")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Indicates the consumer username. If ACL is enabled, the real username will be returned, otherwise null will
        be returned.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class RabbitmqQueueQueueBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "propertiesKey":
            suggest = "properties_key"
        elif key == "routingKey":
            suggest = "routing_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RabbitmqQueueQueueBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RabbitmqQueueQueueBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RabbitmqQueueQueueBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 destination_type: Optional[_builtins.str] = None,
                 properties_key: Optional[_builtins.str] = None,
                 routing_key: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: Indicates the binding target name.
        :param _builtins.str destination_type: Indicates the binding target type.
        :param _builtins.str properties_key: Indicates the URL-translated routing key.
        :param _builtins.str routing_key: Indicates the binding key-value.
        :param _builtins.str source: Indicates the exchange name.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if properties_key is not None:
            pulumi.set(__self__, "properties_key", properties_key)
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Indicates the binding target name.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[_builtins.str]:
        """
        Indicates the binding target type.
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="propertiesKey")
    def properties_key(self) -> Optional[_builtins.str]:
        """
        Indicates the URL-translated routing key.
        """
        return pulumi.get(self, "properties_key")

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[_builtins.str]:
        """
        Indicates the binding key-value.
        """
        return pulumi.get(self, "routing_key")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Indicates the exchange name.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class RabbitmqUserVhost(dict):
    def __init__(__self__, *,
                 conf: _builtins.str,
                 read: _builtins.str,
                 vhost: _builtins.str,
                 write: _builtins.str):
        """
        :param _builtins.str conf: Specifies the granting resource permissions using regular expressions.
        :param _builtins.str read: Specifies the granting resource read permissions using regular expressions.
        :param _builtins.str vhost: Specifies the name of the virtual host to be granted permissions for.
        :param _builtins.str write: Specifies the granting resource write permissions using regular expressions.
        """
        pulumi.set(__self__, "conf", conf)
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "vhost", vhost)
        pulumi.set(__self__, "write", write)

    @_builtins.property
    @pulumi.getter
    def conf(self) -> _builtins.str:
        """
        Specifies the granting resource permissions using regular expressions.
        """
        return pulumi.get(self, "conf")

    @_builtins.property
    @pulumi.getter
    def read(self) -> _builtins.str:
        """
        Specifies the granting resource read permissions using regular expressions.
        """
        return pulumi.get(self, "read")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> _builtins.str:
        """
        Specifies the name of the virtual host to be granted permissions for.
        """
        return pulumi.get(self, "vhost")

    @_builtins.property
    @pulumi.getter
    def write(self) -> _builtins.str:
        """
        Specifies the granting resource write permissions using regular expressions.
        """
        return pulumi.get(self, "write")


@pulumi.output_type
class RocketmqConsumptionVerifyResendResult(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorMessage":
            suggest = "error_message"
        elif key == "messageId":
            suggest = "message_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqConsumptionVerifyResendResult. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqConsumptionVerifyResendResult.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqConsumptionVerifyResendResult.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: Optional[_builtins.str] = None,
                 error_message: Optional[_builtins.str] = None,
                 message_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str error_code: Indicates the error code.
        :param _builtins.str error_message: Indicates the error message.
        :param _builtins.str message_id: Indicates the message ID.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[_builtins.str]:
        """
        Indicates the error code.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[_builtins.str]:
        """
        Indicates the error message.
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[_builtins.str]:
        """
        Indicates the message ID.
        """
        return pulumi.get(self, "message_id")


@pulumi.output_type
class RocketmqDeadLetterResendResendResult(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorMessage":
            suggest = "error_message"
        elif key == "messageId":
            suggest = "message_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqDeadLetterResendResendResult. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqDeadLetterResendResendResult.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqDeadLetterResendResendResult.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: Optional[_builtins.str] = None,
                 error_message: Optional[_builtins.str] = None,
                 message_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str error_code: Indicates the error code.
        :param _builtins.str error_message: Indicates the error message.
        :param _builtins.str message_id: Indicates the message ID.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[_builtins.str]:
        """
        Indicates the error code.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[_builtins.str]:
        """
        Indicates the error message.
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[_builtins.str]:
        """
        Indicates the message ID.
        """
        return pulumi.get(self, "message_id")


@pulumi.output_type
class RocketmqInstanceConfig(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the config name.
        :param _builtins.str value: Specifies the config value.
               
               > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the config name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the config value.

        > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RocketmqInstanceCrossVpcAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedIp":
            suggest = "advertised_ip"
        elif key == "lisenterIp":
            suggest = "lisenter_ip"
        elif key == "listenerIp":
            suggest = "listener_ip"
        elif key == "portId":
            suggest = "port_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqInstanceCrossVpcAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqInstanceCrossVpcAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqInstanceCrossVpcAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_ip: Optional[_builtins.str] = None,
                 lisenter_ip: Optional[_builtins.str] = None,
                 listener_ip: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str advertised_ip: The advertised IP Address or domain name.
        :param _builtins.str listener_ip: The listener IP address.
        :param _builtins.int port: The port number.
        :param _builtins.str port_id: The port ID associated with the address.
        """
        if advertised_ip is not None:
            pulumi.set(__self__, "advertised_ip", advertised_ip)
        if lisenter_ip is not None:
            pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        if listener_ip is not None:
            pulumi.set(__self__, "listener_ip", listener_ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> Optional[_builtins.str]:
        """
        The advertised IP Address or domain name.
        """
        return pulumi.get(self, "advertised_ip")

    @_builtins.property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lisenter_ip")

    @_builtins.property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> Optional[_builtins.str]:
        """
        The listener IP address.
        """
        return pulumi.get(self, "listener_ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[_builtins.str]:
        """
        The port ID associated with the address.
        """
        return pulumi.get(self, "port_id")


@pulumi.output_type
class RocketmqMessageSendPropertyList(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the name of the property.
        :param _builtins.str value: Specifies the value of the property.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the property.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the property.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RocketmqMigrationTaskBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "routingKey":
            suggest = "routing_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqMigrationTaskBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqMigrationTaskBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqMigrationTaskBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 destination_type: Optional[_builtins.str] = None,
                 routing_key: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 vhost: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: Specifies the message target. Changing this creates a new resource.
        :param _builtins.str destination_type: Specifies the message target type.
               Changing this creates a new resource.
        :param _builtins.str routing_key: Specifies the routing key. Changing this creates a new resource.
        :param _builtins.str source: Specifies the message source. Changing this creates a new resource.
        :param _builtins.str vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Specifies the message target. Changing this creates a new resource.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[_builtins.str]:
        """
        Specifies the message target type.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[_builtins.str]:
        """
        Specifies the routing key. Changing this creates a new resource.
        """
        return pulumi.get(self, "routing_key")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Specifies the message source. Changing this creates a new resource.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[_builtins.str]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")


@pulumi.output_type
class RocketmqMigrationTaskExchange(dict):
    def __init__(__self__, *,
                 durable: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 vhost: Optional[_builtins.str] = None):
        """
        :param _builtins.bool durable: Specifies whether to enable data persistence.
               Changing this creates a new resource.
        :param _builtins.str name: Specifies the switch name. Changing this creates a new resource.
        :param _builtins.str type: Specifies the exchange type. Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_bindings"></a>
               The `bindings` block supports:
        :param _builtins.str vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if durable is not None:
            pulumi.set(__self__, "durable", durable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def durable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "durable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the exchange type. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_bindings"></a>
        The `bindings` block supports:
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[_builtins.str]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")


@pulumi.output_type
class RocketmqMigrationTaskQueue(dict):
    def __init__(__self__, *,
                 durable: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 vhost: Optional[_builtins.str] = None):
        """
        :param _builtins.bool durable: Specifies whether to enable data persistence.
               Changing this creates a new resource.
        :param _builtins.str name: Specifies the switch name. Changing this creates a new resource.
        :param _builtins.str vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if durable is not None:
            pulumi.set(__self__, "durable", durable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def durable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "durable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[_builtins.str]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")


@pulumi.output_type
class RocketmqMigrationTaskSubscriptionGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "consumeBroadcastEnable":
            suggest = "consume_broadcast_enable"
        elif key == "consumeEnable":
            suggest = "consume_enable"
        elif key == "consumeFromMinEnable":
            suggest = "consume_from_min_enable"
        elif key == "notifyConsumeridsChangedEnable":
            suggest = "notify_consumerids_changed_enable"
        elif key == "retryMaxTimes":
            suggest = "retry_max_times"
        elif key == "retryQueueNum":
            suggest = "retry_queue_num"
        elif key == "whichBrokerWhenConsumeSlow":
            suggest = "which_broker_when_consume_slow"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqMigrationTaskSubscriptionGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqMigrationTaskSubscriptionGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqMigrationTaskSubscriptionGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: _builtins.str,
                 consume_broadcast_enable: Optional[_builtins.bool] = None,
                 consume_enable: Optional[_builtins.bool] = None,
                 consume_from_min_enable: Optional[_builtins.bool] = None,
                 notify_consumerids_changed_enable: Optional[_builtins.bool] = None,
                 retry_max_times: Optional[_builtins.int] = None,
                 retry_queue_num: Optional[_builtins.int] = None,
                 which_broker_when_consume_slow: Optional[_builtins.int] = None):
        """
        :param _builtins.str group_name: Specifies the name of a consumer group.
               Changing this creates a new resource.
        :param _builtins.bool consume_broadcast_enable: Specifies whether to enable broadcast.
               Changing this creates a new resource.
        :param _builtins.bool consume_enable: Specifies whether to enable consumption.
               Changing this creates a new resource.
        :param _builtins.bool consume_from_min_enable: Specifies whether to enable consumption from the earliest
               offset. Changing this creates a new resource.
        :param _builtins.bool notify_consumerids_changed_enable: Specifies whether to notify changes of consumer IDs.
               Changing this creates a new resource.
        :param _builtins.int retry_max_times: Specifies the maximum number of consumption retries.
               Changing this creates a new resource.
        :param _builtins.int retry_queue_num: Specifies the number of retry queues.
               Changing this creates a new resource.
        :param _builtins.int which_broker_when_consume_slow: Specifies the ID of the broker selected for slow
               consumption. Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_vhosts"></a>
               The `vhosts` block supports:
        """
        pulumi.set(__self__, "group_name", group_name)
        if consume_broadcast_enable is not None:
            pulumi.set(__self__, "consume_broadcast_enable", consume_broadcast_enable)
        if consume_enable is not None:
            pulumi.set(__self__, "consume_enable", consume_enable)
        if consume_from_min_enable is not None:
            pulumi.set(__self__, "consume_from_min_enable", consume_from_min_enable)
        if notify_consumerids_changed_enable is not None:
            pulumi.set(__self__, "notify_consumerids_changed_enable", notify_consumerids_changed_enable)
        if retry_max_times is not None:
            pulumi.set(__self__, "retry_max_times", retry_max_times)
        if retry_queue_num is not None:
            pulumi.set(__self__, "retry_queue_num", retry_queue_num)
        if which_broker_when_consume_slow is not None:
            pulumi.set(__self__, "which_broker_when_consume_slow", which_broker_when_consume_slow)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Specifies the name of a consumer group.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="consumeBroadcastEnable")
    def consume_broadcast_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable broadcast.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_broadcast_enable")

    @_builtins.property
    @pulumi.getter(name="consumeEnable")
    def consume_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable consumption.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_enable")

    @_builtins.property
    @pulumi.getter(name="consumeFromMinEnable")
    def consume_from_min_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable consumption from the earliest
        offset. Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_from_min_enable")

    @_builtins.property
    @pulumi.getter(name="notifyConsumeridsChangedEnable")
    def notify_consumerids_changed_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to notify changes of consumer IDs.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "notify_consumerids_changed_enable")

    @_builtins.property
    @pulumi.getter(name="retryMaxTimes")
    def retry_max_times(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of consumption retries.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "retry_max_times")

    @_builtins.property
    @pulumi.getter(name="retryQueueNum")
    def retry_queue_num(self) -> Optional[_builtins.int]:
        """
        Specifies the number of retry queues.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "retry_queue_num")

    @_builtins.property
    @pulumi.getter(name="whichBrokerWhenConsumeSlow")
    def which_broker_when_consume_slow(self) -> Optional[_builtins.int]:
        """
        Specifies the ID of the broker selected for slow
        consumption. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_vhosts"></a>
        The `vhosts` block supports:
        """
        return pulumi.get(self, "which_broker_when_consume_slow")


@pulumi.output_type
class RocketmqMigrationTaskTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicName":
            suggest = "topic_name"
        elif key == "readQueueNum":
            suggest = "read_queue_num"
        elif key == "topicFilterType":
            suggest = "topic_filter_type"
        elif key == "topicSysFlag":
            suggest = "topic_sys_flag"
        elif key == "writeQueueNum":
            suggest = "write_queue_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqMigrationTaskTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqMigrationTaskTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqMigrationTaskTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_name: _builtins.str,
                 order: Optional[_builtins.bool] = None,
                 perm: Optional[_builtins.int] = None,
                 read_queue_num: Optional[_builtins.int] = None,
                 topic_filter_type: Optional[_builtins.str] = None,
                 topic_sys_flag: Optional[_builtins.int] = None,
                 write_queue_num: Optional[_builtins.int] = None):
        """
        :param _builtins.str topic_name: Specifies the topic name. Changing this creates a new resource.
        :param _builtins.bool order: Specifies whether a message is an ordered message.
               Changing this creates a new resource.
        :param _builtins.int perm: Specifies the number of permission. Changing this creates a new resource.
        :param _builtins.int read_queue_num: Specifies the number of read queues.
               Changing this creates a new resource.
        :param _builtins.str topic_filter_type: Specifies the filter type of a topic.
               Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        :param _builtins.int topic_sys_flag: Specifies the system flag of a topic.
               Changing this creates a new resource.
        :param _builtins.int write_queue_num: Specifies the number of write queues.
               Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_subscription_groups"></a>
               The `subscription_groups` block supports:
        """
        pulumi.set(__self__, "topic_name", topic_name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)
        if read_queue_num is not None:
            pulumi.set(__self__, "read_queue_num", read_queue_num)
        if topic_filter_type is not None:
            pulumi.set(__self__, "topic_filter_type", topic_filter_type)
        if topic_sys_flag is not None:
            pulumi.set(__self__, "topic_sys_flag", topic_sys_flag)
        if write_queue_num is not None:
            pulumi.set(__self__, "write_queue_num", write_queue_num)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.bool]:
        """
        Specifies whether a message is an ordered message.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[_builtins.int]:
        """
        Specifies the number of permission. Changing this creates a new resource.
        """
        return pulumi.get(self, "perm")

    @_builtins.property
    @pulumi.getter(name="readQueueNum")
    def read_queue_num(self) -> Optional[_builtins.int]:
        """
        Specifies the number of read queues.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "read_queue_num")

    @_builtins.property
    @pulumi.getter(name="topicFilterType")
    def topic_filter_type(self) -> Optional[_builtins.str]:
        """
        Specifies the filter type of a topic.
        Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_filter_type")

    @_builtins.property
    @pulumi.getter(name="topicSysFlag")
    def topic_sys_flag(self) -> Optional[_builtins.int]:
        """
        Specifies the system flag of a topic.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_sys_flag")

    @_builtins.property
    @pulumi.getter(name="writeQueueNum")
    def write_queue_num(self) -> Optional[_builtins.int]:
        """
        Specifies the number of write queues.
        Changing this creates a new resource.

        <a name="RocketMQ_migration_task_subscription_groups"></a>
        The `subscription_groups` block supports:
        """
        return pulumi.get(self, "write_queue_num")


@pulumi.output_type
class RocketmqMigrationTaskVhost(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the switch name. Changing this creates a new resource.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RocketmqTopicBroker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readQueueNum":
            suggest = "read_queue_num"
        elif key == "writeQueueNum":
            suggest = "write_queue_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqTopicBroker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqTopicBroker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqTopicBroker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 read_queue_num: Optional[_builtins.int] = None,
                 write_queue_num: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Specifies the name of the broker.
               
               <a name="DmsRocketMQTopic_QueueRef"></a>
               The `queues` block supports:
        :param _builtins.int read_queue_num: Indicates the read queues number of the broker. It's useless when create a topic.
        :param _builtins.int write_queue_num: Indicates the read queues number of the broker. It's useless when create a topic.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_queue_num is not None:
            pulumi.set(__self__, "read_queue_num", read_queue_num)
        if write_queue_num is not None:
            pulumi.set(__self__, "write_queue_num", write_queue_num)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the broker.

        <a name="DmsRocketMQTopic_QueueRef"></a>
        The `queues` block supports:
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="readQueueNum")
    def read_queue_num(self) -> Optional[_builtins.int]:
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        return pulumi.get(self, "read_queue_num")

    @_builtins.property
    @pulumi.getter(name="writeQueueNum")
    def write_queue_num(self) -> Optional[_builtins.int]:
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        return pulumi.get(self, "write_queue_num")


@pulumi.output_type
class RocketmqTopicQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueNum":
            suggest = "queue_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocketmqTopicQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocketmqTopicQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocketmqTopicQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker: Optional[_builtins.str] = None,
                 queue_num: Optional[_builtins.int] = None):
        """
        :param _builtins.str broker: Specifies the associated broker.
        :param _builtins.int queue_num: Specifies the number of the queues.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if queue_num is not None:
            pulumi.set(__self__, "queue_num", queue_num)

    @_builtins.property
    @pulumi.getter
    def broker(self) -> Optional[_builtins.str]:
        """
        Specifies the associated broker.
        """
        return pulumi.get(self, "broker")

    @_builtins.property
    @pulumi.getter(name="queueNum")
    def queue_num(self) -> Optional[_builtins.int]:
        """
        Specifies the number of the queues.
        """
        return pulumi.get(self, "queue_num")


@pulumi.output_type
class RocketmqUserGroupPerm(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 perm: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Indicates the name of a topic or consumer group.
        :param _builtins.str perm: Indicates the permissions of the topic or consumer group.
               Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the name of a topic or consumer group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[_builtins.str]:
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")


@pulumi.output_type
class RocketmqUserTopicPerm(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 perm: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Indicates the name of a topic or consumer group.
        :param _builtins.str perm: Indicates the permissions of the topic or consumer group.
               Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Indicates the name of a topic or consumer group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[_builtins.str]:
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")


@pulumi.output_type
class GetFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch_types: Sequence[_builtins.str],
                 charging_modes: Sequence[_builtins.str],
                 id: _builtins.str,
                 ios: Sequence['outputs.GetFlavorsFlavorIoResult'],
                 properties: Sequence['outputs.GetFlavorsFlavorPropertyResult'],
                 support_features: Sequence['outputs.GetFlavorsFlavorSupportFeatureResult'],
                 type: _builtins.str,
                 vm_specification: _builtins.str):
        """
        :param Sequence[_builtins.str] arch_types: The list of supported CPU architectures.
        :param Sequence[_builtins.str] charging_modes: The list of supported billing modes.
        :param _builtins.str id: The flavor ID.
        :param Sequence['GetFlavorsFlavorIoArgs'] ios: The list of supported disk IO types.
               The object structure is documented below.
        :param Sequence['GetFlavorsFlavorPropertyArgs'] properties: The function property details.
               The object structure is documented below.
        :param Sequence['GetFlavorsFlavorSupportFeatureArgs'] support_features: The list of features supported by the current specification.
               The object structure is documented below.
        :param _builtins.str type: Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
        :param _builtins.str vm_specification: The underlying VM specification.
        """
        pulumi.set(__self__, "arch_types", arch_types)
        pulumi.set(__self__, "charging_modes", charging_modes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ios", ios)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "support_features", support_features)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_specification", vm_specification)

    @_builtins.property
    @pulumi.getter(name="archTypes")
    def arch_types(self) -> Sequence[_builtins.str]:
        """
        The list of supported CPU architectures.
        """
        return pulumi.get(self, "arch_types")

    @_builtins.property
    @pulumi.getter(name="chargingModes")
    def charging_modes(self) -> Sequence[_builtins.str]:
        """
        The list of supported billing modes.
        """
        return pulumi.get(self, "charging_modes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The flavor ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Sequence['outputs.GetFlavorsFlavorIoResult']:
        """
        The list of supported disk IO types.
        The object structure is documented below.
        """
        return pulumi.get(self, "ios")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetFlavorsFlavorPropertyResult']:
        """
        The function property details.
        The object structure is documented below.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="supportFeatures")
    def support_features(self) -> Sequence['outputs.GetFlavorsFlavorSupportFeatureResult']:
        """
        The list of features supported by the current specification.
        The object structure is documented below.
        """
        return pulumi.get(self, "support_features")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vmSpecification")
    def vm_specification(self) -> _builtins.str:
        """
        The underlying VM specification.
        """
        return pulumi.get(self, "vm_specification")


@pulumi.output_type
class GetFlavorsFlavorIoResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[_builtins.str],
                 storage_spec_code: _builtins.str,
                 type: _builtins.str,
                 unavailability_zones: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] availability_zones: Specifies the list of availability zones with available resources.
        :param _builtins.str storage_spec_code: Specifies the disk IO encoding.
               + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
               + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
        :param _builtins.str type: Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
        :param Sequence[_builtins.str] unavailability_zones: The list of unavailability zones with available resources.
        """
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailability_zones", unavailability_zones)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of availability zones with available resources.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Specifies the disk IO encoding.
        + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
        + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies flavor type. The valid values are **single**, **cluster** and **cluster.small**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailabilityZones")
    def unavailability_zones(self) -> Sequence[_builtins.str]:
        """
        The list of unavailability zones with available resources.
        """
        return pulumi.get(self, "unavailability_zones")


@pulumi.output_type
class GetFlavorsFlavorPropertyResult(dict):
    def __init__(__self__, *,
                 flavor_alias: _builtins.str,
                 max_bandwidth_per_broker: _builtins.int,
                 max_broker: _builtins.int,
                 max_consumer_per_broker: _builtins.int,
                 max_partition_per_broker: _builtins.int,
                 max_storage_per_node: _builtins.int,
                 max_tps_per_broker: _builtins.int,
                 min_broker: _builtins.int,
                 min_storage_per_node: _builtins.int):
        """
        :param _builtins.str flavor_alias: The flavor ID alias.
        :param _builtins.int max_bandwidth_per_broker: The maximum bandwidth per broker.
        :param _builtins.int max_broker: The maximum number of brokers.
        :param _builtins.int max_consumer_per_broker: The maximum number of consumers per broker.
        :param _builtins.int max_partition_per_broker: The maximum number of partitions per broker.
        :param _builtins.int max_storage_per_node: The maximum storage per node. The unit is GB.
        :param _builtins.int max_tps_per_broker: The maximum TPS per broker.
        :param _builtins.int min_broker: The minimum number of brokers.
        :param _builtins.int min_storage_per_node: The minimum storage per node. The unit is GB.
        """
        pulumi.set(__self__, "flavor_alias", flavor_alias)
        pulumi.set(__self__, "max_bandwidth_per_broker", max_bandwidth_per_broker)
        pulumi.set(__self__, "max_broker", max_broker)
        pulumi.set(__self__, "max_consumer_per_broker", max_consumer_per_broker)
        pulumi.set(__self__, "max_partition_per_broker", max_partition_per_broker)
        pulumi.set(__self__, "max_storage_per_node", max_storage_per_node)
        pulumi.set(__self__, "max_tps_per_broker", max_tps_per_broker)
        pulumi.set(__self__, "min_broker", min_broker)
        pulumi.set(__self__, "min_storage_per_node", min_storage_per_node)

    @_builtins.property
    @pulumi.getter(name="flavorAlias")
    def flavor_alias(self) -> _builtins.str:
        """
        The flavor ID alias.
        """
        return pulumi.get(self, "flavor_alias")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthPerBroker")
    def max_bandwidth_per_broker(self) -> _builtins.int:
        """
        The maximum bandwidth per broker.
        """
        return pulumi.get(self, "max_bandwidth_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxBroker")
    def max_broker(self) -> _builtins.int:
        """
        The maximum number of brokers.
        """
        return pulumi.get(self, "max_broker")

    @_builtins.property
    @pulumi.getter(name="maxConsumerPerBroker")
    def max_consumer_per_broker(self) -> _builtins.int:
        """
        The maximum number of consumers per broker.
        """
        return pulumi.get(self, "max_consumer_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxPartitionPerBroker")
    def max_partition_per_broker(self) -> _builtins.int:
        """
        The maximum number of partitions per broker.
        """
        return pulumi.get(self, "max_partition_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxStoragePerNode")
    def max_storage_per_node(self) -> _builtins.int:
        """
        The maximum storage per node. The unit is GB.
        """
        return pulumi.get(self, "max_storage_per_node")

    @_builtins.property
    @pulumi.getter(name="maxTpsPerBroker")
    def max_tps_per_broker(self) -> _builtins.int:
        """
        The maximum TPS per broker.
        """
        return pulumi.get(self, "max_tps_per_broker")

    @_builtins.property
    @pulumi.getter(name="minBroker")
    def min_broker(self) -> _builtins.int:
        """
        The minimum number of brokers.
        """
        return pulumi.get(self, "min_broker")

    @_builtins.property
    @pulumi.getter(name="minStoragePerNode")
    def min_storage_per_node(self) -> _builtins.int:
        """
        The minimum storage per node. The unit is GB.
        """
        return pulumi.get(self, "min_storage_per_node")


@pulumi.output_type
class GetFlavorsFlavorSupportFeatureResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 properties: Sequence['outputs.GetFlavorsFlavorSupportFeaturePropertyResult']):
        """
        :param _builtins.str name: The function name, e.g. **connector_obs**.
        :param Sequence['GetFlavorsFlavorSupportFeaturePropertyArgs'] properties: The function property details.
               The object structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The function name, e.g. **connector_obs**.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetFlavorsFlavorSupportFeaturePropertyResult']:
        """
        The function property details.
        The object structure is documented below.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GetFlavorsFlavorSupportFeaturePropertyResult(dict):
    def __init__(__self__, *,
                 max_node: _builtins.int,
                 max_task: _builtins.int,
                 min_node: _builtins.int,
                 min_task: _builtins.int):
        """
        :param _builtins.int max_node: The maximum number of nodes for the dump function.
        :param _builtins.int max_task: The maximum number of tasks for the dump function.
        :param _builtins.int min_node: The minimum number of nodes for the dump function.
        :param _builtins.int min_task: The minimum number of tasks for the dump function.
        """
        pulumi.set(__self__, "max_node", max_node)
        pulumi.set(__self__, "max_task", max_task)
        pulumi.set(__self__, "min_node", min_node)
        pulumi.set(__self__, "min_task", min_task)

    @_builtins.property
    @pulumi.getter(name="maxNode")
    def max_node(self) -> _builtins.int:
        """
        The maximum number of nodes for the dump function.
        """
        return pulumi.get(self, "max_node")

    @_builtins.property
    @pulumi.getter(name="maxTask")
    def max_task(self) -> _builtins.int:
        """
        The maximum number of tasks for the dump function.
        """
        return pulumi.get(self, "max_task")

    @_builtins.property
    @pulumi.getter(name="minNode")
    def min_node(self) -> _builtins.int:
        """
        The minimum number of nodes for the dump function.
        """
        return pulumi.get(self, "min_node")

    @_builtins.property
    @pulumi.getter(name="minTask")
    def min_task(self) -> _builtins.int:
        """
        The minimum number of tasks for the dump function.
        """
        return pulumi.get(self, "min_task")


@pulumi.output_type
class GetInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 access_user: _builtins.str,
                 availability_zones: Sequence[_builtins.str],
                 connect_address: _builtins.str,
                 cross_vpc_accesses: Sequence['outputs.GetInstancesInstanceCrossVpcAccessResult'],
                 description: _builtins.str,
                 dumping: _builtins.bool,
                 enable_auto_topic: _builtins.bool,
                 enable_public_ip: _builtins.bool,
                 enabled_mechanisms: Sequence[_builtins.str],
                 engine_version: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 maintain_begin: _builtins.str,
                 maintain_end: _builtins.str,
                 management_connect_address: _builtins.str,
                 manager_user: _builtins.str,
                 manegement_connect_address: _builtins.str,
                 name: _builtins.str,
                 network_id: _builtins.str,
                 partition_num: _builtins.int,
                 port: _builtins.int,
                 product_id: _builtins.str,
                 public_conn_addresses: _builtins.str,
                 public_ip_ids: Sequence[_builtins.str],
                 resource_spec_code: _builtins.str,
                 retention_policy: _builtins.str,
                 security_group_id: _builtins.str,
                 security_protocol: _builtins.str,
                 ssl_enable: _builtins.bool,
                 status: _builtins.str,
                 storage_space: _builtins.int,
                 storage_spec_code: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 used_storage_space: _builtins.int,
                 user_id: _builtins.str,
                 user_name: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str access_user: The access username.
        :param Sequence[_builtins.str] availability_zones: The list of AZ names.
        :param _builtins.str connect_address: The IP address for instance connection.
        :param Sequence['GetInstancesInstanceCrossVpcAccessArgs'] cross_vpc_accesses: Indicates the Access information of cross-VPC. The structure is documented below.
        :param _builtins.str description: The instance description.
        :param _builtins.bool dumping: Whether to dumping is enabled.
        :param _builtins.bool enable_auto_topic: Whether to enable automatic topic creation.
        :param _builtins.bool enable_public_ip: Whether public access to the instance is enabled.
        :param Sequence[_builtins.str] enabled_mechanisms: The authentication mechanisms to use after SASL is enabled.
        :param _builtins.str engine_version: The kafka engine version.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which all instances of the list
               belong.
        :param _builtins.str id: The instance ID.
        :param _builtins.str maintain_begin: The time at which a maintenance time window starts, the format is `HH:mm`.
        :param _builtins.str maintain_end: The time at which a maintenance time window ends, the format is `HH:mm`.
        :param _builtins.str management_connect_address: The connection address of the Kafka manager of an instance.
        :param _builtins.str manager_user: The username for logging in to the Kafka Manager.
        :param _builtins.str name: Specifies the kafka instance name for data-source queries.
        :param _builtins.str network_id: The subnet ID to which the instance belongs.
        :param _builtins.int partition_num: The maximum number of topics in the DMS kafka instance.
        :param _builtins.int port: The port number.
        :param _builtins.str product_id: The product ID used by the instance.
        :param _builtins.str public_conn_addresses: The instance public access address.
               The format of each connection address is `{IP address}:{port}`.
        :param Sequence[_builtins.str] public_ip_ids: The IDs of the elastic IP address (EIP).
        :param _builtins.str resource_spec_code: The resource specifications identifier.
        :param _builtins.str retention_policy: The action to be taken when the memory usage reaches the disk capacity threshold.
        :param _builtins.str security_group_id: The security group ID associated with the instance.
        :param _builtins.str security_protocol: The protocol to use after SASL is enabled.
        :param _builtins.bool ssl_enable: Whether the Kafka SASL_SSL is enabled.
        :param _builtins.str status: Specifies the kafka instance status for data-source queries.
        :param _builtins.int storage_space: The message storage capacity, in GB unit.
        :param _builtins.str storage_spec_code: The storage I/O specification.
        :param Mapping[str, _builtins.str] tags: The key/value pairs to associate with the instance.
        :param _builtins.str type: The instance type.
        :param _builtins.int used_storage_space: The used message storage space, in GB unit.
        :param _builtins.str user_id: The user ID who created the instance.
        :param _builtins.str user_name: The username who created the instance.
        :param _builtins.str vpc_id: The VPC ID to which the instance belongs.
        """
        pulumi.set(__self__, "access_user", access_user)
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "connect_address", connect_address)
        pulumi.set(__self__, "cross_vpc_accesses", cross_vpc_accesses)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dumping", dumping)
        pulumi.set(__self__, "enable_auto_topic", enable_auto_topic)
        pulumi.set(__self__, "enable_public_ip", enable_public_ip)
        pulumi.set(__self__, "enabled_mechanisms", enabled_mechanisms)
        pulumi.set(__self__, "engine_version", engine_version)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "maintain_begin", maintain_begin)
        pulumi.set(__self__, "maintain_end", maintain_end)
        pulumi.set(__self__, "management_connect_address", management_connect_address)
        pulumi.set(__self__, "manager_user", manager_user)
        pulumi.set(__self__, "manegement_connect_address", manegement_connect_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "partition_num", partition_num)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "public_conn_addresses", public_conn_addresses)
        pulumi.set(__self__, "public_ip_ids", public_ip_ids)
        pulumi.set(__self__, "resource_spec_code", resource_spec_code)
        pulumi.set(__self__, "retention_policy", retention_policy)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "security_protocol", security_protocol)
        pulumi.set(__self__, "ssl_enable", ssl_enable)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_space", storage_space)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "used_storage_space", used_storage_space)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="accessUser")
    def access_user(self) -> _builtins.str:
        """
        The access username.
        """
        return pulumi.get(self, "access_user")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        The list of AZ names.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="connectAddress")
    def connect_address(self) -> _builtins.str:
        """
        The IP address for instance connection.
        """
        return pulumi.get(self, "connect_address")

    @_builtins.property
    @pulumi.getter(name="crossVpcAccesses")
    def cross_vpc_accesses(self) -> Sequence['outputs.GetInstancesInstanceCrossVpcAccessResult']:
        """
        Indicates the Access information of cross-VPC. The structure is documented below.
        """
        return pulumi.get(self, "cross_vpc_accesses")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The instance description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def dumping(self) -> _builtins.bool:
        """
        Whether to dumping is enabled.
        """
        return pulumi.get(self, "dumping")

    @_builtins.property
    @pulumi.getter(name="enableAutoTopic")
    def enable_auto_topic(self) -> _builtins.bool:
        """
        Whether to enable automatic topic creation.
        """
        return pulumi.get(self, "enable_auto_topic")

    @_builtins.property
    @pulumi.getter(name="enablePublicIp")
    def enable_public_ip(self) -> _builtins.bool:
        """
        Whether public access to the instance is enabled.
        """
        return pulumi.get(self, "enable_public_ip")

    @_builtins.property
    @pulumi.getter(name="enabledMechanisms")
    def enabled_mechanisms(self) -> Sequence[_builtins.str]:
        """
        The authentication mechanisms to use after SASL is enabled.
        """
        return pulumi.get(self, "enabled_mechanisms")

    @_builtins.property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> _builtins.str:
        """
        The kafka engine version.
        """
        return pulumi.get(self, "engine_version")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which all instances of the list
        belong.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maintainBegin")
    def maintain_begin(self) -> _builtins.str:
        """
        The time at which a maintenance time window starts, the format is `HH:mm`.
        """
        return pulumi.get(self, "maintain_begin")

    @_builtins.property
    @pulumi.getter(name="maintainEnd")
    def maintain_end(self) -> _builtins.str:
        """
        The time at which a maintenance time window ends, the format is `HH:mm`.
        """
        return pulumi.get(self, "maintain_end")

    @_builtins.property
    @pulumi.getter(name="managementConnectAddress")
    def management_connect_address(self) -> _builtins.str:
        """
        The connection address of the Kafka manager of an instance.
        """
        return pulumi.get(self, "management_connect_address")

    @_builtins.property
    @pulumi.getter(name="managerUser")
    def manager_user(self) -> _builtins.str:
        """
        The username for logging in to the Kafka Manager.
        """
        return pulumi.get(self, "manager_user")

    @_builtins.property
    @pulumi.getter(name="manegementConnectAddress")
    @_utilities.deprecated("""typo in manegement_connect_address, please use \"management_connect_address\" instead.""")
    def manegement_connect_address(self) -> _builtins.str:
        return pulumi.get(self, "manegement_connect_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the kafka instance name for data-source queries.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The subnet ID to which the instance belongs.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="partitionNum")
    def partition_num(self) -> _builtins.int:
        """
        The maximum number of topics in the DMS kafka instance.
        """
        return pulumi.get(self, "partition_num")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        The product ID used by the instance.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="publicConnAddresses")
    def public_conn_addresses(self) -> _builtins.str:
        """
        The instance public access address.
        The format of each connection address is `{IP address}:{port}`.
        """
        return pulumi.get(self, "public_conn_addresses")

    @_builtins.property
    @pulumi.getter(name="publicIpIds")
    def public_ip_ids(self) -> Sequence[_builtins.str]:
        """
        The IDs of the elastic IP address (EIP).
        """
        return pulumi.get(self, "public_ip_ids")

    @_builtins.property
    @pulumi.getter(name="resourceSpecCode")
    def resource_spec_code(self) -> _builtins.str:
        """
        The resource specifications identifier.
        """
        return pulumi.get(self, "resource_spec_code")

    @_builtins.property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> _builtins.str:
        """
        The action to be taken when the memory usage reaches the disk capacity threshold.
        """
        return pulumi.get(self, "retention_policy")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        The security group ID associated with the instance.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> _builtins.str:
        """
        The protocol to use after SASL is enabled.
        """
        return pulumi.get(self, "security_protocol")

    @_builtins.property
    @pulumi.getter(name="sslEnable")
    def ssl_enable(self) -> _builtins.bool:
        """
        Whether the Kafka SASL_SSL is enabled.
        """
        return pulumi.get(self, "ssl_enable")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the kafka instance status for data-source queries.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageSpace")
    def storage_space(self) -> _builtins.int:
        """
        The message storage capacity, in GB unit.
        """
        return pulumi.get(self, "storage_space")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        The storage I/O specification.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to associate with the instance.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The instance type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="usedStorageSpace")
    def used_storage_space(self) -> _builtins.int:
        """
        The used message storage space, in GB unit.
        """
        return pulumi.get(self, "used_storage_space")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        The user ID who created the instance.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        The username who created the instance.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The VPC ID to which the instance belongs.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetInstancesInstanceCrossVpcAccessResult(dict):
    def __init__(__self__, *,
                 advertised_ip: _builtins.str,
                 lisenter_ip: _builtins.str,
                 listener_ip: _builtins.str,
                 port: _builtins.int,
                 port_id: _builtins.str):
        """
        :param _builtins.str advertised_ip: The advertised IP Address.
        :param _builtins.str listener_ip: The listener IP address.
        :param _builtins.int port: The port number.
        :param _builtins.str port_id: The port ID associated with the address.
        """
        pulumi.set(__self__, "advertised_ip", advertised_ip)
        pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        pulumi.set(__self__, "listener_ip", listener_ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> _builtins.str:
        """
        The advertised IP Address.
        """
        return pulumi.get(self, "advertised_ip")

    @_builtins.property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> _builtins.str:
        return pulumi.get(self, "lisenter_ip")

    @_builtins.property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> _builtins.str:
        """
        The listener IP address.
        """
        return pulumi.get(self, "listener_ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        """
        The port ID associated with the address.
        """
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetKafkaBackgroundTasksTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 params: _builtins.str,
                 status: _builtins.str,
                 updated_at: _builtins.str,
                 user_id: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the start time.
        :param _builtins.str id: Indicates the task ID.
        :param _builtins.str name: Indicates the task name.
        :param _builtins.str params: Indicates the task parameters.
        :param _builtins.str status: Indicates the task status.
        :param _builtins.str updated_at: Indicates the end time.
        :param _builtins.str user_id: Indicates the user ID.
        :param _builtins.str user_name: Indicates the username.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the start time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the task ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the task name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def params(self) -> _builtins.str:
        """
        Indicates the task parameters.
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the task status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the end time.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Indicates the user ID.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Indicates the username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetKafkaConsumerGroupsGroupResult(dict):
    def __init__(__self__, *,
                 assignment_strategy: _builtins.str,
                 coordinator_id: _builtins.int,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 group_message_offsets: Sequence['outputs.GetKafkaConsumerGroupsGroupGroupMessageOffsetResult'],
                 lag: _builtins.int,
                 members: Sequence['outputs.GetKafkaConsumerGroupsGroupMemberResult'],
                 name: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str assignment_strategy: Indicates the partition assignment strategy.
        :param _builtins.int coordinator_id: Specifies the coordinator ID.
        :param _builtins.str created_at: Indicates the create time.
        :param _builtins.str description: Specifies the consumer group description.
        :param Sequence['GetKafkaConsumerGroupsGroupGroupMessageOffsetArgs'] group_message_offsets: Indicates the group message offsets.
               The group_message_offsets structure is documented below.
        :param _builtins.int lag: Specifies the the number of accumulated messages.
        :param Sequence['GetKafkaConsumerGroupsGroupMemberArgs'] members: Indicates the consumer group members.
               The members structure is documented below.
        :param _builtins.str name: Specifies the consumer group name.
        :param _builtins.str state: Specifies the consumer group status.
               The value can be:
               + **Dead**: The consumer group has no members or metadata.
               + **Empty**: The consumer group has metadata but has no members.
               + **PreparingRebalance**: The consumer group is to be rebalanced.
               + **CompletingRebalance**: All members have joined the group.
               + **Stable**: Members in the consumer group can consume messages.
        """
        pulumi.set(__self__, "assignment_strategy", assignment_strategy)
        pulumi.set(__self__, "coordinator_id", coordinator_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "group_message_offsets", group_message_offsets)
        pulumi.set(__self__, "lag", lag)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="assignmentStrategy")
    def assignment_strategy(self) -> _builtins.str:
        """
        Indicates the partition assignment strategy.
        """
        return pulumi.get(self, "assignment_strategy")

    @_builtins.property
    @pulumi.getter(name="coordinatorId")
    def coordinator_id(self) -> _builtins.int:
        """
        Specifies the coordinator ID.
        """
        return pulumi.get(self, "coordinator_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Specifies the consumer group description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="groupMessageOffsets")
    def group_message_offsets(self) -> Sequence['outputs.GetKafkaConsumerGroupsGroupGroupMessageOffsetResult']:
        """
        Indicates the group message offsets.
        The group_message_offsets structure is documented below.
        """
        return pulumi.get(self, "group_message_offsets")

    @_builtins.property
    @pulumi.getter
    def lag(self) -> _builtins.int:
        """
        Specifies the the number of accumulated messages.
        """
        return pulumi.get(self, "lag")

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetKafkaConsumerGroupsGroupMemberResult']:
        """
        Indicates the consumer group members.
        The members structure is documented below.
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the consumer group name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Specifies the consumer group status.
        The value can be:
        + **Dead**: The consumer group has no members or metadata.
        + **Empty**: The consumer group has metadata but has no members.
        + **PreparingRebalance**: The consumer group is to be rebalanced.
        + **CompletingRebalance**: All members have joined the group.
        + **Stable**: Members in the consumer group can consume messages.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetKafkaConsumerGroupsGroupGroupMessageOffsetResult(dict):
    def __init__(__self__, *,
                 lag: _builtins.int,
                 message_current_offset: _builtins.int,
                 message_log_end_offset: _builtins.int,
                 partition: _builtins.int,
                 topic: _builtins.str):
        """
        :param _builtins.int lag: Specifies the the number of accumulated messages.
        :param _builtins.int message_current_offset: Indicates the message current offset.
        :param _builtins.int message_log_end_offset: Indicates the message log end offset.
        :param _builtins.int partition: Indicates the partition.
        :param _builtins.str topic: Indicates the topic name.
        """
        pulumi.set(__self__, "lag", lag)
        pulumi.set(__self__, "message_current_offset", message_current_offset)
        pulumi.set(__self__, "message_log_end_offset", message_log_end_offset)
        pulumi.set(__self__, "partition", partition)
        pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter
    def lag(self) -> _builtins.int:
        """
        Specifies the the number of accumulated messages.
        """
        return pulumi.get(self, "lag")

    @_builtins.property
    @pulumi.getter(name="messageCurrentOffset")
    def message_current_offset(self) -> _builtins.int:
        """
        Indicates the message current offset.
        """
        return pulumi.get(self, "message_current_offset")

    @_builtins.property
    @pulumi.getter(name="messageLogEndOffset")
    def message_log_end_offset(self) -> _builtins.int:
        """
        Indicates the message log end offset.
        """
        return pulumi.get(self, "message_log_end_offset")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> _builtins.int:
        """
        Indicates the partition.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Indicates the topic name.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class GetKafkaConsumerGroupsGroupMemberResult(dict):
    def __init__(__self__, *,
                 assignments: Sequence['outputs.GetKafkaConsumerGroupsGroupMemberAssignmentResult'],
                 client_id: _builtins.str,
                 host: _builtins.str,
                 member_id: _builtins.str):
        """
        :param Sequence['GetKafkaConsumerGroupsGroupMemberAssignmentArgs'] assignments: Indicates the details about the partition assigned to the consumer.
               The assignment structure is documented below.
        :param _builtins.str client_id: Indicates the client ID.
        :param _builtins.str host: Indicates the consumer address.
        :param _builtins.str member_id: Indicates the member ID.
        """
        pulumi.set(__self__, "assignments", assignments)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "member_id", member_id)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Sequence['outputs.GetKafkaConsumerGroupsGroupMemberAssignmentResult']:
        """
        Indicates the details about the partition assigned to the consumer.
        The assignment structure is documented below.
        """
        return pulumi.get(self, "assignments")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Indicates the client ID.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Indicates the consumer address.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="memberId")
    def member_id(self) -> _builtins.str:
        """
        Indicates the member ID.
        """
        return pulumi.get(self, "member_id")


@pulumi.output_type
class GetKafkaConsumerGroupsGroupMemberAssignmentResult(dict):
    def __init__(__self__, *,
                 partitions: Sequence[_builtins.int],
                 topic: _builtins.str):
        """
        :param Sequence[_builtins.int] partitions: Indicates the partitions.
        :param _builtins.str topic: Indicates the topic name.
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> Sequence[_builtins.int]:
        """
        Indicates the partitions.
        """
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Indicates the topic name.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class GetKafkaExtendFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch_types: Sequence[_builtins.str],
                 available_zones: Sequence[_builtins.str],
                 charging_modes: Sequence[_builtins.str],
                 id: _builtins.str,
                 ios: Sequence['outputs.GetKafkaExtendFlavorsFlavorIoResult'],
                 properties: Sequence['outputs.GetKafkaExtendFlavorsFlavorPropertyResult'],
                 support_features: Sequence['outputs.GetKafkaExtendFlavorsFlavorSupportFeatureResult'],
                 type: _builtins.str,
                 unavailable_zones: Sequence[_builtins.str],
                 vm_specification: _builtins.str):
        """
        :param Sequence[_builtins.str] arch_types: Indicates the supported CPU architectures.
        :param Sequence[_builtins.str] available_zones: Indicates the AZs where there are available resources.
        :param Sequence[_builtins.str] charging_modes: Indicates the supported billing modes.
        :param _builtins.str id: Indicates the flavor ID.
        :param Sequence['GetKafkaExtendFlavorsFlavorIoArgs'] ios: Indicates the disk I/O information.
        :param Sequence['GetKafkaExtendFlavorsFlavorPropertyArgs'] properties: Indicates the key-value pair of a feature.
        :param Sequence['GetKafkaExtendFlavorsFlavorSupportFeatureArgs'] support_features: Indicates the supported features.
        :param _builtins.str type: Specifies the flavor type.
        :param Sequence[_builtins.str] unavailable_zones: Indicates the AZs where resources are sold out.
        :param _builtins.str vm_specification: Indicates the ECS flavor used by the flavor.
        """
        pulumi.set(__self__, "arch_types", arch_types)
        pulumi.set(__self__, "available_zones", available_zones)
        pulumi.set(__self__, "charging_modes", charging_modes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ios", ios)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "support_features", support_features)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailable_zones", unavailable_zones)
        pulumi.set(__self__, "vm_specification", vm_specification)

    @_builtins.property
    @pulumi.getter(name="archTypes")
    def arch_types(self) -> Sequence[_builtins.str]:
        """
        Indicates the supported CPU architectures.
        """
        return pulumi.get(self, "arch_types")

    @_builtins.property
    @pulumi.getter(name="availableZones")
    def available_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the AZs where there are available resources.
        """
        return pulumi.get(self, "available_zones")

    @_builtins.property
    @pulumi.getter(name="chargingModes")
    def charging_modes(self) -> Sequence[_builtins.str]:
        """
        Indicates the supported billing modes.
        """
        return pulumi.get(self, "charging_modes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the flavor ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Sequence['outputs.GetKafkaExtendFlavorsFlavorIoResult']:
        """
        Indicates the disk I/O information.
        """
        return pulumi.get(self, "ios")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetKafkaExtendFlavorsFlavorPropertyResult']:
        """
        Indicates the key-value pair of a feature.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="supportFeatures")
    def support_features(self) -> Sequence['outputs.GetKafkaExtendFlavorsFlavorSupportFeatureResult']:
        """
        Indicates the supported features.
        """
        return pulumi.get(self, "support_features")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the flavor type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailableZones")
    def unavailable_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the AZs where resources are sold out.
        """
        return pulumi.get(self, "unavailable_zones")

    @_builtins.property
    @pulumi.getter(name="vmSpecification")
    def vm_specification(self) -> _builtins.str:
        """
        Indicates the ECS flavor used by the flavor.
        """
        return pulumi.get(self, "vm_specification")


@pulumi.output_type
class GetKafkaExtendFlavorsFlavorIoResult(dict):
    def __init__(__self__, *,
                 available_zones: Sequence[_builtins.str],
                 storage_spec_code: _builtins.str,
                 type: _builtins.str,
                 unavailable_zones: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] available_zones: Indicates the AZs where there are available resources.
        :param _builtins.str storage_spec_code: Specifies the disk IO encoding, e.g. **dms.physical.storage.high.v2**.
        :param _builtins.str type: Specifies the flavor type.
        :param Sequence[_builtins.str] unavailable_zones: Indicates the AZs where resources are sold out.
        """
        pulumi.set(__self__, "available_zones", available_zones)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailable_zones", unavailable_zones)

    @_builtins.property
    @pulumi.getter(name="availableZones")
    def available_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the AZs where there are available resources.
        """
        return pulumi.get(self, "available_zones")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Specifies the disk IO encoding, e.g. **dms.physical.storage.high.v2**.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the flavor type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailableZones")
    def unavailable_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the AZs where resources are sold out.
        """
        return pulumi.get(self, "unavailable_zones")


@pulumi.output_type
class GetKafkaExtendFlavorsFlavorPropertyResult(dict):
    def __init__(__self__, *,
                 flavor_alias: _builtins.str,
                 max_bandwidth_per_broker: _builtins.str,
                 max_broker: _builtins.str,
                 max_consumer_per_broker: _builtins.str,
                 max_partition_per_broker: _builtins.str,
                 max_storage_per_node: _builtins.str,
                 max_tps_per_broker: _builtins.str,
                 min_broker: _builtins.str,
                 min_storage_per_node: _builtins.str):
        """
        :param _builtins.str flavor_alias: Indicates the alias of **flavor_id**.
        :param _builtins.str max_bandwidth_per_broker: Indicates the maximum bandwidth of each broker.
        :param _builtins.str max_broker: Indicates the maximum number of brokers.
        :param _builtins.str max_consumer_per_broker: Indicates the maximum number of consumers of each broker.
        :param _builtins.str max_partition_per_broker: Indicates the maximum number of partitions of each broker.
        :param _builtins.str max_storage_per_node: Indicates the maximum storage space of each broker. Unit: GB.
        :param _builtins.str max_tps_per_broker: Indicates the maximum TPS of each broker.
        :param _builtins.str min_broker: Indicates the minimum number of brokers.
        :param _builtins.str min_storage_per_node: Indicates the minimum storage space of each broker. Unit: GB.
        """
        pulumi.set(__self__, "flavor_alias", flavor_alias)
        pulumi.set(__self__, "max_bandwidth_per_broker", max_bandwidth_per_broker)
        pulumi.set(__self__, "max_broker", max_broker)
        pulumi.set(__self__, "max_consumer_per_broker", max_consumer_per_broker)
        pulumi.set(__self__, "max_partition_per_broker", max_partition_per_broker)
        pulumi.set(__self__, "max_storage_per_node", max_storage_per_node)
        pulumi.set(__self__, "max_tps_per_broker", max_tps_per_broker)
        pulumi.set(__self__, "min_broker", min_broker)
        pulumi.set(__self__, "min_storage_per_node", min_storage_per_node)

    @_builtins.property
    @pulumi.getter(name="flavorAlias")
    def flavor_alias(self) -> _builtins.str:
        """
        Indicates the alias of **flavor_id**.
        """
        return pulumi.get(self, "flavor_alias")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthPerBroker")
    def max_bandwidth_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum bandwidth of each broker.
        """
        return pulumi.get(self, "max_bandwidth_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxBroker")
    def max_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of brokers.
        """
        return pulumi.get(self, "max_broker")

    @_builtins.property
    @pulumi.getter(name="maxConsumerPerBroker")
    def max_consumer_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of consumers of each broker.
        """
        return pulumi.get(self, "max_consumer_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxPartitionPerBroker")
    def max_partition_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of partitions of each broker.
        """
        return pulumi.get(self, "max_partition_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxStoragePerNode")
    def max_storage_per_node(self) -> _builtins.str:
        """
        Indicates the maximum storage space of each broker. Unit: GB.
        """
        return pulumi.get(self, "max_storage_per_node")

    @_builtins.property
    @pulumi.getter(name="maxTpsPerBroker")
    def max_tps_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum TPS of each broker.
        """
        return pulumi.get(self, "max_tps_per_broker")

    @_builtins.property
    @pulumi.getter(name="minBroker")
    def min_broker(self) -> _builtins.str:
        """
        Indicates the minimum number of brokers.
        """
        return pulumi.get(self, "min_broker")

    @_builtins.property
    @pulumi.getter(name="minStoragePerNode")
    def min_storage_per_node(self) -> _builtins.str:
        """
        Indicates the minimum storage space of each broker. Unit: GB.
        """
        return pulumi.get(self, "min_storage_per_node")


@pulumi.output_type
class GetKafkaExtendFlavorsFlavorSupportFeatureResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 properties: Mapping[str, _builtins.str]):
        """
        :param _builtins.str name: Indicates the feature name.
        :param Mapping[str, _builtins.str] properties: Indicates the key-value pair of a feature.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the feature name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        Indicates the key-value pair of a feature.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GetKafkaMessageDiagnosisTasksReportListResult(dict):
    def __init__(__self__, *,
                 accumulated_partitions: _builtins.int,
                 begin_time: _builtins.str,
                 end_time: _builtins.str,
                 group_name: _builtins.str,
                 report_id: _builtins.str,
                 status: _builtins.str,
                 topic_name: _builtins.str):
        """
        :param _builtins.int accumulated_partitions: Indicates the number of partitions where accumulated messages are found.
        :param _builtins.str begin_time: Indicates the diagnosis task start time.
        :param _builtins.str end_time: Indicates the diagnosis task end time.
        :param _builtins.str group_name: Indicates the name of the consumer group being diagnosed.
        :param _builtins.str report_id: Indicates the diagnosis report ID.
        :param _builtins.str status: Indicates the status of a message stack diagnosis task.
        :param _builtins.str topic_name: Indicates the name of the topic being diagnosed.
        """
        pulumi.set(__self__, "accumulated_partitions", accumulated_partitions)
        pulumi.set(__self__, "begin_time", begin_time)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "report_id", report_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "topic_name", topic_name)

    @_builtins.property
    @pulumi.getter(name="accumulatedPartitions")
    def accumulated_partitions(self) -> _builtins.int:
        """
        Indicates the number of partitions where accumulated messages are found.
        """
        return pulumi.get(self, "accumulated_partitions")

    @_builtins.property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> _builtins.str:
        """
        Indicates the diagnosis task start time.
        """
        return pulumi.get(self, "begin_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Indicates the diagnosis task end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Indicates the name of the consumer group being diagnosed.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="reportId")
    def report_id(self) -> _builtins.str:
        """
        Indicates the diagnosis report ID.
        """
        return pulumi.get(self, "report_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the status of a message stack diagnosis task.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        Indicates the name of the topic being diagnosed.
        """
        return pulumi.get(self, "topic_name")


@pulumi.output_type
class GetKafkaMessagesMessageResult(dict):
    def __init__(__self__, *,
                 app_id: _builtins.str,
                 huge_message: _builtins.bool,
                 key: _builtins.str,
                 message_id: _builtins.str,
                 message_offset: _builtins.int,
                 partition: _builtins.int,
                 size: _builtins.int,
                 tag: _builtins.str,
                 timestamp: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str app_id: Indicates the application ID.
        :param _builtins.bool huge_message: Indicates the big data flag.
        :param _builtins.str key: Indicates the message key.
        :param _builtins.str message_id: Indicates the message ID.
        :param _builtins.int message_offset: Specifies the message offset.
               This parameter is mandatory when you query the message content by offset.
        :param _builtins.int partition: Specifies the partition.
               This parameter is mandatory when you query the message content by offset.
        :param _builtins.int size: Indicates the message size.
        :param _builtins.str tag: Indicates the message label.
        :param _builtins.str timestamp: Indicates the message production time.
        :param _builtins.str value: Indicates the message content.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "huge_message", huge_message)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "message_id", message_id)
        pulumi.set(__self__, "message_offset", message_offset)
        pulumi.set(__self__, "partition", partition)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> _builtins.str:
        """
        Indicates the application ID.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="hugeMessage")
    def huge_message(self) -> _builtins.bool:
        """
        Indicates the big data flag.
        """
        return pulumi.get(self, "huge_message")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Indicates the message key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> _builtins.str:
        """
        Indicates the message ID.
        """
        return pulumi.get(self, "message_id")

    @_builtins.property
    @pulumi.getter(name="messageOffset")
    def message_offset(self) -> _builtins.int:
        """
        Specifies the message offset.
        This parameter is mandatory when you query the message content by offset.
        """
        return pulumi.get(self, "message_offset")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> _builtins.int:
        """
        Specifies the partition.
        This parameter is mandatory when you query the message content by offset.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Indicates the message size.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        Indicates the message label.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        Indicates the message production time.
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Indicates the message content.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaSmartConnectTasksTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 destination_type: _builtins.str,
                 id: _builtins.str,
                 status: _builtins.str,
                 task_name: _builtins.str,
                 topics: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the creation time of the smart connect task.
        :param _builtins.str destination_type: Specifies the destination type of the smart connect task.
        :param _builtins.str id: Indicates the ID of the smart connect task.
        :param _builtins.str status: Specifies the status of the smart connect task. Value options: **RUNNING**, **PAUSED**.
        :param _builtins.str task_name: Specifies the name of the smart connect task.
        :param _builtins.str topics: Indicates the topic names separated by commas or the topic regular expression of the smart connect task.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "topics", topics)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the creation time of the smart connect task.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> _builtins.str:
        """
        Specifies the destination type of the smart connect task.
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of the smart connect task.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the smart connect task. Value options: **RUNNING**, **PAUSED**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Specifies the name of the smart connect task.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> _builtins.str:
        """
        Indicates the topic names separated by commas or the topic regular expression of the smart connect task.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class GetKafkaTopicPartitionsPartitionResult(dict):
    def __init__(__self__, *,
                 last_offset: _builtins.int,
                 last_update_time: _builtins.str,
                 message_count: _builtins.int,
                 partition: _builtins.int,
                 start_offset: _builtins.int):
        """
        :param _builtins.int last_offset: Indicates the last offset.
        :param _builtins.str last_update_time: Indicates the last update time.
        :param _builtins.int message_count: Indicates the message count.
        :param _builtins.int partition: Indicates the partition ID.
        :param _builtins.int start_offset: Indicates the start offset.
        """
        pulumi.set(__self__, "last_offset", last_offset)
        pulumi.set(__self__, "last_update_time", last_update_time)
        pulumi.set(__self__, "message_count", message_count)
        pulumi.set(__self__, "partition", partition)
        pulumi.set(__self__, "start_offset", start_offset)

    @_builtins.property
    @pulumi.getter(name="lastOffset")
    def last_offset(self) -> _builtins.int:
        """
        Indicates the last offset.
        """
        return pulumi.get(self, "last_offset")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> _builtins.str:
        """
        Indicates the last update time.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="messageCount")
    def message_count(self) -> _builtins.int:
        """
        Indicates the message count.
        """
        return pulumi.get(self, "message_count")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> _builtins.int:
        """
        Indicates the partition ID.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="startOffset")
    def start_offset(self) -> _builtins.int:
        """
        Indicates the start offset.
        """
        return pulumi.get(self, "start_offset")


@pulumi.output_type
class GetKafkaTopicProducersProducerResult(dict):
    def __init__(__self__, *,
                 broker_address: _builtins.str,
                 join_time: _builtins.str,
                 producer_address: _builtins.str):
        """
        :param _builtins.str broker_address: Indicates the broker address.
        :param _builtins.str join_time: Indicates the time when the broker was connected.
        :param _builtins.str producer_address: Indicates the producer address.
        """
        pulumi.set(__self__, "broker_address", broker_address)
        pulumi.set(__self__, "join_time", join_time)
        pulumi.set(__self__, "producer_address", producer_address)

    @_builtins.property
    @pulumi.getter(name="brokerAddress")
    def broker_address(self) -> _builtins.str:
        """
        Indicates the broker address.
        """
        return pulumi.get(self, "broker_address")

    @_builtins.property
    @pulumi.getter(name="joinTime")
    def join_time(self) -> _builtins.str:
        """
        Indicates the time when the broker was connected.
        """
        return pulumi.get(self, "join_time")

    @_builtins.property
    @pulumi.getter(name="producerAddress")
    def producer_address(self) -> _builtins.str:
        """
        Indicates the producer address.
        """
        return pulumi.get(self, "producer_address")


@pulumi.output_type
class GetKafkaTopicsTopicResult(dict):
    def __init__(__self__, *,
                 aging_time: _builtins.int,
                 configs: Sequence['outputs.GetKafkaTopicsTopicConfigResult'],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 name: _builtins.str,
                 partitions: _builtins.int,
                 policies_only: _builtins.bool,
                 replicas: _builtins.int,
                 sync_flushing: _builtins.bool,
                 sync_replication: _builtins.bool,
                 type: _builtins.str):
        """
        :param _builtins.int aging_time: Indicates the aging time in hours.
        :param Sequence['GetKafkaTopicsTopicConfigArgs'] configs: Indicates the other topic configurations.
        :param _builtins.str created_at: Indicates the topic create time.
        :param _builtins.str description: Indicates the topic description.
        :param _builtins.str name: Specifies the topic name.
        :param _builtins.int partitions: Indicates the number of topic partitions.
        :param _builtins.bool policies_only: Indicates whether this policy is the default policy.
        :param _builtins.int replicas: Indicates the number of replicas.
        :param _builtins.bool sync_flushing: Indicates whether the synchronous flushing is enabled.
        :param _builtins.bool sync_replication: Indicates whether the synchronous replication is enabled.
        :param _builtins.str type: Indicates the topic type.
        """
        pulumi.set(__self__, "aging_time", aging_time)
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "policies_only", policies_only)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "sync_flushing", sync_flushing)
        pulumi.set(__self__, "sync_replication", sync_replication)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="agingTime")
    def aging_time(self) -> _builtins.int:
        """
        Indicates the aging time in hours.
        """
        return pulumi.get(self, "aging_time")

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetKafkaTopicsTopicConfigResult']:
        """
        Indicates the other topic configurations.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the topic create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the topic description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> _builtins.int:
        """
        Indicates the number of topic partitions.
        """
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter(name="policiesOnly")
    def policies_only(self) -> _builtins.bool:
        """
        Indicates whether this policy is the default policy.
        """
        return pulumi.get(self, "policies_only")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        """
        Indicates the number of replicas.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter(name="syncFlushing")
    def sync_flushing(self) -> _builtins.bool:
        """
        Indicates whether the synchronous flushing is enabled.
        """
        return pulumi.get(self, "sync_flushing")

    @_builtins.property
    @pulumi.getter(name="syncReplication")
    def sync_replication(self) -> _builtins.bool:
        """
        Indicates whether the synchronous replication is enabled.
        """
        return pulumi.get(self, "sync_replication")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the topic type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKafkaTopicsTopicConfigResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the topic name.
        :param _builtins.str value: Indicates the configuration value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Indicates the configuration value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKafkaUserClientQuotasQuotaResult(dict):
    def __init__(__self__, *,
                 client: _builtins.str,
                 client_default: _builtins.bool,
                 consumer_byte_rate: _builtins.int,
                 producer_byte_rate: _builtins.int,
                 user: _builtins.str,
                 user_default: _builtins.bool):
        """
        :param _builtins.str client: Specifies the client ID.
        :param _builtins.bool client_default: Indicates whether to use the default client settings.
        :param _builtins.int consumer_byte_rate: Indicates the consumption rate limit. The unit is byte/s.
        :param _builtins.int producer_byte_rate: Indicates the production rate limit. The unit is byte/s.
        :param _builtins.str user: Specifies the user name.
        :param _builtins.bool user_default: Indicates whether to use the default user settings.
        """
        pulumi.set(__self__, "client", client)
        pulumi.set(__self__, "client_default", client_default)
        pulumi.set(__self__, "consumer_byte_rate", consumer_byte_rate)
        pulumi.set(__self__, "producer_byte_rate", producer_byte_rate)
        pulumi.set(__self__, "user", user)
        pulumi.set(__self__, "user_default", user_default)

    @_builtins.property
    @pulumi.getter
    def client(self) -> _builtins.str:
        """
        Specifies the client ID.
        """
        return pulumi.get(self, "client")

    @_builtins.property
    @pulumi.getter(name="clientDefault")
    def client_default(self) -> _builtins.bool:
        """
        Indicates whether to use the default client settings.
        """
        return pulumi.get(self, "client_default")

    @_builtins.property
    @pulumi.getter(name="consumerByteRate")
    def consumer_byte_rate(self) -> _builtins.int:
        """
        Indicates the consumption rate limit. The unit is byte/s.
        """
        return pulumi.get(self, "consumer_byte_rate")

    @_builtins.property
    @pulumi.getter(name="producerByteRate")
    def producer_byte_rate(self) -> _builtins.int:
        """
        Indicates the production rate limit. The unit is byte/s.
        """
        return pulumi.get(self, "producer_byte_rate")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="userDefault")
    def user_default(self) -> _builtins.bool:
        """
        Indicates whether to use the default user settings.
        """
        return pulumi.get(self, "user_default")


@pulumi.output_type
class GetKafkaUsersUserResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 default_app: _builtins.bool,
                 description: _builtins.str,
                 name: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time.
        :param _builtins.bool default_app: Indicates whether the application is the default application.
        :param _builtins.str description: Specifies the user description.
        :param _builtins.str name: Specifies the user name.
        :param _builtins.str role: Indicates the user role.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "default_app", default_app)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="defaultApp")
    def default_app(self) -> _builtins.bool:
        """
        Indicates whether the application is the default application.
        """
        return pulumi.get(self, "default_app")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Specifies the user description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Indicates the user role.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetKafkav2SmartConnectTasksTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 destination_tasks: Sequence['outputs.GetKafkav2SmartConnectTasksTaskDestinationTaskResult'],
                 destination_type: _builtins.str,
                 id: _builtins.str,
                 source_tasks: Sequence['outputs.GetKafkav2SmartConnectTasksTaskSourceTaskResult'],
                 source_type: _builtins.str,
                 status: _builtins.str,
                 task_name: _builtins.str,
                 topics: Sequence[_builtins.str],
                 topics_regex: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the creation time of the smart connect task.
        :param Sequence['GetKafkav2SmartConnectTasksTaskDestinationTaskArgs'] destination_tasks: Indicates the target configuration of the task.
        :param _builtins.str destination_type: Indicates the destination type of the task.
        :param _builtins.str id: Indicates the task ID.
        :param Sequence['GetKafkav2SmartConnectTasksTaskSourceTaskArgs'] source_tasks: Indicates the source configuration of the task.
        :param _builtins.str source_type: Indicates the source type of the task.
        :param _builtins.str status: Indicates the status of the smart connect task.
        :param _builtins.str task_name: Indicates the task name.
        :param Sequence[_builtins.str] topics: Indicates the task topics name list.
        :param _builtins.str topics_regex: Indicates the regular expression of the topic of the task.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "destination_tasks", destination_tasks)
        pulumi.set(__self__, "destination_type", destination_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "source_tasks", source_tasks)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "task_name", task_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "topics_regex", topics_regex)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the creation time of the smart connect task.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="destinationTasks")
    def destination_tasks(self) -> Sequence['outputs.GetKafkav2SmartConnectTasksTaskDestinationTaskResult']:
        """
        Indicates the target configuration of the task.
        """
        return pulumi.get(self, "destination_tasks")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> _builtins.str:
        """
        Indicates the destination type of the task.
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the task ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="sourceTasks")
    def source_tasks(self) -> Sequence['outputs.GetKafkav2SmartConnectTasksTaskSourceTaskResult']:
        """
        Indicates the source configuration of the task.
        """
        return pulumi.get(self, "source_tasks")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> _builtins.str:
        """
        Indicates the source type of the task.
        """
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the status of the smart connect task.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="taskName")
    def task_name(self) -> _builtins.str:
        """
        Indicates the task name.
        """
        return pulumi.get(self, "task_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence[_builtins.str]:
        """
        Indicates the task topics name list.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="topicsRegex")
    def topics_regex(self) -> _builtins.str:
        """
        Indicates the regular expression of the topic of the task.
        """
        return pulumi.get(self, "topics_regex")


@pulumi.output_type
class GetKafkav2SmartConnectTasksTaskDestinationTaskResult(dict):
    def __init__(__self__, *,
                 consumer_strategy: _builtins.str,
                 deliver_time_interval: _builtins.int,
                 destination_file_type: _builtins.str,
                 flush_size: _builtins.int,
                 key_converter: _builtins.str,
                 kv_delimiter: _builtins.str,
                 obs_bucket_name: _builtins.str,
                 obs_part_size: _builtins.int,
                 obs_path: _builtins.str,
                 partition_format: _builtins.str,
                 partitioner_class: _builtins.str,
                 record_delimiter: _builtins.str,
                 schema_generator_class: _builtins.str,
                 store_keys: _builtins.bool,
                 timezone: _builtins.str,
                 value_converter: _builtins.str):
        """
        :param _builtins.str consumer_strategy: Indicates the consumer strategy of the smart connect task.
        :param _builtins.int deliver_time_interval: Indicates the dumping period in seconds.
        :param _builtins.str destination_file_type: Indicates the destination file type of the smart connect task.
        :param _builtins.int flush_size: Indicates the flush size.
        :param _builtins.str key_converter: Indicates the key converter.
        :param _builtins.str kv_delimiter: Indicates the kv delimiter.
        :param _builtins.str obs_bucket_name: Indicates the obs bucket name of the smart connect task.
        :param _builtins.int obs_part_size: Indicates the size of each file to be uploaded.
        :param _builtins.str obs_path: Indicates the obs path of the smart connect task.
        :param _builtins.str partition_format: Indicates the partiton format of the smart connect task.
        :param _builtins.str partitioner_class: Indicates the partitioner class.
        :param _builtins.str record_delimiter: Indicates the record delimiter of the smart connect task.
        :param _builtins.str schema_generator_class: Indicates the schema generator class.
        :param _builtins.bool store_keys: Indicates whether to store keys.
        :param _builtins.str timezone: Indicates the time zone.
        :param _builtins.str value_converter: Indicates the value converter.
        """
        pulumi.set(__self__, "consumer_strategy", consumer_strategy)
        pulumi.set(__self__, "deliver_time_interval", deliver_time_interval)
        pulumi.set(__self__, "destination_file_type", destination_file_type)
        pulumi.set(__self__, "flush_size", flush_size)
        pulumi.set(__self__, "key_converter", key_converter)
        pulumi.set(__self__, "kv_delimiter", kv_delimiter)
        pulumi.set(__self__, "obs_bucket_name", obs_bucket_name)
        pulumi.set(__self__, "obs_part_size", obs_part_size)
        pulumi.set(__self__, "obs_path", obs_path)
        pulumi.set(__self__, "partition_format", partition_format)
        pulumi.set(__self__, "partitioner_class", partitioner_class)
        pulumi.set(__self__, "record_delimiter", record_delimiter)
        pulumi.set(__self__, "schema_generator_class", schema_generator_class)
        pulumi.set(__self__, "store_keys", store_keys)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "value_converter", value_converter)

    @_builtins.property
    @pulumi.getter(name="consumerStrategy")
    def consumer_strategy(self) -> _builtins.str:
        """
        Indicates the consumer strategy of the smart connect task.
        """
        return pulumi.get(self, "consumer_strategy")

    @_builtins.property
    @pulumi.getter(name="deliverTimeInterval")
    def deliver_time_interval(self) -> _builtins.int:
        """
        Indicates the dumping period in seconds.
        """
        return pulumi.get(self, "deliver_time_interval")

    @_builtins.property
    @pulumi.getter(name="destinationFileType")
    def destination_file_type(self) -> _builtins.str:
        """
        Indicates the destination file type of the smart connect task.
        """
        return pulumi.get(self, "destination_file_type")

    @_builtins.property
    @pulumi.getter(name="flushSize")
    def flush_size(self) -> _builtins.int:
        """
        Indicates the flush size.
        """
        return pulumi.get(self, "flush_size")

    @_builtins.property
    @pulumi.getter(name="keyConverter")
    def key_converter(self) -> _builtins.str:
        """
        Indicates the key converter.
        """
        return pulumi.get(self, "key_converter")

    @_builtins.property
    @pulumi.getter(name="kvDelimiter")
    def kv_delimiter(self) -> _builtins.str:
        """
        Indicates the kv delimiter.
        """
        return pulumi.get(self, "kv_delimiter")

    @_builtins.property
    @pulumi.getter(name="obsBucketName")
    def obs_bucket_name(self) -> _builtins.str:
        """
        Indicates the obs bucket name of the smart connect task.
        """
        return pulumi.get(self, "obs_bucket_name")

    @_builtins.property
    @pulumi.getter(name="obsPartSize")
    def obs_part_size(self) -> _builtins.int:
        """
        Indicates the size of each file to be uploaded.
        """
        return pulumi.get(self, "obs_part_size")

    @_builtins.property
    @pulumi.getter(name="obsPath")
    def obs_path(self) -> _builtins.str:
        """
        Indicates the obs path of the smart connect task.
        """
        return pulumi.get(self, "obs_path")

    @_builtins.property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> _builtins.str:
        """
        Indicates the partiton format of the smart connect task.
        """
        return pulumi.get(self, "partition_format")

    @_builtins.property
    @pulumi.getter(name="partitionerClass")
    def partitioner_class(self) -> _builtins.str:
        """
        Indicates the partitioner class.
        """
        return pulumi.get(self, "partitioner_class")

    @_builtins.property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> _builtins.str:
        """
        Indicates the record delimiter of the smart connect task.
        """
        return pulumi.get(self, "record_delimiter")

    @_builtins.property
    @pulumi.getter(name="schemaGeneratorClass")
    def schema_generator_class(self) -> _builtins.str:
        """
        Indicates the schema generator class.
        """
        return pulumi.get(self, "schema_generator_class")

    @_builtins.property
    @pulumi.getter(name="storeKeys")
    def store_keys(self) -> _builtins.bool:
        """
        Indicates whether to store keys.
        """
        return pulumi.get(self, "store_keys")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> _builtins.str:
        """
        Indicates the time zone.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter(name="valueConverter")
    def value_converter(self) -> _builtins.str:
        """
        Indicates the value converter.
        """
        return pulumi.get(self, "value_converter")


@pulumi.output_type
class GetKafkav2SmartConnectTasksTaskSourceTaskResult(dict):
    def __init__(__self__, *,
                 compression_type: _builtins.str,
                 consumer_strategy: _builtins.str,
                 current_instance_alias: _builtins.str,
                 direction: _builtins.str,
                 peer_instance_addresses: Sequence[_builtins.str],
                 peer_instance_alias: _builtins.str,
                 peer_instance_id: _builtins.str,
                 provenance_header_enabled: _builtins.bool,
                 rename_topic_enabled: _builtins.bool,
                 replication_factor: _builtins.int,
                 sasl_mechanism: _builtins.str,
                 security_protocol: _builtins.str,
                 sync_consumer_offsets_enabled: _builtins.bool,
                 task_num: _builtins.int,
                 topics_mappings: Sequence[_builtins.str],
                 user_name: _builtins.str):
        """
        :param _builtins.str compression_type: Indicates  the compression algorithm to use for copying messages.
        :param _builtins.str consumer_strategy: Indicates the consumer strategy of the smart connect task.
        :param _builtins.str current_instance_alias: Indicates the current Kafka instance alias.
        :param _builtins.str direction: Indicates the sync direction.
        :param Sequence[_builtins.str] peer_instance_addresses: Indicates the peer Kafka instance address.
        :param _builtins.str peer_instance_alias: Indicates the peer Kafka instance alias.
        :param _builtins.str peer_instance_id: Indicates the peer Kafka instance ID.
        :param _builtins.bool provenance_header_enabled: Indicates whether to add the source header.
        :param _builtins.bool rename_topic_enabled: Indicates whether to rename a topic.
        :param _builtins.int replication_factor: Indicates the number of replicas.
        :param _builtins.str sasl_mechanism: Indicates the peer Kafka instance authentication mode.
        :param _builtins.str security_protocol: Indicates the peer Kafka instance authentication.
        :param _builtins.bool sync_consumer_offsets_enabled: Indicates whether to sync the consumption progress.
        :param _builtins.int task_num: Indicates the number of data replication tasks.
        :param Sequence[_builtins.str] topics_mappings: Indicates the topic mapping.
        :param _builtins.str user_name: Indicates the peer Kafka instance username.
        """
        pulumi.set(__self__, "compression_type", compression_type)
        pulumi.set(__self__, "consumer_strategy", consumer_strategy)
        pulumi.set(__self__, "current_instance_alias", current_instance_alias)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "peer_instance_addresses", peer_instance_addresses)
        pulumi.set(__self__, "peer_instance_alias", peer_instance_alias)
        pulumi.set(__self__, "peer_instance_id", peer_instance_id)
        pulumi.set(__self__, "provenance_header_enabled", provenance_header_enabled)
        pulumi.set(__self__, "rename_topic_enabled", rename_topic_enabled)
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        pulumi.set(__self__, "security_protocol", security_protocol)
        pulumi.set(__self__, "sync_consumer_offsets_enabled", sync_consumer_offsets_enabled)
        pulumi.set(__self__, "task_num", task_num)
        pulumi.set(__self__, "topics_mappings", topics_mappings)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> _builtins.str:
        """
        Indicates  the compression algorithm to use for copying messages.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="consumerStrategy")
    def consumer_strategy(self) -> _builtins.str:
        """
        Indicates the consumer strategy of the smart connect task.
        """
        return pulumi.get(self, "consumer_strategy")

    @_builtins.property
    @pulumi.getter(name="currentInstanceAlias")
    def current_instance_alias(self) -> _builtins.str:
        """
        Indicates the current Kafka instance alias.
        """
        return pulumi.get(self, "current_instance_alias")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        Indicates the sync direction.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="peerInstanceAddresses")
    def peer_instance_addresses(self) -> Sequence[_builtins.str]:
        """
        Indicates the peer Kafka instance address.
        """
        return pulumi.get(self, "peer_instance_addresses")

    @_builtins.property
    @pulumi.getter(name="peerInstanceAlias")
    def peer_instance_alias(self) -> _builtins.str:
        """
        Indicates the peer Kafka instance alias.
        """
        return pulumi.get(self, "peer_instance_alias")

    @_builtins.property
    @pulumi.getter(name="peerInstanceId")
    def peer_instance_id(self) -> _builtins.str:
        """
        Indicates the peer Kafka instance ID.
        """
        return pulumi.get(self, "peer_instance_id")

    @_builtins.property
    @pulumi.getter(name="provenanceHeaderEnabled")
    def provenance_header_enabled(self) -> _builtins.bool:
        """
        Indicates whether to add the source header.
        """
        return pulumi.get(self, "provenance_header_enabled")

    @_builtins.property
    @pulumi.getter(name="renameTopicEnabled")
    def rename_topic_enabled(self) -> _builtins.bool:
        """
        Indicates whether to rename a topic.
        """
        return pulumi.get(self, "rename_topic_enabled")

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> _builtins.int:
        """
        Indicates the number of replicas.
        """
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> _builtins.str:
        """
        Indicates the peer Kafka instance authentication mode.
        """
        return pulumi.get(self, "sasl_mechanism")

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> _builtins.str:
        """
        Indicates the peer Kafka instance authentication.
        """
        return pulumi.get(self, "security_protocol")

    @_builtins.property
    @pulumi.getter(name="syncConsumerOffsetsEnabled")
    def sync_consumer_offsets_enabled(self) -> _builtins.bool:
        """
        Indicates whether to sync the consumption progress.
        """
        return pulumi.get(self, "sync_consumer_offsets_enabled")

    @_builtins.property
    @pulumi.getter(name="taskNum")
    def task_num(self) -> _builtins.int:
        """
        Indicates the number of data replication tasks.
        """
        return pulumi.get(self, "task_num")

    @_builtins.property
    @pulumi.getter(name="topicsMappings")
    def topics_mappings(self) -> Sequence[_builtins.str]:
        """
        Indicates the topic mapping.
        """
        return pulumi.get(self, "topics_mappings")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Indicates the peer Kafka instance username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetRabbitmqBackgroundTasksTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 params: _builtins.str,
                 status: _builtins.str,
                 updated_at: _builtins.str,
                 user_id: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the start time.
        :param _builtins.str id: Indicates the task ID.
        :param _builtins.str name: Indicates the task name.
        :param _builtins.str params: Indicates the task parameters.
        :param _builtins.str status: Indicates the task status.
        :param _builtins.str updated_at: Indicates the end time.
        :param _builtins.str user_id: Indicates the user ID.
        :param _builtins.str user_name: Indicates the username.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the start time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the task ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the task name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def params(self) -> _builtins.str:
        """
        Indicates the task parameters.
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the task status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the end time.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Indicates the user ID.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Indicates the username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetRabbitmqExchangesExchangeResult(dict):
    def __init__(__self__, *,
                 auto_delete: _builtins.bool,
                 default: _builtins.bool,
                 durable: _builtins.bool,
                 internal: _builtins.bool,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.bool auto_delete: Indicates whether the auto delete is enabled.
        :param _builtins.bool default: Indicates whether the exchange is default.
        :param _builtins.bool durable: Indicates whether the durable is enabled.
        :param _builtins.bool internal: Indicates whether the exchange is internal.
        :param _builtins.str name: Indicates the exchange name.
        :param _builtins.str type: Indicates the exchange type.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "durable", durable)
        pulumi.set(__self__, "internal", internal)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Indicates whether the auto delete is enabled.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.bool:
        """
        Indicates whether the exchange is default.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def durable(self) -> _builtins.bool:
        """
        Indicates whether the durable is enabled.
        """
        return pulumi.get(self, "durable")

    @_builtins.property
    @pulumi.getter
    def internal(self) -> _builtins.bool:
        """
        Indicates whether the exchange is internal.
        """
        return pulumi.get(self, "internal")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the exchange name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the exchange type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRabbitmqExtendFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch_types: Sequence[_builtins.str],
                 charging_modes: Sequence[_builtins.str],
                 id: _builtins.str,
                 ios: Sequence['outputs.GetRabbitmqExtendFlavorsFlavorIoResult'],
                 properties: Sequence['outputs.GetRabbitmqExtendFlavorsFlavorPropertyResult'],
                 support_features: Sequence['outputs.GetRabbitmqExtendFlavorsFlavorSupportFeatureResult'],
                 type: _builtins.str,
                 vm_specification: _builtins.str):
        """
        :param Sequence[_builtins.str] arch_types: Indicates the list of supported CPU architectures.
        :param Sequence[_builtins.str] charging_modes: Indicates the list of supported billing modes.
        :param _builtins.str id: Indicates the flavor ID.
        :param Sequence['GetRabbitmqExtendFlavorsFlavorIoArgs'] ios: Indicates the list of supported disk IO types.
        :param Sequence['GetRabbitmqExtendFlavorsFlavorPropertyArgs'] properties: Indicates the property details.
        :param Sequence['GetRabbitmqExtendFlavorsFlavorSupportFeatureArgs'] support_features: Indicates the list of features supported by the current specification.
        :param _builtins.str type: Specifies flavor type. The valid values are **single** and **cluster**.
        :param _builtins.str vm_specification: Indicates the underlying VM specification.
        """
        pulumi.set(__self__, "arch_types", arch_types)
        pulumi.set(__self__, "charging_modes", charging_modes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ios", ios)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "support_features", support_features)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_specification", vm_specification)

    @_builtins.property
    @pulumi.getter(name="archTypes")
    def arch_types(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of supported CPU architectures.
        """
        return pulumi.get(self, "arch_types")

    @_builtins.property
    @pulumi.getter(name="chargingModes")
    def charging_modes(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of supported billing modes.
        """
        return pulumi.get(self, "charging_modes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the flavor ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Sequence['outputs.GetRabbitmqExtendFlavorsFlavorIoResult']:
        """
        Indicates the list of supported disk IO types.
        """
        return pulumi.get(self, "ios")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetRabbitmqExtendFlavorsFlavorPropertyResult']:
        """
        Indicates the property details.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="supportFeatures")
    def support_features(self) -> Sequence['outputs.GetRabbitmqExtendFlavorsFlavorSupportFeatureResult']:
        """
        Indicates the list of features supported by the current specification.
        """
        return pulumi.get(self, "support_features")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies flavor type. The valid values are **single** and **cluster**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vmSpecification")
    def vm_specification(self) -> _builtins.str:
        """
        Indicates the underlying VM specification.
        """
        return pulumi.get(self, "vm_specification")


@pulumi.output_type
class GetRabbitmqExtendFlavorsFlavorIoResult(dict):
    def __init__(__self__, *,
                 available_zones: Sequence[_builtins.str],
                 storage_spec_code: _builtins.str,
                 type: _builtins.str,
                 unavailable_zones: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] available_zones: Indicates the list of availability zones with available resources.
        :param _builtins.str storage_spec_code: Specifies the disk IO encoding, e.g. **dms.physical.storage.high.v2**.
        :param _builtins.str type: Specifies flavor type. The valid values are **single** and **cluster**.
        :param Sequence[_builtins.str] unavailable_zones: Indicates the list of unavailability zones with available resources.
        """
        pulumi.set(__self__, "available_zones", available_zones)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailable_zones", unavailable_zones)

    @_builtins.property
    @pulumi.getter(name="availableZones")
    def available_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of availability zones with available resources.
        """
        return pulumi.get(self, "available_zones")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Specifies the disk IO encoding, e.g. **dms.physical.storage.high.v2**.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies flavor type. The valid values are **single** and **cluster**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailableZones")
    def unavailable_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of unavailability zones with available resources.
        """
        return pulumi.get(self, "unavailable_zones")


@pulumi.output_type
class GetRabbitmqExtendFlavorsFlavorPropertyResult(dict):
    def __init__(__self__, *,
                 flavor_alias: _builtins.str,
                 max_broker: _builtins.str,
                 max_connection_per_broker: _builtins.str,
                 max_queue_per_broker: _builtins.str,
                 max_storage_per_node: _builtins.str,
                 min_broker: _builtins.str,
                 min_storage_per_node: _builtins.str,
                 step_length: _builtins.str):
        """
        :param _builtins.str flavor_alias: Indicates the alias of **flavor_id**.
        :param _builtins.str max_broker: Indicates the maximum number of brokers.
        :param _builtins.str max_connection_per_broker: Indicates the maximum number of connections.
        :param _builtins.str max_queue_per_broker: Indicates the maximum number of queues.
        :param _builtins.str max_storage_per_node: Indicates the maximum storage per node. The unit is GB.
        :param _builtins.str min_broker: Indicates the minimum number of brokers.
        :param _builtins.str min_storage_per_node: Indicates the minimum storage per node. The unit is GB.
        :param _builtins.str step_length: Indicates the step length.
        """
        pulumi.set(__self__, "flavor_alias", flavor_alias)
        pulumi.set(__self__, "max_broker", max_broker)
        pulumi.set(__self__, "max_connection_per_broker", max_connection_per_broker)
        pulumi.set(__self__, "max_queue_per_broker", max_queue_per_broker)
        pulumi.set(__self__, "max_storage_per_node", max_storage_per_node)
        pulumi.set(__self__, "min_broker", min_broker)
        pulumi.set(__self__, "min_storage_per_node", min_storage_per_node)
        pulumi.set(__self__, "step_length", step_length)

    @_builtins.property
    @pulumi.getter(name="flavorAlias")
    def flavor_alias(self) -> _builtins.str:
        """
        Indicates the alias of **flavor_id**.
        """
        return pulumi.get(self, "flavor_alias")

    @_builtins.property
    @pulumi.getter(name="maxBroker")
    def max_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of brokers.
        """
        return pulumi.get(self, "max_broker")

    @_builtins.property
    @pulumi.getter(name="maxConnectionPerBroker")
    def max_connection_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of connections.
        """
        return pulumi.get(self, "max_connection_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxQueuePerBroker")
    def max_queue_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of queues.
        """
        return pulumi.get(self, "max_queue_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxStoragePerNode")
    def max_storage_per_node(self) -> _builtins.str:
        """
        Indicates the maximum storage per node. The unit is GB.
        """
        return pulumi.get(self, "max_storage_per_node")

    @_builtins.property
    @pulumi.getter(name="minBroker")
    def min_broker(self) -> _builtins.str:
        """
        Indicates the minimum number of brokers.
        """
        return pulumi.get(self, "min_broker")

    @_builtins.property
    @pulumi.getter(name="minStoragePerNode")
    def min_storage_per_node(self) -> _builtins.str:
        """
        Indicates the minimum storage per node. The unit is GB.
        """
        return pulumi.get(self, "min_storage_per_node")

    @_builtins.property
    @pulumi.getter(name="stepLength")
    def step_length(self) -> _builtins.str:
        """
        Indicates the step length.
        """
        return pulumi.get(self, "step_length")


@pulumi.output_type
class GetRabbitmqExtendFlavorsFlavorSupportFeatureResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 properties: Mapping[str, _builtins.str]):
        """
        :param _builtins.str name: Indicates the feature name.
        :param Mapping[str, _builtins.str] properties: Indicates the property details.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the feature name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        Indicates the property details.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GetRabbitmqFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch_types: Sequence[_builtins.str],
                 charging_modes: Sequence[_builtins.str],
                 id: _builtins.str,
                 ios: Sequence['outputs.GetRabbitmqFlavorsFlavorIoResult'],
                 properties: Sequence['outputs.GetRabbitmqFlavorsFlavorPropertyResult'],
                 support_features: Sequence['outputs.GetRabbitmqFlavorsFlavorSupportFeatureResult'],
                 type: _builtins.str,
                 vm_specification: _builtins.str):
        """
        :param Sequence[_builtins.str] arch_types: Indicates the list of supported CPU architectures.
        :param Sequence[_builtins.str] charging_modes: Indicates the list of supported billing modes.
        :param _builtins.str id: Indicates the flavor ID.
        :param Sequence['GetRabbitmqFlavorsFlavorIoArgs'] ios: Indicates the list of supported disk IO types.
               The object structure is documented below.
        :param Sequence['GetRabbitmqFlavorsFlavorPropertyArgs'] properties: Indicates the function property details.
               The object structure is documented below.
        :param Sequence['GetRabbitmqFlavorsFlavorSupportFeatureArgs'] support_features: Indicates the list of features supported by the current specification.
               The object structure is documented below.
        :param _builtins.str type: Specifies flavor type.
               The valid values are **single**, **cluster**, **single.professional** and **cluster.professional**.
        :param _builtins.str vm_specification: Indicates the underlying VM specification.
        """
        pulumi.set(__self__, "arch_types", arch_types)
        pulumi.set(__self__, "charging_modes", charging_modes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ios", ios)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "support_features", support_features)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_specification", vm_specification)

    @_builtins.property
    @pulumi.getter(name="archTypes")
    def arch_types(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of supported CPU architectures.
        """
        return pulumi.get(self, "arch_types")

    @_builtins.property
    @pulumi.getter(name="chargingModes")
    def charging_modes(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of supported billing modes.
        """
        return pulumi.get(self, "charging_modes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the flavor ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Sequence['outputs.GetRabbitmqFlavorsFlavorIoResult']:
        """
        Indicates the list of supported disk IO types.
        The object structure is documented below.
        """
        return pulumi.get(self, "ios")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetRabbitmqFlavorsFlavorPropertyResult']:
        """
        Indicates the function property details.
        The object structure is documented below.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="supportFeatures")
    def support_features(self) -> Sequence['outputs.GetRabbitmqFlavorsFlavorSupportFeatureResult']:
        """
        Indicates the list of features supported by the current specification.
        The object structure is documented below.
        """
        return pulumi.get(self, "support_features")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies flavor type.
        The valid values are **single**, **cluster**, **single.professional** and **cluster.professional**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vmSpecification")
    def vm_specification(self) -> _builtins.str:
        """
        Indicates the underlying VM specification.
        """
        return pulumi.get(self, "vm_specification")


@pulumi.output_type
class GetRabbitmqFlavorsFlavorIoResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[_builtins.str],
                 storage_spec_code: _builtins.str,
                 type: _builtins.str,
                 unavailability_zones: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] availability_zones: Specifies the list of availability zones with available resources.
        :param _builtins.str storage_spec_code: Specifies the disk IO encoding.
               + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
               + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
        :param _builtins.str type: Specifies flavor type.
               The valid values are **single**, **cluster**, **single.professional** and **cluster.professional**.
        :param Sequence[_builtins.str] unavailability_zones: Indicates the list of unavailability zones with available resources.
        """
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailability_zones", unavailability_zones)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of availability zones with available resources.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Specifies the disk IO encoding.
        + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
        + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies flavor type.
        The valid values are **single**, **cluster**, **single.professional** and **cluster.professional**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailabilityZones")
    def unavailability_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of unavailability zones with available resources.
        """
        return pulumi.get(self, "unavailability_zones")


@pulumi.output_type
class GetRabbitmqFlavorsFlavorPropertyResult(dict):
    def __init__(__self__, *,
                 flavor_alias: _builtins.str,
                 max_bandwidth_per_broker: _builtins.int,
                 max_broker: _builtins.int,
                 max_consumer_per_broker: _builtins.int,
                 max_partition_per_broker: _builtins.int,
                 max_storage_per_node: _builtins.int,
                 max_tps_per_broker: _builtins.int,
                 min_broker: _builtins.int,
                 min_storage_per_node: _builtins.int):
        """
        :param _builtins.str flavor_alias: Indicates the flavor ID alias.
        :param _builtins.int max_bandwidth_per_broker: Indicates the maximum bandwidth per broker.
        :param _builtins.int max_broker: Indicates the maximum number of brokers.
        :param _builtins.int max_consumer_per_broker: Indicates the maximum number of consumers per broker.
        :param _builtins.int max_partition_per_broker: Indicates the maximum number of partitions per broker.
        :param _builtins.int max_storage_per_node: Indicates the maximum storage per node. The unit is GB.
        :param _builtins.int max_tps_per_broker: Indicates the maximum TPS per broker.
        :param _builtins.int min_broker: Indicates the minimum number of brokers.
        :param _builtins.int min_storage_per_node: Indicates the minimum storage per node. The unit is GB.
        """
        pulumi.set(__self__, "flavor_alias", flavor_alias)
        pulumi.set(__self__, "max_bandwidth_per_broker", max_bandwidth_per_broker)
        pulumi.set(__self__, "max_broker", max_broker)
        pulumi.set(__self__, "max_consumer_per_broker", max_consumer_per_broker)
        pulumi.set(__self__, "max_partition_per_broker", max_partition_per_broker)
        pulumi.set(__self__, "max_storage_per_node", max_storage_per_node)
        pulumi.set(__self__, "max_tps_per_broker", max_tps_per_broker)
        pulumi.set(__self__, "min_broker", min_broker)
        pulumi.set(__self__, "min_storage_per_node", min_storage_per_node)

    @_builtins.property
    @pulumi.getter(name="flavorAlias")
    def flavor_alias(self) -> _builtins.str:
        """
        Indicates the flavor ID alias.
        """
        return pulumi.get(self, "flavor_alias")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthPerBroker")
    def max_bandwidth_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum bandwidth per broker.
        """
        return pulumi.get(self, "max_bandwidth_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxBroker")
    def max_broker(self) -> _builtins.int:
        """
        Indicates the maximum number of brokers.
        """
        return pulumi.get(self, "max_broker")

    @_builtins.property
    @pulumi.getter(name="maxConsumerPerBroker")
    def max_consumer_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum number of consumers per broker.
        """
        return pulumi.get(self, "max_consumer_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxPartitionPerBroker")
    def max_partition_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum number of partitions per broker.
        """
        return pulumi.get(self, "max_partition_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxStoragePerNode")
    def max_storage_per_node(self) -> _builtins.int:
        """
        Indicates the maximum storage per node. The unit is GB.
        """
        return pulumi.get(self, "max_storage_per_node")

    @_builtins.property
    @pulumi.getter(name="maxTpsPerBroker")
    def max_tps_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum TPS per broker.
        """
        return pulumi.get(self, "max_tps_per_broker")

    @_builtins.property
    @pulumi.getter(name="minBroker")
    def min_broker(self) -> _builtins.int:
        """
        Indicates the minimum number of brokers.
        """
        return pulumi.get(self, "min_broker")

    @_builtins.property
    @pulumi.getter(name="minStoragePerNode")
    def min_storage_per_node(self) -> _builtins.int:
        """
        Indicates the minimum storage per node. The unit is GB.
        """
        return pulumi.get(self, "min_storage_per_node")


@pulumi.output_type
class GetRabbitmqFlavorsFlavorSupportFeatureResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 properties: Sequence['outputs.GetRabbitmqFlavorsFlavorSupportFeaturePropertyResult']):
        """
        :param _builtins.str name: Indicates the function name, e.g. **connector_obs**.
        :param Sequence['GetRabbitmqFlavorsFlavorSupportFeaturePropertyArgs'] properties: Indicates the function property details.
               The object structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the function name, e.g. **connector_obs**.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetRabbitmqFlavorsFlavorSupportFeaturePropertyResult']:
        """
        Indicates the function property details.
        The object structure is documented below.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GetRabbitmqFlavorsFlavorSupportFeaturePropertyResult(dict):
    def __init__(__self__, *,
                 max_node: _builtins.int,
                 max_task: _builtins.int,
                 min_node: _builtins.int,
                 min_task: _builtins.int):
        """
        :param _builtins.int max_node: Indicates the maximum number of nodes for the dump function.
        :param _builtins.int max_task: Indicates the maximum number of tasks for the dump function.
        :param _builtins.int min_node: Indicates the minimum number of nodes for the dump function.
        :param _builtins.int min_task: Indicates the minimum number of tasks for the dump function.
        """
        pulumi.set(__self__, "max_node", max_node)
        pulumi.set(__self__, "max_task", max_task)
        pulumi.set(__self__, "min_node", min_node)
        pulumi.set(__self__, "min_task", min_task)

    @_builtins.property
    @pulumi.getter(name="maxNode")
    def max_node(self) -> _builtins.int:
        """
        Indicates the maximum number of nodes for the dump function.
        """
        return pulumi.get(self, "max_node")

    @_builtins.property
    @pulumi.getter(name="maxTask")
    def max_task(self) -> _builtins.int:
        """
        Indicates the maximum number of tasks for the dump function.
        """
        return pulumi.get(self, "max_task")

    @_builtins.property
    @pulumi.getter(name="minNode")
    def min_node(self) -> _builtins.int:
        """
        Indicates the minimum number of nodes for the dump function.
        """
        return pulumi.get(self, "min_node")

    @_builtins.property
    @pulumi.getter(name="minTask")
    def min_task(self) -> _builtins.int:
        """
        Indicates the minimum number of tasks for the dump function.
        """
        return pulumi.get(self, "min_task")


@pulumi.output_type
class GetRabbitmqInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 access_user: _builtins.str,
                 availability_zones: Sequence[_builtins.str],
                 broker_num: _builtins.int,
                 charging_mode: _builtins.str,
                 connect_address: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 engine: _builtins.str,
                 engine_version: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 extend_times: _builtins.int,
                 flavor_id: _builtins.str,
                 id: _builtins.str,
                 is_logical_volume: _builtins.bool,
                 maintain_begin: _builtins.str,
                 maintain_end: _builtins.str,
                 management_connect_address: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 security_group_id: _builtins.str,
                 security_group_name: _builtins.str,
                 specification: _builtins.str,
                 ssl_enable: _builtins.bool,
                 status: _builtins.str,
                 storage_resource_id: _builtins.str,
                 storage_space: _builtins.int,
                 storage_spec_code: _builtins.str,
                 subnet_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 used_storage_space: _builtins.int,
                 user_name: _builtins.str,
                 vpc_id: _builtins.str,
                 vpc_name: _builtins.str):
        """
        :param _builtins.str access_user: Indicates the name of the user accessing the RabbitMQ instance.
        :param Sequence[_builtins.str] availability_zones: Indicates the list of the availability zone names.
        :param _builtins.int broker_num: Indicates the number of the brokers.
        :param _builtins.str charging_mode: Indicates the billing mode. The value can be: **prePaid** or **postPaid**.
        :param _builtins.str connect_address: Indicates the IP address of the RabbitMQ instance.
        :param _builtins.str created_at: Indicates the creation time of the RabbitMQ instance.
        :param _builtins.str description: Indicates the description of the RabbitMQ instance.
        :param _builtins.str engine: Indicates the message engine type. The value is `rabbitmq`.
        :param _builtins.str engine_version: Specifies the version of the RabbitMQ engine.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the RabbitMQ instance belongs.
        :param _builtins.int extend_times: Indicates the number of disk expansion times. If the value exceeds 20, disk expansion is
               no longer allowed.
        :param _builtins.str flavor_id: Specifies the flavor ID of the RabbitMQ instance.
        :param _builtins.str id: Indicates the ID of the RabbitMQ instance.
        :param _builtins.bool is_logical_volume: Indicates whether the instance is a new instance. This parameter is used to
               distinguish old instances from new instances during instance capacity expansion.
        :param _builtins.str maintain_begin: Indicates the time at which the maintenance window starts. The format is HH:mm:ss.
        :param _builtins.str maintain_end: Indicates the time at which the maintenance window ends. The format is HH:mm:ss.
        :param _builtins.str management_connect_address: Indicates the management address of the RabbitMQ instance.
        :param _builtins.str name: Specifies the name of the RabbitMQ instance.
        :param _builtins.int port: Indicates the port of the RabbitMQ instance.
        :param _builtins.str security_group_id: Indicates the ID of a security group.
        :param _builtins.str security_group_name: Indicates the name of a security group.
        :param _builtins.str specification: Indicates the instance specification.
        :param _builtins.bool ssl_enable: Indicates whether the RabbitMQ SASL_SSL is enabled. The value can be: **true** or **false**.
        :param _builtins.str status: Specifies the status of the RabbitMQ instance. Value options: **CREATING** **RUNNING**,
               **FAULTY**,  **RESTARTING**, **STARTING**, **CHANGING**, **CHANGE FAILED**, **FROZEN**, **FREEZING**, **UPGRADING**,
               **EXTENDING**, **ROLLING BACK**.
        :param _builtins.str storage_resource_id: Indicates the ID of the storage resource.
        :param _builtins.int storage_space: Indicates the message storage space in GB.
        :param _builtins.str storage_spec_code: Indicates the storage I/O specification.
        :param _builtins.str subnet_id: Indicates the ID of a subnet.
        :param Mapping[str, _builtins.str] tags: Indicates the key/value pairs of tags associated with the RabbitMQ instance.
        :param _builtins.str type: Specifies the RabbitMQ instance type. Value options: **cluster**, **single**.
        :param _builtins.int used_storage_space: Indicates the used message storage space in GB.
        :param _builtins.str user_name: Indicates the name of the user creating the RabbitMQ instance.
        :param _builtins.str vpc_id: Indicates the ID of a VPC.
        :param _builtins.str vpc_name: Indicates the name of a VPC.
        """
        pulumi.set(__self__, "access_user", access_user)
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "broker_num", broker_num)
        pulumi.set(__self__, "charging_mode", charging_mode)
        pulumi.set(__self__, "connect_address", connect_address)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "engine", engine)
        pulumi.set(__self__, "engine_version", engine_version)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "extend_times", extend_times)
        pulumi.set(__self__, "flavor_id", flavor_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_logical_volume", is_logical_volume)
        pulumi.set(__self__, "maintain_begin", maintain_begin)
        pulumi.set(__self__, "maintain_end", maintain_end)
        pulumi.set(__self__, "management_connect_address", management_connect_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "security_group_name", security_group_name)
        pulumi.set(__self__, "specification", specification)
        pulumi.set(__self__, "ssl_enable", ssl_enable)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_resource_id", storage_resource_id)
        pulumi.set(__self__, "storage_space", storage_space)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "used_storage_space", used_storage_space)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "vpc_name", vpc_name)

    @_builtins.property
    @pulumi.getter(name="accessUser")
    def access_user(self) -> _builtins.str:
        """
        Indicates the name of the user accessing the RabbitMQ instance.
        """
        return pulumi.get(self, "access_user")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of the availability zone names.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="brokerNum")
    def broker_num(self) -> _builtins.int:
        """
        Indicates the number of the brokers.
        """
        return pulumi.get(self, "broker_num")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> _builtins.str:
        """
        Indicates the billing mode. The value can be: **prePaid** or **postPaid**.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter(name="connectAddress")
    def connect_address(self) -> _builtins.str:
        """
        Indicates the IP address of the RabbitMQ instance.
        """
        return pulumi.get(self, "connect_address")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the creation time of the RabbitMQ instance.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the RabbitMQ instance.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> _builtins.str:
        """
        Indicates the message engine type. The value is `rabbitmq`.
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> _builtins.str:
        """
        Specifies the version of the RabbitMQ engine.
        """
        return pulumi.get(self, "engine_version")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the RabbitMQ instance belongs.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="extendTimes")
    def extend_times(self) -> _builtins.int:
        """
        Indicates the number of disk expansion times. If the value exceeds 20, disk expansion is
        no longer allowed.
        """
        return pulumi.get(self, "extend_times")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> _builtins.str:
        """
        Specifies the flavor ID of the RabbitMQ instance.
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of the RabbitMQ instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isLogicalVolume")
    def is_logical_volume(self) -> _builtins.bool:
        """
        Indicates whether the instance is a new instance. This parameter is used to
        distinguish old instances from new instances during instance capacity expansion.
        """
        return pulumi.get(self, "is_logical_volume")

    @_builtins.property
    @pulumi.getter(name="maintainBegin")
    def maintain_begin(self) -> _builtins.str:
        """
        Indicates the time at which the maintenance window starts. The format is HH:mm:ss.
        """
        return pulumi.get(self, "maintain_begin")

    @_builtins.property
    @pulumi.getter(name="maintainEnd")
    def maintain_end(self) -> _builtins.str:
        """
        Indicates the time at which the maintenance window ends. The format is HH:mm:ss.
        """
        return pulumi.get(self, "maintain_end")

    @_builtins.property
    @pulumi.getter(name="managementConnectAddress")
    def management_connect_address(self) -> _builtins.str:
        """
        Indicates the management address of the RabbitMQ instance.
        """
        return pulumi.get(self, "management_connect_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the RabbitMQ instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Indicates the port of the RabbitMQ instance.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        Indicates the ID of a security group.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> _builtins.str:
        """
        Indicates the name of a security group.
        """
        return pulumi.get(self, "security_group_name")

    @_builtins.property
    @pulumi.getter
    def specification(self) -> _builtins.str:
        """
        Indicates the instance specification.
        """
        return pulumi.get(self, "specification")

    @_builtins.property
    @pulumi.getter(name="sslEnable")
    def ssl_enable(self) -> _builtins.bool:
        """
        Indicates whether the RabbitMQ SASL_SSL is enabled. The value can be: **true** or **false**.
        """
        return pulumi.get(self, "ssl_enable")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the RabbitMQ instance. Value options: **CREATING** **RUNNING**,
        **FAULTY**,  **RESTARTING**, **STARTING**, **CHANGING**, **CHANGE FAILED**, **FROZEN**, **FREEZING**, **UPGRADING**,
        **EXTENDING**, **ROLLING BACK**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageResourceId")
    def storage_resource_id(self) -> _builtins.str:
        """
        Indicates the ID of the storage resource.
        """
        return pulumi.get(self, "storage_resource_id")

    @_builtins.property
    @pulumi.getter(name="storageSpace")
    def storage_space(self) -> _builtins.int:
        """
        Indicates the message storage space in GB.
        """
        return pulumi.get(self, "storage_space")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Indicates the storage I/O specification.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Indicates the ID of a subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Indicates the key/value pairs of tags associated with the RabbitMQ instance.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the RabbitMQ instance type. Value options: **cluster**, **single**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="usedStorageSpace")
    def used_storage_space(self) -> _builtins.int:
        """
        Indicates the used message storage space in GB.
        """
        return pulumi.get(self, "used_storage_space")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Indicates the name of the user creating the RabbitMQ instance.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Indicates the ID of a VPC.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="vpcName")
    def vpc_name(self) -> _builtins.str:
        """
        Indicates the name of a VPC.
        """
        return pulumi.get(self, "vpc_name")


@pulumi.output_type
class GetRabbitmqPluginsPluginResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool,
                 name: _builtins.str,
                 running: _builtins.bool,
                 version: _builtins.str):
        """
        :param _builtins.bool enable: Specifies whether the plugin is enabled. Defaults to **false**.
        :param _builtins.str name: Specifies the name of the plugin.
        :param _builtins.bool running: Specifies whether the plugin is running. Defaults to **false**.
        :param _builtins.str version: Specifies the version of the plugin.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "running", running)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Specifies whether the plugin is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the plugin.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def running(self) -> _builtins.bool:
        """
        Specifies whether the plugin is running. Defaults to **false**.
        """
        return pulumi.get(self, "running")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Specifies the version of the plugin.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetRabbitmqQueuesQueueResult(dict):
    def __init__(__self__, *,
                 auto_delete: _builtins.bool,
                 consumers: _builtins.int,
                 dead_letter_exchange: _builtins.str,
                 dead_letter_routing_key: _builtins.str,
                 durable: _builtins.bool,
                 lazy_mode: _builtins.str,
                 message_ttl: _builtins.int,
                 messages: _builtins.int,
                 name: _builtins.str,
                 policy: _builtins.str):
        """
        :param _builtins.bool auto_delete: Indicates whether the auto delete is enabled.
        :param _builtins.int consumers: Indicates the connected consumers.
        :param _builtins.str dead_letter_exchange: Indicates the name of the dead letter exchange.
        :param _builtins.str dead_letter_routing_key: Indicates the routing key of the dead letter exchange.
        :param _builtins.bool durable: Indicates whether the durable is enabled.
        :param _builtins.str lazy_mode: Indicates the lazy mode.
        :param _builtins.int message_ttl: Indicates how long a message in this queue can be retained.
        :param _builtins.int messages: Indicates the accumulated messages.
        :param _builtins.str name: Indicates the queue name.
        :param _builtins.str policy: Indicates the policy.
        """
        pulumi.set(__self__, "auto_delete", auto_delete)
        pulumi.set(__self__, "consumers", consumers)
        pulumi.set(__self__, "dead_letter_exchange", dead_letter_exchange)
        pulumi.set(__self__, "dead_letter_routing_key", dead_letter_routing_key)
        pulumi.set(__self__, "durable", durable)
        pulumi.set(__self__, "lazy_mode", lazy_mode)
        pulumi.set(__self__, "message_ttl", message_ttl)
        pulumi.set(__self__, "messages", messages)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter(name="autoDelete")
    def auto_delete(self) -> _builtins.bool:
        """
        Indicates whether the auto delete is enabled.
        """
        return pulumi.get(self, "auto_delete")

    @_builtins.property
    @pulumi.getter
    def consumers(self) -> _builtins.int:
        """
        Indicates the connected consumers.
        """
        return pulumi.get(self, "consumers")

    @_builtins.property
    @pulumi.getter(name="deadLetterExchange")
    def dead_letter_exchange(self) -> _builtins.str:
        """
        Indicates the name of the dead letter exchange.
        """
        return pulumi.get(self, "dead_letter_exchange")

    @_builtins.property
    @pulumi.getter(name="deadLetterRoutingKey")
    def dead_letter_routing_key(self) -> _builtins.str:
        """
        Indicates the routing key of the dead letter exchange.
        """
        return pulumi.get(self, "dead_letter_routing_key")

    @_builtins.property
    @pulumi.getter
    def durable(self) -> _builtins.bool:
        """
        Indicates whether the durable is enabled.
        """
        return pulumi.get(self, "durable")

    @_builtins.property
    @pulumi.getter(name="lazyMode")
    def lazy_mode(self) -> _builtins.str:
        """
        Indicates the lazy mode.
        """
        return pulumi.get(self, "lazy_mode")

    @_builtins.property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> _builtins.int:
        """
        Indicates how long a message in this queue can be retained.
        """
        return pulumi.get(self, "message_ttl")

    @_builtins.property
    @pulumi.getter
    def messages(self) -> _builtins.int:
        """
        Indicates the accumulated messages.
        """
        return pulumi.get(self, "messages")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the queue name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        """
        Indicates the policy.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class GetRabbitmqUsersUserResult(dict):
    def __init__(__self__, *,
                 access_key: _builtins.str,
                 vhosts: Sequence['outputs.GetRabbitmqUsersUserVhostResult']):
        """
        :param _builtins.str access_key: Indicates the user name.
        :param Sequence['GetRabbitmqUsersUserVhostArgs'] vhosts: Indicates the virtual hosts to be granted permissions for.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "vhosts", vhosts)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Indicates the user name.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def vhosts(self) -> Sequence['outputs.GetRabbitmqUsersUserVhostResult']:
        """
        Indicates the virtual hosts to be granted permissions for.
        """
        return pulumi.get(self, "vhosts")


@pulumi.output_type
class GetRabbitmqUsersUserVhostResult(dict):
    def __init__(__self__, *,
                 conf: _builtins.str,
                 read: _builtins.str,
                 vhost: _builtins.str,
                 write: _builtins.str):
        """
        :param _builtins.str conf: Indicates the granting resource permissions using regular expressions.
        :param _builtins.str read: Indicates the granting resource read permissions using regular expressions.
        :param _builtins.str vhost: Indicates the name of the virtual host to be granted permissions for.
        :param _builtins.str write: Indicates the granting resource write permissions using regular expressions.
        """
        pulumi.set(__self__, "conf", conf)
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "vhost", vhost)
        pulumi.set(__self__, "write", write)

    @_builtins.property
    @pulumi.getter
    def conf(self) -> _builtins.str:
        """
        Indicates the granting resource permissions using regular expressions.
        """
        return pulumi.get(self, "conf")

    @_builtins.property
    @pulumi.getter
    def read(self) -> _builtins.str:
        """
        Indicates the granting resource read permissions using regular expressions.
        """
        return pulumi.get(self, "read")

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> _builtins.str:
        """
        Indicates the name of the virtual host to be granted permissions for.
        """
        return pulumi.get(self, "vhost")

    @_builtins.property
    @pulumi.getter
    def write(self) -> _builtins.str:
        """
        Indicates the granting resource write permissions using regular expressions.
        """
        return pulumi.get(self, "write")


@pulumi.output_type
class GetRabbitmqVhostsVhostResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 tracing: _builtins.bool):
        """
        :param _builtins.str name: Indicates the vhost name.
        :param _builtins.bool tracing: Indicates whether the message tracing of the vhost is enabled.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tracing", tracing)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the vhost name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tracing(self) -> _builtins.bool:
        """
        Indicates whether the message tracing of the vhost is enabled.
        """
        return pulumi.get(self, "tracing")


@pulumi.output_type
class GetRocketmqAvailabilityZonesAvailabilityZoneResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 default_az: _builtins.bool,
                 id: _builtins.str,
                 ipv6_enable: _builtins.bool,
                 name: _builtins.str,
                 port: _builtins.str,
                 remain_time: _builtins.float,
                 resource_availability: _builtins.str,
                 sold_out: _builtins.bool):
        """
        :param _builtins.str code: The code of the availability zone. e.g. `cn-north-4a`.
        :param _builtins.bool default_az: Whether the availability zone is the default availability zone.
        :param _builtins.str id: The ID of the availability zone.
        :param _builtins.bool ipv6_enable: Whether the availability zone supports IPv6.
        :param _builtins.str name: The name of the availability zone. e.g. `AZ1`.
        :param _builtins.str port: The port of the availability zone.
        :param _builtins.float remain_time: The remaining time of the availability zone.
        :param _builtins.str resource_availability: The resource availability of the availability zone.
        :param _builtins.bool sold_out: Whether the availability zone is sold out.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "default_az", default_az)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "remain_time", remain_time)
        pulumi.set(__self__, "resource_availability", resource_availability)
        pulumi.set(__self__, "sold_out", sold_out)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        The code of the availability zone. e.g. `cn-north-4a`.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="defaultAz")
    def default_az(self) -> _builtins.bool:
        """
        Whether the availability zone is the default availability zone.
        """
        return pulumi.get(self, "default_az")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the availability zone.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> _builtins.bool:
        """
        Whether the availability zone supports IPv6.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the availability zone. e.g. `AZ1`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        The port of the availability zone.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="remainTime")
    def remain_time(self) -> _builtins.float:
        """
        The remaining time of the availability zone.
        """
        return pulumi.get(self, "remain_time")

    @_builtins.property
    @pulumi.getter(name="resourceAvailability")
    def resource_availability(self) -> _builtins.str:
        """
        The resource availability of the availability zone.
        """
        return pulumi.get(self, "resource_availability")

    @_builtins.property
    @pulumi.getter(name="soldOut")
    def sold_out(self) -> _builtins.bool:
        """
        Whether the availability zone is sold out.
        """
        return pulumi.get(self, "sold_out")


@pulumi.output_type
class GetRocketmqBackgroundTasksTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 params: _builtins.str,
                 status: _builtins.str,
                 updated_at: _builtins.str,
                 user_id: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the background task, in UTC format.
        :param _builtins.str id: The ID of the background task.
        :param _builtins.str name: The name of the background task.
        :param _builtins.str params: The parameters of the background task.
        :param _builtins.str status: The status of the background task.
        :param _builtins.str updated_at: The latest update time of the background task, in UTC format.
        :param _builtins.str user_id: The ID of the user who executed the background task.
        :param _builtins.str user_name: The username of the user who executed the background task.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the background task, in UTC format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the background task.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the background task.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def params(self) -> _builtins.str:
        """
        The parameters of the background task.
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the background task.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest update time of the background task, in UTC format.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        The ID of the user who executed the background task.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        The username of the user who executed the background task.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetRocketmqConsumerGroupAccessUsersPolicyResult(dict):
    def __init__(__self__, *,
                 access_key: _builtins.str,
                 admin: _builtins.bool,
                 perm: _builtins.str,
                 white_remote_address: _builtins.str):
        """
        :param _builtins.str access_key: Indicates the user name.
        :param _builtins.bool admin: Indicates whether the user is an administrator.
        :param _builtins.str perm: Indicates the permissions.
        :param _builtins.str white_remote_address: Indicates the IP address whitelist.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "admin", admin)
        pulumi.set(__self__, "perm", perm)
        pulumi.set(__self__, "white_remote_address", white_remote_address)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Indicates the user name.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def admin(self) -> _builtins.bool:
        """
        Indicates whether the user is an administrator.
        """
        return pulumi.get(self, "admin")

    @_builtins.property
    @pulumi.getter
    def perm(self) -> _builtins.str:
        """
        Indicates the permissions.
        """
        return pulumi.get(self, "perm")

    @_builtins.property
    @pulumi.getter(name="whiteRemoteAddress")
    def white_remote_address(self) -> _builtins.str:
        """
        Indicates the IP address whitelist.
        """
        return pulumi.get(self, "white_remote_address")


@pulumi.output_type
class GetRocketmqConsumerGroupsGroupResult(dict):
    def __init__(__self__, *,
                 broadcast: _builtins.bool,
                 brokers: Sequence[_builtins.str],
                 description: _builtins.str,
                 enabled: _builtins.bool,
                 name: _builtins.str,
                 retry_max_times: _builtins.int):
        """
        :param _builtins.bool broadcast: Specifies whether to broadcast the consumer group. Defaults to **false**.
        :param Sequence[_builtins.str] brokers: Indicates the list of associated brokers of the consumer group.
        :param _builtins.str description: Indicates the description of the consumer group.
        :param _builtins.bool enabled: Specifies the consumer group is enabled or not. Defaults to **true**.
        :param _builtins.str name: Specifies the name of the consumer group.
        :param _builtins.int retry_max_times: Specifies the maximum number of retry times.
        """
        pulumi.set(__self__, "broadcast", broadcast)
        pulumi.set(__self__, "brokers", brokers)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "retry_max_times", retry_max_times)

    @_builtins.property
    @pulumi.getter
    def broadcast(self) -> _builtins.bool:
        """
        Specifies whether to broadcast the consumer group. Defaults to **false**.
        """
        return pulumi.get(self, "broadcast")

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of associated brokers of the consumer group.
        """
        return pulumi.get(self, "brokers")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the consumer group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies the consumer group is enabled or not. Defaults to **true**.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the consumer group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="retryMaxTimes")
    def retry_max_times(self) -> _builtins.int:
        """
        Specifies the maximum number of retry times.
        """
        return pulumi.get(self, "retry_max_times")


@pulumi.output_type
class GetRocketmqConsumersClientResult(dict):
    def __init__(__self__, *,
                 client_address: _builtins.str,
                 client_id: _builtins.str,
                 language: _builtins.str,
                 subscriptions: Sequence['outputs.GetRocketmqConsumersClientSubscriptionResult'],
                 version: _builtins.str):
        """
        :param _builtins.str client_address: Indicates the client address.
        :param _builtins.str client_id: Indicates the client ID.
        :param _builtins.str language: Indicates the client language.
        :param Sequence['GetRocketmqConsumersClientSubscriptionArgs'] subscriptions: Indicates the subscription list.
        :param _builtins.str version: Indicates the client version.
        """
        pulumi.set(__self__, "client_address", client_address)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "subscriptions", subscriptions)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="clientAddress")
    def client_address(self) -> _builtins.str:
        """
        Indicates the client address.
        """
        return pulumi.get(self, "client_address")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Indicates the client ID.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def language(self) -> _builtins.str:
        """
        Indicates the client language.
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Sequence['outputs.GetRocketmqConsumersClientSubscriptionResult']:
        """
        Indicates the subscription list.
        """
        return pulumi.get(self, "subscriptions")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Indicates the client version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetRocketmqConsumersClientSubscriptionResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str,
                 topic: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str expression: Indicates the subscription tag.
        :param _builtins.str topic: Indicates the name of the subscribed topic.
        :param _builtins.str type: Indicates the subscription type. The value can be **TAG** and **SQL92**.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "topic", topic)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Indicates the subscription tag.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Indicates the name of the subscribed topic.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the subscription type. The value can be **TAG** and **SQL92**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRocketmqDeadLetterMessagesMessageResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 body_crc: _builtins.int,
                 born_host: _builtins.str,
                 born_time: _builtins.str,
                 instance_id: _builtins.str,
                 msg_id: _builtins.str,
                 property_lists: Sequence['outputs.GetRocketmqDeadLetterMessagesMessagePropertyListResult'],
                 queue_id: _builtins.int,
                 queue_offset: _builtins.int,
                 reconsume_times: _builtins.int,
                 store_host: _builtins.str,
                 store_size: _builtins.int,
                 store_time: _builtins.str,
                 topic: _builtins.str):
        """
        :param _builtins.str body: The body of the message.
        :param _builtins.int body_crc: The checksum of the message body.
        :param _builtins.str born_host: The IP address of the host that generated the message.
        :param _builtins.str born_time: The time when the dead letter message was generated, in RFC3339 format.
        :param _builtins.str instance_id: Specifies the ID of the RocketMQ instance.
        :param _builtins.str msg_id: The ID of the dead letter message.
        :param Sequence['GetRocketmqDeadLetterMessagesMessagePropertyListArgs'] property_lists: The list of message properties.  
               The property_list structure is documented below.
        :param _builtins.int queue_id: The ID of the queue.
        :param _builtins.int queue_offset: The offset in the queue.
        :param _builtins.int reconsume_times: The number of times the message has been retried.
        :param _builtins.str store_host: The IP address of the host that stored the message.
        :param _builtins.int store_size: The storage size of the message.
        :param _builtins.str store_time: The time when the dead letter message was stored, in RFC3339 format.
        :param _builtins.str topic: Specifies the name of the topic to which the dead letter messages belong.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "body_crc", body_crc)
        pulumi.set(__self__, "born_host", born_host)
        pulumi.set(__self__, "born_time", born_time)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "msg_id", msg_id)
        pulumi.set(__self__, "property_lists", property_lists)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "queue_offset", queue_offset)
        pulumi.set(__self__, "reconsume_times", reconsume_times)
        pulumi.set(__self__, "store_host", store_host)
        pulumi.set(__self__, "store_size", store_size)
        pulumi.set(__self__, "store_time", store_time)
        pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The body of the message.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter(name="bodyCrc")
    def body_crc(self) -> _builtins.int:
        """
        The checksum of the message body.
        """
        return pulumi.get(self, "body_crc")

    @_builtins.property
    @pulumi.getter(name="bornHost")
    def born_host(self) -> _builtins.str:
        """
        The IP address of the host that generated the message.
        """
        return pulumi.get(self, "born_host")

    @_builtins.property
    @pulumi.getter(name="bornTime")
    def born_time(self) -> _builtins.str:
        """
        The time when the dead letter message was generated, in RFC3339 format.
        """
        return pulumi.get(self, "born_time")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Specifies the ID of the RocketMQ instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="msgId")
    def msg_id(self) -> _builtins.str:
        """
        The ID of the dead letter message.
        """
        return pulumi.get(self, "msg_id")

    @_builtins.property
    @pulumi.getter(name="propertyLists")
    def property_lists(self) -> Sequence['outputs.GetRocketmqDeadLetterMessagesMessagePropertyListResult']:
        """
        The list of message properties.  
        The property_list structure is documented below.
        """
        return pulumi.get(self, "property_lists")

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> _builtins.int:
        """
        The ID of the queue.
        """
        return pulumi.get(self, "queue_id")

    @_builtins.property
    @pulumi.getter(name="queueOffset")
    def queue_offset(self) -> _builtins.int:
        """
        The offset in the queue.
        """
        return pulumi.get(self, "queue_offset")

    @_builtins.property
    @pulumi.getter(name="reconsumeTimes")
    def reconsume_times(self) -> _builtins.int:
        """
        The number of times the message has been retried.
        """
        return pulumi.get(self, "reconsume_times")

    @_builtins.property
    @pulumi.getter(name="storeHost")
    def store_host(self) -> _builtins.str:
        """
        The IP address of the host that stored the message.
        """
        return pulumi.get(self, "store_host")

    @_builtins.property
    @pulumi.getter(name="storeSize")
    def store_size(self) -> _builtins.int:
        """
        The storage size of the message.
        """
        return pulumi.get(self, "store_size")

    @_builtins.property
    @pulumi.getter(name="storeTime")
    def store_time(self) -> _builtins.str:
        """
        The time when the dead letter message was stored, in RFC3339 format.
        """
        return pulumi.get(self, "store_time")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Specifies the name of the topic to which the dead letter messages belong.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class GetRocketmqDeadLetterMessagesMessagePropertyListResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the property.
        :param _builtins.str value: The value of the property.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the property.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the property.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRocketmqExtendFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch_types: Sequence[_builtins.str],
                 available_zones: Sequence[_builtins.str],
                 billing_code: _builtins.str,
                 charging_modes: Sequence[_builtins.str],
                 id: _builtins.str,
                 ios: Sequence['outputs.GetRocketmqExtendFlavorsFlavorIoResult'],
                 properties: Sequence['outputs.GetRocketmqExtendFlavorsFlavorPropertyResult'],
                 support_features: Sequence['outputs.GetRocketmqExtendFlavorsFlavorSupportFeatureResult'],
                 type: _builtins.str,
                 unavailable_zones: Sequence[_builtins.str],
                 vm_specification: _builtins.str):
        """
        :param Sequence[_builtins.str] arch_types: Indicates the list of supported CPU architectures.
        :param Sequence[_builtins.str] available_zones: Indicates the list of availability zones with available resources.
        :param _builtins.str billing_code: Indicates the billing code.
        :param Sequence[_builtins.str] charging_modes: Indicates the list of supported billing modes.
        :param _builtins.str id: Indicates the flavor ID.
        :param Sequence['GetRocketmqExtendFlavorsFlavorIoArgs'] ios: Indicates the list of supported disk IO types.
        :param Sequence['GetRocketmqExtendFlavorsFlavorPropertyArgs'] properties: Indicates the key-value pair of a feature.
        :param Sequence['GetRocketmqExtendFlavorsFlavorSupportFeatureArgs'] support_features: Indicates the supported features.
        :param _builtins.str type: Specifies the flavor type.
        :param Sequence[_builtins.str] unavailable_zones: Indicates the list of unavailability zones with available resources.
        :param _builtins.str vm_specification: Indicates the underlying VM specification.
        """
        pulumi.set(__self__, "arch_types", arch_types)
        pulumi.set(__self__, "available_zones", available_zones)
        pulumi.set(__self__, "billing_code", billing_code)
        pulumi.set(__self__, "charging_modes", charging_modes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ios", ios)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "support_features", support_features)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailable_zones", unavailable_zones)
        pulumi.set(__self__, "vm_specification", vm_specification)

    @_builtins.property
    @pulumi.getter(name="archTypes")
    def arch_types(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of supported CPU architectures.
        """
        return pulumi.get(self, "arch_types")

    @_builtins.property
    @pulumi.getter(name="availableZones")
    def available_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of availability zones with available resources.
        """
        return pulumi.get(self, "available_zones")

    @_builtins.property
    @pulumi.getter(name="billingCode")
    def billing_code(self) -> _builtins.str:
        """
        Indicates the billing code.
        """
        return pulumi.get(self, "billing_code")

    @_builtins.property
    @pulumi.getter(name="chargingModes")
    def charging_modes(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of supported billing modes.
        """
        return pulumi.get(self, "charging_modes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the flavor ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Sequence['outputs.GetRocketmqExtendFlavorsFlavorIoResult']:
        """
        Indicates the list of supported disk IO types.
        """
        return pulumi.get(self, "ios")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetRocketmqExtendFlavorsFlavorPropertyResult']:
        """
        Indicates the key-value pair of a feature.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="supportFeatures")
    def support_features(self) -> Sequence['outputs.GetRocketmqExtendFlavorsFlavorSupportFeatureResult']:
        """
        Indicates the supported features.
        """
        return pulumi.get(self, "support_features")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the flavor type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailableZones")
    def unavailable_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of unavailability zones with available resources.
        """
        return pulumi.get(self, "unavailable_zones")

    @_builtins.property
    @pulumi.getter(name="vmSpecification")
    def vm_specification(self) -> _builtins.str:
        """
        Indicates the underlying VM specification.
        """
        return pulumi.get(self, "vm_specification")


@pulumi.output_type
class GetRocketmqExtendFlavorsFlavorIoResult(dict):
    def __init__(__self__, *,
                 available_zones: Sequence[_builtins.str],
                 storage_spec_code: _builtins.str,
                 type: _builtins.str,
                 unavailable_zones: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] available_zones: Indicates the list of availability zones with available resources.
        :param _builtins.str storage_spec_code: Specifies the disk IO encoding, e.g. **dms.physical.storage.high.v2**.
        :param _builtins.str type: Specifies the flavor type.
        :param Sequence[_builtins.str] unavailable_zones: Indicates the list of unavailability zones with available resources.
        """
        pulumi.set(__self__, "available_zones", available_zones)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailable_zones", unavailable_zones)

    @_builtins.property
    @pulumi.getter(name="availableZones")
    def available_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of availability zones with available resources.
        """
        return pulumi.get(self, "available_zones")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Specifies the disk IO encoding, e.g. **dms.physical.storage.high.v2**.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the flavor type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailableZones")
    def unavailable_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of unavailability zones with available resources.
        """
        return pulumi.get(self, "unavailable_zones")


@pulumi.output_type
class GetRocketmqExtendFlavorsFlavorPropertyResult(dict):
    def __init__(__self__, *,
                 engine_versions: _builtins.str,
                 flavor_alias: _builtins.str,
                 max_broker: _builtins.str,
                 max_consumer_per_broker: _builtins.str,
                 max_storage_per_node: _builtins.str,
                 max_topic_per_broker: _builtins.str,
                 min_broker: _builtins.str,
                 min_storage_per_node: _builtins.str):
        """
        :param _builtins.str engine_versions: Indicates the version of the message engine.
        :param _builtins.str flavor_alias: Indicates the alias of **flavor_id**.
        :param _builtins.str max_broker: Indicates the maximum number of brokers.
        :param _builtins.str max_consumer_per_broker: Indicates the maximum number of consumers of each broker.
        :param _builtins.str max_storage_per_node: Indicates the maximum storage space of each broker. Unit: GB.
        :param _builtins.str max_topic_per_broker: Indicates the maximum number of topics that can be created on each broker.
        :param _builtins.str min_broker: Indicates the minimum number of brokers.
        :param _builtins.str min_storage_per_node: Indicates the minimum storage space of each broker. Unit: GB.
        """
        pulumi.set(__self__, "engine_versions", engine_versions)
        pulumi.set(__self__, "flavor_alias", flavor_alias)
        pulumi.set(__self__, "max_broker", max_broker)
        pulumi.set(__self__, "max_consumer_per_broker", max_consumer_per_broker)
        pulumi.set(__self__, "max_storage_per_node", max_storage_per_node)
        pulumi.set(__self__, "max_topic_per_broker", max_topic_per_broker)
        pulumi.set(__self__, "min_broker", min_broker)
        pulumi.set(__self__, "min_storage_per_node", min_storage_per_node)

    @_builtins.property
    @pulumi.getter(name="engineVersions")
    def engine_versions(self) -> _builtins.str:
        """
        Indicates the version of the message engine.
        """
        return pulumi.get(self, "engine_versions")

    @_builtins.property
    @pulumi.getter(name="flavorAlias")
    def flavor_alias(self) -> _builtins.str:
        """
        Indicates the alias of **flavor_id**.
        """
        return pulumi.get(self, "flavor_alias")

    @_builtins.property
    @pulumi.getter(name="maxBroker")
    def max_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of brokers.
        """
        return pulumi.get(self, "max_broker")

    @_builtins.property
    @pulumi.getter(name="maxConsumerPerBroker")
    def max_consumer_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of consumers of each broker.
        """
        return pulumi.get(self, "max_consumer_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxStoragePerNode")
    def max_storage_per_node(self) -> _builtins.str:
        """
        Indicates the maximum storage space of each broker. Unit: GB.
        """
        return pulumi.get(self, "max_storage_per_node")

    @_builtins.property
    @pulumi.getter(name="maxTopicPerBroker")
    def max_topic_per_broker(self) -> _builtins.str:
        """
        Indicates the maximum number of topics that can be created on each broker.
        """
        return pulumi.get(self, "max_topic_per_broker")

    @_builtins.property
    @pulumi.getter(name="minBroker")
    def min_broker(self) -> _builtins.str:
        """
        Indicates the minimum number of brokers.
        """
        return pulumi.get(self, "min_broker")

    @_builtins.property
    @pulumi.getter(name="minStoragePerNode")
    def min_storage_per_node(self) -> _builtins.str:
        """
        Indicates the minimum storage space of each broker. Unit: GB.
        """
        return pulumi.get(self, "min_storage_per_node")


@pulumi.output_type
class GetRocketmqExtendFlavorsFlavorSupportFeatureResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 properties: Mapping[str, _builtins.str]):
        """
        :param _builtins.str name: Indicates the feature name.
        :param Mapping[str, _builtins.str] properties: Indicates the key-value pair of a feature.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the feature name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        Indicates the key-value pair of a feature.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GetRocketmqFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch_types: Sequence[_builtins.str],
                 charging_modes: Sequence[_builtins.str],
                 id: _builtins.str,
                 ios: Sequence['outputs.GetRocketmqFlavorsFlavorIoResult'],
                 properties: Sequence['outputs.GetRocketmqFlavorsFlavorPropertyResult'],
                 support_features: Sequence['outputs.GetRocketmqFlavorsFlavorSupportFeatureResult'],
                 type: _builtins.str,
                 vm_specification: _builtins.str):
        """
        :param Sequence[_builtins.str] arch_types: Indicates the list of the types of CPU architecture.
        :param Sequence[_builtins.str] charging_modes: Indicates the list of the billing modes.
        :param _builtins.str id: Indicates the ID of the flavor.
        :param Sequence['GetRocketmqFlavorsFlavorIoArgs'] ios: Indicates the list of disk IO types.
               The ios structure is documented below.
        :param Sequence['GetRocketmqFlavorsFlavorPropertyArgs'] properties: Indicates the list of the function property details.
               The properties structure is documented below.
        :param Sequence['GetRocketmqFlavorsFlavorSupportFeatureArgs'] support_features: Indicates the list of features supported by the current specification.
               The support_features structure is documented below.
        :param _builtins.str type: Specifies the type of the flavor. Value options: **single** and **cluster**.
        :param _builtins.str vm_specification: Indicates the underlying VM specification, e.g. **c6.large.2**
        """
        pulumi.set(__self__, "arch_types", arch_types)
        pulumi.set(__self__, "charging_modes", charging_modes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ios", ios)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "support_features", support_features)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_specification", vm_specification)

    @_builtins.property
    @pulumi.getter(name="archTypes")
    def arch_types(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of the types of CPU architecture.
        """
        return pulumi.get(self, "arch_types")

    @_builtins.property
    @pulumi.getter(name="chargingModes")
    def charging_modes(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of the billing modes.
        """
        return pulumi.get(self, "charging_modes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of the flavor.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ios(self) -> Sequence['outputs.GetRocketmqFlavorsFlavorIoResult']:
        """
        Indicates the list of disk IO types.
        The ios structure is documented below.
        """
        return pulumi.get(self, "ios")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetRocketmqFlavorsFlavorPropertyResult']:
        """
        Indicates the list of the function property details.
        The properties structure is documented below.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="supportFeatures")
    def support_features(self) -> Sequence['outputs.GetRocketmqFlavorsFlavorSupportFeatureResult']:
        """
        Indicates the list of features supported by the current specification.
        The support_features structure is documented below.
        """
        return pulumi.get(self, "support_features")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the flavor. Value options: **single** and **cluster**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vmSpecification")
    def vm_specification(self) -> _builtins.str:
        """
        Indicates the underlying VM specification, e.g. **c6.large.2**
        """
        return pulumi.get(self, "vm_specification")


@pulumi.output_type
class GetRocketmqFlavorsFlavorIoResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[_builtins.str],
                 storage_spec_code: _builtins.str,
                 type: _builtins.str,
                 unavailability_zones: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] availability_zones: Specifies the list of availability zone names.
        :param _builtins.str storage_spec_code: Specifies the disk IO encoding.
               Value options:
               + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
               + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
        :param _builtins.str type: Specifies the type of the flavor. Value options: **single** and **cluster**.
        :param Sequence[_builtins.str] unavailability_zones: Indicates the list of unavailability zone names.
        """
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unavailability_zones", unavailability_zones)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of availability zone names.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Specifies the disk IO encoding.
        Value options:
        + **dms.physical.storage.high.v2**: Type of the disk that uses high I/O.
        + **dms.physical.storage.ultra.v2**: Type of the disk that uses ultra-high I/O.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the flavor. Value options: **single** and **cluster**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="unavailabilityZones")
    def unavailability_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of unavailability zone names.
        """
        return pulumi.get(self, "unavailability_zones")


@pulumi.output_type
class GetRocketmqFlavorsFlavorPropertyResult(dict):
    def __init__(__self__, *,
                 flavor_alias: _builtins.str,
                 max_bandwidth_per_broker: _builtins.int,
                 max_broker: _builtins.int,
                 max_consumer_per_broker: _builtins.int,
                 max_partition_per_broker: _builtins.int,
                 max_storage_per_node: _builtins.int,
                 max_tps_per_broker: _builtins.int,
                 min_broker: _builtins.int,
                 min_storage_per_node: _builtins.int):
        """
        :param _builtins.str flavor_alias: Indicates the alias of the flavor.
        :param _builtins.int max_bandwidth_per_broker: Indicates the maximum bandwidth per broker.
        :param _builtins.int max_broker: Indicates the maximum number of brokers.
        :param _builtins.int max_consumer_per_broker: Indicates the maximum number of consumers per broker.
        :param _builtins.int max_partition_per_broker: Indicates the maximum number of partitions per broker.
        :param _builtins.int max_storage_per_node: Indicates the maximum storage per node. The unit is GB.
        :param _builtins.int max_tps_per_broker: Indicates the maximum TPS per broker.
        :param _builtins.int min_broker: Indicates the minimum number of brokers.
        :param _builtins.int min_storage_per_node: Indicates the minimum storage per node. The unit is GB.
        """
        pulumi.set(__self__, "flavor_alias", flavor_alias)
        pulumi.set(__self__, "max_bandwidth_per_broker", max_bandwidth_per_broker)
        pulumi.set(__self__, "max_broker", max_broker)
        pulumi.set(__self__, "max_consumer_per_broker", max_consumer_per_broker)
        pulumi.set(__self__, "max_partition_per_broker", max_partition_per_broker)
        pulumi.set(__self__, "max_storage_per_node", max_storage_per_node)
        pulumi.set(__self__, "max_tps_per_broker", max_tps_per_broker)
        pulumi.set(__self__, "min_broker", min_broker)
        pulumi.set(__self__, "min_storage_per_node", min_storage_per_node)

    @_builtins.property
    @pulumi.getter(name="flavorAlias")
    def flavor_alias(self) -> _builtins.str:
        """
        Indicates the alias of the flavor.
        """
        return pulumi.get(self, "flavor_alias")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthPerBroker")
    def max_bandwidth_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum bandwidth per broker.
        """
        return pulumi.get(self, "max_bandwidth_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxBroker")
    def max_broker(self) -> _builtins.int:
        """
        Indicates the maximum number of brokers.
        """
        return pulumi.get(self, "max_broker")

    @_builtins.property
    @pulumi.getter(name="maxConsumerPerBroker")
    def max_consumer_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum number of consumers per broker.
        """
        return pulumi.get(self, "max_consumer_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxPartitionPerBroker")
    def max_partition_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum number of partitions per broker.
        """
        return pulumi.get(self, "max_partition_per_broker")

    @_builtins.property
    @pulumi.getter(name="maxStoragePerNode")
    def max_storage_per_node(self) -> _builtins.int:
        """
        Indicates the maximum storage per node. The unit is GB.
        """
        return pulumi.get(self, "max_storage_per_node")

    @_builtins.property
    @pulumi.getter(name="maxTpsPerBroker")
    def max_tps_per_broker(self) -> _builtins.int:
        """
        Indicates the maximum TPS per broker.
        """
        return pulumi.get(self, "max_tps_per_broker")

    @_builtins.property
    @pulumi.getter(name="minBroker")
    def min_broker(self) -> _builtins.int:
        """
        Indicates the minimum number of brokers.
        """
        return pulumi.get(self, "min_broker")

    @_builtins.property
    @pulumi.getter(name="minStoragePerNode")
    def min_storage_per_node(self) -> _builtins.int:
        """
        Indicates the minimum storage per node. The unit is GB.
        """
        return pulumi.get(self, "min_storage_per_node")


@pulumi.output_type
class GetRocketmqFlavorsFlavorSupportFeatureResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 properties: Sequence['outputs.GetRocketmqFlavorsFlavorSupportFeaturePropertyResult']):
        """
        :param _builtins.str name: Indicates the function name, e.g. **connector_obs**.
        :param Sequence['GetRocketmqFlavorsFlavorSupportFeaturePropertyArgs'] properties: Indicates the list of the function property details.
               The properties structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the function name, e.g. **connector_obs**.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetRocketmqFlavorsFlavorSupportFeaturePropertyResult']:
        """
        Indicates the list of the function property details.
        The properties structure is documented below.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GetRocketmqFlavorsFlavorSupportFeaturePropertyResult(dict):
    def __init__(__self__, *,
                 max_node: _builtins.int,
                 max_task: _builtins.int,
                 min_node: _builtins.int,
                 min_task: _builtins.int):
        """
        :param _builtins.int max_node: Indicates the maximum number of nodes for the dump function.
        :param _builtins.int max_task: Indicates the maximum number of tasks for the dump function.
        :param _builtins.int min_node: Indicates the minimum number of nodes for the dump function.
        :param _builtins.int min_task: Indicates the minimum number of tasks for the dump function.
        """
        pulumi.set(__self__, "max_node", max_node)
        pulumi.set(__self__, "max_task", max_task)
        pulumi.set(__self__, "min_node", min_node)
        pulumi.set(__self__, "min_task", min_task)

    @_builtins.property
    @pulumi.getter(name="maxNode")
    def max_node(self) -> _builtins.int:
        """
        Indicates the maximum number of nodes for the dump function.
        """
        return pulumi.get(self, "max_node")

    @_builtins.property
    @pulumi.getter(name="maxTask")
    def max_task(self) -> _builtins.int:
        """
        Indicates the maximum number of tasks for the dump function.
        """
        return pulumi.get(self, "max_task")

    @_builtins.property
    @pulumi.getter(name="minNode")
    def min_node(self) -> _builtins.int:
        """
        Indicates the minimum number of nodes for the dump function.
        """
        return pulumi.get(self, "min_node")

    @_builtins.property
    @pulumi.getter(name="minTask")
    def min_task(self) -> _builtins.int:
        """
        Indicates the minimum number of tasks for the dump function.
        """
        return pulumi.get(self, "min_task")


@pulumi.output_type
class GetRocketmqInstanceNodesNodeResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 broker_id: _builtins.int,
                 broker_name: _builtins.str,
                 id: _builtins.str,
                 public_address: _builtins.str):
        """
        :param _builtins.str address: The private address.
        :param _builtins.int broker_id: The broker ID.
        :param _builtins.str broker_name: The broker name.
        :param _builtins.str id: The node ID.
        :param _builtins.str public_address: The public address.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "broker_id", broker_id)
        pulumi.set(__self__, "broker_name", broker_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "public_address", public_address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The private address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="brokerId")
    def broker_id(self) -> _builtins.int:
        """
        The broker ID.
        """
        return pulumi.get(self, "broker_id")

    @_builtins.property
    @pulumi.getter(name="brokerName")
    def broker_name(self) -> _builtins.str:
        """
        The broker name.
        """
        return pulumi.get(self, "broker_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The node ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="publicAddress")
    def public_address(self) -> _builtins.str:
        """
        The public address.
        """
        return pulumi.get(self, "public_address")


@pulumi.output_type
class GetRocketmqInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 availability_zones: Sequence[_builtins.str],
                 broker_address: _builtins.str,
                 broker_num: _builtins.int,
                 cross_vpc_accesses: Sequence['outputs.GetRocketmqInstancesInstanceCrossVpcAccessResult'],
                 description: _builtins.str,
                 enable_acl: _builtins.bool,
                 enable_publicip: _builtins.bool,
                 engine_version: _builtins.str,
                 flavor_id: _builtins.str,
                 id: _builtins.str,
                 ipv6_enable: _builtins.bool,
                 maintain_begin: _builtins.str,
                 maintain_end: _builtins.str,
                 name: _builtins.str,
                 namesrv_address: _builtins.str,
                 new_spec_billing_enable: _builtins.bool,
                 node_num: _builtins.int,
                 public_broker_address: _builtins.str,
                 public_namesrv_address: _builtins.str,
                 publicip_address: _builtins.str,
                 publicip_id: _builtins.str,
                 resource_spec_code: _builtins.str,
                 security_group_id: _builtins.str,
                 specification: _builtins.str,
                 ssl_enable: _builtins.bool,
                 status: _builtins.str,
                 storage_space: _builtins.int,
                 storage_spec_code: _builtins.str,
                 subnet_id: _builtins.str,
                 type: _builtins.str,
                 used_storage_space: _builtins.int,
                 vpc_id: _builtins.str):
        """
        :param Sequence[_builtins.str] availability_zones: Indicates the list of availability zone names, where
               instance brokers reside and which has available resources.
        :param _builtins.str broker_address: Indicates the service data address.
        :param _builtins.int broker_num: Specifies the broker numbers. Defaults to 1.
        :param Sequence['GetRocketmqInstancesInstanceCrossVpcAccessArgs'] cross_vpc_accesses: Indicates the Cross-VPC access information.
               The CrossVpc structure is documented below.
        :param _builtins.str description: Indicates the description of the DMS RocketMQ instance.
        :param _builtins.bool enable_acl: Indicates whether access control is enabled.
        :param _builtins.bool enable_publicip: Indicates whether to enable public access.
        :param _builtins.str engine_version: Indicates the version of the RocketMQ engine.
        :param _builtins.str flavor_id: Indicates a product ID.
        :param _builtins.str id: Indicates the ID of the DMS RocketMQ instance.
        :param _builtins.bool ipv6_enable: Indicates whether to support IPv6. Defaults to false.
        :param _builtins.str maintain_begin: Indicates the time at which the maintenance window starts. The format is HH:mm:ss.
        :param _builtins.str maintain_end: Indicates the time at which the maintenance window ends. The format is HH:mm:ss.
        :param _builtins.str name: Specifies the name of the DMS RocketMQ instance.
        :param _builtins.str namesrv_address: Indicates the metadata address.
        :param _builtins.bool new_spec_billing_enable: Indicates the whether billing based on new specifications is enabled.
        :param _builtins.int node_num: Indicates the node quantity.
        :param _builtins.str public_broker_address: Indicates the public network service data address.
        :param _builtins.str public_namesrv_address: Indicates the public network metadata address.
        :param _builtins.str publicip_address: Indicates the public IP address.
        :param _builtins.str publicip_id: Indicates the ID of the EIP bound to the instance.
               Use commas (,) to separate multiple EIP IDs.
               This parameter is mandatory if public access is enabled (that is, enable_publicip is set to true).
        :param _builtins.str resource_spec_code: Indicates the resource specifications.
        :param _builtins.str security_group_id: Indicates the ID of a security group.
        :param _builtins.str specification: Indicates the instance specification. For a cluster DMS RocketMQ instance, VM specifications
               and the number of nodes are returned.
        :param _builtins.bool ssl_enable: Indicates whether the RocketMQ SASL_SSL is enabled. Defaults to false.
        :param _builtins.str status: Specifies the status of the DMS RocketMQ instance.
        :param _builtins.int storage_space: Indicates the message storage capacity. Unit: GB.
        :param _builtins.str storage_spec_code: Indicates the storage I/O specification.
        :param _builtins.str subnet_id: Indicates the ID of a subnet.
        :param _builtins.str type: Indicates the DMS RocketMQ instance type.
        :param _builtins.int used_storage_space: Indicates the used message storage space. Unit: GB.
        :param _builtins.str vpc_id: Indicates the ID of a VPC.
        """
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "broker_address", broker_address)
        pulumi.set(__self__, "broker_num", broker_num)
        pulumi.set(__self__, "cross_vpc_accesses", cross_vpc_accesses)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enable_acl", enable_acl)
        pulumi.set(__self__, "enable_publicip", enable_publicip)
        pulumi.set(__self__, "engine_version", engine_version)
        pulumi.set(__self__, "flavor_id", flavor_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        pulumi.set(__self__, "maintain_begin", maintain_begin)
        pulumi.set(__self__, "maintain_end", maintain_end)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namesrv_address", namesrv_address)
        pulumi.set(__self__, "new_spec_billing_enable", new_spec_billing_enable)
        pulumi.set(__self__, "node_num", node_num)
        pulumi.set(__self__, "public_broker_address", public_broker_address)
        pulumi.set(__self__, "public_namesrv_address", public_namesrv_address)
        pulumi.set(__self__, "publicip_address", publicip_address)
        pulumi.set(__self__, "publicip_id", publicip_id)
        pulumi.set(__self__, "resource_spec_code", resource_spec_code)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "specification", specification)
        pulumi.set(__self__, "ssl_enable", ssl_enable)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_space", storage_space)
        pulumi.set(__self__, "storage_spec_code", storage_spec_code)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "used_storage_space", used_storage_space)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        Indicates the list of availability zone names, where
        instance brokers reside and which has available resources.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="brokerAddress")
    def broker_address(self) -> _builtins.str:
        """
        Indicates the service data address.
        """
        return pulumi.get(self, "broker_address")

    @_builtins.property
    @pulumi.getter(name="brokerNum")
    def broker_num(self) -> _builtins.int:
        """
        Specifies the broker numbers. Defaults to 1.
        """
        return pulumi.get(self, "broker_num")

    @_builtins.property
    @pulumi.getter(name="crossVpcAccesses")
    def cross_vpc_accesses(self) -> Sequence['outputs.GetRocketmqInstancesInstanceCrossVpcAccessResult']:
        """
        Indicates the Cross-VPC access information.
        The CrossVpc structure is documented below.
        """
        return pulumi.get(self, "cross_vpc_accesses")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the DMS RocketMQ instance.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enableAcl")
    def enable_acl(self) -> _builtins.bool:
        """
        Indicates whether access control is enabled.
        """
        return pulumi.get(self, "enable_acl")

    @_builtins.property
    @pulumi.getter(name="enablePublicip")
    def enable_publicip(self) -> _builtins.bool:
        """
        Indicates whether to enable public access.
        """
        return pulumi.get(self, "enable_publicip")

    @_builtins.property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> _builtins.str:
        """
        Indicates the version of the RocketMQ engine.
        """
        return pulumi.get(self, "engine_version")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> _builtins.str:
        """
        Indicates a product ID.
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of the DMS RocketMQ instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> _builtins.bool:
        """
        Indicates whether to support IPv6. Defaults to false.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="maintainBegin")
    def maintain_begin(self) -> _builtins.str:
        """
        Indicates the time at which the maintenance window starts. The format is HH:mm:ss.
        """
        return pulumi.get(self, "maintain_begin")

    @_builtins.property
    @pulumi.getter(name="maintainEnd")
    def maintain_end(self) -> _builtins.str:
        """
        Indicates the time at which the maintenance window ends. The format is HH:mm:ss.
        """
        return pulumi.get(self, "maintain_end")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the DMS RocketMQ instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="namesrvAddress")
    def namesrv_address(self) -> _builtins.str:
        """
        Indicates the metadata address.
        """
        return pulumi.get(self, "namesrv_address")

    @_builtins.property
    @pulumi.getter(name="newSpecBillingEnable")
    def new_spec_billing_enable(self) -> _builtins.bool:
        """
        Indicates the whether billing based on new specifications is enabled.
        """
        return pulumi.get(self, "new_spec_billing_enable")

    @_builtins.property
    @pulumi.getter(name="nodeNum")
    def node_num(self) -> _builtins.int:
        """
        Indicates the node quantity.
        """
        return pulumi.get(self, "node_num")

    @_builtins.property
    @pulumi.getter(name="publicBrokerAddress")
    def public_broker_address(self) -> _builtins.str:
        """
        Indicates the public network service data address.
        """
        return pulumi.get(self, "public_broker_address")

    @_builtins.property
    @pulumi.getter(name="publicNamesrvAddress")
    def public_namesrv_address(self) -> _builtins.str:
        """
        Indicates the public network metadata address.
        """
        return pulumi.get(self, "public_namesrv_address")

    @_builtins.property
    @pulumi.getter(name="publicipAddress")
    def publicip_address(self) -> _builtins.str:
        """
        Indicates the public IP address.
        """
        return pulumi.get(self, "publicip_address")

    @_builtins.property
    @pulumi.getter(name="publicipId")
    def publicip_id(self) -> _builtins.str:
        """
        Indicates the ID of the EIP bound to the instance.
        Use commas (,) to separate multiple EIP IDs.
        This parameter is mandatory if public access is enabled (that is, enable_publicip is set to true).
        """
        return pulumi.get(self, "publicip_id")

    @_builtins.property
    @pulumi.getter(name="resourceSpecCode")
    def resource_spec_code(self) -> _builtins.str:
        """
        Indicates the resource specifications.
        """
        return pulumi.get(self, "resource_spec_code")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        Indicates the ID of a security group.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter
    def specification(self) -> _builtins.str:
        """
        Indicates the instance specification. For a cluster DMS RocketMQ instance, VM specifications
        and the number of nodes are returned.
        """
        return pulumi.get(self, "specification")

    @_builtins.property
    @pulumi.getter(name="sslEnable")
    def ssl_enable(self) -> _builtins.bool:
        """
        Indicates whether the RocketMQ SASL_SSL is enabled. Defaults to false.
        """
        return pulumi.get(self, "ssl_enable")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the DMS RocketMQ instance.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageSpace")
    def storage_space(self) -> _builtins.int:
        """
        Indicates the message storage capacity. Unit: GB.
        """
        return pulumi.get(self, "storage_space")

    @_builtins.property
    @pulumi.getter(name="storageSpecCode")
    def storage_spec_code(self) -> _builtins.str:
        """
        Indicates the storage I/O specification.
        """
        return pulumi.get(self, "storage_spec_code")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Indicates the ID of a subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the DMS RocketMQ instance type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="usedStorageSpace")
    def used_storage_space(self) -> _builtins.int:
        """
        Indicates the used message storage space. Unit: GB.
        """
        return pulumi.get(self, "used_storage_space")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Indicates the ID of a VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetRocketmqInstancesInstanceCrossVpcAccessResult(dict):
    def __init__(__self__, *,
                 advertised_ip: _builtins.str,
                 lisenter_ip: _builtins.str,
                 listener_ip: _builtins.str,
                 port: _builtins.int,
                 port_id: _builtins.str):
        """
        :param _builtins.str advertised_ip: Indicates the advertised IP.
        :param _builtins.str listener_ip: Indicates the IP of the listener.
        :param _builtins.int port: Indicates the port.
        :param _builtins.str port_id: Indicates the port ID associated with the address.
        """
        pulumi.set(__self__, "advertised_ip", advertised_ip)
        pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        pulumi.set(__self__, "listener_ip", listener_ip)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> _builtins.str:
        """
        Indicates the advertised IP.
        """
        return pulumi.get(self, "advertised_ip")

    @_builtins.property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> _builtins.str:
        return pulumi.get(self, "lisenter_ip")

    @_builtins.property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> _builtins.str:
        """
        Indicates the IP of the listener.
        """
        return pulumi.get(self, "listener_ip")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Indicates the port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> _builtins.str:
        """
        Indicates the port ID associated with the address.
        """
        return pulumi.get(self, "port_id")


@pulumi.output_type
class GetRocketmqMessageTracesTraceResult(dict):
    def __init__(__self__, *,
                 body_length: _builtins.float,
                 client_host: _builtins.str,
                 consume_status: _builtins.float,
                 cost_time: _builtins.float,
                 from_transaction_check: _builtins.bool,
                 group_name: _builtins.str,
                 keys: _builtins.str,
                 message_id: _builtins.str,
                 message_type: _builtins.str,
                 offset_message_id: _builtins.str,
                 request_id: _builtins.str,
                 retry_times: _builtins.int,
                 store_host: _builtins.str,
                 success: _builtins.bool,
                 tags: _builtins.str,
                 time: _builtins.str,
                 topic: _builtins.str,
                 trace_type: _builtins.str,
                 transaction_id: _builtins.str,
                 transaction_state: _builtins.str):
        """
        :param _builtins.float body_length: Specifies the message body length.
        :param _builtins.str client_host: Specifies the IP address of the host that generates the message.
        :param _builtins.float consume_status: Specifies the consumption status.
               + **0**: successful
               + **1**: timeout
               + **2**: abnormal
               + **3**: null
               + **5**: failed
        :param _builtins.float cost_time: Specifies the time spent.
        :param _builtins.bool from_transaction_check: Specifies whether the response is a transaction check response.
        :param _builtins.str group_name: Specifies the producer group or consumer group.
        :param _builtins.str keys: Specifies the message keys.
        :param _builtins.str message_id: Specifies the message ID.
        :param _builtins.str message_type: Specifies the message type.
        :param _builtins.str offset_message_id: Specifies the offset message ID.
        :param _builtins.str request_id: Specifies the request ID.
        :param _builtins.int retry_times: Specifies the number of retry times.
        :param _builtins.str store_host: Specifies the IP address of the host that stores the message.
        :param _builtins.bool success: Specifies whether the request is successful.
        :param _builtins.str tags: Specifies the message tag.
        :param _builtins.str time: Specifies the time.
        :param _builtins.str topic: Specifies the topic name.
        :param _builtins.str trace_type: Specifies the trace type.
        :param _builtins.str transaction_id: Specifies the transaction ID.
        :param _builtins.str transaction_state: Specifies the transaction status.
        """
        pulumi.set(__self__, "body_length", body_length)
        pulumi.set(__self__, "client_host", client_host)
        pulumi.set(__self__, "consume_status", consume_status)
        pulumi.set(__self__, "cost_time", cost_time)
        pulumi.set(__self__, "from_transaction_check", from_transaction_check)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "message_id", message_id)
        pulumi.set(__self__, "message_type", message_type)
        pulumi.set(__self__, "offset_message_id", offset_message_id)
        pulumi.set(__self__, "request_id", request_id)
        pulumi.set(__self__, "retry_times", retry_times)
        pulumi.set(__self__, "store_host", store_host)
        pulumi.set(__self__, "success", success)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "topic", topic)
        pulumi.set(__self__, "trace_type", trace_type)
        pulumi.set(__self__, "transaction_id", transaction_id)
        pulumi.set(__self__, "transaction_state", transaction_state)

    @_builtins.property
    @pulumi.getter(name="bodyLength")
    def body_length(self) -> _builtins.float:
        """
        Specifies the message body length.
        """
        return pulumi.get(self, "body_length")

    @_builtins.property
    @pulumi.getter(name="clientHost")
    def client_host(self) -> _builtins.str:
        """
        Specifies the IP address of the host that generates the message.
        """
        return pulumi.get(self, "client_host")

    @_builtins.property
    @pulumi.getter(name="consumeStatus")
    def consume_status(self) -> _builtins.float:
        """
        Specifies the consumption status.
        + **0**: successful
        + **1**: timeout
        + **2**: abnormal
        + **3**: null
        + **5**: failed
        """
        return pulumi.get(self, "consume_status")

    @_builtins.property
    @pulumi.getter(name="costTime")
    def cost_time(self) -> _builtins.float:
        """
        Specifies the time spent.
        """
        return pulumi.get(self, "cost_time")

    @_builtins.property
    @pulumi.getter(name="fromTransactionCheck")
    def from_transaction_check(self) -> _builtins.bool:
        """
        Specifies whether the response is a transaction check response.
        """
        return pulumi.get(self, "from_transaction_check")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> _builtins.str:
        """
        Specifies the producer group or consumer group.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> _builtins.str:
        """
        Specifies the message keys.
        """
        return pulumi.get(self, "keys")

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> _builtins.str:
        """
        Specifies the message ID.
        """
        return pulumi.get(self, "message_id")

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> _builtins.str:
        """
        Specifies the message type.
        """
        return pulumi.get(self, "message_type")

    @_builtins.property
    @pulumi.getter(name="offsetMessageId")
    def offset_message_id(self) -> _builtins.str:
        """
        Specifies the offset message ID.
        """
        return pulumi.get(self, "offset_message_id")

    @_builtins.property
    @pulumi.getter(name="requestId")
    def request_id(self) -> _builtins.str:
        """
        Specifies the request ID.
        """
        return pulumi.get(self, "request_id")

    @_builtins.property
    @pulumi.getter(name="retryTimes")
    def retry_times(self) -> _builtins.int:
        """
        Specifies the number of retry times.
        """
        return pulumi.get(self, "retry_times")

    @_builtins.property
    @pulumi.getter(name="storeHost")
    def store_host(self) -> _builtins.str:
        """
        Specifies the IP address of the host that stores the message.
        """
        return pulumi.get(self, "store_host")

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.bool:
        """
        Specifies whether the request is successful.
        """
        return pulumi.get(self, "success")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> _builtins.str:
        """
        Specifies the message tag.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.str:
        """
        Specifies the time.
        """
        return pulumi.get(self, "time")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter(name="traceType")
    def trace_type(self) -> _builtins.str:
        """
        Specifies the trace type.
        """
        return pulumi.get(self, "trace_type")

    @_builtins.property
    @pulumi.getter(name="transactionId")
    def transaction_id(self) -> _builtins.str:
        """
        Specifies the transaction ID.
        """
        return pulumi.get(self, "transaction_id")

    @_builtins.property
    @pulumi.getter(name="transactionState")
    def transaction_state(self) -> _builtins.str:
        """
        Specifies the transaction status.
        """
        return pulumi.get(self, "transaction_state")


@pulumi.output_type
class GetRocketmqMessagesMessageResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 body_crc: _builtins.int,
                 born_host: _builtins.str,
                 born_time: _builtins.str,
                 message_id: _builtins.str,
                 property_lists: Sequence['outputs.GetRocketmqMessagesMessagePropertyListResult'],
                 queue_id: _builtins.int,
                 queue_offset: _builtins.int,
                 reconsume_times: _builtins.int,
                 store_host: _builtins.str,
                 store_size: _builtins.int,
                 store_time: _builtins.str):
        """
        :param _builtins.str body: Indicates the message body. Only return when querying message by message ID.
        :param _builtins.int body_crc: Indicates the message body checksum.
        :param _builtins.str born_host: Indicates the IP address of the host that generates the message.
        :param _builtins.str born_time: Indicates the message generated time.
        :param _builtins.str message_id: Specifies the message ID.
        :param Sequence['GetRocketmqMessagesMessagePropertyListArgs'] property_lists: Indicates the property list.
               The property_list structure is documented below.
        :param _builtins.int queue_id: Indicates the queue ID.
        :param _builtins.int queue_offset: Indicates the offset in the queue.
        :param _builtins.int reconsume_times: Indicates the number of retry times.
        :param _builtins.str store_host: Indicates the IP address of the host that stores the message.
        :param _builtins.int store_size: Indicates the storage size.
        :param _builtins.str store_time: Indicates the message stored time.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "body_crc", body_crc)
        pulumi.set(__self__, "born_host", born_host)
        pulumi.set(__self__, "born_time", born_time)
        pulumi.set(__self__, "message_id", message_id)
        pulumi.set(__self__, "property_lists", property_lists)
        pulumi.set(__self__, "queue_id", queue_id)
        pulumi.set(__self__, "queue_offset", queue_offset)
        pulumi.set(__self__, "reconsume_times", reconsume_times)
        pulumi.set(__self__, "store_host", store_host)
        pulumi.set(__self__, "store_size", store_size)
        pulumi.set(__self__, "store_time", store_time)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        Indicates the message body. Only return when querying message by message ID.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter(name="bodyCrc")
    def body_crc(self) -> _builtins.int:
        """
        Indicates the message body checksum.
        """
        return pulumi.get(self, "body_crc")

    @_builtins.property
    @pulumi.getter(name="bornHost")
    def born_host(self) -> _builtins.str:
        """
        Indicates the IP address of the host that generates the message.
        """
        return pulumi.get(self, "born_host")

    @_builtins.property
    @pulumi.getter(name="bornTime")
    def born_time(self) -> _builtins.str:
        """
        Indicates the message generated time.
        """
        return pulumi.get(self, "born_time")

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> _builtins.str:
        """
        Specifies the message ID.
        """
        return pulumi.get(self, "message_id")

    @_builtins.property
    @pulumi.getter(name="propertyLists")
    def property_lists(self) -> Sequence['outputs.GetRocketmqMessagesMessagePropertyListResult']:
        """
        Indicates the property list.
        The property_list structure is documented below.
        """
        return pulumi.get(self, "property_lists")

    @_builtins.property
    @pulumi.getter(name="queueId")
    def queue_id(self) -> _builtins.int:
        """
        Indicates the queue ID.
        """
        return pulumi.get(self, "queue_id")

    @_builtins.property
    @pulumi.getter(name="queueOffset")
    def queue_offset(self) -> _builtins.int:
        """
        Indicates the offset in the queue.
        """
        return pulumi.get(self, "queue_offset")

    @_builtins.property
    @pulumi.getter(name="reconsumeTimes")
    def reconsume_times(self) -> _builtins.int:
        """
        Indicates the number of retry times.
        """
        return pulumi.get(self, "reconsume_times")

    @_builtins.property
    @pulumi.getter(name="storeHost")
    def store_host(self) -> _builtins.str:
        """
        Indicates the IP address of the host that stores the message.
        """
        return pulumi.get(self, "store_host")

    @_builtins.property
    @pulumi.getter(name="storeSize")
    def store_size(self) -> _builtins.int:
        """
        Indicates the storage size.
        """
        return pulumi.get(self, "store_size")

    @_builtins.property
    @pulumi.getter(name="storeTime")
    def store_time(self) -> _builtins.str:
        """
        Indicates the message stored time.
        """
        return pulumi.get(self, "store_time")


@pulumi.output_type
class GetRocketmqMessagesMessagePropertyListResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Indicates the property name.
        :param _builtins.str value: Indicates the property value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Indicates the property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRocketmqMigrationTasksTaskResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 start_date: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: Indicates the ID of a metadata migration task.
        :param _builtins.str name: Specifies the RocketMQ migration task name.
        :param _builtins.str start_date: Indicates the start time of a metadata migration task.
        :param _builtins.str status: Indicates the status of a metadata migration task.
        :param _builtins.str type: Specifies the RocketMQ migration task type.
               Valid values are **rocketmq** and **rabbitToRocket**.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the ID of a metadata migration task.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the RocketMQ migration task name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> _builtins.str:
        """
        Indicates the start time of a metadata migration task.
        """
        return pulumi.get(self, "start_date")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the status of a metadata migration task.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the RocketMQ migration task type.
        Valid values are **rocketmq** and **rabbitToRocket**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRocketmqTagsTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The tag key.
        :param Sequence[_builtins.str] values: The list of tag values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of tag values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetRocketmqTopicAccessUsersPolicyResult(dict):
    def __init__(__self__, *,
                 access_key: _builtins.str,
                 admin: _builtins.bool,
                 perm: _builtins.str,
                 white_remote_address: _builtins.str):
        """
        :param _builtins.str access_key: Indicates the user name.
        :param _builtins.bool admin: Indicates whether the user is an administrator.
        :param _builtins.str perm: Indicates the permissions.
        :param _builtins.str white_remote_address: Indicates the IP address whitelist.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "admin", admin)
        pulumi.set(__self__, "perm", perm)
        pulumi.set(__self__, "white_remote_address", white_remote_address)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Indicates the user name.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def admin(self) -> _builtins.bool:
        """
        Indicates whether the user is an administrator.
        """
        return pulumi.get(self, "admin")

    @_builtins.property
    @pulumi.getter
    def perm(self) -> _builtins.str:
        """
        Indicates the permissions.
        """
        return pulumi.get(self, "perm")

    @_builtins.property
    @pulumi.getter(name="whiteRemoteAddress")
    def white_remote_address(self) -> _builtins.str:
        """
        Indicates the IP address whitelist.
        """
        return pulumi.get(self, "white_remote_address")


@pulumi.output_type
class GetRocketmqTopicsTopicResult(dict):
    def __init__(__self__, *,
                 brokers: Sequence['outputs.GetRocketmqTopicsTopicBrokerResult'],
                 name: _builtins.str,
                 permission: _builtins.str,
                 total_read_queue_num: _builtins.int,
                 total_write_queue_num: _builtins.int):
        """
        :param Sequence['GetRocketmqTopicsTopicBrokerArgs'] brokers: The list of brokers.
               The brokers structure is documented below.
        :param _builtins.str name: Specifies the topic name.
        :param _builtins.str permission: Specifies the permission. Value options: **sub**, **pub** or **all**.
        :param _builtins.int total_read_queue_num: Specifies the number of total read queue.
        :param _builtins.int total_write_queue_num: Specifies the number of total write queue.
        """
        pulumi.set(__self__, "brokers", brokers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "total_read_queue_num", total_read_queue_num)
        pulumi.set(__self__, "total_write_queue_num", total_write_queue_num)

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> Sequence['outputs.GetRocketmqTopicsTopicBrokerResult']:
        """
        The list of brokers.
        The brokers structure is documented below.
        """
        return pulumi.get(self, "brokers")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Specifies the permission. Value options: **sub**, **pub** or **all**.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="totalReadQueueNum")
    def total_read_queue_num(self) -> _builtins.int:
        """
        Specifies the number of total read queue.
        """
        return pulumi.get(self, "total_read_queue_num")

    @_builtins.property
    @pulumi.getter(name="totalWriteQueueNum")
    def total_write_queue_num(self) -> _builtins.int:
        """
        Specifies the number of total write queue.
        """
        return pulumi.get(self, "total_write_queue_num")


@pulumi.output_type
class GetRocketmqTopicsTopicBrokerResult(dict):
    def __init__(__self__, *,
                 broker_name: _builtins.str,
                 read_queue_num: _builtins.int,
                 write_queue_num: _builtins.int):
        """
        :param _builtins.str broker_name: Indicates the broker name.
        :param _builtins.int read_queue_num: Indicates the number of read queue.
        :param _builtins.int write_queue_num: Indicates the number of write queue.
        """
        pulumi.set(__self__, "broker_name", broker_name)
        pulumi.set(__self__, "read_queue_num", read_queue_num)
        pulumi.set(__self__, "write_queue_num", write_queue_num)

    @_builtins.property
    @pulumi.getter(name="brokerName")
    def broker_name(self) -> _builtins.str:
        """
        Indicates the broker name.
        """
        return pulumi.get(self, "broker_name")

    @_builtins.property
    @pulumi.getter(name="readQueueNum")
    def read_queue_num(self) -> _builtins.int:
        """
        Indicates the number of read queue.
        """
        return pulumi.get(self, "read_queue_num")

    @_builtins.property
    @pulumi.getter(name="writeQueueNum")
    def write_queue_num(self) -> _builtins.int:
        """
        Indicates the number of write queue.
        """
        return pulumi.get(self, "write_queue_num")


@pulumi.output_type
class GetRocketmqUsersUserResult(dict):
    def __init__(__self__, *,
                 access_key: _builtins.str,
                 admin: _builtins.bool,
                 default_group_perm: _builtins.str,
                 default_topic_perm: _builtins.str,
                 group_perms: Sequence['outputs.GetRocketmqUsersUserGroupPermResult'],
                 topic_perms: Sequence['outputs.GetRocketmqUsersUserTopicPermResult'],
                 white_remote_address: _builtins.str):
        """
        :param _builtins.str access_key: Specifies the user name.
        :param _builtins.bool admin: Specifies whether the user is an administrator.
        :param _builtins.str default_group_perm: Specifies the default consumer group permissions.
               Value options: **SUB**, **DENY**.
        :param _builtins.str default_topic_perm: Specifies the default topic permissions.
               Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        :param Sequence['GetRocketmqUsersUserGroupPermArgs'] group_perms: The list of the special consumer group permissions.
               The group_perms structure is documented below.
        :param Sequence['GetRocketmqUsersUserTopicPermArgs'] topic_perms: The list of the special topic permissions.
               The topic_perms structure is documented below.
        :param _builtins.str white_remote_address: Specifies the IP address whitelist.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "admin", admin)
        pulumi.set(__self__, "default_group_perm", default_group_perm)
        pulumi.set(__self__, "default_topic_perm", default_topic_perm)
        pulumi.set(__self__, "group_perms", group_perms)
        pulumi.set(__self__, "topic_perms", topic_perms)
        pulumi.set(__self__, "white_remote_address", white_remote_address)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter
    def admin(self) -> _builtins.bool:
        """
        Specifies whether the user is an administrator.
        """
        return pulumi.get(self, "admin")

    @_builtins.property
    @pulumi.getter(name="defaultGroupPerm")
    def default_group_perm(self) -> _builtins.str:
        """
        Specifies the default consumer group permissions.
        Value options: **SUB**, **DENY**.
        """
        return pulumi.get(self, "default_group_perm")

    @_builtins.property
    @pulumi.getter(name="defaultTopicPerm")
    def default_topic_perm(self) -> _builtins.str:
        """
        Specifies the default topic permissions.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        return pulumi.get(self, "default_topic_perm")

    @_builtins.property
    @pulumi.getter(name="groupPerms")
    def group_perms(self) -> Sequence['outputs.GetRocketmqUsersUserGroupPermResult']:
        """
        The list of the special consumer group permissions.
        The group_perms structure is documented below.
        """
        return pulumi.get(self, "group_perms")

    @_builtins.property
    @pulumi.getter(name="topicPerms")
    def topic_perms(self) -> Sequence['outputs.GetRocketmqUsersUserTopicPermResult']:
        """
        The list of the special topic permissions.
        The topic_perms structure is documented below.
        """
        return pulumi.get(self, "topic_perms")

    @_builtins.property
    @pulumi.getter(name="whiteRemoteAddress")
    def white_remote_address(self) -> _builtins.str:
        """
        Specifies the IP address whitelist.
        """
        return pulumi.get(self, "white_remote_address")


@pulumi.output_type
class GetRocketmqUsersUserGroupPermResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 perm: _builtins.str):
        """
        :param _builtins.str name: Indicates the name of consumer group.
        :param _builtins.str perm: Indicates the permissions of consumer group.
               Value options: **SUB**, **DENY**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the name of consumer group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def perm(self) -> _builtins.str:
        """
        Indicates the permissions of consumer group.
        Value options: **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")


@pulumi.output_type
class GetRocketmqUsersUserTopicPermResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 perm: _builtins.str):
        """
        :param _builtins.str name: Indicates the name of consumer group.
        :param _builtins.str perm: Indicates the permissions of consumer group.
               Value options: **SUB**, **DENY**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the name of consumer group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def perm(self) -> _builtins.str:
        """
        Indicates the permissions of consumer group.
        Value options: **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")


