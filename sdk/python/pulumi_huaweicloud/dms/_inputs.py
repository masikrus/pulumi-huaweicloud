# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'KafkaInstanceCrossVpcAccessArgs',
    'KafkaInstanceCrossVpcAccessArgsDict',
    'KafkaInstanceParameterArgs',
    'KafkaInstanceParameterArgsDict',
    'KafkaInstancePortProtocolArgs',
    'KafkaInstancePortProtocolArgsDict',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListArgs',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListArgsDict',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgs',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgsDict',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgs',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgs',
    'KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict',
    'KafkaMessageProducePropertyListArgs',
    'KafkaMessageProducePropertyListArgsDict',
    'KafkaPartitionReassignReassignmentArgs',
    'KafkaPartitionReassignReassignmentArgsDict',
    'KafkaPartitionReassignReassignmentAssignmentArgs',
    'KafkaPartitionReassignReassignmentAssignmentArgsDict',
    'KafkaPermissionsPolicyArgs',
    'KafkaPermissionsPolicyArgsDict',
    'KafkaTopicConfigArgs',
    'KafkaTopicConfigArgsDict',
    'Kafkav2SmartConnectTaskDestinationTaskArgs',
    'Kafkav2SmartConnectTaskDestinationTaskArgsDict',
    'Kafkav2SmartConnectTaskSourceTaskArgs',
    'Kafkav2SmartConnectTaskSourceTaskArgsDict',
    'RabbitmqExchangeBindingArgs',
    'RabbitmqExchangeBindingArgsDict',
    'RabbitmqQueueConsumerDetailArgs',
    'RabbitmqQueueConsumerDetailArgsDict',
    'RabbitmqQueueConsumerDetailChannelDetailArgs',
    'RabbitmqQueueConsumerDetailChannelDetailArgsDict',
    'RabbitmqQueueQueueBindingArgs',
    'RabbitmqQueueQueueBindingArgsDict',
    'RabbitmqUserVhostArgs',
    'RabbitmqUserVhostArgsDict',
    'RocketmqConsumptionVerifyResendResultArgs',
    'RocketmqConsumptionVerifyResendResultArgsDict',
    'RocketmqDeadLetterResendResendResultArgs',
    'RocketmqDeadLetterResendResendResultArgsDict',
    'RocketmqInstanceConfigArgs',
    'RocketmqInstanceConfigArgsDict',
    'RocketmqInstanceCrossVpcAccessArgs',
    'RocketmqInstanceCrossVpcAccessArgsDict',
    'RocketmqMessageSendPropertyListArgs',
    'RocketmqMessageSendPropertyListArgsDict',
    'RocketmqMigrationTaskBindingArgs',
    'RocketmqMigrationTaskBindingArgsDict',
    'RocketmqMigrationTaskExchangeArgs',
    'RocketmqMigrationTaskExchangeArgsDict',
    'RocketmqMigrationTaskQueueArgs',
    'RocketmqMigrationTaskQueueArgsDict',
    'RocketmqMigrationTaskSubscriptionGroupArgs',
    'RocketmqMigrationTaskSubscriptionGroupArgsDict',
    'RocketmqMigrationTaskTopicConfigArgs',
    'RocketmqMigrationTaskTopicConfigArgsDict',
    'RocketmqMigrationTaskVhostArgs',
    'RocketmqMigrationTaskVhostArgsDict',
    'RocketmqTopicBrokerArgs',
    'RocketmqTopicBrokerArgsDict',
    'RocketmqTopicQueueArgs',
    'RocketmqTopicQueueArgsDict',
    'RocketmqUserGroupPermArgs',
    'RocketmqUserGroupPermArgsDict',
    'RocketmqUserTopicPermArgs',
    'RocketmqUserTopicPermArgsDict',
]

MYPY = False

if not MYPY:
    class KafkaInstanceCrossVpcAccessArgsDict(TypedDict):
        advertised_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The advertised IP Address or domain name.

        <a name="dms_parameters"></a>
        The `parameters` block supports:
        """
        lisenter_ip: NotRequired[pulumi.Input[_builtins.str]]
        listener_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The listener IP address.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number.
        """
        port_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port ID associated with the address.
        """
elif False:
    KafkaInstanceCrossVpcAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaInstanceCrossVpcAccessArgs:
    def __init__(__self__, *,
                 advertised_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 lisenter_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 listener_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advertised_ip: The advertised IP Address or domain name.
               
               <a name="dms_parameters"></a>
               The `parameters` block supports:
        :param pulumi.Input[_builtins.str] listener_ip: The listener IP address.
        :param pulumi.Input[_builtins.int] port: The port number.
        :param pulumi.Input[_builtins.str] port_id: The port ID associated with the address.
        """
        if advertised_ip is not None:
            pulumi.set(__self__, "advertised_ip", advertised_ip)
        if lisenter_ip is not None:
            warnings.warn("""typo in lisenter_ip, please use \"listener_ip\" instead.""", DeprecationWarning)
            pulumi.log.warn("""lisenter_ip is deprecated: typo in lisenter_ip, please use \"listener_ip\" instead.""")
        if lisenter_ip is not None:
            pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        if listener_ip is not None:
            pulumi.set(__self__, "listener_ip", listener_ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The advertised IP Address or domain name.

        <a name="dms_parameters"></a>
        The `parameters` block supports:
        """
        return pulumi.get(self, "advertised_ip")

    @advertised_ip.setter
    def advertised_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advertised_ip", value)

    @_builtins.property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lisenter_ip")

    @lisenter_ip.setter
    def lisenter_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lisenter_ip", value)

    @_builtins.property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The listener IP address.
        """
        return pulumi.get(self, "listener_ip")

    @listener_ip.setter
    def listener_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port ID associated with the address.
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_id", value)


if not MYPY:
    class KafkaInstanceParameterArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the parameter name. Static parameter needs to restart the instance to take effect.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the parameter value.
        """
elif False:
    KafkaInstanceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaInstanceParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the parameter name. Static parameter needs to restart the instance to take effect.
        :param pulumi.Input[_builtins.str] value: Specifies the parameter value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameter name. Static parameter needs to restart the instance to take effect.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KafkaInstancePortProtocolArgsDict(TypedDict):
        private_plain_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private plain address.
        """
        private_plain_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private plain domain name.
        """
        private_plain_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the private plain enabled.
        """
        private_sasl_plaintext_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private sasl plaintext address.
        """
        private_sasl_plaintext_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private sasl plaintext domain name.
        """
        private_sasl_plaintext_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the private sasl plaintext enabled.
        """
        private_sasl_ssl_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private sasl ssl address.
        """
        private_sasl_ssl_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private sasl ssl domain name.
        """
        private_sasl_ssl_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the private sasl ssl enabled.
        """
        public_plain_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public plain address.
        """
        public_plain_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public plain domain name.
        """
        public_plain_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the public plain enabled.
        """
        public_sasl_plaintext_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public sasl plaintext address.
        """
        public_sasl_plaintext_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public sasl plaintext domain name.
        """
        public_sasl_plaintext_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the public sasl plaintext enabled.
        """
        public_sasl_ssl_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public sasl ssl address.
        """
        public_sasl_ssl_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public sasl ssl domain name.
        """
        public_sasl_ssl_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the public sasl ssl enabled.
        """
elif False:
    KafkaInstancePortProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaInstancePortProtocolArgs:
    def __init__(__self__, *,
                 private_plain_address: Optional[pulumi.Input[_builtins.str]] = None,
                 private_plain_domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_plain_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 private_sasl_plaintext_address: Optional[pulumi.Input[_builtins.str]] = None,
                 private_sasl_plaintext_domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_sasl_plaintext_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 private_sasl_ssl_address: Optional[pulumi.Input[_builtins.str]] = None,
                 private_sasl_ssl_domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 private_sasl_ssl_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 public_plain_address: Optional[pulumi.Input[_builtins.str]] = None,
                 public_plain_domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_plain_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 public_sasl_plaintext_address: Optional[pulumi.Input[_builtins.str]] = None,
                 public_sasl_plaintext_domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_sasl_plaintext_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 public_sasl_ssl_address: Optional[pulumi.Input[_builtins.str]] = None,
                 public_sasl_ssl_domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_sasl_ssl_enable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] private_plain_address: The private plain address.
        :param pulumi.Input[_builtins.str] private_plain_domain_name: The private plain domain name.
        :param pulumi.Input[_builtins.bool] private_plain_enable: Whether the private plain enabled.
        :param pulumi.Input[_builtins.str] private_sasl_plaintext_address: The private sasl plaintext address.
        :param pulumi.Input[_builtins.str] private_sasl_plaintext_domain_name: The private sasl plaintext domain name.
        :param pulumi.Input[_builtins.bool] private_sasl_plaintext_enable: Whether the private sasl plaintext enabled.
        :param pulumi.Input[_builtins.str] private_sasl_ssl_address: The private sasl ssl address.
        :param pulumi.Input[_builtins.str] private_sasl_ssl_domain_name: The private sasl ssl domain name.
        :param pulumi.Input[_builtins.bool] private_sasl_ssl_enable: Whether the private sasl ssl enabled.
        :param pulumi.Input[_builtins.str] public_plain_address: The public plain address.
        :param pulumi.Input[_builtins.str] public_plain_domain_name: The public plain domain name.
        :param pulumi.Input[_builtins.bool] public_plain_enable: Whether the public plain enabled.
        :param pulumi.Input[_builtins.str] public_sasl_plaintext_address: The public sasl plaintext address.
        :param pulumi.Input[_builtins.str] public_sasl_plaintext_domain_name: The public sasl plaintext domain name.
        :param pulumi.Input[_builtins.bool] public_sasl_plaintext_enable: Whether the public sasl plaintext enabled.
        :param pulumi.Input[_builtins.str] public_sasl_ssl_address: The public sasl ssl address.
        :param pulumi.Input[_builtins.str] public_sasl_ssl_domain_name: The public sasl ssl domain name.
        :param pulumi.Input[_builtins.bool] public_sasl_ssl_enable: Whether the public sasl ssl enabled.
        """
        if private_plain_address is not None:
            pulumi.set(__self__, "private_plain_address", private_plain_address)
        if private_plain_domain_name is not None:
            pulumi.set(__self__, "private_plain_domain_name", private_plain_domain_name)
        if private_plain_enable is not None:
            pulumi.set(__self__, "private_plain_enable", private_plain_enable)
        if private_sasl_plaintext_address is not None:
            pulumi.set(__self__, "private_sasl_plaintext_address", private_sasl_plaintext_address)
        if private_sasl_plaintext_domain_name is not None:
            pulumi.set(__self__, "private_sasl_plaintext_domain_name", private_sasl_plaintext_domain_name)
        if private_sasl_plaintext_enable is not None:
            pulumi.set(__self__, "private_sasl_plaintext_enable", private_sasl_plaintext_enable)
        if private_sasl_ssl_address is not None:
            pulumi.set(__self__, "private_sasl_ssl_address", private_sasl_ssl_address)
        if private_sasl_ssl_domain_name is not None:
            pulumi.set(__self__, "private_sasl_ssl_domain_name", private_sasl_ssl_domain_name)
        if private_sasl_ssl_enable is not None:
            pulumi.set(__self__, "private_sasl_ssl_enable", private_sasl_ssl_enable)
        if public_plain_address is not None:
            pulumi.set(__self__, "public_plain_address", public_plain_address)
        if public_plain_domain_name is not None:
            pulumi.set(__self__, "public_plain_domain_name", public_plain_domain_name)
        if public_plain_enable is not None:
            pulumi.set(__self__, "public_plain_enable", public_plain_enable)
        if public_sasl_plaintext_address is not None:
            pulumi.set(__self__, "public_sasl_plaintext_address", public_sasl_plaintext_address)
        if public_sasl_plaintext_domain_name is not None:
            pulumi.set(__self__, "public_sasl_plaintext_domain_name", public_sasl_plaintext_domain_name)
        if public_sasl_plaintext_enable is not None:
            pulumi.set(__self__, "public_sasl_plaintext_enable", public_sasl_plaintext_enable)
        if public_sasl_ssl_address is not None:
            pulumi.set(__self__, "public_sasl_ssl_address", public_sasl_ssl_address)
        if public_sasl_ssl_domain_name is not None:
            pulumi.set(__self__, "public_sasl_ssl_domain_name", public_sasl_ssl_domain_name)
        if public_sasl_ssl_enable is not None:
            pulumi.set(__self__, "public_sasl_ssl_enable", public_sasl_ssl_enable)

    @_builtins.property
    @pulumi.getter(name="privatePlainAddress")
    def private_plain_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private plain address.
        """
        return pulumi.get(self, "private_plain_address")

    @private_plain_address.setter
    def private_plain_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_plain_address", value)

    @_builtins.property
    @pulumi.getter(name="privatePlainDomainName")
    def private_plain_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private plain domain name.
        """
        return pulumi.get(self, "private_plain_domain_name")

    @private_plain_domain_name.setter
    def private_plain_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_plain_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="privatePlainEnable")
    def private_plain_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the private plain enabled.
        """
        return pulumi.get(self, "private_plain_enable")

    @private_plain_enable.setter
    def private_plain_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "private_plain_enable", value)

    @_builtins.property
    @pulumi.getter(name="privateSaslPlaintextAddress")
    def private_sasl_plaintext_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private sasl plaintext address.
        """
        return pulumi.get(self, "private_sasl_plaintext_address")

    @private_sasl_plaintext_address.setter
    def private_sasl_plaintext_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_sasl_plaintext_address", value)

    @_builtins.property
    @pulumi.getter(name="privateSaslPlaintextDomainName")
    def private_sasl_plaintext_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private sasl plaintext domain name.
        """
        return pulumi.get(self, "private_sasl_plaintext_domain_name")

    @private_sasl_plaintext_domain_name.setter
    def private_sasl_plaintext_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_sasl_plaintext_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="privateSaslPlaintextEnable")
    def private_sasl_plaintext_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the private sasl plaintext enabled.
        """
        return pulumi.get(self, "private_sasl_plaintext_enable")

    @private_sasl_plaintext_enable.setter
    def private_sasl_plaintext_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "private_sasl_plaintext_enable", value)

    @_builtins.property
    @pulumi.getter(name="privateSaslSslAddress")
    def private_sasl_ssl_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private sasl ssl address.
        """
        return pulumi.get(self, "private_sasl_ssl_address")

    @private_sasl_ssl_address.setter
    def private_sasl_ssl_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_sasl_ssl_address", value)

    @_builtins.property
    @pulumi.getter(name="privateSaslSslDomainName")
    def private_sasl_ssl_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private sasl ssl domain name.
        """
        return pulumi.get(self, "private_sasl_ssl_domain_name")

    @private_sasl_ssl_domain_name.setter
    def private_sasl_ssl_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_sasl_ssl_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="privateSaslSslEnable")
    def private_sasl_ssl_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the private sasl ssl enabled.
        """
        return pulumi.get(self, "private_sasl_ssl_enable")

    @private_sasl_ssl_enable.setter
    def private_sasl_ssl_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "private_sasl_ssl_enable", value)

    @_builtins.property
    @pulumi.getter(name="publicPlainAddress")
    def public_plain_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public plain address.
        """
        return pulumi.get(self, "public_plain_address")

    @public_plain_address.setter
    def public_plain_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_plain_address", value)

    @_builtins.property
    @pulumi.getter(name="publicPlainDomainName")
    def public_plain_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public plain domain name.
        """
        return pulumi.get(self, "public_plain_domain_name")

    @public_plain_domain_name.setter
    def public_plain_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_plain_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="publicPlainEnable")
    def public_plain_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the public plain enabled.
        """
        return pulumi.get(self, "public_plain_enable")

    @public_plain_enable.setter
    def public_plain_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "public_plain_enable", value)

    @_builtins.property
    @pulumi.getter(name="publicSaslPlaintextAddress")
    def public_sasl_plaintext_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public sasl plaintext address.
        """
        return pulumi.get(self, "public_sasl_plaintext_address")

    @public_sasl_plaintext_address.setter
    def public_sasl_plaintext_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_sasl_plaintext_address", value)

    @_builtins.property
    @pulumi.getter(name="publicSaslPlaintextDomainName")
    def public_sasl_plaintext_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public sasl plaintext domain name.
        """
        return pulumi.get(self, "public_sasl_plaintext_domain_name")

    @public_sasl_plaintext_domain_name.setter
    def public_sasl_plaintext_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_sasl_plaintext_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="publicSaslPlaintextEnable")
    def public_sasl_plaintext_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the public sasl plaintext enabled.
        """
        return pulumi.get(self, "public_sasl_plaintext_enable")

    @public_sasl_plaintext_enable.setter
    def public_sasl_plaintext_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "public_sasl_plaintext_enable", value)

    @_builtins.property
    @pulumi.getter(name="publicSaslSslAddress")
    def public_sasl_ssl_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public sasl ssl address.
        """
        return pulumi.get(self, "public_sasl_ssl_address")

    @public_sasl_ssl_address.setter
    def public_sasl_ssl_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_sasl_ssl_address", value)

    @_builtins.property
    @pulumi.getter(name="publicSaslSslDomainName")
    def public_sasl_ssl_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public sasl ssl domain name.
        """
        return pulumi.get(self, "public_sasl_ssl_domain_name")

    @public_sasl_ssl_domain_name.setter
    def public_sasl_ssl_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_sasl_ssl_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="publicSaslSslEnable")
    def public_sasl_ssl_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the public sasl ssl enabled.
        """
        return pulumi.get(self, "public_sasl_ssl_enable")

    @public_sasl_ssl_enable.setter
    def public_sasl_ssl_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "public_sasl_ssl_enable", value)


if not MYPY:
    class KafkaMessageDiagnosisTaskDiagnosisDimensionListArgsDict(TypedDict):
        abnormal_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the total number of abnormal items in this diagnosis dimension.
        """
        diagnosis_item_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgsDict']]]]
        """
        Indicates the diagnosis items.
        The diagnosis_item_list structure is documented below.
        """
        failed_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the total number of failed items in this diagnosis dimension.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the diagnosis item name.
        """
elif False:
    KafkaMessageDiagnosisTaskDiagnosisDimensionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionListArgs:
    def __init__(__self__, *,
                 abnormal_num: Optional[pulumi.Input[_builtins.int]] = None,
                 diagnosis_item_lists: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgs']]]] = None,
                 failed_num: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] abnormal_num: Indicates the total number of abnormal items in this diagnosis dimension.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgs']]] diagnosis_item_lists: Indicates the diagnosis items.
               The diagnosis_item_list structure is documented below.
        :param pulumi.Input[_builtins.int] failed_num: Indicates the total number of failed items in this diagnosis dimension.
        :param pulumi.Input[_builtins.str] name: Indicates the diagnosis item name.
        """
        if abnormal_num is not None:
            pulumi.set(__self__, "abnormal_num", abnormal_num)
        if diagnosis_item_lists is not None:
            pulumi.set(__self__, "diagnosis_item_lists", diagnosis_item_lists)
        if failed_num is not None:
            pulumi.set(__self__, "failed_num", failed_num)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="abnormalNum")
    def abnormal_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the total number of abnormal items in this diagnosis dimension.
        """
        return pulumi.get(self, "abnormal_num")

    @abnormal_num.setter
    def abnormal_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "abnormal_num", value)

    @_builtins.property
    @pulumi.getter(name="diagnosisItemLists")
    def diagnosis_item_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgs']]]]:
        """
        Indicates the diagnosis items.
        The diagnosis_item_list structure is documented below.
        """
        return pulumi.get(self, "diagnosis_item_lists")

    @diagnosis_item_lists.setter
    def diagnosis_item_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgs']]]]):
        pulumi.set(self, "diagnosis_item_lists", value)

    @_builtins.property
    @pulumi.getter(name="failedNum")
    def failed_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the total number of failed items in this diagnosis dimension.
        """
        return pulumi.get(self, "failed_num")

    @failed_num.setter
    def failed_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failed_num", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the diagnosis item name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgsDict(TypedDict):
        advice_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict']]]]
        """
        Indicates the suggestions for diagnosis exceptions.
        The conclusion structure is documented below.
        """
        broker_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Indicates the brokers affected by the diagnosis exceptions.
        """
        cause_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict']]]]
        """
        Indicates the diagnosis exception causes.
        The conclusion structure is documented below.
        """
        failed_partitions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Indicates the partitions that failed to be diagnosed.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the diagnosis item name.
        """
        partitions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Indicates the partitions affected by the diagnosis exceptions.
        """
        result: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the diagnosis result.
        """
elif False:
    KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListArgs:
    def __init__(__self__, *,
                 advice_ids: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]]] = None,
                 broker_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 cause_ids: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]]] = None,
                 failed_partitions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 partitions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 result: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]] advice_ids: Indicates the suggestions for diagnosis exceptions.
               The conclusion structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] broker_ids: Indicates the brokers affected by the diagnosis exceptions.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]] cause_ids: Indicates the diagnosis exception causes.
               The conclusion structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] failed_partitions: Indicates the partitions that failed to be diagnosed.
        :param pulumi.Input[_builtins.str] name: Indicates the diagnosis item name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] partitions: Indicates the partitions affected by the diagnosis exceptions.
        :param pulumi.Input[_builtins.str] result: Indicates the diagnosis result.
        """
        if advice_ids is not None:
            pulumi.set(__self__, "advice_ids", advice_ids)
        if broker_ids is not None:
            pulumi.set(__self__, "broker_ids", broker_ids)
        if cause_ids is not None:
            pulumi.set(__self__, "cause_ids", cause_ids)
        if failed_partitions is not None:
            pulumi.set(__self__, "failed_partitions", failed_partitions)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @_builtins.property
    @pulumi.getter(name="adviceIds")
    def advice_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]]]:
        """
        Indicates the suggestions for diagnosis exceptions.
        The conclusion structure is documented below.
        """
        return pulumi.get(self, "advice_ids")

    @advice_ids.setter
    def advice_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgs']]]]):
        pulumi.set(self, "advice_ids", value)

    @_builtins.property
    @pulumi.getter(name="brokerIds")
    def broker_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Indicates the brokers affected by the diagnosis exceptions.
        """
        return pulumi.get(self, "broker_ids")

    @broker_ids.setter
    def broker_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "broker_ids", value)

    @_builtins.property
    @pulumi.getter(name="causeIds")
    def cause_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]]]:
        """
        Indicates the diagnosis exception causes.
        The conclusion structure is documented below.
        """
        return pulumi.get(self, "cause_ids")

    @cause_ids.setter
    def cause_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgs']]]]):
        pulumi.set(self, "cause_ids", value)

    @_builtins.property
    @pulumi.getter(name="failedPartitions")
    def failed_partitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Indicates the partitions that failed to be diagnosed.
        """
        return pulumi.get(self, "failed_partitions")

    @failed_partitions.setter
    def failed_partitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "failed_partitions", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the diagnosis item name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Indicates the partitions affected by the diagnosis exceptions.
        """
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "partitions", value)

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the diagnosis result.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "result", value)


if not MYPY:
    class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the diagnosis conclusion ID.
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Indicates the diagnosis conclusion parameters.
        """
elif False:
    KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListAdviceIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Indicates the diagnosis conclusion ID.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Indicates the diagnosis conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the diagnosis conclusion ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Indicates the diagnosis conclusion parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)


if not MYPY:
    class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the diagnosis conclusion ID.
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Indicates the diagnosis conclusion parameters.
        """
elif False:
    KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaMessageDiagnosisTaskDiagnosisDimensionListDiagnosisItemListCauseIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.int]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] id: Indicates the diagnosis conclusion ID.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Indicates the diagnosis conclusion parameters.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the diagnosis conclusion ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Indicates the diagnosis conclusion parameters.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)


if not MYPY:
    class KafkaMessageProducePropertyListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the feature name.
        + **KEY**: Specifies the message key.
        + **PARTITION** : Specifies the partition to which the message will be sent.
        Changing this creates a new resource.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the feature value.
        Changing this creates a new resource.
        """
elif False:
    KafkaMessageProducePropertyListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaMessageProducePropertyListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the feature name.
               + **KEY**: Specifies the message key.
               + **PARTITION** : Specifies the partition to which the message will be sent.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] value: Specifies the feature value.
               Changing this creates a new resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the feature name.
        + **KEY**: Specifies the message key.
        + **PARTITION** : Specifies the partition to which the message will be sent.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the feature value.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KafkaPartitionReassignReassignmentArgsDict(TypedDict):
        topic: pulumi.Input[_builtins.str]
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['KafkaPartitionReassignReassignmentAssignmentArgsDict']]]]
        """
        Specifies the manually specified assignment plan.
        It's **required** in **manually** specified assignment. Changing this creates a new resource.
        The assignment structure is documented below.

        > If manually specified assignment and automatic assignment are both specified, only **manually** specified assignment
        will take effect.

        <a name="reassignments_assignment_struct"></a>
        The `assignment` block supports:
        """
        brokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Specifies the integer list of brokers to which partitions are reassigned.
        It's **required** in **automatic** assignment. Changing this creates a new resource.
        """
        replication_factor: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the replication factor, which can be specified in
        **automatic** assignment. Changing this creates a new resource.
        """
elif False:
    KafkaPartitionReassignReassignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaPartitionReassignReassignmentArgs:
    def __init__(__self__, *,
                 topic: pulumi.Input[_builtins.str],
                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaPartitionReassignReassignmentAssignmentArgs']]]] = None,
                 brokers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 replication_factor: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] topic: Specifies the topic name. Changing this creates a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaPartitionReassignReassignmentAssignmentArgs']]] assignments: Specifies the manually specified assignment plan.
               It's **required** in **manually** specified assignment. Changing this creates a new resource.
               The assignment structure is documented below.
               
               > If manually specified assignment and automatic assignment are both specified, only **manually** specified assignment
               will take effect.
               
               <a name="reassignments_assignment_struct"></a>
               The `assignment` block supports:
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] brokers: Specifies the integer list of brokers to which partitions are reassigned.
               It's **required** in **automatic** assignment. Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] replication_factor: Specifies the replication factor, which can be specified in
               **automatic** assignment. Changing this creates a new resource.
        """
        pulumi.set(__self__, "topic", topic)
        if assignments is not None:
            pulumi.set(__self__, "assignments", assignments)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)
        if replication_factor is not None:
            pulumi.set(__self__, "replication_factor", replication_factor)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaPartitionReassignReassignmentAssignmentArgs']]]]:
        """
        Specifies the manually specified assignment plan.
        It's **required** in **manually** specified assignment. Changing this creates a new resource.
        The assignment structure is documented below.

        > If manually specified assignment and automatic assignment are both specified, only **manually** specified assignment
        will take effect.

        <a name="reassignments_assignment_struct"></a>
        The `assignment` block supports:
        """
        return pulumi.get(self, "assignments")

    @assignments.setter
    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaPartitionReassignReassignmentAssignmentArgs']]]]):
        pulumi.set(self, "assignments", value)

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Specifies the integer list of brokers to which partitions are reassigned.
        It's **required** in **automatic** assignment. Changing this creates a new resource.
        """
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "brokers", value)

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the replication factor, which can be specified in
        **automatic** assignment. Changing this creates a new resource.
        """
        return pulumi.get(self, "replication_factor")

    @replication_factor.setter
    def replication_factor(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replication_factor", value)


if not MYPY:
    class KafkaPartitionReassignReassignmentAssignmentArgsDict(TypedDict):
        partition: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the partition number in manual assignment.
        It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
        partition_brokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Specifies the integer list of brokers to be assigned to a partition in
        manual assignment. It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
elif False:
    KafkaPartitionReassignReassignmentAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaPartitionReassignReassignmentAssignmentArgs:
    def __init__(__self__, *,
                 partition: Optional[pulumi.Input[_builtins.int]] = None,
                 partition_brokers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.int] partition: Specifies the partition number in manual assignment.
               It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] partition_brokers: Specifies the integer list of brokers to be assigned to a partition in
               manual assignment. It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if partition_brokers is not None:
            pulumi.set(__self__, "partition_brokers", partition_brokers)

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the partition number in manual assignment.
        It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "partition", value)

    @_builtins.property
    @pulumi.getter(name="partitionBrokers")
    def partition_brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Specifies the integer list of brokers to be assigned to a partition in
        manual assignment. It's actually **required** in **manual** assignment plan. Changing this creates a new resource.
        """
        return pulumi.get(self, "partition_brokers")

    @partition_brokers.setter
    def partition_brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "partition_brokers", value)


if not MYPY:
    class KafkaPermissionsPolicyArgsDict(TypedDict):
        access_policy: pulumi.Input[_builtins.str]
        """
        Specifies the permissions type. The value can be:
        + **all**: publish and subscribe permissions.
        + **pub**: publish permissions.
        + **sub**: subscribe permissions.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        Specifies the username.
        """
elif False:
    KafkaPermissionsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaPermissionsPolicyArgs:
    def __init__(__self__, *,
                 access_policy: pulumi.Input[_builtins.str],
                 user_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] access_policy: Specifies the permissions type. The value can be:
               + **all**: publish and subscribe permissions.
               + **pub**: publish permissions.
               + **sub**: subscribe permissions.
        :param pulumi.Input[_builtins.str] user_name: Specifies the username.
        """
        pulumi.set(__self__, "access_policy", access_policy)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="accessPolicy")
    def access_policy(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the permissions type. The value can be:
        + **all**: publish and subscribe permissions.
        + **pub**: publish permissions.
        + **sub**: subscribe permissions.
        """
        return pulumi.get(self, "access_policy")

    @access_policy.setter
    def access_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_policy", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the username.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class KafkaTopicConfigArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the configuration name.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the configuration value.

        > When `name` is **max.message.bytes**, `value` ranges from `0` to `10,485,760`.
        When `name` is **message.timestamp.type**, `value` can be **LogAppendTime** and **CreateTime**.
        """
elif False:
    KafkaTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaTopicConfigArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the configuration name.
        :param pulumi.Input[_builtins.str] value: Specifies the configuration value.
               
               > When `name` is **max.message.bytes**, `value` ranges from `0` to `10,485,760`.
               When `name` is **message.timestamp.type**, `value` can be **LogAppendTime** and **CreateTime**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the configuration name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the configuration value.

        > When `name` is **max.message.bytes**, `value` ranges from `0` to `10,485,760`.
        When `name` is **message.timestamp.type**, `value` can be **LogAppendTime** and **CreateTime**.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Kafkav2SmartConnectTaskDestinationTaskArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the access key used to access the OBS bucket.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        agency_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Internal
        """
        consumer_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the consumer strategy of the smart connect task.
        Value options:
        + **latest**: Read the latest data.
        + **earliest**: Read the earliest data.

        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        deliver_time_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the deliver time interval of the smart connect task.
        It's **required** when `destination_type` is **OBS_SINK**.
        The value should be between `30` and `900`. Changing this parameter will create a new resource.
        """
        destination_file_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination file type of the smart connect task.
        Only **TEXT** is supported. Changing this parameter will create a new resource.
        """
        flush_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the flush size.
        """
        key_converter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the key converter.
        """
        kv_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the kv delimiter.
        """
        obs_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the obs bucket name of the smart connect task.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        obs_part_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the size of each file to be uploaded.
        """
        obs_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the obs path of the smart connect task.
        Obs path is separated by a slash. Changing this parameter will create a new resource.
        """
        partition_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time directory format of the smart connect task.
        Value options: **yyyy**, **yyyy/MM**, **yyyy/MM/dd**, **yyyy/MM/dd/HH**, **yyyy/MM/dd/HH/mm**.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        partitioner_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the partitioner class.
        """
        record_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the record delimiter of the smart connect task.
        Value options: **,**, **;**, **|**, **\\n**.
        Changing this parameter will create a new resource.
        """
        schema_generator_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the schema generator class.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the secret access key used to access the OBS bucket.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        store_keys: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to dump keys.
        Changing this parameter will create a new resource.
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the time zone.
        """
        value_converter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the value converter.
        """
elif False:
    Kafkav2SmartConnectTaskDestinationTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Kafkav2SmartConnectTaskDestinationTaskArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 agency_name: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 deliver_time_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 destination_file_type: Optional[pulumi.Input[_builtins.str]] = None,
                 flush_size: Optional[pulumi.Input[_builtins.int]] = None,
                 key_converter: Optional[pulumi.Input[_builtins.str]] = None,
                 kv_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_part_size: Optional[pulumi.Input[_builtins.int]] = None,
                 obs_path: Optional[pulumi.Input[_builtins.str]] = None,
                 partition_format: Optional[pulumi.Input[_builtins.str]] = None,
                 partitioner_class: Optional[pulumi.Input[_builtins.str]] = None,
                 record_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_generator_class: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 store_keys: Optional[pulumi.Input[_builtins.bool]] = None,
                 timezone: Optional[pulumi.Input[_builtins.str]] = None,
                 value_converter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Specifies the access key used to access the OBS bucket.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] agency_name: schema: Internal
        :param pulumi.Input[_builtins.str] consumer_strategy: Specifies the consumer strategy of the smart connect task.
               Value options:
               + **latest**: Read the latest data.
               + **earliest**: Read the earliest data.
               
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] deliver_time_interval: Specifies the deliver time interval of the smart connect task.
               It's **required** when `destination_type` is **OBS_SINK**.
               The value should be between `30` and `900`. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] destination_file_type: Specifies the destination file type of the smart connect task.
               Only **TEXT** is supported. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] flush_size: Indicates the flush size.
        :param pulumi.Input[_builtins.str] key_converter: Indicates the key converter.
        :param pulumi.Input[_builtins.str] kv_delimiter: Indicates the kv delimiter.
        :param pulumi.Input[_builtins.str] obs_bucket_name: Specifies the obs bucket name of the smart connect task.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] obs_part_size: Indicates the size of each file to be uploaded.
        :param pulumi.Input[_builtins.str] obs_path: Specifies the obs path of the smart connect task.
               Obs path is separated by a slash. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] partition_format: Specifies the time directory format of the smart connect task.
               Value options: **yyyy**, **yyyy/MM**, **yyyy/MM/dd**, **yyyy/MM/dd/HH**, **yyyy/MM/dd/HH/mm**.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] partitioner_class: Indicates the partitioner class.
        :param pulumi.Input[_builtins.str] record_delimiter: Specifies the record delimiter of the smart connect task.
               Value options: **,**, **;**, **|**, **\\n**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] schema_generator_class: Indicates the schema generator class.
        :param pulumi.Input[_builtins.str] secret_key: Specifies the secret access key used to access the OBS bucket.
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.bool] store_keys: Specifies whether to dump keys.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] timezone: Indicates the time zone.
        :param pulumi.Input[_builtins.str] value_converter: Indicates the value converter.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if consumer_strategy is not None:
            pulumi.set(__self__, "consumer_strategy", consumer_strategy)
        if deliver_time_interval is not None:
            pulumi.set(__self__, "deliver_time_interval", deliver_time_interval)
        if destination_file_type is not None:
            pulumi.set(__self__, "destination_file_type", destination_file_type)
        if flush_size is not None:
            pulumi.set(__self__, "flush_size", flush_size)
        if key_converter is not None:
            pulumi.set(__self__, "key_converter", key_converter)
        if kv_delimiter is not None:
            pulumi.set(__self__, "kv_delimiter", kv_delimiter)
        if obs_bucket_name is not None:
            pulumi.set(__self__, "obs_bucket_name", obs_bucket_name)
        if obs_part_size is not None:
            pulumi.set(__self__, "obs_part_size", obs_part_size)
        if obs_path is not None:
            pulumi.set(__self__, "obs_path", obs_path)
        if partition_format is not None:
            pulumi.set(__self__, "partition_format", partition_format)
        if partitioner_class is not None:
            pulumi.set(__self__, "partitioner_class", partitioner_class)
        if record_delimiter is not None:
            pulumi.set(__self__, "record_delimiter", record_delimiter)
        if schema_generator_class is not None:
            pulumi.set(__self__, "schema_generator_class", schema_generator_class)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if store_keys is not None:
            pulumi.set(__self__, "store_keys", store_keys)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if value_converter is not None:
            pulumi.set(__self__, "value_converter", value_converter)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the access key used to access the OBS bucket.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agency_name", value)

    @_builtins.property
    @pulumi.getter(name="consumerStrategy")
    def consumer_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the consumer strategy of the smart connect task.
        Value options:
        + **latest**: Read the latest data.
        + **earliest**: Read the earliest data.

        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "consumer_strategy")

    @consumer_strategy.setter
    def consumer_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_strategy", value)

    @_builtins.property
    @pulumi.getter(name="deliverTimeInterval")
    def deliver_time_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the deliver time interval of the smart connect task.
        It's **required** when `destination_type` is **OBS_SINK**.
        The value should be between `30` and `900`. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "deliver_time_interval")

    @deliver_time_interval.setter
    def deliver_time_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "deliver_time_interval", value)

    @_builtins.property
    @pulumi.getter(name="destinationFileType")
    def destination_file_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination file type of the smart connect task.
        Only **TEXT** is supported. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "destination_file_type")

    @destination_file_type.setter
    def destination_file_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_file_type", value)

    @_builtins.property
    @pulumi.getter(name="flushSize")
    def flush_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the flush size.
        """
        return pulumi.get(self, "flush_size")

    @flush_size.setter
    def flush_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "flush_size", value)

    @_builtins.property
    @pulumi.getter(name="keyConverter")
    def key_converter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the key converter.
        """
        return pulumi.get(self, "key_converter")

    @key_converter.setter
    def key_converter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_converter", value)

    @_builtins.property
    @pulumi.getter(name="kvDelimiter")
    def kv_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the kv delimiter.
        """
        return pulumi.get(self, "kv_delimiter")

    @kv_delimiter.setter
    def kv_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kv_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="obsBucketName")
    def obs_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the obs bucket name of the smart connect task.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "obs_bucket_name")

    @obs_bucket_name.setter
    def obs_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="obsPartSize")
    def obs_part_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the size of each file to be uploaded.
        """
        return pulumi.get(self, "obs_part_size")

    @obs_part_size.setter
    def obs_part_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "obs_part_size", value)

    @_builtins.property
    @pulumi.getter(name="obsPath")
    def obs_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the obs path of the smart connect task.
        Obs path is separated by a slash. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "obs_path")

    @obs_path.setter
    def obs_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_path", value)

    @_builtins.property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time directory format of the smart connect task.
        Value options: **yyyy**, **yyyy/MM**, **yyyy/MM/dd**, **yyyy/MM/dd/HH**, **yyyy/MM/dd/HH/mm**.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "partition_format")

    @partition_format.setter
    def partition_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partition_format", value)

    @_builtins.property
    @pulumi.getter(name="partitionerClass")
    def partitioner_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the partitioner class.
        """
        return pulumi.get(self, "partitioner_class")

    @partitioner_class.setter
    def partitioner_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "partitioner_class", value)

    @_builtins.property
    @pulumi.getter(name="recordDelimiter")
    def record_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the record delimiter of the smart connect task.
        Value options: **,**, **;**, **|**, **\\n**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "record_delimiter")

    @record_delimiter.setter
    def record_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="schemaGeneratorClass")
    def schema_generator_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the schema generator class.
        """
        return pulumi.get(self, "schema_generator_class")

    @schema_generator_class.setter
    def schema_generator_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_generator_class", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the secret access key used to access the OBS bucket.
        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="storeKeys")
    def store_keys(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to dump keys.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "store_keys")

    @store_keys.setter
    def store_keys(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "store_keys", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the time zone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)

    @_builtins.property
    @pulumi.getter(name="valueConverter")
    def value_converter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the value converter.
        """
        return pulumi.get(self, "value_converter")

    @value_converter.setter
    def value_converter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_converter", value)


if not MYPY:
    class Kafkav2SmartConnectTaskSourceTaskArgsDict(TypedDict):
        compression_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the compression algorithm to use for copying messages.
        Valid values are **none**, **gzip**, **snappy**, **lz4** and **zstd**.
        Changing this parameter will create a new resource.

        <a name="dms_destination_task"></a>
        The `destination_task` block supports:
        """
        consumer_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the consumer strategy of the smart connect task.
        Value options:
        + **latest**: Read the latest data.
        + **earliest**: Read the earliest data.

        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        current_instance_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the current Kafka instance alias.
        Changing this parameter will create a new resource.
        """
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the sync direction. Valid values are:
        + **pull**: Copy the data of the peer Kafka instance to the current Kafka instance.
        + **push**: Copy the data of the current Kafka instance to the peer Kafka instance.
        + **two-way**: Copy the data of the Kafka instances at both ends in both directions.

        Changing this parameter will create a new resource.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the peer Kafka user password.
        It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
        peer_instance_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the peer Kafka instance address list.
        Changing this parameter will create a new resource.

        > Exactly one of `peer_instance_id` and `peer_instance_address` should be specified.
        """
        peer_instance_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the peer Kafka instance alias.
        Changing this parameter will create a new resource.
        """
        peer_instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the peer Kafka instance ID.
        Changing this parameter will create a new resource.
        """
        provenance_header_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the message header contains the message source.
        Changing this parameter will create a new resource.
        """
        rename_topic_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to rename the topic. If true, will add the
        alias of the source Kafka instance before the target topic name to form a new name of the target topic.
        Changing this parameter will create a new resource.
        """
        replication_factor: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of topic replicas. The value of this parameter
        cannot exceed the number of brokers in the peer instance. Changing this parameter will create a new resource.
        """
        sasl_mechanism: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the peer Kafka authentication mode.
        Changing this parameter will create a new resource.
        """
        security_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the peer Kafka authentication. Valid values are:
        + **SASL_SSL**: SASL_SSL is enabled.
        + **PLAINTEXT**: SASL_SSL is disabled.

        Changing this parameter will create a new resource.
        """
        sync_consumer_offsets_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to sync the consumption progress.
        Changing this parameter will create a new resource.
        """
        task_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of data replication tasks.
        If the `direction` is set to **two-way**, the actual number of tasks will be twice the number of tasks you configure here.
        Changing this parameter will create a new resource.
        """
        topics_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the topic mapping string list, which is used to customize
        the target topic name, e.g., topic-sc-1:topic-sc-2. Changing this parameter will create a new resource.

        > When `rename_topic_enabled` is true, `topics_mapping` can not be specified.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the peer Kafka user name.
        It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
elif False:
    Kafkav2SmartConnectTaskSourceTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Kafkav2SmartConnectTaskSourceTaskArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 current_instance_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_instance_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 peer_instance_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 provenance_header_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 rename_topic_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 replication_factor: Optional[pulumi.Input[_builtins.int]] = None,
                 sasl_mechanism: Optional[pulumi.Input[_builtins.str]] = None,
                 security_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 sync_consumer_offsets_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 task_num: Optional[pulumi.Input[_builtins.int]] = None,
                 topics_mappings: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] compression_type: Specifies the compression algorithm to use for copying messages.
               Valid values are **none**, **gzip**, **snappy**, **lz4** and **zstd**.
               Changing this parameter will create a new resource.
               
               <a name="dms_destination_task"></a>
               The `destination_task` block supports:
        :param pulumi.Input[_builtins.str] consumer_strategy: Specifies the consumer strategy of the smart connect task.
               Value options:
               + **latest**: Read the latest data.
               + **earliest**: Read the earliest data.
               
               It's **required** when `destination_type` is **OBS_SINK**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] current_instance_alias: Specifies the current Kafka instance alias.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] direction: Specifies the sync direction. Valid values are:
               + **pull**: Copy the data of the peer Kafka instance to the current Kafka instance.
               + **push**: Copy the data of the current Kafka instance to the peer Kafka instance.
               + **two-way**: Copy the data of the Kafka instances at both ends in both directions.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] password: Specifies the peer Kafka user password.
               It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] peer_instance_addresses: Specifies the peer Kafka instance address list.
               Changing this parameter will create a new resource.
               
               > Exactly one of `peer_instance_id` and `peer_instance_address` should be specified.
        :param pulumi.Input[_builtins.str] peer_instance_alias: Specifies the peer Kafka instance alias.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] peer_instance_id: Specifies the peer Kafka instance ID.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.bool] provenance_header_enabled: Specifies whether the message header contains the message source.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.bool] rename_topic_enabled: Specifies whether to rename the topic. If true, will add the
               alias of the source Kafka instance before the target topic name to form a new name of the target topic.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] replication_factor: Specifies the number of topic replicas. The value of this parameter
               cannot exceed the number of brokers in the peer instance. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] sasl_mechanism: Specifies the peer Kafka authentication mode.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] security_protocol: Specifies the peer Kafka authentication. Valid values are:
               + **SASL_SSL**: SASL_SSL is enabled.
               + **PLAINTEXT**: SASL_SSL is disabled.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.bool] sync_consumer_offsets_enabled: Specifies whether to sync the consumption progress.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] task_num: Specifies the number of data replication tasks.
               If the `direction` is set to **two-way**, the actual number of tasks will be twice the number of tasks you configure here.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] topics_mappings: Specifies the topic mapping string list, which is used to customize
               the target topic name, e.g., topic-sc-1:topic-sc-2. Changing this parameter will create a new resource.
               
               > When `rename_topic_enabled` is true, `topics_mapping` can not be specified.
        :param pulumi.Input[_builtins.str] user_name: Specifies the peer Kafka user name.
               It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if consumer_strategy is not None:
            pulumi.set(__self__, "consumer_strategy", consumer_strategy)
        if current_instance_alias is not None:
            pulumi.set(__self__, "current_instance_alias", current_instance_alias)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if peer_instance_addresses is not None:
            pulumi.set(__self__, "peer_instance_addresses", peer_instance_addresses)
        if peer_instance_alias is not None:
            pulumi.set(__self__, "peer_instance_alias", peer_instance_alias)
        if peer_instance_id is not None:
            pulumi.set(__self__, "peer_instance_id", peer_instance_id)
        if provenance_header_enabled is not None:
            pulumi.set(__self__, "provenance_header_enabled", provenance_header_enabled)
        if rename_topic_enabled is not None:
            pulumi.set(__self__, "rename_topic_enabled", rename_topic_enabled)
        if replication_factor is not None:
            pulumi.set(__self__, "replication_factor", replication_factor)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if security_protocol is not None:
            pulumi.set(__self__, "security_protocol", security_protocol)
        if sync_consumer_offsets_enabled is not None:
            pulumi.set(__self__, "sync_consumer_offsets_enabled", sync_consumer_offsets_enabled)
        if task_num is not None:
            pulumi.set(__self__, "task_num", task_num)
        if topics_mappings is not None:
            pulumi.set(__self__, "topics_mappings", topics_mappings)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the compression algorithm to use for copying messages.
        Valid values are **none**, **gzip**, **snappy**, **lz4** and **zstd**.
        Changing this parameter will create a new resource.

        <a name="dms_destination_task"></a>
        The `destination_task` block supports:
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_type", value)

    @_builtins.property
    @pulumi.getter(name="consumerStrategy")
    def consumer_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the consumer strategy of the smart connect task.
        Value options:
        + **latest**: Read the latest data.
        + **earliest**: Read the earliest data.

        It's **required** when `destination_type` is **OBS_SINK**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "consumer_strategy")

    @consumer_strategy.setter
    def consumer_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_strategy", value)

    @_builtins.property
    @pulumi.getter(name="currentInstanceAlias")
    def current_instance_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the current Kafka instance alias.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "current_instance_alias")

    @current_instance_alias.setter
    def current_instance_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_instance_alias", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the sync direction. Valid values are:
        + **pull**: Copy the data of the peer Kafka instance to the current Kafka instance.
        + **push**: Copy the data of the current Kafka instance to the peer Kafka instance.
        + **two-way**: Copy the data of the Kafka instances at both ends in both directions.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the peer Kafka user password.
        It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="peerInstanceAddresses")
    def peer_instance_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the peer Kafka instance address list.
        Changing this parameter will create a new resource.

        > Exactly one of `peer_instance_id` and `peer_instance_address` should be specified.
        """
        return pulumi.get(self, "peer_instance_addresses")

    @peer_instance_addresses.setter
    def peer_instance_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "peer_instance_addresses", value)

    @_builtins.property
    @pulumi.getter(name="peerInstanceAlias")
    def peer_instance_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the peer Kafka instance alias.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "peer_instance_alias")

    @peer_instance_alias.setter
    def peer_instance_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_instance_alias", value)

    @_builtins.property
    @pulumi.getter(name="peerInstanceId")
    def peer_instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the peer Kafka instance ID.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "peer_instance_id")

    @peer_instance_id.setter
    def peer_instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_instance_id", value)

    @_builtins.property
    @pulumi.getter(name="provenanceHeaderEnabled")
    def provenance_header_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the message header contains the message source.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "provenance_header_enabled")

    @provenance_header_enabled.setter
    def provenance_header_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "provenance_header_enabled", value)

    @_builtins.property
    @pulumi.getter(name="renameTopicEnabled")
    def rename_topic_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to rename the topic. If true, will add the
        alias of the source Kafka instance before the target topic name to form a new name of the target topic.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "rename_topic_enabled")

    @rename_topic_enabled.setter
    def rename_topic_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "rename_topic_enabled", value)

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of topic replicas. The value of this parameter
        cannot exceed the number of brokers in the peer instance. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "replication_factor")

    @replication_factor.setter
    def replication_factor(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replication_factor", value)

    @_builtins.property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the peer Kafka authentication mode.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sasl_mechanism")

    @sasl_mechanism.setter
    def sasl_mechanism(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sasl_mechanism", value)

    @_builtins.property
    @pulumi.getter(name="securityProtocol")
    def security_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the peer Kafka authentication. Valid values are:
        + **SASL_SSL**: SASL_SSL is enabled.
        + **PLAINTEXT**: SASL_SSL is disabled.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "security_protocol")

    @security_protocol.setter
    def security_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_protocol", value)

    @_builtins.property
    @pulumi.getter(name="syncConsumerOffsetsEnabled")
    def sync_consumer_offsets_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to sync the consumption progress.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sync_consumer_offsets_enabled")

    @sync_consumer_offsets_enabled.setter
    def sync_consumer_offsets_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_consumer_offsets_enabled", value)

    @_builtins.property
    @pulumi.getter(name="taskNum")
    def task_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of data replication tasks.
        If the `direction` is set to **two-way**, the actual number of tasks will be twice the number of tasks you configure here.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "task_num")

    @task_num.setter
    def task_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "task_num", value)

    @_builtins.property
    @pulumi.getter(name="topicsMappings")
    def topics_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the topic mapping string list, which is used to customize
        the target topic name, e.g., topic-sc-1:topic-sc-2. Changing this parameter will create a new resource.

        > When `rename_topic_enabled` is true, `topics_mapping` can not be specified.
        """
        return pulumi.get(self, "topics_mappings")

    @topics_mappings.setter
    def topics_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "topics_mappings", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the peer Kafka user name.
        It's **required** when `security_protocol` is **SASL_SSL**. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class RabbitmqExchangeBindingArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the destination.
        """
        destination_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the destination type.
        """
        properties_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the properties key.
        """
        routing_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the routin key.
        """
elif False:
    RabbitmqExchangeBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RabbitmqExchangeBindingArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_type: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_key: Optional[pulumi.Input[_builtins.str]] = None,
                 routing_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Indicates the destination.
        :param pulumi.Input[_builtins.str] destination_type: Indicates the destination type.
        :param pulumi.Input[_builtins.str] properties_key: Indicates the properties key.
        :param pulumi.Input[_builtins.str] routing_key: Indicates the routin key.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if properties_key is not None:
            pulumi.set(__self__, "properties_key", properties_key)
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the destination.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the destination type.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="propertiesKey")
    def properties_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the properties key.
        """
        return pulumi.get(self, "properties_key")

    @properties_key.setter
    def properties_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_key", value)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the routin key.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "routing_key", value)


if not MYPY:
    class RabbitmqQueueConsumerDetailArgsDict(TypedDict):
        ack_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether manual acknowledgement is enabled on the consumer client.
        """
        channel_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['RabbitmqQueueConsumerDetailChannelDetailArgsDict']]]]
        """
        Indicates the consumer connections.
        The channel_details structure is documented below.
        """
        consumer_tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the consumer tag.
        """
        prefetch_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the consumer client preset value.
        """
elif False:
    RabbitmqQueueConsumerDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RabbitmqQueueConsumerDetailArgs:
    def __init__(__self__, *,
                 ack_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 channel_details: Optional[pulumi.Input[Sequence[pulumi.Input['RabbitmqQueueConsumerDetailChannelDetailArgs']]]] = None,
                 consumer_tag: Optional[pulumi.Input[_builtins.str]] = None,
                 prefetch_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] ack_required: Indicates whether manual acknowledgement is enabled on the consumer client.
        :param pulumi.Input[Sequence[pulumi.Input['RabbitmqQueueConsumerDetailChannelDetailArgs']]] channel_details: Indicates the consumer connections.
               The channel_details structure is documented below.
        :param pulumi.Input[_builtins.str] consumer_tag: Indicates the consumer tag.
        :param pulumi.Input[_builtins.int] prefetch_count: Indicates the consumer client preset value.
        """
        if ack_required is not None:
            pulumi.set(__self__, "ack_required", ack_required)
        if channel_details is not None:
            pulumi.set(__self__, "channel_details", channel_details)
        if consumer_tag is not None:
            pulumi.set(__self__, "consumer_tag", consumer_tag)
        if prefetch_count is not None:
            pulumi.set(__self__, "prefetch_count", prefetch_count)

    @_builtins.property
    @pulumi.getter(name="ackRequired")
    def ack_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether manual acknowledgement is enabled on the consumer client.
        """
        return pulumi.get(self, "ack_required")

    @ack_required.setter
    def ack_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ack_required", value)

    @_builtins.property
    @pulumi.getter(name="channelDetails")
    def channel_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RabbitmqQueueConsumerDetailChannelDetailArgs']]]]:
        """
        Indicates the consumer connections.
        The channel_details structure is documented below.
        """
        return pulumi.get(self, "channel_details")

    @channel_details.setter
    def channel_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RabbitmqQueueConsumerDetailChannelDetailArgs']]]]):
        pulumi.set(self, "channel_details", value)

    @_builtins.property
    @pulumi.getter(name="consumerTag")
    def consumer_tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the consumer tag.
        """
        return pulumi.get(self, "consumer_tag")

    @consumer_tag.setter
    def consumer_tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_tag", value)

    @_builtins.property
    @pulumi.getter(name="prefetchCount")
    def prefetch_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the consumer client preset value.
        """
        return pulumi.get(self, "prefetch_count")

    @prefetch_count.setter
    def prefetch_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "prefetch_count", value)


if not MYPY:
    class RabbitmqQueueConsumerDetailChannelDetailArgsDict(TypedDict):
        connection_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the connection details.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the queue name.
        Changing this creates a new resource.
        """
        number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the channel quantity.
        """
        peer_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the IP address of the connected consumer.
        """
        peer_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the port of the process of the connected consumer.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the consumer username. If ACL is enabled, the real username will be returned, otherwise null will
        be returned.
        """
elif False:
    RabbitmqQueueConsumerDetailChannelDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RabbitmqQueueConsumerDetailChannelDetailArgs:
    def __init__(__self__, *,
                 connection_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 number: Optional[pulumi.Input[_builtins.int]] = None,
                 peer_host: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_port: Optional[pulumi.Input[_builtins.int]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_name: Indicates the connection details.
        :param pulumi.Input[_builtins.str] name: Specifies the queue name.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] number: Indicates the channel quantity.
        :param pulumi.Input[_builtins.str] peer_host: Indicates the IP address of the connected consumer.
        :param pulumi.Input[_builtins.int] peer_port: Indicates the port of the process of the connected consumer.
        :param pulumi.Input[_builtins.str] user: Indicates the consumer username. If ACL is enabled, the real username will be returned, otherwise null will
               be returned.
        """
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if peer_host is not None:
            pulumi.set(__self__, "peer_host", peer_host)
        if peer_port is not None:
            pulumi.set(__self__, "peer_port", peer_port)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the connection details.
        """
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the queue name.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the channel quantity.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter(name="peerHost")
    def peer_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the IP address of the connected consumer.
        """
        return pulumi.get(self, "peer_host")

    @peer_host.setter
    def peer_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_host", value)

    @_builtins.property
    @pulumi.getter(name="peerPort")
    def peer_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the port of the process of the connected consumer.
        """
        return pulumi.get(self, "peer_port")

    @peer_port.setter
    def peer_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "peer_port", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the consumer username. If ACL is enabled, the real username will be returned, otherwise null will
        be returned.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class RabbitmqQueueQueueBindingArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the binding target name.
        """
        destination_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the binding target type.
        """
        properties_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the URL-translated routing key.
        """
        routing_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the binding key-value.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the exchange name.
        """
elif False:
    RabbitmqQueueQueueBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RabbitmqQueueQueueBindingArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_type: Optional[pulumi.Input[_builtins.str]] = None,
                 properties_key: Optional[pulumi.Input[_builtins.str]] = None,
                 routing_key: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Indicates the binding target name.
        :param pulumi.Input[_builtins.str] destination_type: Indicates the binding target type.
        :param pulumi.Input[_builtins.str] properties_key: Indicates the URL-translated routing key.
        :param pulumi.Input[_builtins.str] routing_key: Indicates the binding key-value.
        :param pulumi.Input[_builtins.str] source: Indicates the exchange name.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if properties_key is not None:
            pulumi.set(__self__, "properties_key", properties_key)
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the binding target name.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the binding target type.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="propertiesKey")
    def properties_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the URL-translated routing key.
        """
        return pulumi.get(self, "properties_key")

    @properties_key.setter
    def properties_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties_key", value)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the binding key-value.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "routing_key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the exchange name.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class RabbitmqUserVhostArgsDict(TypedDict):
        conf: pulumi.Input[_builtins.str]
        """
        Specifies the granting resource permissions using regular expressions.
        """
        read: pulumi.Input[_builtins.str]
        """
        Specifies the granting resource read permissions using regular expressions.
        """
        vhost: pulumi.Input[_builtins.str]
        """
        Specifies the name of the virtual host to be granted permissions for.
        """
        write: pulumi.Input[_builtins.str]
        """
        Specifies the granting resource write permissions using regular expressions.
        """
elif False:
    RabbitmqUserVhostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RabbitmqUserVhostArgs:
    def __init__(__self__, *,
                 conf: pulumi.Input[_builtins.str],
                 read: pulumi.Input[_builtins.str],
                 vhost: pulumi.Input[_builtins.str],
                 write: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] conf: Specifies the granting resource permissions using regular expressions.
        :param pulumi.Input[_builtins.str] read: Specifies the granting resource read permissions using regular expressions.
        :param pulumi.Input[_builtins.str] vhost: Specifies the name of the virtual host to be granted permissions for.
        :param pulumi.Input[_builtins.str] write: Specifies the granting resource write permissions using regular expressions.
        """
        pulumi.set(__self__, "conf", conf)
        pulumi.set(__self__, "read", read)
        pulumi.set(__self__, "vhost", vhost)
        pulumi.set(__self__, "write", write)

    @_builtins.property
    @pulumi.getter
    def conf(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the granting resource permissions using regular expressions.
        """
        return pulumi.get(self, "conf")

    @conf.setter
    def conf(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "conf", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the granting resource read permissions using regular expressions.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the virtual host to be granted permissions for.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vhost", value)

    @_builtins.property
    @pulumi.getter
    def write(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the granting resource write permissions using regular expressions.
        """
        return pulumi.get(self, "write")

    @write.setter
    def write(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "write", value)


if not MYPY:
    class RocketmqConsumptionVerifyResendResultArgsDict(TypedDict):
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error code.
        """
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error message.
        """
        message_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the message ID.
        """
elif False:
    RocketmqConsumptionVerifyResendResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqConsumptionVerifyResendResultArgs:
    def __init__(__self__, *,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 message_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_code: Indicates the error code.
        :param pulumi.Input[_builtins.str] error_message: Indicates the error message.
        :param pulumi.Input[_builtins.str] message_id: Indicates the message ID.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error code.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error message.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the message ID.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_id", value)


if not MYPY:
    class RocketmqDeadLetterResendResendResultArgsDict(TypedDict):
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error code.
        """
        error_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the error message.
        """
        message_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the message ID.
        """
elif False:
    RocketmqDeadLetterResendResendResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqDeadLetterResendResendResultArgs:
    def __init__(__self__, *,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_message: Optional[pulumi.Input[_builtins.str]] = None,
                 message_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_code: Indicates the error code.
        :param pulumi.Input[_builtins.str] error_message: Indicates the error message.
        :param pulumi.Input[_builtins.str] message_id: Indicates the message ID.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error code.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the error message.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_message", value)

    @_builtins.property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the message ID.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_id", value)


if not MYPY:
    class RocketmqInstanceConfigArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the config name.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the config value.

        > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
elif False:
    RocketmqInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqInstanceConfigArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the config name.
        :param pulumi.Input[_builtins.str] value: Specifies the config value.
               
               > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the config name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the config value.

        > When `name` is **fileReservedTime**, `value` ranges from `1` to `720` and unit is **hour**. Defaults to `48`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RocketmqInstanceCrossVpcAccessArgsDict(TypedDict):
        advertised_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The advertised IP Address or domain name.
        """
        lisenter_ip: NotRequired[pulumi.Input[_builtins.str]]
        listener_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The listener IP address.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number.
        """
        port_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port ID associated with the address.
        """
elif False:
    RocketmqInstanceCrossVpcAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqInstanceCrossVpcAccessArgs:
    def __init__(__self__, *,
                 advertised_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 lisenter_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 listener_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] advertised_ip: The advertised IP Address or domain name.
        :param pulumi.Input[_builtins.str] listener_ip: The listener IP address.
        :param pulumi.Input[_builtins.int] port: The port number.
        :param pulumi.Input[_builtins.str] port_id: The port ID associated with the address.
        """
        if advertised_ip is not None:
            pulumi.set(__self__, "advertised_ip", advertised_ip)
        if lisenter_ip is not None:
            warnings.warn("""typo in lisenter_ip, please use \"listener_ip\" instead.""", DeprecationWarning)
            pulumi.log.warn("""lisenter_ip is deprecated: typo in lisenter_ip, please use \"listener_ip\" instead.""")
        if lisenter_ip is not None:
            pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        if listener_ip is not None:
            pulumi.set(__self__, "listener_ip", listener_ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @_builtins.property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The advertised IP Address or domain name.
        """
        return pulumi.get(self, "advertised_ip")

    @advertised_ip.setter
    def advertised_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "advertised_ip", value)

    @_builtins.property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lisenter_ip")

    @lisenter_ip.setter
    def lisenter_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lisenter_ip", value)

    @_builtins.property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The listener IP address.
        """
        return pulumi.get(self, "listener_ip")

    @listener_ip.setter
    def listener_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_ip", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port ID associated with the address.
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_id", value)


if not MYPY:
    class RocketmqMessageSendPropertyListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the property.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value of the property.
        """
elif False:
    RocketmqMessageSendPropertyListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqMessageSendPropertyListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the property.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the property.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value of the property.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RocketmqMigrationTaskBindingArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the message target. Changing this creates a new resource.
        """
        destination_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the message target type.
        Changing this creates a new resource.
        """
        routing_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the routing key. Changing this creates a new resource.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the message source. Changing this creates a new resource.
        """
        vhost: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
elif False:
    RocketmqMigrationTaskBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqMigrationTaskBindingArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_type: Optional[pulumi.Input[_builtins.str]] = None,
                 routing_key: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 vhost: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the message target. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] destination_type: Specifies the message target type.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] routing_key: Specifies the routing key. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] source: Specifies the message source. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the message target. Changing this creates a new resource.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the message target type.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the routing key. Changing this creates a new resource.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "routing_key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the message source. Changing this creates a new resource.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class RocketmqMigrationTaskExchangeArgsDict(TypedDict):
        durable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the exchange type. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_bindings"></a>
        The `bindings` block supports:
        """
        vhost: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
elif False:
    RocketmqMigrationTaskExchangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqMigrationTaskExchangeArgs:
    def __init__(__self__, *,
                 durable: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 vhost: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] durable: Specifies whether to enable data persistence.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the switch name. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] type: Specifies the exchange type. Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_bindings"></a>
               The `bindings` block supports:
        :param pulumi.Input[_builtins.str] vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if durable is not None:
            pulumi.set(__self__, "durable", durable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def durable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "durable")

    @durable.setter
    def durable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "durable", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the exchange type. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_bindings"></a>
        The `bindings` block supports:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class RocketmqMigrationTaskQueueArgsDict(TypedDict):
        durable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        vhost: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
elif False:
    RocketmqMigrationTaskQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqMigrationTaskQueueArgs:
    def __init__(__self__, *,
                 durable: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 vhost: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] durable: Specifies whether to enable data persistence.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the switch name. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] vhost: Specifies the virtual host name. Changing this creates a new resource.
        """
        if durable is not None:
            pulumi.set(__self__, "durable", durable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vhost is not None:
            pulumi.set(__self__, "vhost", vhost)

    @_builtins.property
    @pulumi.getter
    def durable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable data persistence.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "durable")

    @durable.setter
    def durable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "durable", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def vhost(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the virtual host name. Changing this creates a new resource.
        """
        return pulumi.get(self, "vhost")

    @vhost.setter
    def vhost(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vhost", value)


if not MYPY:
    class RocketmqMigrationTaskSubscriptionGroupArgsDict(TypedDict):
        group_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of a consumer group.
        Changing this creates a new resource.
        """
        consume_broadcast_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable broadcast.
        Changing this creates a new resource.
        """
        consume_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable consumption.
        Changing this creates a new resource.
        """
        consume_from_min_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable consumption from the earliest
        offset. Changing this creates a new resource.
        """
        notify_consumerids_changed_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to notify changes of consumer IDs.
        Changing this creates a new resource.
        """
        retry_max_times: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of consumption retries.
        Changing this creates a new resource.
        """
        retry_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of retry queues.
        Changing this creates a new resource.
        """
        which_broker_when_consume_slow: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the ID of the broker selected for slow
        consumption. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_vhosts"></a>
        The `vhosts` block supports:
        """
elif False:
    RocketmqMigrationTaskSubscriptionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqMigrationTaskSubscriptionGroupArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[_builtins.str],
                 consume_broadcast_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 consume_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 consume_from_min_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 notify_consumerids_changed_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 retry_max_times: Optional[pulumi.Input[_builtins.int]] = None,
                 retry_queue_num: Optional[pulumi.Input[_builtins.int]] = None,
                 which_broker_when_consume_slow: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] group_name: Specifies the name of a consumer group.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] consume_broadcast_enable: Specifies whether to enable broadcast.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] consume_enable: Specifies whether to enable consumption.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] consume_from_min_enable: Specifies whether to enable consumption from the earliest
               offset. Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] notify_consumerids_changed_enable: Specifies whether to notify changes of consumer IDs.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] retry_max_times: Specifies the maximum number of consumption retries.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] retry_queue_num: Specifies the number of retry queues.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] which_broker_when_consume_slow: Specifies the ID of the broker selected for slow
               consumption. Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_vhosts"></a>
               The `vhosts` block supports:
        """
        pulumi.set(__self__, "group_name", group_name)
        if consume_broadcast_enable is not None:
            pulumi.set(__self__, "consume_broadcast_enable", consume_broadcast_enable)
        if consume_enable is not None:
            pulumi.set(__self__, "consume_enable", consume_enable)
        if consume_from_min_enable is not None:
            pulumi.set(__self__, "consume_from_min_enable", consume_from_min_enable)
        if notify_consumerids_changed_enable is not None:
            pulumi.set(__self__, "notify_consumerids_changed_enable", notify_consumerids_changed_enable)
        if retry_max_times is not None:
            pulumi.set(__self__, "retry_max_times", retry_max_times)
        if retry_queue_num is not None:
            pulumi.set(__self__, "retry_queue_num", retry_queue_num)
        if which_broker_when_consume_slow is not None:
            pulumi.set(__self__, "which_broker_when_consume_slow", which_broker_when_consume_slow)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of a consumer group.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="consumeBroadcastEnable")
    def consume_broadcast_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable broadcast.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_broadcast_enable")

    @consume_broadcast_enable.setter
    def consume_broadcast_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "consume_broadcast_enable", value)

    @_builtins.property
    @pulumi.getter(name="consumeEnable")
    def consume_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable consumption.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_enable")

    @consume_enable.setter
    def consume_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "consume_enable", value)

    @_builtins.property
    @pulumi.getter(name="consumeFromMinEnable")
    def consume_from_min_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable consumption from the earliest
        offset. Changing this creates a new resource.
        """
        return pulumi.get(self, "consume_from_min_enable")

    @consume_from_min_enable.setter
    def consume_from_min_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "consume_from_min_enable", value)

    @_builtins.property
    @pulumi.getter(name="notifyConsumeridsChangedEnable")
    def notify_consumerids_changed_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to notify changes of consumer IDs.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "notify_consumerids_changed_enable")

    @notify_consumerids_changed_enable.setter
    def notify_consumerids_changed_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_consumerids_changed_enable", value)

    @_builtins.property
    @pulumi.getter(name="retryMaxTimes")
    def retry_max_times(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of consumption retries.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "retry_max_times")

    @retry_max_times.setter
    def retry_max_times(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retry_max_times", value)

    @_builtins.property
    @pulumi.getter(name="retryQueueNum")
    def retry_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of retry queues.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "retry_queue_num")

    @retry_queue_num.setter
    def retry_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retry_queue_num", value)

    @_builtins.property
    @pulumi.getter(name="whichBrokerWhenConsumeSlow")
    def which_broker_when_consume_slow(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the ID of the broker selected for slow
        consumption. Changing this creates a new resource.

        <a name="RocketMQ_migration_task_vhosts"></a>
        The `vhosts` block supports:
        """
        return pulumi.get(self, "which_broker_when_consume_slow")

    @which_broker_when_consume_slow.setter
    def which_broker_when_consume_slow(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "which_broker_when_consume_slow", value)


if not MYPY:
    class RocketmqMigrationTaskTopicConfigArgsDict(TypedDict):
        topic_name: pulumi.Input[_builtins.str]
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        order: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether a message is an ordered message.
        Changing this creates a new resource.
        """
        perm: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of permission. Changing this creates a new resource.
        """
        read_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of read queues.
        Changing this creates a new resource.
        """
        topic_filter_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the filter type of a topic.
        Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        """
        topic_sys_flag: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the system flag of a topic.
        Changing this creates a new resource.
        """
        write_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of write queues.
        Changing this creates a new resource.

        <a name="RocketMQ_migration_task_subscription_groups"></a>
        The `subscription_groups` block supports:
        """
elif False:
    RocketmqMigrationTaskTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqMigrationTaskTopicConfigArgs:
    def __init__(__self__, *,
                 topic_name: pulumi.Input[_builtins.str],
                 order: Optional[pulumi.Input[_builtins.bool]] = None,
                 perm: Optional[pulumi.Input[_builtins.int]] = None,
                 read_queue_num: Optional[pulumi.Input[_builtins.int]] = None,
                 topic_filter_type: Optional[pulumi.Input[_builtins.str]] = None,
                 topic_sys_flag: Optional[pulumi.Input[_builtins.int]] = None,
                 write_queue_num: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_name: Specifies the topic name. Changing this creates a new resource.
        :param pulumi.Input[_builtins.bool] order: Specifies whether a message is an ordered message.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] perm: Specifies the number of permission. Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] read_queue_num: Specifies the number of read queues.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] topic_filter_type: Specifies the filter type of a topic.
               Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] topic_sys_flag: Specifies the system flag of a topic.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] write_queue_num: Specifies the number of write queues.
               Changing this creates a new resource.
               
               <a name="RocketMQ_migration_task_subscription_groups"></a>
               The `subscription_groups` block supports:
        """
        pulumi.set(__self__, "topic_name", topic_name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)
        if read_queue_num is not None:
            pulumi.set(__self__, "read_queue_num", read_queue_num)
        if topic_filter_type is not None:
            pulumi.set(__self__, "topic_filter_type", topic_filter_type)
        if topic_sys_flag is not None:
            pulumi.set(__self__, "topic_sys_flag", topic_sys_flag)
        if write_queue_num is not None:
            pulumi.set(__self__, "write_queue_num", write_queue_num)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_name", value)

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether a message is an ordered message.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of permission. Changing this creates a new resource.
        """
        return pulumi.get(self, "perm")

    @perm.setter
    def perm(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "perm", value)

    @_builtins.property
    @pulumi.getter(name="readQueueNum")
    def read_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of read queues.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "read_queue_num")

    @read_queue_num.setter
    def read_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_queue_num", value)

    @_builtins.property
    @pulumi.getter(name="topicFilterType")
    def topic_filter_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the filter type of a topic.
        Value options: **SINGLE_TAG**, **MULTI_TAG**. Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_filter_type")

    @topic_filter_type.setter
    def topic_filter_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic_filter_type", value)

    @_builtins.property
    @pulumi.getter(name="topicSysFlag")
    def topic_sys_flag(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the system flag of a topic.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "topic_sys_flag")

    @topic_sys_flag.setter
    def topic_sys_flag(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "topic_sys_flag", value)

    @_builtins.property
    @pulumi.getter(name="writeQueueNum")
    def write_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of write queues.
        Changing this creates a new resource.

        <a name="RocketMQ_migration_task_subscription_groups"></a>
        The `subscription_groups` block supports:
        """
        return pulumi.get(self, "write_queue_num")

    @write_queue_num.setter
    def write_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_queue_num", value)


if not MYPY:
    class RocketmqMigrationTaskVhostArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the switch name. Changing this creates a new resource.
        """
elif False:
    RocketmqMigrationTaskVhostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqMigrationTaskVhostArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the switch name. Changing this creates a new resource.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the switch name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RocketmqTopicBrokerArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the broker.

        <a name="DmsRocketMQTopic_QueueRef"></a>
        The `queues` block supports:
        """
        read_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        write_queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
elif False:
    RocketmqTopicBrokerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqTopicBrokerArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 read_queue_num: Optional[pulumi.Input[_builtins.int]] = None,
                 write_queue_num: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the broker.
               
               <a name="DmsRocketMQTopic_QueueRef"></a>
               The `queues` block supports:
        :param pulumi.Input[_builtins.int] read_queue_num: Indicates the read queues number of the broker. It's useless when create a topic.
        :param pulumi.Input[_builtins.int] write_queue_num: Indicates the read queues number of the broker. It's useless when create a topic.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if read_queue_num is not None:
            pulumi.set(__self__, "read_queue_num", read_queue_num)
        if write_queue_num is not None:
            pulumi.set(__self__, "write_queue_num", write_queue_num)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the broker.

        <a name="DmsRocketMQTopic_QueueRef"></a>
        The `queues` block supports:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="readQueueNum")
    def read_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        return pulumi.get(self, "read_queue_num")

    @read_queue_num.setter
    def read_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "read_queue_num", value)

    @_builtins.property
    @pulumi.getter(name="writeQueueNum")
    def write_queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates the read queues number of the broker. It's useless when create a topic.
        """
        return pulumi.get(self, "write_queue_num")

    @write_queue_num.setter
    def write_queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "write_queue_num", value)


if not MYPY:
    class RocketmqTopicQueueArgsDict(TypedDict):
        broker: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the associated broker.
        """
        queue_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of the queues.
        """
elif False:
    RocketmqTopicQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqTopicQueueArgs:
    def __init__(__self__, *,
                 broker: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_num: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] broker: Specifies the associated broker.
        :param pulumi.Input[_builtins.int] queue_num: Specifies the number of the queues.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if queue_num is not None:
            pulumi.set(__self__, "queue_num", queue_num)

    @_builtins.property
    @pulumi.getter
    def broker(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the associated broker.
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "broker", value)

    @_builtins.property
    @pulumi.getter(name="queueNum")
    def queue_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of the queues.
        """
        return pulumi.get(self, "queue_num")

    @queue_num.setter
    def queue_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "queue_num", value)


if not MYPY:
    class RocketmqUserGroupPermArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of a topic or consumer group.
        """
        perm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
elif False:
    RocketmqUserGroupPermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqUserGroupPermArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 perm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Indicates the name of a topic or consumer group.
        :param pulumi.Input[_builtins.str] perm: Indicates the permissions of the topic or consumer group.
               Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of a topic or consumer group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")

    @perm.setter
    def perm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "perm", value)


if not MYPY:
    class RocketmqUserTopicPermArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the name of a topic or consumer group.
        """
        perm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
elif False:
    RocketmqUserTopicPermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RocketmqUserTopicPermArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 perm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Indicates the name of a topic or consumer group.
        :param pulumi.Input[_builtins.str] perm: Indicates the permissions of the topic or consumer group.
               Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if perm is not None:
            pulumi.set(__self__, "perm", perm)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the name of a topic or consumer group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def perm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the permissions of the topic or consumer group.
        Value options: **PUB|SUB**, **PUB**, **SUB**, **DENY**.
        """
        return pulumi.get(self, "perm")

    @perm.setter
    def perm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "perm", value)


