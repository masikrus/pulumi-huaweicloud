# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AlarmActionRuleSmnTopic',
    'AlarmGroupRuleDetail',
    'AlarmGroupRuleDetailMatch',
    'AlarmPolicyAlarmNotification',
    'AlarmPolicyEventAlarmSpec',
    'AlarmPolicyEventAlarmSpecAlarmTag',
    'AlarmPolicyEventAlarmSpecNoDataCondition',
    'AlarmPolicyMetricAlarmSpec',
    'AlarmPolicyMetricAlarmSpecAlarmTag',
    'AlarmPolicyMetricAlarmSpecNoDataCondition',
    'AlarmPolicyMetricAlarmSpecTriggerCondition',
    'AlarmRuleDimension',
    'AlarmRuleV4AlarmNotifications',
    'AlarmRuleV4EventAlarmSpec',
    'AlarmRuleV4EventAlarmSpecTriggerCondition',
    'AlarmRuleV4MetricAlarmSpec',
    'AlarmRuleV4MetricAlarmSpecAlarmTags',
    'AlarmRuleV4MetricAlarmSpecNoDataConditions',
    'AlarmRuleV4MetricAlarmSpecRecoveryConditions',
    'AlarmRuleV4MetricAlarmSpecTriggerCondition',
    'AlarmRulesTemplateAlarmTemplateSpecList',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmNotification',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItem',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpec',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerCondition',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpec',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTags',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditions',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditions',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerCondition',
    'AlarmRulesTemplateTemplating',
    'AlarmRulesTemplateTemplatingList',
    'AlarmSilenceRuleSilenceCondition',
    'AlarmSilenceRuleSilenceConditionCondition',
    'AlarmSilenceRuleSilenceTime',
    'EnvironmentEnvTag',
    'MessageTemplateTemplate',
    'MultiAccountAggregationRuleAccount',
    'MultiAccountAggregationRuleService',
    'PrometheusInstancePromForCloudService',
    'ServiceDiscoveryRuleDiscoveryRule',
    'ServiceDiscoveryRuleLogPathRule',
    'ServiceDiscoveryRuleNameRules',
    'ServiceDiscoveryRuleNameRulesApplicationNameRule',
    'ServiceDiscoveryRuleNameRulesServiceNameRule',
    'GetAccessCodesAccessCodeResult',
    'GetAggregationMetricsServiceMetricResult',
    'GetAlarmActionRulesActionRuleResult',
    'GetAlarmActionRulesActionRuleSmnTopicResult',
    'GetAlarmGroupRulesRuleResult',
    'GetAlarmGroupRulesRuleDetailResult',
    'GetAlarmGroupRulesRuleDetailMatchResult',
    'GetAlarmRulesAlarmRuleResult',
    'GetAlarmRulesAlarmRuleAlarmNotificationResult',
    'GetAlarmRulesAlarmRuleEventAlarmSpecResult',
    'GetAlarmRulesAlarmRuleEventAlarmSpecTriggerConditionResult',
    'GetAlarmRulesAlarmRuleMetricAlarmSpecResult',
    'GetAlarmRulesAlarmRuleMetricAlarmSpecAlarmTagResult',
    'GetAlarmRulesAlarmRuleMetricAlarmSpecNoDataConditionResult',
    'GetAlarmRulesAlarmRuleMetricAlarmSpecRecoveryConditionResult',
    'GetAlarmRulesAlarmRuleMetricAlarmSpecTriggerConditionResult',
    'GetAlarmRulesTemplatesTemplateResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmNotificationResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionResult',
    'GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionResult',
    'GetAlarmRulesTemplatesTemplateTemplatingResult',
    'GetAlarmRulesTemplatesTemplateTemplatingListResult',
    'GetAlarmSilenceRulesRuleResult',
    'GetAlarmSilenceRulesRuleSilenceConditionResult',
    'GetAlarmSilenceRulesRuleSilenceConditionConditionResult',
    'GetAlarmSilenceRulesRuleSilenceTimeResult',
    'GetCloudServiceAuthorizationsAuthorizationResult',
    'GetDashboardsDashboardResult',
    'GetDashboardsFoldersFolderResult',
    'GetMessageTemplatesMessageTemplateResult',
    'GetMessageTemplatesMessageTemplateTemplateResult',
    'GetMultiAccountAggregationRulesRuleResult',
    'GetMultiAccountAggregationRulesRuleAccountResult',
    'GetMultiAccountAggregationRulesRuleServiceResult',
    'GetOrganizationAccountsAccountResult',
    'GetPromInstancesInstanceResult',
    'GetServiceDiscoveryRulesRuleResult',
    'GetServiceDiscoveryRulesRuleDiscoveryRuleResult',
    'GetServiceDiscoveryRulesRuleLogPathRuleResult',
    'GetServiceDiscoveryRulesRuleNameRuleResult',
    'GetServiceDiscoveryRulesRuleNameRuleApplicationNameRuleResult',
    'GetServiceDiscoveryRulesRuleNameRuleServiceNameRuleResult',
]

@pulumi.output_type
class AlarmActionRuleSmnTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicUrn":
            suggest = "topic_urn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmActionRuleSmnTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmActionRuleSmnTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmActionRuleSmnTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_urn: _builtins.str,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str topic_urn: Specifies the SMN topic URN.
        :param _builtins.str name: Specifies the SMN topic name.
        """
        pulumi.set(__self__, "topic_urn", topic_urn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the SMN topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the SMN topic name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AlarmGroupRuleDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindNotificationRuleIds":
            suggest = "bind_notification_rule_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmGroupRuleDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmGroupRuleDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmGroupRuleDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_notification_rule_ids: Sequence[_builtins.str],
                 matches: Sequence['outputs.AlarmGroupRuleDetailMatch']):
        """
        :param Sequence[_builtins.str] bind_notification_rule_ids: Specifies the action rule IDs.
        :param Sequence['AlarmGroupRuleDetailMatchArgs'] matches: Specifies the matching conditions list.
               The match structure is documented below.
               
               <a name="block--detail--match"></a>
               The `match` block supports:
        """
        pulumi.set(__self__, "bind_notification_rule_ids", bind_notification_rule_ids)
        pulumi.set(__self__, "matches", matches)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleIds")
    def bind_notification_rule_ids(self) -> Sequence[_builtins.str]:
        """
        Specifies the action rule IDs.
        """
        return pulumi.get(self, "bind_notification_rule_ids")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.AlarmGroupRuleDetailMatch']:
        """
        Specifies the matching conditions list.
        The match structure is documented below.

        <a name="block--detail--match"></a>
        The `match` block supports:
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class AlarmGroupRuleDetailMatch(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operate: _builtins.str,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: Specifies the matching condition key.
               Valid value are as follows, or using specific key means taking tag as condition:
               + **event_severity**: event severity
               + **notification_scene**: notification scene
               + **resource_provider**: alarm source
               + **resource_type**: resource type
        :param _builtins.str operate: Specifies the matching condition operator. Valid values are **EQUALS**, **REGEX**, **EXIST**.
        :param Sequence[_builtins.str] values: Specifies the matching condition value.
               + If `operate` is **EXIST**, it should be empty.
               + If `operate` is **REGEX**, it should be a regex expression.
               + If `operate` is **EQUALS**, it depends on `key`, can be as follows:
               - If `key` is **event_severity**, it can be **Critical**, **Major**, **Minor**, **Info**.
               - If `key` is **notification_scene**, it can be **notify_resolved**, **notify_triggered**.
               - If `key` is **resource_provider**, it can be specific alarm source.
               - If `key` is **resource_type**, it can be **cce-cluster**, **cluster**, **clusters-clustercert**, **clusters-nodepools**,
               **clusters-nodes**, **configmaps**, **deployments**, **ingresses**, **jobs**, **node**, **pods**,
               **podsecuritypolicies**, **releases**, **rolebindings**, **roles**, **routes**, **secrets**, **service**.
               - If `key` is specific key, it can be specific values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operate", operate)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the matching condition key.
        Valid value are as follows, or using specific key means taking tag as condition:
        + **event_severity**: event severity
        + **notification_scene**: notification scene
        + **resource_provider**: alarm source
        + **resource_type**: resource type
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operate(self) -> _builtins.str:
        """
        Specifies the matching condition operator. Valid values are **EQUALS**, **REGEX**, **EXIST**.
        """
        return pulumi.get(self, "operate")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the matching condition value.
        + If `operate` is **EXIST**, it should be empty.
        + If `operate` is **REGEX**, it should be a regex expression.
        + If `operate` is **EQUALS**, it depends on `key`, can be as follows:
        - If `key` is **event_severity**, it can be **Critical**, **Major**, **Minor**, **Info**.
        - If `key` is **notification_scene**, it can be **notify_resolved**, **notify_triggered**.
        - If `key` is **resource_provider**, it can be specific alarm source.
        - If `key` is **resource_type**, it can be **cce-cluster**, **cluster**, **clusters-clustercert**, **clusters-nodepools**,
        **clusters-nodes**, **configmaps**, **deployments**, **ingresses**, **jobs**, **node**, **pods**,
        **podsecuritypolicies**, **releases**, **rolebindings**, **roles**, **routes**, **secrets**, **service**.
        - If `key` is specific key, it can be specific values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlarmPolicyAlarmNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindNotificationRuleId":
            suggest = "bind_notification_rule_id"
        elif key == "inhibitEnable":
            suggest = "inhibit_enable"
        elif key == "inhibitRule":
            suggest = "inhibit_rule"
        elif key == "notificationEnable":
            suggest = "notification_enable"
        elif key == "notificationType":
            suggest = "notification_type"
        elif key == "notifyResolved":
            suggest = "notify_resolved"
        elif key == "routeGroupEnable":
            suggest = "route_group_enable"
        elif key == "routeGroupRule":
            suggest = "route_group_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyAlarmNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyAlarmNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyAlarmNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_notification_rule_id: Optional[_builtins.str] = None,
                 inhibit_enable: Optional[_builtins.bool] = None,
                 inhibit_rule: Optional[_builtins.str] = None,
                 notification_enable: Optional[_builtins.bool] = None,
                 notification_type: Optional[_builtins.str] = None,
                 notify_resolved: Optional[_builtins.bool] = None,
                 route_group_enable: Optional[_builtins.bool] = None,
                 route_group_rule: Optional[_builtins.str] = None):
        if bind_notification_rule_id is not None:
            pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        if inhibit_enable is not None:
            pulumi.set(__self__, "inhibit_enable", inhibit_enable)
        if inhibit_rule is not None:
            pulumi.set(__self__, "inhibit_rule", inhibit_rule)
        if notification_enable is not None:
            pulumi.set(__self__, "notification_enable", notification_enable)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)
        if notify_resolved is not None:
            pulumi.set(__self__, "notify_resolved", notify_resolved)
        if route_group_enable is not None:
            pulumi.set(__self__, "route_group_enable", route_group_enable)
        if route_group_rule is not None:
            pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bind_notification_rule_id")

    @_builtins.property
    @pulumi.getter(name="inhibitEnable")
    def inhibit_enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "inhibit_enable")

    @_builtins.property
    @pulumi.getter(name="inhibitRule")
    def inhibit_rule(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inhibit_rule")

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notification_enable")

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notify_resolved")

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "route_group_enable")

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_group_rule")


@pulumi.output_type
class AlarmPolicyEventAlarmSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmTags":
            suggest = "alarm_tags"
        elif key == "eventSource":
            suggest = "event_source"
        elif key == "monitorObjects":
            suggest = "monitor_objects"
        elif key == "noDataConditions":
            suggest = "no_data_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyEventAlarmSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyEventAlarmSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyEventAlarmSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_tags: Optional[Sequence['outputs.AlarmPolicyEventAlarmSpecAlarmTag']] = None,
                 event_source: Optional[_builtins.str] = None,
                 monitor_objects: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 no_data_conditions: Optional[Sequence['outputs.AlarmPolicyEventAlarmSpecNoDataCondition']] = None):
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if event_source is not None:
            pulumi.set(__self__, "event_source", event_source)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional[Sequence['outputs.AlarmPolicyEventAlarmSpecAlarmTag']]:
        return pulumi.get(self, "alarm_tags")

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "event_source")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional[Sequence['outputs.AlarmPolicyEventAlarmSpecNoDataCondition']]:
        return pulumi.get(self, "no_data_conditions")


@pulumi.output_type
class AlarmPolicyEventAlarmSpecAlarmTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoTags":
            suggest = "auto_tags"
        elif key == "customAnnotations":
            suggest = "custom_annotations"
        elif key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyEventAlarmSpecAlarmTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyEventAlarmSpecAlarmTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyEventAlarmSpecAlarmTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_tags: Optional[Sequence[_builtins.str]] = None,
                 custom_annotations: Optional[Sequence[_builtins.str]] = None,
                 custom_tags: Optional[Sequence[_builtins.str]] = None):
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "auto_tags")

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "custom_annotations")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class AlarmPolicyEventAlarmSpecNoDataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noDataAlertState":
            suggest = "no_data_alert_state"
        elif key == "noDataTimeframe":
            suggest = "no_data_timeframe"
        elif key == "notifyNoData":
            suggest = "notify_no_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyEventAlarmSpecNoDataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyEventAlarmSpecNoDataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyEventAlarmSpecNoDataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_data_alert_state: Optional[_builtins.str] = None,
                 no_data_timeframe: Optional[_builtins.int] = None,
                 notify_no_data: Optional[_builtins.bool] = None):
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "no_data_alert_state")

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "no_data_timeframe")

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notify_no_data")


@pulumi.output_type
class AlarmPolicyMetricAlarmSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorType":
            suggest = "monitor_type"
        elif key == "alarmRuleTemplateBindEnable":
            suggest = "alarm_rule_template_bind_enable"
        elif key == "alarmRuleTemplateId":
            suggest = "alarm_rule_template_id"
        elif key == "alarmTags":
            suggest = "alarm_tags"
        elif key == "metricKind":
            suggest = "metric_kind"
        elif key == "monitorObjects":
            suggest = "monitor_objects"
        elif key == "noDataConditions":
            suggest = "no_data_conditions"
        elif key == "recoveryConditions":
            suggest = "recovery_conditions"
        elif key == "resourceKind":
            suggest = "resource_kind"
        elif key == "triggerConditions":
            suggest = "trigger_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyMetricAlarmSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyMetricAlarmSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyMetricAlarmSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_type: _builtins.str,
                 alarm_rule_template_bind_enable: Optional[_builtins.bool] = None,
                 alarm_rule_template_id: Optional[_builtins.str] = None,
                 alarm_tags: Optional[Sequence['outputs.AlarmPolicyMetricAlarmSpecAlarmTag']] = None,
                 metric_kind: Optional[_builtins.str] = None,
                 monitor_objects: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 no_data_conditions: Optional[Sequence['outputs.AlarmPolicyMetricAlarmSpecNoDataCondition']] = None,
                 recovery_conditions: Optional[Mapping[str, _builtins.int]] = None,
                 resource_kind: Optional[_builtins.str] = None,
                 trigger_conditions: Optional[Sequence['outputs.AlarmPolicyMetricAlarmSpecTriggerCondition']] = None):
        pulumi.set(__self__, "monitor_type", monitor_type)
        if alarm_rule_template_bind_enable is not None:
            pulumi.set(__self__, "alarm_rule_template_bind_enable", alarm_rule_template_bind_enable)
        if alarm_rule_template_id is not None:
            pulumi.set(__self__, "alarm_rule_template_id", alarm_rule_template_id)
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if metric_kind is not None:
            pulumi.set(__self__, "metric_kind", metric_kind)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        if recovery_conditions is not None:
            pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        if resource_kind is not None:
            pulumi.set(__self__, "resource_kind", resource_kind)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> _builtins.str:
        return pulumi.get(self, "monitor_type")

    @_builtins.property
    @pulumi.getter(name="alarmRuleTemplateBindEnable")
    def alarm_rule_template_bind_enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alarm_rule_template_bind_enable")

    @_builtins.property
    @pulumi.getter(name="alarmRuleTemplateId")
    def alarm_rule_template_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "alarm_rule_template_id")

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional[Sequence['outputs.AlarmPolicyMetricAlarmSpecAlarmTag']]:
        return pulumi.get(self, "alarm_tags")

    @_builtins.property
    @pulumi.getter(name="metricKind")
    def metric_kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_kind")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional[Sequence['outputs.AlarmPolicyMetricAlarmSpecNoDataCondition']]:
        return pulumi.get(self, "no_data_conditions")

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> Optional[Mapping[str, _builtins.int]]:
        return pulumi.get(self, "recovery_conditions")

    @_builtins.property
    @pulumi.getter(name="resourceKind")
    def resource_kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_kind")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[Sequence['outputs.AlarmPolicyMetricAlarmSpecTriggerCondition']]:
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class AlarmPolicyMetricAlarmSpecAlarmTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoTags":
            suggest = "auto_tags"
        elif key == "customAnnotations":
            suggest = "custom_annotations"
        elif key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyMetricAlarmSpecAlarmTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyMetricAlarmSpecAlarmTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyMetricAlarmSpecAlarmTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_tags: Optional[Sequence[_builtins.str]] = None,
                 custom_annotations: Optional[Sequence[_builtins.str]] = None,
                 custom_tags: Optional[Sequence[_builtins.str]] = None):
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "auto_tags")

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "custom_annotations")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class AlarmPolicyMetricAlarmSpecNoDataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noDataAlertState":
            suggest = "no_data_alert_state"
        elif key == "noDataTimeframe":
            suggest = "no_data_timeframe"
        elif key == "notifyNoData":
            suggest = "notify_no_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyMetricAlarmSpecNoDataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyMetricAlarmSpecNoDataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyMetricAlarmSpecNoDataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_data_alert_state: Optional[_builtins.str] = None,
                 no_data_timeframe: Optional[_builtins.int] = None,
                 notify_no_data: Optional[_builtins.bool] = None):
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "no_data_alert_state")

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "no_data_timeframe")

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notify_no_data")


@pulumi.output_type
class AlarmPolicyMetricAlarmSpecTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "aggregationWindow":
            suggest = "aggregation_window"
        elif key == "metricLabels":
            suggest = "metric_labels"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricQueryMode":
            suggest = "metric_query_mode"
        elif key == "metricUnit":
            suggest = "metric_unit"
        elif key == "triggerInterval":
            suggest = "trigger_interval"
        elif key == "triggerTimes":
            suggest = "trigger_times"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmPolicyMetricAlarmSpecTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmPolicyMetricAlarmSpecTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmPolicyMetricAlarmSpecTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: Optional[_builtins.str] = None,
                 aggregation_window: Optional[_builtins.str] = None,
                 metric_labels: Optional[Sequence[_builtins.str]] = None,
                 metric_name: Optional[_builtins.str] = None,
                 metric_namespace: Optional[_builtins.str] = None,
                 metric_query_mode: Optional[_builtins.str] = None,
                 metric_unit: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 promql: Optional[_builtins.str] = None,
                 thresholds: Optional[Mapping[str, _builtins.str]] = None,
                 trigger_interval: Optional[_builtins.str] = None,
                 trigger_times: Optional[_builtins.int] = None,
                 trigger_type: Optional[_builtins.str] = None):
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if metric_labels is not None:
            pulumi.set(__self__, "metric_labels", metric_labels)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_query_mode is not None:
            pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        if metric_unit is not None:
            pulumi.set(__self__, "metric_unit", metric_unit)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if promql is not None:
            pulumi.set(__self__, "promql", promql)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)
        if trigger_interval is not None:
            pulumi.set(__self__, "trigger_interval", trigger_interval)
        if trigger_times is not None:
            pulumi.set(__self__, "trigger_times", trigger_times)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "metric_labels")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_query_mode")

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metric_unit")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def promql(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "promql")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "thresholds")

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trigger_interval")

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "trigger_times")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class AlarmRuleDimension(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Specifies the dimension name. Changing this creates a new resource.
        :param _builtins.str value: Specifies the dimension value. Changing this creates a new resource.
               
               > **NOTE:** You can get more information about `metric_name`, `namespace`, `unit` and `dimensions`
               from [Metric Overview](https://support.huaweicloud.com/intl/en-us/productdesc-aom/aom_06_0014.html).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the dimension name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the dimension value. Changing this creates a new resource.

        > **NOTE:** You can get more information about `metric_name`, `namespace`, `unit` and `dimensions`
        from [Metric Overview](https://support.huaweicloud.com/intl/en-us/productdesc-aom/aom_06_0014.html).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlarmRuleV4AlarmNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationType":
            suggest = "notification_type"
        elif key == "bindNotificationRuleId":
            suggest = "bind_notification_rule_id"
        elif key == "notificationEnable":
            suggest = "notification_enable"
        elif key == "notifyFrequency":
            suggest = "notify_frequency"
        elif key == "notifyResolved":
            suggest = "notify_resolved"
        elif key == "notifyTriggered":
            suggest = "notify_triggered"
        elif key == "routeGroupEnable":
            suggest = "route_group_enable"
        elif key == "routeGroupRule":
            suggest = "route_group_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4AlarmNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4AlarmNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4AlarmNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification_type: _builtins.str,
                 bind_notification_rule_id: Optional[_builtins.str] = None,
                 notification_enable: Optional[_builtins.bool] = None,
                 notify_frequency: Optional[_builtins.str] = None,
                 notify_resolved: Optional[_builtins.bool] = None,
                 notify_triggered: Optional[_builtins.bool] = None,
                 route_group_enable: Optional[_builtins.bool] = None,
                 route_group_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str notification_type: Specifies the notification type.
               Valid values are as follows:
               + **direct**: Direct alarm reporting.
               + **alarm_policy**: Alarm reporting after noise reduction.
        :param _builtins.str bind_notification_rule_id: Specifies the alarm action rule ID.
               It's required if `notification_enable` is **true**.
        :param _builtins.bool notification_enable: Specifies whether to enable an alarm action rule. Defaults to **false**.
               If the `notification_type` is **direct**, set this parameter to **true**.
        :param _builtins.str notify_frequency: Specifies the notification frequency.
               If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
               If the `notification_type` is **direct**, set this parameter to any of the following:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
               
               <a name="block--event_alarm_spec"></a>
               The `event_alarm_spec` block supports:
        :param _builtins.bool notify_resolved: Specifies whether to send a notification when an alarm is cleared.
               Defaults to **false**.
        :param _builtins.bool notify_triggered: Specifies whether to send a notification when an alarm is triggered.
               Defaults to **false**.
        :param _builtins.bool route_group_enable: Specifies whether to enable the grouping rule. Defaults to **false**.
               If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        :param _builtins.str route_group_rule: Specifies the grouping rule name.
               It's required if `route_group_enable` is **true**.
        """
        pulumi.set(__self__, "notification_type", notification_type)
        if bind_notification_rule_id is not None:
            pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        if notification_enable is not None:
            pulumi.set(__self__, "notification_enable", notification_enable)
        if notify_frequency is not None:
            pulumi.set(__self__, "notify_frequency", notify_frequency)
        if notify_resolved is not None:
            pulumi.set(__self__, "notify_resolved", notify_resolved)
        if notify_triggered is not None:
            pulumi.set(__self__, "notify_triggered", notify_triggered)
        if route_group_enable is not None:
            pulumi.set(__self__, "route_group_enable", route_group_enable)
        if route_group_rule is not None:
            pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> _builtins.str:
        """
        Specifies the notification type.
        Valid values are as follows:
        + **direct**: Direct alarm reporting.
        + **alarm_policy**: Alarm reporting after noise reduction.
        """
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm action rule ID.
        It's required if `notification_enable` is **true**.
        """
        return pulumi.get(self, "bind_notification_rule_id")

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable an alarm action rule. Defaults to **false**.
        If the `notification_type` is **direct**, set this parameter to **true**.
        """
        return pulumi.get(self, "notification_enable")

    @_builtins.property
    @pulumi.getter(name="notifyFrequency")
    def notify_frequency(self) -> Optional[_builtins.str]:
        """
        Specifies the notification frequency.
        If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
        If the `notification_type` is **direct**, set this parameter to any of the following:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day

        <a name="block--event_alarm_spec"></a>
        The `event_alarm_spec` block supports:
        """
        return pulumi.get(self, "notify_frequency")

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to send a notification when an alarm is cleared.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_resolved")

    @_builtins.property
    @pulumi.getter(name="notifyTriggered")
    def notify_triggered(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to send a notification when an alarm is triggered.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_triggered")

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable the grouping rule. Defaults to **false**.
        If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        """
        return pulumi.get(self, "route_group_enable")

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> Optional[_builtins.str]:
        """
        Specifies the grouping rule name.
        It's required if `route_group_enable` is **true**.
        """
        return pulumi.get(self, "route_group_rule")


@pulumi.output_type
class AlarmRuleV4EventAlarmSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmSource":
            suggest = "alarm_source"
        elif key == "eventSource":
            suggest = "event_source"
        elif key == "monitorObjects":
            suggest = "monitor_objects"
        elif key == "triggerConditions":
            suggest = "trigger_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4EventAlarmSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4EventAlarmSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4EventAlarmSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_source: _builtins.str,
                 event_source: _builtins.str,
                 monitor_objects: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 trigger_conditions: Optional[Sequence['outputs.AlarmRuleV4EventAlarmSpecTriggerCondition']] = None):
        """
        :param _builtins.str alarm_source: Specifies the alarm rule source.
               Valid values are **systemEvent** and **customEvent**.
               Changing this creates a new resource.
        :param _builtins.str event_source: Specifies the alarm source.
               Valid values are **RDS**, **EVS**, **CCE**, **LTS** and **AOM**.
        :param Sequence[Mapping[str, _builtins.str]] monitor_objects: Specifies the monitored objects. It's an array of Map objects.
               
               <a name="block--metric_alarm_spec--recovery_conditions"></a>
               The `recovery_conditions` block supports:
        :param Sequence['AlarmRuleV4EventAlarmSpecTriggerConditionArgs'] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions structure is documented below.
        """
        pulumi.set(__self__, "alarm_source", alarm_source)
        pulumi.set(__self__, "event_source", event_source)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> _builtins.str:
        """
        Specifies the alarm rule source.
        Valid values are **systemEvent** and **customEvent**.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "alarm_source")

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> _builtins.str:
        """
        Specifies the alarm source.
        Valid values are **RDS**, **EVS**, **CCE**, **LTS** and **AOM**.
        """
        return pulumi.get(self, "event_source")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        """
        Specifies the monitored objects. It's an array of Map objects.

        <a name="block--metric_alarm_spec--recovery_conditions"></a>
        The `recovery_conditions` block supports:
        """
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[Sequence['outputs.AlarmRuleV4EventAlarmSpecTriggerCondition']]:
        """
        Specifies the trigger conditions.
        The trigger_conditions structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class AlarmRuleV4EventAlarmSpecTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "aggregationWindow":
            suggest = "aggregation_window"
        elif key == "eventName":
            suggest = "event_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4EventAlarmSpecTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4EventAlarmSpecTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4EventAlarmSpecTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_type: _builtins.str,
                 aggregation_window: Optional[_builtins.int] = None,
                 event_name: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 thresholds: Optional[Mapping[str, _builtins.int]] = None):
        """
        :param _builtins.str trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        :param _builtins.int aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param _builtins.str event_name: Specifies the event name.
        :param _builtins.str frequency: Specifies the event alarm notification frequency. Leave this parameter empty if
               `trigger_type` is set to **immediately**. Valid values are as follows:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
        :param _builtins.str operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param Mapping[str, _builtins.int] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        """
        pulumi.set(__self__, "trigger_type", trigger_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if event_name is not None:
            pulumi.set(__self__, "event_name", event_name)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[_builtins.int]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> Optional[_builtins.str]:
        """
        Specifies the event name.
        """
        return pulumi.get(self, "event_name")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        Specifies the event alarm notification frequency. Leave this parameter empty if
        `trigger_type` is set to **immediately**. Valid values are as follows:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[Mapping[str, _builtins.int]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class AlarmRuleV4MetricAlarmSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorType":
            suggest = "monitor_type"
        elif key == "recoveryConditions":
            suggest = "recovery_conditions"
        elif key == "alarmTags":
            suggest = "alarm_tags"
        elif key == "monitorObjects":
            suggest = "monitor_objects"
        elif key == "noDataConditions":
            suggest = "no_data_conditions"
        elif key == "triggerConditions":
            suggest = "trigger_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4MetricAlarmSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4MetricAlarmSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4MetricAlarmSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_type: _builtins.str,
                 recovery_conditions: 'outputs.AlarmRuleV4MetricAlarmSpecRecoveryConditions',
                 alarm_tags: Optional['outputs.AlarmRuleV4MetricAlarmSpecAlarmTags'] = None,
                 monitor_objects: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 no_data_conditions: Optional['outputs.AlarmRuleV4MetricAlarmSpecNoDataConditions'] = None,
                 trigger_conditions: Optional[Sequence['outputs.AlarmRuleV4MetricAlarmSpecTriggerCondition']] = None):
        """
        :param _builtins.str monitor_type: Specifies the monitoring type.
               Valid values are as follows:
               + **all_metric**: Select metrics from all metrics.
               + **promql**: Select metrics using PromQL.
               
               Changing this creates a new resource.
        :param 'AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgs' recovery_conditions: Specifies the alarm clearance condition.
               The recovery_conditions structure is documented below.
        :param 'AlarmRuleV4MetricAlarmSpecAlarmTagsArgs' alarm_tags: Specifies the alarm tags.
               The alarm_tags structure is documented below.
        :param Sequence[Mapping[str, _builtins.str]] monitor_objects: Specifies the monitored objects. It's an array of Map objects.
               
               <a name="block--metric_alarm_spec--recovery_conditions"></a>
               The `recovery_conditions` block supports:
        :param 'AlarmRuleV4MetricAlarmSpecNoDataConditionsArgs' no_data_conditions: Specifies the action taken for insufficient data.
               The no_data_conditions structure is documented below.
        :param Sequence['AlarmRuleV4MetricAlarmSpecTriggerConditionArgs'] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions structure is documented below.
        """
        pulumi.set(__self__, "monitor_type", monitor_type)
        pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> _builtins.str:
        """
        Specifies the monitoring type.
        Valid values are as follows:
        + **all_metric**: Select metrics from all metrics.
        + **promql**: Select metrics using PromQL.

        Changing this creates a new resource.
        """
        return pulumi.get(self, "monitor_type")

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> 'outputs.AlarmRuleV4MetricAlarmSpecRecoveryConditions':
        """
        Specifies the alarm clearance condition.
        The recovery_conditions structure is documented below.
        """
        return pulumi.get(self, "recovery_conditions")

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional['outputs.AlarmRuleV4MetricAlarmSpecAlarmTags']:
        """
        Specifies the alarm tags.
        The alarm_tags structure is documented below.
        """
        return pulumi.get(self, "alarm_tags")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        """
        Specifies the monitored objects. It's an array of Map objects.

        <a name="block--metric_alarm_spec--recovery_conditions"></a>
        The `recovery_conditions` block supports:
        """
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional['outputs.AlarmRuleV4MetricAlarmSpecNoDataConditions']:
        """
        Specifies the action taken for insufficient data.
        The no_data_conditions structure is documented below.
        """
        return pulumi.get(self, "no_data_conditions")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[Sequence['outputs.AlarmRuleV4MetricAlarmSpecTriggerCondition']]:
        """
        Specifies the trigger conditions.
        The trigger_conditions structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class AlarmRuleV4MetricAlarmSpecAlarmTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoTags":
            suggest = "auto_tags"
        elif key == "customAnnotations":
            suggest = "custom_annotations"
        elif key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4MetricAlarmSpecAlarmTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4MetricAlarmSpecAlarmTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4MetricAlarmSpecAlarmTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_tags: Optional[Sequence[_builtins.str]] = None,
                 custom_annotations: Optional[Sequence[_builtins.str]] = None,
                 custom_tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] auto_tags: Specifies the automatic tag.
        :param Sequence[_builtins.str] custom_annotations: Specifies the custom tag.
        :param Sequence[_builtins.str] custom_tags: Specifies the alarm annotation.
               
               <a name="block--metric_alarm_spec--no_data_conditions"></a>
               The `no_data_conditions` block supports:
        """
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the automatic tag.
        """
        return pulumi.get(self, "auto_tags")

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the custom tag.
        """
        return pulumi.get(self, "custom_annotations")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the alarm annotation.

        <a name="block--metric_alarm_spec--no_data_conditions"></a>
        The `no_data_conditions` block supports:
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class AlarmRuleV4MetricAlarmSpecNoDataConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noDataAlertState":
            suggest = "no_data_alert_state"
        elif key == "noDataTimeframe":
            suggest = "no_data_timeframe"
        elif key == "notifyNoData":
            suggest = "notify_no_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4MetricAlarmSpecNoDataConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4MetricAlarmSpecNoDataConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4MetricAlarmSpecNoDataConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_data_alert_state: Optional[_builtins.str] = None,
                 no_data_timeframe: Optional[_builtins.int] = None,
                 notify_no_data: Optional[_builtins.bool] = None):
        """
        :param _builtins.str no_data_alert_state: Specifies the status of the threshold rule when the data is insufficient.
               Valid values are as follows:
               + **no_data**: A notification indicating insufficient data is sent.
               + **alerting**: An alarm is triggered.
               + **ok**: No exception occurs.
               + **pre_state**: Retain the previous state.
        :param _builtins.int no_data_timeframe: Specifies the number of periods without data.
        :param _builtins.bool notify_no_data: Specifies whether to send a notification when data is insufficient.
               Defaults to **false**.
        """
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[_builtins.str]:
        """
        Specifies the status of the threshold rule when the data is insufficient.
        Valid values are as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        return pulumi.get(self, "no_data_alert_state")

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[_builtins.int]:
        """
        Specifies the number of periods without data.
        """
        return pulumi.get(self, "no_data_timeframe")

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to send a notification when data is insufficient.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_no_data")


@pulumi.output_type
class AlarmRuleV4MetricAlarmSpecRecoveryConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryTimeframe":
            suggest = "recovery_timeframe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4MetricAlarmSpecRecoveryConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4MetricAlarmSpecRecoveryConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4MetricAlarmSpecRecoveryConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recovery_timeframe: Optional[_builtins.int] = None):
        """
        :param _builtins.int recovery_timeframe: Specifies the number of consecutive periods for which the trigger condition is
               not met to clear an alarm.
               
               <a name="block--metric_alarm_spec--trigger_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if recovery_timeframe is not None:
            pulumi.set(__self__, "recovery_timeframe", recovery_timeframe)

    @_builtins.property
    @pulumi.getter(name="recoveryTimeframe")
    def recovery_timeframe(self) -> Optional[_builtins.int]:
        """
        Specifies the number of consecutive periods for which the trigger condition is
        not met to clear an alarm.

        <a name="block--metric_alarm_spec--trigger_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "recovery_timeframe")


@pulumi.output_type
class AlarmRuleV4MetricAlarmSpecTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricQueryMode":
            suggest = "metric_query_mode"
        elif key == "aggregateType":
            suggest = "aggregate_type"
        elif key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "aggregationWindow":
            suggest = "aggregation_window"
        elif key == "aomMonitorLevel":
            suggest = "aom_monitor_level"
        elif key == "metricLabels":
            suggest = "metric_labels"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricStatisticMethod":
            suggest = "metric_statistic_method"
        elif key == "metricUnit":
            suggest = "metric_unit"
        elif key == "mixPromql":
            suggest = "mix_promql"
        elif key == "promqlExprs":
            suggest = "promql_exprs"
        elif key == "promqlFor":
            suggest = "promql_for"
        elif key == "queryMatch":
            suggest = "query_match"
        elif key == "queryParam":
            suggest = "query_param"
        elif key == "triggerInterval":
            suggest = "trigger_interval"
        elif key == "triggerTimes":
            suggest = "trigger_times"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRuleV4MetricAlarmSpecTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRuleV4MetricAlarmSpecTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRuleV4MetricAlarmSpecTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 metric_query_mode: _builtins.str,
                 promql: _builtins.str,
                 aggregate_type: Optional[_builtins.str] = None,
                 aggregation_type: Optional[_builtins.str] = None,
                 aggregation_window: Optional[_builtins.str] = None,
                 aom_monitor_level: Optional[_builtins.str] = None,
                 expression: Optional[_builtins.str] = None,
                 metric_labels: Optional[Sequence[_builtins.str]] = None,
                 metric_namespace: Optional[_builtins.str] = None,
                 metric_statistic_method: Optional[_builtins.str] = None,
                 metric_unit: Optional[_builtins.str] = None,
                 mix_promql: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 promql_exprs: Optional[Sequence[_builtins.str]] = None,
                 promql_for: Optional[_builtins.str] = None,
                 query_match: Optional[_builtins.str] = None,
                 query_param: Optional[_builtins.str] = None,
                 thresholds: Optional[Mapping[str, _builtins.str]] = None,
                 trigger_interval: Optional[_builtins.str] = None,
                 trigger_times: Optional[_builtins.str] = None,
                 trigger_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_name: Specifies the metric name.
        :param _builtins.str metric_query_mode: Specifies the metric query mode.
               Valid values are as follows:
               + **AOM**: native AOM
               + **PROM**: AOM prometheus
               + **NATIVE_PROM**: native prometheus
        :param _builtins.str promql: Specifies the prometheus statement.
        :param _builtins.str aggregate_type: Specifies the aggregation mode.
               Valid values are **by**, **avg**, **max**, **min** and **sum**.
        :param _builtins.str aggregation_type: Specifies the statistical mode.
               Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        :param _builtins.str aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param _builtins.str aom_monitor_level: Specifies the monitoring layer.
        :param _builtins.str expression: Specifies the expression of a combined operation.
        :param Sequence[_builtins.str] metric_labels: Specifies the metric dimension.
        :param _builtins.str metric_namespace: Specifies the metric namespace.
        :param _builtins.str metric_statistic_method: Specifies the metric statistics method to be used when you set
               Configuration Mode to Select from all metrics during alarm rule setting.
               Valid values are as follows:
               + **single**: single metric
               + **mix**: multi-metric combined operations
        :param _builtins.str metric_unit: Specifies the metric unit.
        :param _builtins.str mix_promql: Specifies the promQL of a combined operation.
        :param _builtins.str operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param Sequence[_builtins.str] promql_exprs: Specifies the prometheus statement template.
        :param _builtins.str promql_for: Specifies the native prometheus monitoring duration.
        :param _builtins.str query_match: Specifies the query filter criteria.
        :param _builtins.str query_param: Specifies the query parameters.
        :param Mapping[str, _builtins.str] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        :param _builtins.str trigger_interval: Specifies the check interval.
               Valid values are as follows:
               + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
               + If `trigger_type` is set to **DAILY**, set 00:0023:00. Example: **03:00**.
               + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:0023:00.
               Example: **1 03:00** indicates 03:00 on every Monday.
               + If `trigger_type` is set to **CRON**, specify a standard cron expression.
               + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 159 min, or 124 h.
               Example: **15s**, **30s**, **1min**, or **1h**.
        :param _builtins.str trigger_times: Specifies the number of consecutive periods.
               
               <a name="block--metric_alarm_spec--alarm_tags"></a>
               The `alarm_tags` block supports:
        :param _builtins.str trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        pulumi.set(__self__, "promql", promql)
        if aggregate_type is not None:
            pulumi.set(__self__, "aggregate_type", aggregate_type)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if aom_monitor_level is not None:
            pulumi.set(__self__, "aom_monitor_level", aom_monitor_level)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if metric_labels is not None:
            pulumi.set(__self__, "metric_labels", metric_labels)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_statistic_method is not None:
            pulumi.set(__self__, "metric_statistic_method", metric_statistic_method)
        if metric_unit is not None:
            pulumi.set(__self__, "metric_unit", metric_unit)
        if mix_promql is not None:
            pulumi.set(__self__, "mix_promql", mix_promql)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if promql_exprs is not None:
            pulumi.set(__self__, "promql_exprs", promql_exprs)
        if promql_for is not None:
            pulumi.set(__self__, "promql_for", promql_for)
        if query_match is not None:
            pulumi.set(__self__, "query_match", query_match)
        if query_param is not None:
            pulumi.set(__self__, "query_param", query_param)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)
        if trigger_interval is not None:
            pulumi.set(__self__, "trigger_interval", trigger_interval)
        if trigger_times is not None:
            pulumi.set(__self__, "trigger_times", trigger_times)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Specifies the metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> _builtins.str:
        """
        Specifies the metric query mode.
        Valid values are as follows:
        + **AOM**: native AOM
        + **PROM**: AOM prometheus
        + **NATIVE_PROM**: native prometheus
        """
        return pulumi.get(self, "metric_query_mode")

    @_builtins.property
    @pulumi.getter
    def promql(self) -> _builtins.str:
        """
        Specifies the prometheus statement.
        """
        return pulumi.get(self, "promql")

    @_builtins.property
    @pulumi.getter(name="aggregateType")
    def aggregate_type(self) -> Optional[_builtins.str]:
        """
        Specifies the aggregation mode.
        Valid values are **by**, **avg**, **max**, **min** and **sum**.
        """
        return pulumi.get(self, "aggregate_type")

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[_builtins.str]:
        """
        Specifies the statistical mode.
        Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[_builtins.str]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="aomMonitorLevel")
    def aom_monitor_level(self) -> Optional[_builtins.str]:
        """
        Specifies the monitoring layer.
        """
        return pulumi.get(self, "aom_monitor_level")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Specifies the expression of a combined operation.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the metric dimension.
        """
        return pulumi.get(self, "metric_labels")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the metric namespace.
        """
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="metricStatisticMethod")
    def metric_statistic_method(self) -> Optional[_builtins.str]:
        """
        Specifies the metric statistics method to be used when you set
        Configuration Mode to Select from all metrics during alarm rule setting.
        Valid values are as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        return pulumi.get(self, "metric_statistic_method")

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the metric unit.
        """
        return pulumi.get(self, "metric_unit")

    @_builtins.property
    @pulumi.getter(name="mixPromql")
    def mix_promql(self) -> Optional[_builtins.str]:
        """
        Specifies the promQL of a combined operation.
        """
        return pulumi.get(self, "mix_promql")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter(name="promqlExprs")
    def promql_exprs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the prometheus statement template.
        """
        return pulumi.get(self, "promql_exprs")

    @_builtins.property
    @pulumi.getter(name="promqlFor")
    def promql_for(self) -> Optional[_builtins.str]:
        """
        Specifies the native prometheus monitoring duration.
        """
        return pulumi.get(self, "promql_for")

    @_builtins.property
    @pulumi.getter(name="queryMatch")
    def query_match(self) -> Optional[_builtins.str]:
        """
        Specifies the query filter criteria.
        """
        return pulumi.get(self, "query_match")

    @_builtins.property
    @pulumi.getter(name="queryParam")
    def query_param(self) -> Optional[_builtins.str]:
        """
        Specifies the query parameters.
        """
        return pulumi.get(self, "query_param")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the check interval.
        Valid values are as follows:
        + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
        + If `trigger_type` is set to **DAILY**, set 00:0023:00. Example: **03:00**.
        + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:0023:00.
        Example: **1 03:00** indicates 03:00 on every Monday.
        + If `trigger_type` is set to **CRON**, specify a standard cron expression.
        + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 159 min, or 124 h.
        Example: **15s**, **30s**, **1min**, or **1h**.
        """
        return pulumi.get(self, "trigger_interval")

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> Optional[_builtins.str]:
        """
        Specifies the number of consecutive periods.

        <a name="block--metric_alarm_spec--alarm_tags"></a>
        The `alarm_tags` block supports:
        """
        return pulumi.get(self, "trigger_times")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[_builtins.str]:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmNotification":
            suggest = "alarm_notification"
        elif key == "alarmTemplateSpecItems":
            suggest = "alarm_template_spec_items"
        elif key == "relatedCceClusters":
            suggest = "related_cce_clusters"
        elif key == "relatedCloudService":
            suggest = "related_cloud_service"
        elif key == "relatedPrometheusInstances":
            suggest = "related_prometheus_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_notification: Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmNotification'] = None,
                 alarm_template_spec_items: Optional[Sequence['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItem']] = None,
                 related_cce_clusters: Optional[Sequence[_builtins.str]] = None,
                 related_cloud_service: Optional[_builtins.str] = None,
                 related_prometheus_instances: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgs' alarm_notification: Specifies the alarm notification.
               The alarm_notification structure is documented below.
        :param Sequence['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs'] alarm_template_spec_items: Specifies the alarm template spec items.
               The alarm_template_spec_items structure is documented below.
               
               <a name="alarm_template_spec_list--alarm_notification"></a>
               The `alarm_notification` block supports:
        :param Sequence[_builtins.str] related_cce_clusters: Specifies the related cce clusters of the alarm rules.
        :param _builtins.str related_cloud_service: Specifies the related cloud service of the alarm rules.
        :param Sequence[_builtins.str] related_prometheus_instances: Specifies the related prometheus instances of the alarm rules.
        """
        if alarm_notification is not None:
            pulumi.set(__self__, "alarm_notification", alarm_notification)
        if alarm_template_spec_items is not None:
            pulumi.set(__self__, "alarm_template_spec_items", alarm_template_spec_items)
        if related_cce_clusters is not None:
            pulumi.set(__self__, "related_cce_clusters", related_cce_clusters)
        if related_cloud_service is not None:
            pulumi.set(__self__, "related_cloud_service", related_cloud_service)
        if related_prometheus_instances is not None:
            pulumi.set(__self__, "related_prometheus_instances", related_prometheus_instances)

    @_builtins.property
    @pulumi.getter(name="alarmNotification")
    def alarm_notification(self) -> Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmNotification']:
        """
        Specifies the alarm notification.
        The alarm_notification structure is documented below.
        """
        return pulumi.get(self, "alarm_notification")

    @_builtins.property
    @pulumi.getter(name="alarmTemplateSpecItems")
    def alarm_template_spec_items(self) -> Optional[Sequence['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItem']]:
        """
        Specifies the alarm template spec items.
        The alarm_template_spec_items structure is documented below.

        <a name="alarm_template_spec_list--alarm_notification"></a>
        The `alarm_notification` block supports:
        """
        return pulumi.get(self, "alarm_template_spec_items")

    @_builtins.property
    @pulumi.getter(name="relatedCceClusters")
    def related_cce_clusters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the related cce clusters of the alarm rules.
        """
        return pulumi.get(self, "related_cce_clusters")

    @_builtins.property
    @pulumi.getter(name="relatedCloudService")
    def related_cloud_service(self) -> Optional[_builtins.str]:
        """
        Specifies the related cloud service of the alarm rules.
        """
        return pulumi.get(self, "related_cloud_service")

    @_builtins.property
    @pulumi.getter(name="relatedPrometheusInstances")
    def related_prometheus_instances(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the related prometheus instances of the alarm rules.
        """
        return pulumi.get(self, "related_prometheus_instances")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationType":
            suggest = "notification_type"
        elif key == "bindNotificationRuleId":
            suggest = "bind_notification_rule_id"
        elif key == "notificationEnable":
            suggest = "notification_enable"
        elif key == "notifyFrequency":
            suggest = "notify_frequency"
        elif key == "notifyResolved":
            suggest = "notify_resolved"
        elif key == "notifyTriggered":
            suggest = "notify_triggered"
        elif key == "routeGroupEnable":
            suggest = "route_group_enable"
        elif key == "routeGroupRule":
            suggest = "route_group_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification_type: _builtins.str,
                 bind_notification_rule_id: Optional[_builtins.str] = None,
                 notification_enable: Optional[_builtins.bool] = None,
                 notify_frequency: Optional[_builtins.str] = None,
                 notify_resolved: Optional[_builtins.bool] = None,
                 notify_triggered: Optional[_builtins.bool] = None,
                 route_group_enable: Optional[_builtins.bool] = None,
                 route_group_rule: Optional[_builtins.str] = None):
        """
        :param _builtins.str notification_type: Specifies the notification type.
               Valid values are as follows:
               + **direct**: Direct alarm reporting.
               + **alarm_policy**: Alarm reporting after noise reduction.
        :param _builtins.str bind_notification_rule_id: Specifies the alarm action rule ID.
               It's required if `notification_enable` is **true**.
        :param _builtins.bool notification_enable: Specifies whether to enable an alarm action rule. Defaults to **false**.
               If the `notification_type` is **direct**, set this parameter to **true**.
        :param _builtins.str notify_frequency: Specifies the notification frequency.
               If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
               If the `notification_type` is **direct**, set this parameter to any of the following:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
               
               <a name="alarm_template_spec_list--alarm_template_spec_items"></a>
               The `alarm_template_spec_items` block supports:
        :param _builtins.bool notify_resolved: Specifies whether to send a notification when an alarm is cleared.
               Defaults to **false**.
        :param _builtins.bool notify_triggered: Specifies whether to send a notification when an alarm is triggered.
               Defaults to **false**.
        :param _builtins.bool route_group_enable: Specifies whether to enable the grouping rule. Defaults to **false**.
               If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        :param _builtins.str route_group_rule: Specifies the grouping rule name.
               It's required if `route_group_enable` is **true**.
        """
        pulumi.set(__self__, "notification_type", notification_type)
        if bind_notification_rule_id is not None:
            pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        if notification_enable is not None:
            pulumi.set(__self__, "notification_enable", notification_enable)
        if notify_frequency is not None:
            pulumi.set(__self__, "notify_frequency", notify_frequency)
        if notify_resolved is not None:
            pulumi.set(__self__, "notify_resolved", notify_resolved)
        if notify_triggered is not None:
            pulumi.set(__self__, "notify_triggered", notify_triggered)
        if route_group_enable is not None:
            pulumi.set(__self__, "route_group_enable", route_group_enable)
        if route_group_rule is not None:
            pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> _builtins.str:
        """
        Specifies the notification type.
        Valid values are as follows:
        + **direct**: Direct alarm reporting.
        + **alarm_policy**: Alarm reporting after noise reduction.
        """
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm action rule ID.
        It's required if `notification_enable` is **true**.
        """
        return pulumi.get(self, "bind_notification_rule_id")

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable an alarm action rule. Defaults to **false**.
        If the `notification_type` is **direct**, set this parameter to **true**.
        """
        return pulumi.get(self, "notification_enable")

    @_builtins.property
    @pulumi.getter(name="notifyFrequency")
    def notify_frequency(self) -> Optional[_builtins.str]:
        """
        Specifies the notification frequency.
        If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
        If the `notification_type` is **direct**, set this parameter to any of the following:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day

        <a name="alarm_template_spec_list--alarm_template_spec_items"></a>
        The `alarm_template_spec_items` block supports:
        """
        return pulumi.get(self, "notify_frequency")

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to send a notification when an alarm is cleared.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_resolved")

    @_builtins.property
    @pulumi.getter(name="notifyTriggered")
    def notify_triggered(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to send a notification when an alarm is triggered.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_triggered")

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable the grouping rule. Defaults to **false**.
        If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        """
        return pulumi.get(self, "route_group_enable")

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> Optional[_builtins.str]:
        """
        Specifies the grouping rule name.
        It's required if `route_group_enable` is **true**.
        """
        return pulumi.get(self, "route_group_rule")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmRuleName":
            suggest = "alarm_rule_name"
        elif key == "alarmRuleType":
            suggest = "alarm_rule_type"
        elif key == "alarmRuleDescription":
            suggest = "alarm_rule_description"
        elif key == "eventAlarmSpec":
            suggest = "event_alarm_spec"
        elif key == "metricAlarmSpec":
            suggest = "metric_alarm_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_rule_name: _builtins.str,
                 alarm_rule_type: _builtins.str,
                 alarm_rule_description: Optional[_builtins.str] = None,
                 event_alarm_spec: Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpec'] = None,
                 metric_alarm_spec: Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpec'] = None):
        """
        :param _builtins.str alarm_rule_name: Specifies the alarm rule name.
        :param _builtins.str alarm_rule_type: Specifies the alarm rule type.
               Valid values are as follows:
               + **metric**: metric alarm rule
               + **event**: event alarm rule
        :param _builtins.str alarm_rule_description: Specifies the alarm rule description.
        :param 'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs' event_alarm_spec: Specifies the event alarm spec.
               The event_alarm_spec structure is documented
               below.
        :param 'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs' metric_alarm_spec: Specifies the metric alarm spec.
               The metric_alarm_spec structure is
               documented below.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--event_alarm_spec"></a>
               The `event_alarm_spec` block supports:
        """
        pulumi.set(__self__, "alarm_rule_name", alarm_rule_name)
        pulumi.set(__self__, "alarm_rule_type", alarm_rule_type)
        if alarm_rule_description is not None:
            pulumi.set(__self__, "alarm_rule_description", alarm_rule_description)
        if event_alarm_spec is not None:
            pulumi.set(__self__, "event_alarm_spec", event_alarm_spec)
        if metric_alarm_spec is not None:
            pulumi.set(__self__, "metric_alarm_spec", metric_alarm_spec)

    @_builtins.property
    @pulumi.getter(name="alarmRuleName")
    def alarm_rule_name(self) -> _builtins.str:
        """
        Specifies the alarm rule name.
        """
        return pulumi.get(self, "alarm_rule_name")

    @_builtins.property
    @pulumi.getter(name="alarmRuleType")
    def alarm_rule_type(self) -> _builtins.str:
        """
        Specifies the alarm rule type.
        Valid values are as follows:
        + **metric**: metric alarm rule
        + **event**: event alarm rule
        """
        return pulumi.get(self, "alarm_rule_type")

    @_builtins.property
    @pulumi.getter(name="alarmRuleDescription")
    def alarm_rule_description(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm rule description.
        """
        return pulumi.get(self, "alarm_rule_description")

    @_builtins.property
    @pulumi.getter(name="eventAlarmSpec")
    def event_alarm_spec(self) -> Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpec']:
        """
        Specifies the event alarm spec.
        The event_alarm_spec structure is documented
        below.
        """
        return pulumi.get(self, "event_alarm_spec")

    @_builtins.property
    @pulumi.getter(name="metricAlarmSpec")
    def metric_alarm_spec(self) -> Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpec']:
        """
        Specifies the metric alarm spec.
        The metric_alarm_spec structure is
        documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--event_alarm_spec"></a>
        The `event_alarm_spec` block supports:
        """
        return pulumi.get(self, "metric_alarm_spec")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmSource":
            suggest = "alarm_source"
        elif key == "alarmSubtype":
            suggest = "alarm_subtype"
        elif key == "eventSource":
            suggest = "event_source"
        elif key == "monitorObjectTemplates":
            suggest = "monitor_object_templates"
        elif key == "monitorObjects":
            suggest = "monitor_objects"
        elif key == "triggerConditions":
            suggest = "trigger_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_source: Optional[_builtins.str] = None,
                 alarm_subtype: Optional[_builtins.str] = None,
                 event_source: Optional[_builtins.str] = None,
                 monitor_object_templates: Optional[Sequence[_builtins.str]] = None,
                 monitor_objects: Optional[Sequence[Mapping[str, _builtins.str]]] = None,
                 trigger_conditions: Optional[Sequence['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerCondition']] = None):
        """
        :param _builtins.str alarm_source: Specifies the alarm source.
        :param _builtins.str alarm_subtype: Specifies the alarm subtype.
        :param _builtins.str event_source: Specifies the alarm source.
        :param Sequence[_builtins.str] monitor_object_templates: Specifies the monitor object templates.
        :param Sequence[Mapping[str, _builtins.str]] monitor_objects: Specifies the monitored objects. It's an array of map objects.
               Key-value pair, key can be as follows:
               + **event_type**: notification type
               + **event_severity**: alarm severity
               + **event_name**: event name
               + **namespace**: namespace
               + **clusterId**: cluster ID
               + **customField**: user-defined field
        :param Sequence['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs'] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions
               structure is documented below.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
               The `trigger_conditions` block supports:
        """
        if alarm_source is not None:
            pulumi.set(__self__, "alarm_source", alarm_source)
        if alarm_subtype is not None:
            pulumi.set(__self__, "alarm_subtype", alarm_subtype)
        if event_source is not None:
            pulumi.set(__self__, "event_source", event_source)
        if monitor_object_templates is not None:
            pulumi.set(__self__, "monitor_object_templates", monitor_object_templates)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm source.
        """
        return pulumi.get(self, "alarm_source")

    @_builtins.property
    @pulumi.getter(name="alarmSubtype")
    def alarm_subtype(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm subtype.
        """
        return pulumi.get(self, "alarm_subtype")

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm source.
        """
        return pulumi.get(self, "event_source")

    @_builtins.property
    @pulumi.getter(name="monitorObjectTemplates")
    def monitor_object_templates(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the monitor object templates.
        """
        return pulumi.get(self, "monitor_object_templates")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[Sequence[Mapping[str, _builtins.str]]]:
        """
        Specifies the monitored objects. It's an array of map objects.
        Key-value pair, key can be as follows:
        + **event_type**: notification type
        + **event_severity**: alarm severity
        + **event_name**: event name
        + **namespace**: namespace
        + **clusterId**: cluster ID
        + **customField**: user-defined field
        """
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[Sequence['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerCondition']]:
        """
        Specifies the trigger conditions.
        The trigger_conditions
        structure is documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "aggregationWindow":
            suggest = "aggregation_window"
        elif key == "eventName":
            suggest = "event_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_type: _builtins.str,
                 aggregation_window: Optional[_builtins.int] = None,
                 event_name: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 thresholds: Optional[Mapping[str, _builtins.int]] = None):
        """
        :param _builtins.str trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        :param _builtins.int aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param _builtins.str event_name: Specifies the event name.
        :param _builtins.str frequency: Specifies the event alarm notification frequency. Leave this parameter empty if
               `trigger_type` is set to **immediately**. Valid values are as follows:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
        :param _builtins.str operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param Mapping[str, _builtins.int] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        """
        pulumi.set(__self__, "trigger_type", trigger_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if event_name is not None:
            pulumi.set(__self__, "event_name", event_name)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[_builtins.int]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> Optional[_builtins.str]:
        """
        Specifies the event name.
        """
        return pulumi.get(self, "event_name")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        Specifies the event alarm notification frequency. Leave this parameter empty if
        `trigger_type` is set to **immediately**. Valid values are as follows:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[Mapping[str, _builtins.int]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmSource":
            suggest = "alarm_source"
        elif key == "alarmSubtype":
            suggest = "alarm_subtype"
        elif key == "alarmTags":
            suggest = "alarm_tags"
        elif key == "monitorType":
            suggest = "monitor_type"
        elif key == "noDataConditions":
            suggest = "no_data_conditions"
        elif key == "recoveryConditions":
            suggest = "recovery_conditions"
        elif key == "triggerConditions":
            suggest = "trigger_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_source: Optional[_builtins.str] = None,
                 alarm_subtype: Optional[_builtins.str] = None,
                 alarm_tags: Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTags'] = None,
                 monitor_type: Optional[_builtins.str] = None,
                 no_data_conditions: Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditions'] = None,
                 recovery_conditions: Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditions'] = None,
                 trigger_conditions: Optional[Sequence['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerCondition']] = None):
        """
        :param _builtins.str alarm_source: Specifies the alarm source.
        :param _builtins.str alarm_subtype: Specifies the alarm subtype.
        :param 'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgs' alarm_tags: Specifies the alarm tags.
               The alarm_tags structure
               is documented below.
        :param _builtins.str monitor_type: Specifies the monitor type.
        :param 'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgs' no_data_conditions: Specifies the no data conditions.
               The no_data_conditions
               structure is documented below.
        :param 'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgs' recovery_conditions: Specifies the recovery conditions.
               The recovery_conditions
               structure is documented below.
        :param Sequence['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs'] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions
               structure is documented below.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
               The `trigger_conditions` block supports:
        """
        if alarm_source is not None:
            pulumi.set(__self__, "alarm_source", alarm_source)
        if alarm_subtype is not None:
            pulumi.set(__self__, "alarm_subtype", alarm_subtype)
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if monitor_type is not None:
            pulumi.set(__self__, "monitor_type", monitor_type)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        if recovery_conditions is not None:
            pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm source.
        """
        return pulumi.get(self, "alarm_source")

    @_builtins.property
    @pulumi.getter(name="alarmSubtype")
    def alarm_subtype(self) -> Optional[_builtins.str]:
        """
        Specifies the alarm subtype.
        """
        return pulumi.get(self, "alarm_subtype")

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTags']:
        """
        Specifies the alarm tags.
        The alarm_tags structure
        is documented below.
        """
        return pulumi.get(self, "alarm_tags")

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> Optional[_builtins.str]:
        """
        Specifies the monitor type.
        """
        return pulumi.get(self, "monitor_type")

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditions']:
        """
        Specifies the no data conditions.
        The no_data_conditions
        structure is documented below.
        """
        return pulumi.get(self, "no_data_conditions")

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> Optional['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditions']:
        """
        Specifies the recovery conditions.
        The recovery_conditions
        structure is documented below.
        """
        return pulumi.get(self, "recovery_conditions")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[Sequence['outputs.AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerCondition']]:
        """
        Specifies the trigger conditions.
        The trigger_conditions
        structure is documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoTags":
            suggest = "auto_tags"
        elif key == "customAnnotations":
            suggest = "custom_annotations"
        elif key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_tags: Optional[Sequence[_builtins.str]] = None,
                 custom_annotations: Optional[Sequence[_builtins.str]] = None,
                 custom_tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] auto_tags: Specifies the automatic tag.
        :param Sequence[_builtins.str] custom_annotations: Specifies the custom tag.
        :param Sequence[_builtins.str] custom_tags: Specifies the alarm annotation.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--no_data_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the automatic tag.
        """
        return pulumi.get(self, "auto_tags")

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the custom tag.
        """
        return pulumi.get(self, "custom_annotations")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the alarm annotation.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--no_data_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noDataAlertState":
            suggest = "no_data_alert_state"
        elif key == "noDataTimeframe":
            suggest = "no_data_timeframe"
        elif key == "notifyNoData":
            suggest = "notify_no_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_data_alert_state: Optional[_builtins.str] = None,
                 no_data_timeframe: Optional[_builtins.int] = None,
                 notify_no_data: Optional[_builtins.bool] = None):
        """
        :param _builtins.str no_data_alert_state: Specifies the status of the threshold rule when the data is insufficient.
               Valid values are as follows:
               + **no_data**: A notification indicating insufficient data is sent.
               + **alerting**: An alarm is triggered.
               + **ok**: No exception occurs.
               + **pre_state**: Retain the previous state.
        :param _builtins.int no_data_timeframe: Specifies the number of periods without data.
        :param _builtins.bool notify_no_data: Specifies whether to send a notification when data is insufficient.
               Defaults to **false**.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--recovery_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[_builtins.str]:
        """
        Specifies the status of the threshold rule when the data is insufficient.
        Valid values are as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        return pulumi.get(self, "no_data_alert_state")

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[_builtins.int]:
        """
        Specifies the number of periods without data.
        """
        return pulumi.get(self, "no_data_timeframe")

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to send a notification when data is insufficient.
        Defaults to **false**.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--recovery_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "notify_no_data")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryTimeframe":
            suggest = "recovery_timeframe"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recovery_timeframe: Optional[_builtins.int] = None):
        """
        :param _builtins.int recovery_timeframe: Specifies the number of consecutive periods for which the trigger condition is
               not met to clear an alarm.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--trigger_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if recovery_timeframe is not None:
            pulumi.set(__self__, "recovery_timeframe", recovery_timeframe)

    @_builtins.property
    @pulumi.getter(name="recoveryTimeframe")
    def recovery_timeframe(self) -> Optional[_builtins.int]:
        """
        Specifies the number of consecutive periods for which the trigger condition is
        not met to clear an alarm.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--trigger_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "recovery_timeframe")


@pulumi.output_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricQueryMode":
            suggest = "metric_query_mode"
        elif key == "aggregateType":
            suggest = "aggregate_type"
        elif key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "aggregationWindow":
            suggest = "aggregation_window"
        elif key == "aomMonitorLevel":
            suggest = "aom_monitor_level"
        elif key == "metricLabels":
            suggest = "metric_labels"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricStatisticMethod":
            suggest = "metric_statistic_method"
        elif key == "metricUnit":
            suggest = "metric_unit"
        elif key == "mixPromql":
            suggest = "mix_promql"
        elif key == "promqlExprs":
            suggest = "promql_exprs"
        elif key == "promqlFor":
            suggest = "promql_for"
        elif key == "queryMatch":
            suggest = "query_match"
        elif key == "triggerInterval":
            suggest = "trigger_interval"
        elif key == "triggerTimes":
            suggest = "trigger_times"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_query_mode: _builtins.str,
                 aggregate_type: Optional[_builtins.str] = None,
                 aggregation_type: Optional[_builtins.str] = None,
                 aggregation_window: Optional[_builtins.str] = None,
                 aom_monitor_level: Optional[_builtins.str] = None,
                 expression: Optional[_builtins.str] = None,
                 metric_labels: Optional[Sequence[_builtins.str]] = None,
                 metric_name: Optional[_builtins.str] = None,
                 metric_namespace: Optional[_builtins.str] = None,
                 metric_statistic_method: Optional[_builtins.str] = None,
                 metric_unit: Optional[_builtins.str] = None,
                 mix_promql: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 promql: Optional[_builtins.str] = None,
                 promql_exprs: Optional[Sequence[_builtins.str]] = None,
                 promql_for: Optional[_builtins.str] = None,
                 query_match: Optional[_builtins.str] = None,
                 thresholds: Optional[Mapping[str, _builtins.str]] = None,
                 trigger_interval: Optional[_builtins.str] = None,
                 trigger_times: Optional[_builtins.str] = None,
                 trigger_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_query_mode: Specifies the metric query mode.
               Valid values are as follows:
               + **AOM**: native AOM
               + **PROM**: AOM prometheus
               + **NATIVE_PROM**: native prometheus
        :param _builtins.str aggregate_type: Specifies the aggregation mode.
               Valid values are **by**, **avg**, **max**, **min** and **sum**.
        :param _builtins.str aggregation_type: Specifies the statistical mode.
               Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        :param _builtins.str aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param _builtins.str aom_monitor_level: Specifies the monitoring layer.
        :param _builtins.str expression: Specifies the expression of a combined operation.
        :param Sequence[_builtins.str] metric_labels: Specifies the metric dimension.
        :param _builtins.str metric_name: Specifies the metric name.
        :param _builtins.str metric_namespace: Specifies the metric namespace.
        :param _builtins.str metric_statistic_method: Specifies the metric statistics method to be used when you set
               Configuration Mode to Select from all metrics during alarm rule setting.
               Valid values are as follows:
               + **single**: single metric
               + **mix**: multi-metric combined operations
        :param _builtins.str metric_unit: Specifies the metric unit.
        :param _builtins.str mix_promql: Specifies the promQL of a combined operation.
        :param _builtins.str operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param _builtins.str promql: Specifies the prometheus statement.
        :param Sequence[_builtins.str] promql_exprs: Specifies the prometheus statement template.
        :param _builtins.str promql_for: Specifies the native prometheus monitoring duration.
        :param _builtins.str query_match: Specifies the query filter criteria.
        :param Mapping[str, _builtins.str] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        :param _builtins.str trigger_interval: Specifies the check interval.
               Valid values are as follows:
               + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
               + If `trigger_type` is set to **DAILY**, set 00:0023:00. Example: **03:00**.
               + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:0023:00.
               Example: **1 03:00** indicates 03:00 on every Monday.
               + If `trigger_type` is set to **CRON**, specify a standard cron expression.
               + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 159 min, or 124 h.
               Example: **15s**, **30s**, **1min**, or **1h**.
        :param _builtins.str trigger_times: Specifies the number of consecutive periods.
               
               <a name="templating"></a>
               The `templating` block supports:
        :param _builtins.str trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        if aggregate_type is not None:
            pulumi.set(__self__, "aggregate_type", aggregate_type)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if aom_monitor_level is not None:
            pulumi.set(__self__, "aom_monitor_level", aom_monitor_level)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if metric_labels is not None:
            pulumi.set(__self__, "metric_labels", metric_labels)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_statistic_method is not None:
            pulumi.set(__self__, "metric_statistic_method", metric_statistic_method)
        if metric_unit is not None:
            pulumi.set(__self__, "metric_unit", metric_unit)
        if mix_promql is not None:
            pulumi.set(__self__, "mix_promql", mix_promql)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if promql is not None:
            pulumi.set(__self__, "promql", promql)
        if promql_exprs is not None:
            pulumi.set(__self__, "promql_exprs", promql_exprs)
        if promql_for is not None:
            pulumi.set(__self__, "promql_for", promql_for)
        if query_match is not None:
            pulumi.set(__self__, "query_match", query_match)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)
        if trigger_interval is not None:
            pulumi.set(__self__, "trigger_interval", trigger_interval)
        if trigger_times is not None:
            pulumi.set(__self__, "trigger_times", trigger_times)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> _builtins.str:
        """
        Specifies the metric query mode.
        Valid values are as follows:
        + **AOM**: native AOM
        + **PROM**: AOM prometheus
        + **NATIVE_PROM**: native prometheus
        """
        return pulumi.get(self, "metric_query_mode")

    @_builtins.property
    @pulumi.getter(name="aggregateType")
    def aggregate_type(self) -> Optional[_builtins.str]:
        """
        Specifies the aggregation mode.
        Valid values are **by**, **avg**, **max**, **min** and **sum**.
        """
        return pulumi.get(self, "aggregate_type")

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[_builtins.str]:
        """
        Specifies the statistical mode.
        Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[_builtins.str]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="aomMonitorLevel")
    def aom_monitor_level(self) -> Optional[_builtins.str]:
        """
        Specifies the monitoring layer.
        """
        return pulumi.get(self, "aom_monitor_level")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Specifies the expression of a combined operation.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the metric dimension.
        """
        return pulumi.get(self, "metric_labels")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[_builtins.str]:
        """
        Specifies the metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the metric namespace.
        """
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="metricStatisticMethod")
    def metric_statistic_method(self) -> Optional[_builtins.str]:
        """
        Specifies the metric statistics method to be used when you set
        Configuration Mode to Select from all metrics during alarm rule setting.
        Valid values are as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        return pulumi.get(self, "metric_statistic_method")

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the metric unit.
        """
        return pulumi.get(self, "metric_unit")

    @_builtins.property
    @pulumi.getter(name="mixPromql")
    def mix_promql(self) -> Optional[_builtins.str]:
        """
        Specifies the promQL of a combined operation.
        """
        return pulumi.get(self, "mix_promql")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def promql(self) -> Optional[_builtins.str]:
        """
        Specifies the prometheus statement.
        """
        return pulumi.get(self, "promql")

    @_builtins.property
    @pulumi.getter(name="promqlExprs")
    def promql_exprs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the prometheus statement template.
        """
        return pulumi.get(self, "promql_exprs")

    @_builtins.property
    @pulumi.getter(name="promqlFor")
    def promql_for(self) -> Optional[_builtins.str]:
        """
        Specifies the native prometheus monitoring duration.
        """
        return pulumi.get(self, "promql_for")

    @_builtins.property
    @pulumi.getter(name="queryMatch")
    def query_match(self) -> Optional[_builtins.str]:
        """
        Specifies the query filter criteria.
        """
        return pulumi.get(self, "query_match")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the check interval.
        Valid values are as follows:
        + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
        + If `trigger_type` is set to **DAILY**, set 00:0023:00. Example: **03:00**.
        + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:0023:00.
        Example: **1 03:00** indicates 03:00 on every Monday.
        + If `trigger_type` is set to **CRON**, specify a standard cron expression.
        + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 159 min, or 124 h.
        Example: **15s**, **30s**, **1min**, or **1h**.
        """
        return pulumi.get(self, "trigger_interval")

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> Optional[_builtins.str]:
        """
        Specifies the number of consecutive periods.

        <a name="templating"></a>
        The `templating` block supports:
        """
        return pulumi.get(self, "trigger_times")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[_builtins.str]:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class AlarmRulesTemplateTemplating(dict):
    def __init__(__self__, *,
                 lists: Sequence['outputs.AlarmRulesTemplateTemplatingList']):
        """
        :param Sequence['AlarmRulesTemplateTemplatingListArgs'] lists: Specifies the
               The list structure is documented below.
               
               <a name="templating--list"></a>
               The `list` block supports:
        """
        pulumi.set(__self__, "lists", lists)

    @_builtins.property
    @pulumi.getter
    def lists(self) -> Sequence['outputs.AlarmRulesTemplateTemplatingList']:
        """
        Specifies the
        The list structure is documented below.

        <a name="templating--list"></a>
        The `list` block supports:
        """
        return pulumi.get(self, "lists")


@pulumi.output_type
class AlarmRulesTemplateTemplatingList(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 query: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name.
        :param _builtins.str description: Specifies the description.
        :param _builtins.str query: Specifies the query.
        :param _builtins.str type: Specifies the type.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        Specifies the query.
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AlarmSilenceRuleSilenceCondition(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.AlarmSilenceRuleSilenceConditionCondition']):
        """
        :param Sequence['AlarmSilenceRuleSilenceConditionConditionArgs'] conditions: Specifies the serial conditions.
               A maximum of 10 conditions are allowed.
               The conditions structure is documented below.
               
               <a name="conditions"></a>
               The `conditions` block supports:
        """
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.AlarmSilenceRuleSilenceConditionCondition']:
        """
        Specifies the serial conditions.
        A maximum of 10 conditions are allowed.
        The conditions structure is documented below.

        <a name="conditions"></a>
        The `conditions` block supports:
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class AlarmSilenceRuleSilenceConditionCondition(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operate: _builtins.str,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: Specifies the key of the match condition.
        :param _builtins.str operate: Specifies the operate of the match condition.
               The value can be: **EQUALS**, **REGEX** and **EXIST**.
        :param Sequence[_builtins.str] values: Specifies the value list of the match condition.
               A maximum of 5 values are allowed. This should be empty when the value of operate is *EXIST**.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operate", operate)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match condition.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operate(self) -> _builtins.str:
        """
        Specifies the operate of the match condition.
        The value can be: **EQUALS**, **REGEX** and **EXIST**.
        """
        return pulumi.get(self, "operate")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the value list of the match condition.
        A maximum of 5 values are allowed. This should be empty when the value of operate is *EXIST**.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class AlarmSilenceRuleSilenceTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startsAt":
            suggest = "starts_at"
        elif key == "endsAt":
            suggest = "ends_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlarmSilenceRuleSilenceTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlarmSilenceRuleSilenceTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlarmSilenceRuleSilenceTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 starts_at: _builtins.int,
                 type: _builtins.str,
                 ends_at: Optional[_builtins.int] = None,
                 scopes: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int starts_at: Specifies the start time of the silence rule.
               When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
               which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
               or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        :param _builtins.str type: Specifies the effective time type of the silence rule.
               The value can be: **FIXED**, **DAILY**, **WEEKLY** and **MONTHLY**.
        :param _builtins.int ends_at: Specifies the end time of the silence rule.
               When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
               which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
               or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        :param Sequence[_builtins.int] scopes: Specifies the silence time of the rule.
               It's required when the type is **WEEKLY** or **MONTHLY**.
               
               <a name="silence_conditions"></a>
               The `silence_conditions` block supports:
        """
        pulumi.set(__self__, "starts_at", starts_at)
        pulumi.set(__self__, "type", type)
        if ends_at is not None:
            pulumi.set(__self__, "ends_at", ends_at)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter(name="startsAt")
    def starts_at(self) -> _builtins.int:
        """
        Specifies the start time of the silence rule.
        When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
        which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
        or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        """
        return pulumi.get(self, "starts_at")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the effective time type of the silence rule.
        The value can be: **FIXED**, **DAILY**, **WEEKLY** and **MONTHLY**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="endsAt")
    def ends_at(self) -> Optional[_builtins.int]:
        """
        Specifies the end time of the silence rule.
        When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
        which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
        or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        """
        return pulumi.get(self, "ends_at")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.int]]:
        """
        Specifies the silence time of the rule.
        It's required when the type is **WEEKLY** or **MONTHLY**.

        <a name="silence_conditions"></a>
        The `silence_conditions` block supports:
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class EnvironmentEnvTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagId":
            suggest = "tag_id"
        elif key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentEnvTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentEnvTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentEnvTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_id: Optional[_builtins.str] = None,
                 tag_name: Optional[_builtins.str] = None):
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @_builtins.property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tag_id")

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class MessageTemplateTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subType":
            suggest = "sub_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 sub_type: _builtins.str,
                 topic: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: Specifies the content of the template.
        :param _builtins.str sub_type: Specifies the subscription type of the template.
               Valid value are **email**, **sms**, **wechat**, **dingding**, **webhook**, **voice**, **espace**, **feishu**, **welink**.
        :param _builtins.str topic: Specifies the topic of the template.
        :param _builtins.str version: Specifies the version of the template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "sub_type", sub_type)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Specifies the content of the template.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> _builtins.str:
        """
        Specifies the subscription type of the template.
        Valid value are **email**, **sms**, **wechat**, **dingding**, **webhook**, **voice**, **espace**, **feishu**, **welink**.
        """
        return pulumi.get(self, "sub_type")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[_builtins.str]:
        """
        Specifies the topic of the template.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Specifies the version of the template.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MultiAccountAggregationRuleAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "joinMethod":
            suggest = "join_method"
        elif key == "joinedAt":
            suggest = "joined_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MultiAccountAggregationRuleAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MultiAccountAggregationRuleAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MultiAccountAggregationRuleAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 join_method: Optional[_builtins.str] = None,
                 joined_at: Optional[_builtins.str] = None,
                 urn: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Specifies the account ID.
        :param _builtins.str name: Specifies the account name.
        :param _builtins.str join_method: Specifies the method how the account joined in the organization.
        :param _builtins.str joined_at: Specifies the time when the account joined in the organization.
               
               <a name="services_struct"></a>
               The `services` block supports:
        :param _builtins.str urn: Specifies the uniform resource name of the account.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        if join_method is not None:
            pulumi.set(__self__, "join_method", join_method)
        if joined_at is not None:
            pulumi.set(__self__, "joined_at", joined_at)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Specifies the account ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the account name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="joinMethod")
    def join_method(self) -> Optional[_builtins.str]:
        """
        Specifies the method how the account joined in the organization.
        """
        return pulumi.get(self, "join_method")

    @_builtins.property
    @pulumi.getter(name="joinedAt")
    def joined_at(self) -> Optional[_builtins.str]:
        """
        Specifies the time when the account joined in the organization.

        <a name="services_struct"></a>
        The `services` block supports:
        """
        return pulumi.get(self, "joined_at")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[_builtins.str]:
        """
        Specifies the uniform resource name of the account.
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class MultiAccountAggregationRuleService(dict):
    def __init__(__self__, *,
                 metrics: Sequence[_builtins.str],
                 service: _builtins.str):
        """
        :param Sequence[_builtins.str] metrics: Specifies the metrics List.
        :param _builtins.str service: Specifies the service name.
        """
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence[_builtins.str]:
        """
        Specifies the metrics List.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Specifies the service name.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class PrometheusInstancePromForCloudService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cesMetricNamespaces":
            suggest = "ces_metric_namespaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusInstancePromForCloudService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusInstancePromForCloudService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusInstancePromForCloudService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ces_metric_namespaces: Sequence[_builtins.str]):
        pulumi.set(__self__, "ces_metric_namespaces", ces_metric_namespaces)

    @_builtins.property
    @pulumi.getter(name="cesMetricNamespaces")
    def ces_metric_namespaces(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "ces_metric_namespaces")


@pulumi.output_type
class ServiceDiscoveryRuleDiscoveryRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkContents":
            suggest = "check_contents"
        elif key == "checkMode":
            suggest = "check_mode"
        elif key == "checkType":
            suggest = "check_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDiscoveryRuleDiscoveryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDiscoveryRuleDiscoveryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDiscoveryRuleDiscoveryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_contents: Sequence[_builtins.str],
                 check_mode: _builtins.str,
                 check_type: _builtins.str):
        """
        :param Sequence[_builtins.str] check_contents: Specifies the matched value. This is a list of strings.
        :param _builtins.str check_mode: Specifies the match condition. The values can be **contain** and **equals**.
        :param _builtins.str check_type: Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
        """
        pulumi.set(__self__, "check_contents", check_contents)
        pulumi.set(__self__, "check_mode", check_mode)
        pulumi.set(__self__, "check_type", check_type)

    @_builtins.property
    @pulumi.getter(name="checkContents")
    def check_contents(self) -> Sequence[_builtins.str]:
        """
        Specifies the matched value. This is a list of strings.
        """
        return pulumi.get(self, "check_contents")

    @_builtins.property
    @pulumi.getter(name="checkMode")
    def check_mode(self) -> _builtins.str:
        """
        Specifies the match condition. The values can be **contain** and **equals**.
        """
        return pulumi.get(self, "check_mode")

    @_builtins.property
    @pulumi.getter(name="checkType")
    def check_type(self) -> _builtins.str:
        """
        Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
        """
        return pulumi.get(self, "check_type")


@pulumi.output_type
class ServiceDiscoveryRuleLogPathRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameType":
            suggest = "name_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDiscoveryRuleLogPathRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDiscoveryRuleLogPathRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDiscoveryRuleLogPathRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 name_type: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] args: Specifies the command. This is a list of strings.
        :param _builtins.str name_type: Specifies the value type, which can be **cmdLineHash**.
        :param Sequence[_builtins.str] values: Specifies the log path. This is a list of strings.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        Specifies the command. This is a list of strings.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> _builtins.str:
        """
        Specifies the value type, which can be **cmdLineHash**.
        """
        return pulumi.get(self, "name_type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the log path. This is a list of strings.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ServiceDiscoveryRuleNameRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationNameRules":
            suggest = "application_name_rules"
        elif key == "serviceNameRules":
            suggest = "service_name_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDiscoveryRuleNameRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDiscoveryRuleNameRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDiscoveryRuleNameRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name_rules: Sequence['outputs.ServiceDiscoveryRuleNameRulesApplicationNameRule'],
                 service_name_rules: Sequence['outputs.ServiceDiscoveryRuleNameRulesServiceNameRule']):
        """
        :param Sequence['ServiceDiscoveryRuleNameRulesApplicationNameRuleArgs'] application_name_rules: Specifies the application name rule. If the value of `name_type` is
               **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
               the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"], indicating that
               the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the format of
               ["fix"], indicating that the application name is suffixed with fix. If the value of `name_type` is **cmdLineHash**,
               `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
               ser when the startup command is 0001. The object structure is documented below.
               
               <a name="basic_name_rule_object"></a>
               The `service_name_rule` block and `application_name_rule` block support:
        :param Sequence['ServiceDiscoveryRuleNameRulesServiceNameRuleArgs'] service_name_rules: Specifies the service name rule. If there are multiple objects in the array,
               the character strings extracted from these objects constitute the service name. If the value of `name_type` is
               **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
               in the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"],
               indicating that the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the
               format of ["fix"], indicating that the service name is suffixed with fix. If the value of `name_type` is
               **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
               service name is ser when the startup command is 0001. The object structure is
               documented below.
        """
        pulumi.set(__self__, "application_name_rules", application_name_rules)
        pulumi.set(__self__, "service_name_rules", service_name_rules)

    @_builtins.property
    @pulumi.getter(name="applicationNameRules")
    def application_name_rules(self) -> Sequence['outputs.ServiceDiscoveryRuleNameRulesApplicationNameRule']:
        """
        Specifies the application name rule. If the value of `name_type` is
        **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
        the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"], indicating that
        the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the format of
        ["fix"], indicating that the application name is suffixed with fix. If the value of `name_type` is **cmdLineHash**,
        `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
        ser when the startup command is 0001. The object structure is documented below.

        <a name="basic_name_rule_object"></a>
        The `service_name_rule` block and `application_name_rule` block support:
        """
        return pulumi.get(self, "application_name_rules")

    @_builtins.property
    @pulumi.getter(name="serviceNameRules")
    def service_name_rules(self) -> Sequence['outputs.ServiceDiscoveryRuleNameRulesServiceNameRule']:
        """
        Specifies the service name rule. If there are multiple objects in the array,
        the character strings extracted from these objects constitute the service name. If the value of `name_type` is
        **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
        in the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"],
        indicating that the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the
        format of ["fix"], indicating that the service name is suffixed with fix. If the value of `name_type` is
        **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
        service name is ser when the startup command is 0001. The object structure is
        documented below.
        """
        return pulumi.get(self, "service_name_rules")


@pulumi.output_type
class ServiceDiscoveryRuleNameRulesApplicationNameRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameType":
            suggest = "name_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDiscoveryRuleNameRulesApplicationNameRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDiscoveryRuleNameRulesApplicationNameRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDiscoveryRuleNameRulesApplicationNameRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 name_type: _builtins.str,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] args: Specifies the input value.
        :param _builtins.str name_type: Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
               and **str**.
        :param Sequence[_builtins.str] values: Specifies the application name, which is mandatory only when the value of `name_type` is
               **cmdLineHash**.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        Specifies the input value.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> _builtins.str:
        """
        Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
        and **str**.
        """
        return pulumi.get(self, "name_type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the application name, which is mandatory only when the value of `name_type` is
        **cmdLineHash**.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ServiceDiscoveryRuleNameRulesServiceNameRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameType":
            suggest = "name_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDiscoveryRuleNameRulesServiceNameRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDiscoveryRuleNameRulesServiceNameRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDiscoveryRuleNameRulesServiceNameRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 name_type: _builtins.str,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] args: Specifies the input value.
        :param _builtins.str name_type: Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
               and **str**.
        :param Sequence[_builtins.str] values: Specifies the application name, which is mandatory only when the value of `name_type` is
               **cmdLineHash**.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        Specifies the input value.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> _builtins.str:
        """
        Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
        and **str**.
        """
        return pulumi.get(self, "name_type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the application name, which is mandatory only when the value of `name_type` is
        **cmdLineHash**.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAccessCodesAccessCodeResult(dict):
    def __init__(__self__, *,
                 access_code: _builtins.str,
                 access_code_id: _builtins.str,
                 create_at: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str access_code: Indicates the access code.
        :param _builtins.str access_code_id: Indicates the access code ID.
        :param _builtins.str create_at: Indicates the creation time.
        :param _builtins.str status: Indicates the status.
        """
        pulumi.set(__self__, "access_code", access_code)
        pulumi.set(__self__, "access_code_id", access_code_id)
        pulumi.set(__self__, "create_at", create_at)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="accessCode")
    def access_code(self) -> _builtins.str:
        """
        Indicates the access code.
        """
        return pulumi.get(self, "access_code")

    @_builtins.property
    @pulumi.getter(name="accessCodeId")
    def access_code_id(self) -> _builtins.str:
        """
        Indicates the access code ID.
        """
        return pulumi.get(self, "access_code_id")

    @_builtins.property
    @pulumi.getter(name="createAt")
    def create_at(self) -> _builtins.str:
        """
        Indicates the creation time.
        """
        return pulumi.get(self, "create_at")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAggregationMetricsServiceMetricResult(dict):
    def __init__(__self__, *,
                 metrics: Sequence[_builtins.str],
                 service: _builtins.str):
        """
        :param Sequence[_builtins.str] metrics: Indicates the metrics list.
        :param _builtins.str service: Indicates the service name.
        """
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence[_builtins.str]:
        """
        Indicates the metrics list.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Indicates the service name.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetAlarmActionRulesActionRuleResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 created_by: _builtins.str,
                 description: _builtins.str,
                 name: _builtins.str,
                 notification_template: _builtins.str,
                 smn_topics: Sequence['outputs.GetAlarmActionRulesActionRuleSmnTopicResult'],
                 time_zone: _builtins.str,
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time.
        :param _builtins.str created_by: Indicates the user who created the rule.
        :param _builtins.str description: Indicates the rule description.
        :param _builtins.str name: Indicates the name of the topic.
        :param _builtins.str notification_template: Indicates the message template.
        :param Sequence['GetAlarmActionRulesActionRuleSmnTopicArgs'] smn_topics: Indicates the SMN topics.
        :param _builtins.str time_zone: Indicates the time zone.
        :param _builtins.str type: Indicates the action type.
        :param _builtins.str updated_at: Indicates the update time.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_template", notification_template)
        pulumi.set(__self__, "smn_topics", smn_topics)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        Indicates the user who created the rule.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the rule description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notificationTemplate")
    def notification_template(self) -> _builtins.str:
        """
        Indicates the message template.
        """
        return pulumi.get(self, "notification_template")

    @_builtins.property
    @pulumi.getter(name="smnTopics")
    def smn_topics(self) -> Sequence['outputs.GetAlarmActionRulesActionRuleSmnTopicResult']:
        """
        Indicates the SMN topics.
        """
        return pulumi.get(self, "smn_topics")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Indicates the time zone.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the action type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetAlarmActionRulesActionRuleSmnTopicResult(dict):
    def __init__(__self__, *,
                 display_name: _builtins.str,
                 name: _builtins.str,
                 push_policy: _builtins.int,
                 status: _builtins.int,
                 topic_urn: _builtins.str):
        """
        :param _builtins.str display_name: Indicates the topic display name.
        :param _builtins.str name: Indicates the name of the topic.
        :param _builtins.int push_policy: Indicates the SMN message push policy.
        :param _builtins.int status: Indicates the status of the topic subscriber.
               Value can be:
               + **0**: The topic has been deleted or the subscription list of this topic is empty.
               + **1**: The subscription object is in the subscribed state.
               + **2**: The subscription object is in the unsubscribed or canceled state.
        :param _builtins.str topic_urn: Indicates the unique resource identifier of the topic.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "push_policy", push_policy)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Indicates the topic display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> _builtins.int:
        """
        Indicates the SMN message push policy.
        """
        return pulumi.get(self, "push_policy")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Indicates the status of the topic subscriber.
        Value can be:
        + **0**: The topic has been deleted or the subscription list of this topic is empty.
        + **1**: The subscription object is in the subscribed state.
        + **2**: The subscription object is in the unsubscribed or canceled state.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Indicates the unique resource identifier of the topic.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetAlarmGroupRulesRuleResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 details: Sequence['outputs.GetAlarmGroupRulesRuleDetailResult'],
                 enterprise_project_id: _builtins.str,
                 group_bies: Sequence[_builtins.str],
                 group_interval: _builtins.int,
                 group_repeat_waiting: _builtins.int,
                 group_wait: _builtins.int,
                 name: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the rule create time.
        :param _builtins.str description: Indicates the alarm group rule description.
        :param Sequence['GetAlarmGroupRulesRuleDetailArgs'] details: Indicates the grouping conditions list.
               The detail structure is documented below.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the rules belong.
        :param Sequence[_builtins.str] group_bies: Indicates the combine notifications.
        :param _builtins.int group_interval: Indicates the batch processing interval.
        :param _builtins.int group_repeat_waiting: Indicates the repeat interval.
        :param _builtins.int group_wait: Indicates the initial wait time.
        :param _builtins.str name: Indicates the alarm group rule name.
        :param _builtins.str updated_at: Indicates the rule update time.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "group_bies", group_bies)
        pulumi.set(__self__, "group_interval", group_interval)
        pulumi.set(__self__, "group_repeat_waiting", group_repeat_waiting)
        pulumi.set(__self__, "group_wait", group_wait)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the rule create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the alarm group rule description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetAlarmGroupRulesRuleDetailResult']:
        """
        Indicates the grouping conditions list.
        The detail structure is documented below.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the rules belong.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Sequence[_builtins.str]:
        """
        Indicates the combine notifications.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter(name="groupInterval")
    def group_interval(self) -> _builtins.int:
        """
        Indicates the batch processing interval.
        """
        return pulumi.get(self, "group_interval")

    @_builtins.property
    @pulumi.getter(name="groupRepeatWaiting")
    def group_repeat_waiting(self) -> _builtins.int:
        """
        Indicates the repeat interval.
        """
        return pulumi.get(self, "group_repeat_waiting")

    @_builtins.property
    @pulumi.getter(name="groupWait")
    def group_wait(self) -> _builtins.int:
        """
        Indicates the initial wait time.
        """
        return pulumi.get(self, "group_wait")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the alarm group rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the rule update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetAlarmGroupRulesRuleDetailResult(dict):
    def __init__(__self__, *,
                 bind_notification_rule_ids: Sequence[_builtins.str],
                 matches: Sequence['outputs.GetAlarmGroupRulesRuleDetailMatchResult']):
        """
        :param Sequence[_builtins.str] bind_notification_rule_ids: Indicates the action rule IDs.
        :param Sequence['GetAlarmGroupRulesRuleDetailMatchArgs'] matches: Indicates the matching conditions list.
               The match structure is documented below.
        """
        pulumi.set(__self__, "bind_notification_rule_ids", bind_notification_rule_ids)
        pulumi.set(__self__, "matches", matches)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleIds")
    def bind_notification_rule_ids(self) -> Sequence[_builtins.str]:
        """
        Indicates the action rule IDs.
        """
        return pulumi.get(self, "bind_notification_rule_ids")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetAlarmGroupRulesRuleDetailMatchResult']:
        """
        Indicates the matching conditions list.
        The match structure is documented below.
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetAlarmGroupRulesRuleDetailMatchResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operate: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Indicates the matching condition key.
        :param _builtins.str operate: Indicates the matching condition operator.
        :param Sequence[_builtins.str] values: Indicates the matching condition value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operate", operate)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Indicates the matching condition key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operate(self) -> _builtins.str:
        """
        Indicates the matching condition operator.
        """
        return pulumi.get(self, "operate")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Indicates the matching condition value.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAlarmRulesAlarmRuleResult(dict):
    def __init__(__self__, *,
                 alarm_notifications: Sequence['outputs.GetAlarmRulesAlarmRuleAlarmNotificationResult'],
                 alarm_rule_id: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 enable: _builtins.bool,
                 enterprise_project_id: _builtins.str,
                 event_alarm_specs: Sequence['outputs.GetAlarmRulesAlarmRuleEventAlarmSpecResult'],
                 metric_alarm_specs: Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecResult'],
                 name: _builtins.str,
                 prom_instance_id: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param Sequence['GetAlarmRulesAlarmRuleAlarmNotificationArgs'] alarm_notifications: Indicates the alarm notification.
               The alarm_notifications structure is documented below.
        :param _builtins.str alarm_rule_id: Indicates the alarm rule ID.
        :param _builtins.str created_at: Indicates the time when an alarm rule was created.
        :param _builtins.str description: Indicates the alarm rule description.
        :param _builtins.bool enable: Indicates whether the alarm rule enabled.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the rule belongs.
        :param Sequence['GetAlarmRulesAlarmRuleEventAlarmSpecArgs'] event_alarm_specs: Indicates the event alarm rule.
               The event_alarm_spec structure is documented below.
        :param Sequence['GetAlarmRulesAlarmRuleMetricAlarmSpecArgs'] metric_alarm_specs: Indicates the metric alarm rule.
               The metric_alarm_spec structure is documented below.
        :param _builtins.str name: Indicates the alarm rule name.
        :param _builtins.str prom_instance_id: Specifies the prometheus instance ID.
        :param _builtins.str status: Indicates the alarm rule status.
        :param _builtins.str type: Indicates the alarm rule type.
        :param _builtins.str updated_at: Indicates the time when an alarm rule was updated.
        """
        pulumi.set(__self__, "alarm_notifications", alarm_notifications)
        pulumi.set(__self__, "alarm_rule_id", alarm_rule_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "event_alarm_specs", event_alarm_specs)
        pulumi.set(__self__, "metric_alarm_specs", metric_alarm_specs)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prom_instance_id", prom_instance_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="alarmNotifications")
    def alarm_notifications(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleAlarmNotificationResult']:
        """
        Indicates the alarm notification.
        The alarm_notifications structure is documented below.
        """
        return pulumi.get(self, "alarm_notifications")

    @_builtins.property
    @pulumi.getter(name="alarmRuleId")
    def alarm_rule_id(self) -> _builtins.str:
        """
        Indicates the alarm rule ID.
        """
        return pulumi.get(self, "alarm_rule_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when an alarm rule was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the alarm rule description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Indicates whether the alarm rule enabled.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the rule belongs.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="eventAlarmSpecs")
    def event_alarm_specs(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleEventAlarmSpecResult']:
        """
        Indicates the event alarm rule.
        The event_alarm_spec structure is documented below.
        """
        return pulumi.get(self, "event_alarm_specs")

    @_builtins.property
    @pulumi.getter(name="metricAlarmSpecs")
    def metric_alarm_specs(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecResult']:
        """
        Indicates the metric alarm rule.
        The metric_alarm_spec structure is documented below.
        """
        return pulumi.get(self, "metric_alarm_specs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the alarm rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="promInstanceId")
    def prom_instance_id(self) -> _builtins.str:
        """
        Specifies the prometheus instance ID.
        """
        return pulumi.get(self, "prom_instance_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the alarm rule status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the alarm rule type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the time when an alarm rule was updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetAlarmRulesAlarmRuleAlarmNotificationResult(dict):
    def __init__(__self__, *,
                 bind_notification_rule_id: _builtins.str,
                 notification_enable: _builtins.bool,
                 notification_type: _builtins.str,
                 notify_frequency: _builtins.str,
                 notify_resolved: _builtins.bool,
                 notify_triggered: _builtins.bool,
                 route_group_enable: _builtins.bool,
                 route_group_rule: _builtins.str):
        """
        :param _builtins.str bind_notification_rule_id: Specifies the name of the bound alarm action rule.
        :param _builtins.bool notification_enable: Indicates whether the alarm action rule enabled.
        :param _builtins.str notification_type: Indicates the notification type.
               Value can be as follows:
               + **direct**: direct alarm reporting
               + **alarm_policy**: alarm reporting after noise reduction
        :param _builtins.str notify_frequency: Indicates the notification frequency.
        :param _builtins.bool notify_resolved: Indicates whether the notification enabled when an alarm is cleared.
        :param _builtins.bool notify_triggered: Indicates whether the notification enabled when an alarm is triggered.
        :param _builtins.bool route_group_enable: Indicates whether the grouping rule enabled.
        :param _builtins.str route_group_rule: Indicates the grouping rule name.
        """
        pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        pulumi.set(__self__, "notification_enable", notification_enable)
        pulumi.set(__self__, "notification_type", notification_type)
        pulumi.set(__self__, "notify_frequency", notify_frequency)
        pulumi.set(__self__, "notify_resolved", notify_resolved)
        pulumi.set(__self__, "notify_triggered", notify_triggered)
        pulumi.set(__self__, "route_group_enable", route_group_enable)
        pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> _builtins.str:
        """
        Specifies the name of the bound alarm action rule.
        """
        return pulumi.get(self, "bind_notification_rule_id")

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> _builtins.bool:
        """
        Indicates whether the alarm action rule enabled.
        """
        return pulumi.get(self, "notification_enable")

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> _builtins.str:
        """
        Indicates the notification type.
        Value can be as follows:
        + **direct**: direct alarm reporting
        + **alarm_policy**: alarm reporting after noise reduction
        """
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter(name="notifyFrequency")
    def notify_frequency(self) -> _builtins.str:
        """
        Indicates the notification frequency.
        """
        return pulumi.get(self, "notify_frequency")

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> _builtins.bool:
        """
        Indicates whether the notification enabled when an alarm is cleared.
        """
        return pulumi.get(self, "notify_resolved")

    @_builtins.property
    @pulumi.getter(name="notifyTriggered")
    def notify_triggered(self) -> _builtins.bool:
        """
        Indicates whether the notification enabled when an alarm is triggered.
        """
        return pulumi.get(self, "notify_triggered")

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> _builtins.bool:
        """
        Indicates whether the grouping rule enabled.
        """
        return pulumi.get(self, "route_group_enable")

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> _builtins.str:
        """
        Indicates the grouping rule name.
        """
        return pulumi.get(self, "route_group_rule")


@pulumi.output_type
class GetAlarmRulesAlarmRuleEventAlarmSpecResult(dict):
    def __init__(__self__, *,
                 alarm_source: _builtins.str,
                 event_source: _builtins.str,
                 monitor_objects: Sequence[Mapping[str, _builtins.str]],
                 trigger_conditions: Sequence['outputs.GetAlarmRulesAlarmRuleEventAlarmSpecTriggerConditionResult']):
        """
        :param _builtins.str alarm_source: Indicates the alarm rule source.
               Value can be **systemEvent** and **customEvent**.
        :param _builtins.str event_source: Specifies the source of an event alarm rule.
               Valid values are **RDS**, **EVS**, **CCE**, **LTS** and **AOM**.
        :param Sequence[Mapping[str, _builtins.str]] monitor_objects: Indicates the list of monitored objects.
        :param Sequence['GetAlarmRulesAlarmRuleEventAlarmSpecTriggerConditionArgs'] trigger_conditions: Indicates the trigger conditions.
               The trigger_conditions structure is documented below.
        """
        pulumi.set(__self__, "alarm_source", alarm_source)
        pulumi.set(__self__, "event_source", event_source)
        pulumi.set(__self__, "monitor_objects", monitor_objects)
        pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> _builtins.str:
        """
        Indicates the alarm rule source.
        Value can be **systemEvent** and **customEvent**.
        """
        return pulumi.get(self, "alarm_source")

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> _builtins.str:
        """
        Specifies the source of an event alarm rule.
        Valid values are **RDS**, **EVS**, **CCE**, **LTS** and **AOM**.
        """
        return pulumi.get(self, "event_source")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Sequence[Mapping[str, _builtins.str]]:
        """
        Indicates the list of monitored objects.
        """
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleEventAlarmSpecTriggerConditionResult']:
        """
        Indicates the trigger conditions.
        The trigger_conditions structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class GetAlarmRulesAlarmRuleEventAlarmSpecTriggerConditionResult(dict):
    def __init__(__self__, *,
                 aggregation_window: _builtins.int,
                 event_name: _builtins.str,
                 frequency: _builtins.str,
                 operator: _builtins.str,
                 thresholds: Mapping[str, _builtins.int],
                 trigger_type: _builtins.str):
        """
        :param _builtins.int aggregation_window: Indicates the statistical period.
        :param _builtins.str event_name: Indicates the event name.
        :param _builtins.str frequency: Indicates the event alarm notification frequency.
        :param _builtins.str operator: Indicates the operator.
        :param Mapping[str, _builtins.int] thresholds: Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        :param _builtins.str trigger_type: Indicates the trigger type.
               Value can be as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "aggregation_window", aggregation_window)
        pulumi.set(__self__, "event_name", event_name)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "thresholds", thresholds)
        pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> _builtins.int:
        """
        Indicates the statistical period.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> _builtins.str:
        """
        Indicates the event name.
        """
        return pulumi.get(self, "event_name")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        Indicates the event alarm notification frequency.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Indicates the operator.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Mapping[str, _builtins.int]:
        """
        Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        Indicates the trigger type.
        Value can be as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class GetAlarmRulesAlarmRuleMetricAlarmSpecResult(dict):
    def __init__(__self__, *,
                 alarm_tags: Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecAlarmTagResult'],
                 monitor_objects: Sequence[Mapping[str, _builtins.str]],
                 monitor_type: _builtins.str,
                 no_data_conditions: Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecNoDataConditionResult'],
                 recovery_conditions: Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecRecoveryConditionResult'],
                 trigger_conditions: Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecTriggerConditionResult']):
        """
        :param Sequence['GetAlarmRulesAlarmRuleMetricAlarmSpecAlarmTagArgs'] alarm_tags: Indicates the alarm tags.
               The alarm_tags structure is documented below.
        :param Sequence[Mapping[str, _builtins.str]] monitor_objects: Indicates the list of monitored objects.
        :param _builtins.str monitor_type: Indicates the monitoring type.
               Value can be as follows:
               + **all_metric**: Select metrics from all metrics.
               + **promql**: Select metrics using PromQL.
        :param Sequence['GetAlarmRulesAlarmRuleMetricAlarmSpecNoDataConditionArgs'] no_data_conditions: Indicates the action taken for insufficient data.
               The no_data_conditions structure is documented below.
        :param Sequence['GetAlarmRulesAlarmRuleMetricAlarmSpecRecoveryConditionArgs'] recovery_conditions: Indicates the alarm clearance condition.
               The recovery_conditions structure is documented below.
        :param Sequence['GetAlarmRulesAlarmRuleMetricAlarmSpecTriggerConditionArgs'] trigger_conditions: Indicates the trigger conditions.
               The trigger_conditions structure is documented below.
        """
        pulumi.set(__self__, "alarm_tags", alarm_tags)
        pulumi.set(__self__, "monitor_objects", monitor_objects)
        pulumi.set(__self__, "monitor_type", monitor_type)
        pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecAlarmTagResult']:
        """
        Indicates the alarm tags.
        The alarm_tags structure is documented below.
        """
        return pulumi.get(self, "alarm_tags")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Sequence[Mapping[str, _builtins.str]]:
        """
        Indicates the list of monitored objects.
        """
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> _builtins.str:
        """
        Indicates the monitoring type.
        Value can be as follows:
        + **all_metric**: Select metrics from all metrics.
        + **promql**: Select metrics using PromQL.
        """
        return pulumi.get(self, "monitor_type")

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecNoDataConditionResult']:
        """
        Indicates the action taken for insufficient data.
        The no_data_conditions structure is documented below.
        """
        return pulumi.get(self, "no_data_conditions")

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecRecoveryConditionResult']:
        """
        Indicates the alarm clearance condition.
        The recovery_conditions structure is documented below.
        """
        return pulumi.get(self, "recovery_conditions")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Sequence['outputs.GetAlarmRulesAlarmRuleMetricAlarmSpecTriggerConditionResult']:
        """
        Indicates the trigger conditions.
        The trigger_conditions structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class GetAlarmRulesAlarmRuleMetricAlarmSpecAlarmTagResult(dict):
    def __init__(__self__, *,
                 auto_tags: Sequence[_builtins.str],
                 custom_annotations: Sequence[_builtins.str],
                 custom_tags: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] auto_tags: Indicates the automatic tag.
        :param Sequence[_builtins.str] custom_annotations: Indicates the alarm annotation.
        :param Sequence[_builtins.str] custom_tags: Indicates the custom tag.
        """
        pulumi.set(__self__, "auto_tags", auto_tags)
        pulumi.set(__self__, "custom_annotations", custom_annotations)
        pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Sequence[_builtins.str]:
        """
        Indicates the automatic tag.
        """
        return pulumi.get(self, "auto_tags")

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Sequence[_builtins.str]:
        """
        Indicates the alarm annotation.
        """
        return pulumi.get(self, "custom_annotations")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Sequence[_builtins.str]:
        """
        Indicates the custom tag.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetAlarmRulesAlarmRuleMetricAlarmSpecNoDataConditionResult(dict):
    def __init__(__self__, *,
                 no_data_alert_state: _builtins.str,
                 no_data_timeframe: _builtins.int,
                 notify_no_data: _builtins.bool):
        """
        :param _builtins.str no_data_alert_state: Indicates the status of the threshold rule when the data is insufficient.
               Value can be as follows:
               + **no_data**: A notification indicating insufficient data is sent.
               + **alerting**: An alarm is triggered.
               + **ok**: No exception occurs.
               + **pre_state**: Retain the previous state.
        :param _builtins.int no_data_timeframe: Indicates the number of periods without data.
        :param _builtins.bool notify_no_data: Indicates whether to send a notification when data is insufficient.
        """
        pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> _builtins.str:
        """
        Indicates the status of the threshold rule when the data is insufficient.
        Value can be as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        return pulumi.get(self, "no_data_alert_state")

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> _builtins.int:
        """
        Indicates the number of periods without data.
        """
        return pulumi.get(self, "no_data_timeframe")

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> _builtins.bool:
        """
        Indicates whether to send a notification when data is insufficient.
        """
        return pulumi.get(self, "notify_no_data")


@pulumi.output_type
class GetAlarmRulesAlarmRuleMetricAlarmSpecRecoveryConditionResult(dict):
    def __init__(__self__, *,
                 recovery_timeframe: _builtins.int):
        """
        :param _builtins.int recovery_timeframe: Indicates the number of consecutive periods for which the trigger condition is not met to clear
               an alarm.
        """
        pulumi.set(__self__, "recovery_timeframe", recovery_timeframe)

    @_builtins.property
    @pulumi.getter(name="recoveryTimeframe")
    def recovery_timeframe(self) -> _builtins.int:
        """
        Indicates the number of consecutive periods for which the trigger condition is not met to clear
        an alarm.
        """
        return pulumi.get(self, "recovery_timeframe")


@pulumi.output_type
class GetAlarmRulesAlarmRuleMetricAlarmSpecTriggerConditionResult(dict):
    def __init__(__self__, *,
                 aggregate_type: _builtins.str,
                 aggregation_type: _builtins.str,
                 aggregation_window: _builtins.str,
                 aom_monitor_level: _builtins.str,
                 expression: _builtins.str,
                 metric_labels: Sequence[_builtins.str],
                 metric_name: _builtins.str,
                 metric_namespace: _builtins.str,
                 metric_query_mode: _builtins.str,
                 metric_statistic_method: _builtins.str,
                 metric_unit: _builtins.str,
                 mix_promql: _builtins.str,
                 operator: _builtins.str,
                 promql: _builtins.str,
                 promql_exprs: Sequence[_builtins.str],
                 promql_for: _builtins.str,
                 query_match: _builtins.str,
                 query_param: _builtins.str,
                 thresholds: Mapping[str, _builtins.str],
                 trigger_interval: _builtins.str,
                 trigger_times: _builtins.str,
                 trigger_type: _builtins.str):
        """
        :param _builtins.str aggregate_type: Indicates the aggregation mode.
               Value can be **by**, **avg**, **max**, **min** and **sum**.
        :param _builtins.str aggregation_type: Indicates the statistical mode.
               Value can be **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        :param _builtins.str aggregation_window: Indicates the statistical period.
        :param _builtins.str aom_monitor_level: Indicates the monitoring layer.
        :param _builtins.str expression: Indicates the expression of a combined operation.
        :param Sequence[_builtins.str] metric_labels: Indicates the metric dimension.
        :param _builtins.str metric_name: Indicates the metric name.
        :param _builtins.str metric_namespace: Indicates the metric namespace.
        :param _builtins.str metric_query_mode: Indicates the metric query mode.
               Value can be as follows:
               + **AOM**: native AOM
               + **PROM**: AOM Prometheus
               + **NATIVE_PROM**: native Prometheus
        :param _builtins.str metric_statistic_method: Indicates the metric statistics method to be used.
               Value can be as follows:
               + **single**: single metric
               + **mix**: multi-metric combined operations
        :param _builtins.str metric_unit: Indicates the metric unit.
        :param _builtins.str mix_promql: Indicates the promQL of a combined operation.
        :param _builtins.str operator: Indicates the operator.
        :param _builtins.str promql: Indicates the prometheus statement.
        :param Sequence[_builtins.str] promql_exprs: Indicates the prometheus statement template.
        :param _builtins.str promql_for: Indicates the native Prometheus monitoring duration.
        :param _builtins.str query_match: Indicates the query filter criteria.
        :param _builtins.str query_param: Indicates the query parameters.
        :param Mapping[str, _builtins.str] thresholds: Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        :param _builtins.str trigger_interval: Indicates the check interval.
        :param _builtins.str trigger_times: Indicates the number of consecutive periods.
        :param _builtins.str trigger_type: Indicates the trigger type.
               Value can be as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "aggregate_type", aggregate_type)
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "aggregation_window", aggregation_window)
        pulumi.set(__self__, "aom_monitor_level", aom_monitor_level)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "metric_labels", metric_labels)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        pulumi.set(__self__, "metric_statistic_method", metric_statistic_method)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "mix_promql", mix_promql)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "promql", promql)
        pulumi.set(__self__, "promql_exprs", promql_exprs)
        pulumi.set(__self__, "promql_for", promql_for)
        pulumi.set(__self__, "query_match", query_match)
        pulumi.set(__self__, "query_param", query_param)
        pulumi.set(__self__, "thresholds", thresholds)
        pulumi.set(__self__, "trigger_interval", trigger_interval)
        pulumi.set(__self__, "trigger_times", trigger_times)
        pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="aggregateType")
    def aggregate_type(self) -> _builtins.str:
        """
        Indicates the aggregation mode.
        Value can be **by**, **avg**, **max**, **min** and **sum**.
        """
        return pulumi.get(self, "aggregate_type")

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Indicates the statistical mode.
        Value can be **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> _builtins.str:
        """
        Indicates the statistical period.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="aomMonitorLevel")
    def aom_monitor_level(self) -> _builtins.str:
        """
        Indicates the monitoring layer.
        """
        return pulumi.get(self, "aom_monitor_level")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Indicates the expression of a combined operation.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Sequence[_builtins.str]:
        """
        Indicates the metric dimension.
        """
        return pulumi.get(self, "metric_labels")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Indicates the metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> _builtins.str:
        """
        Indicates the metric namespace.
        """
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> _builtins.str:
        """
        Indicates the metric query mode.
        Value can be as follows:
        + **AOM**: native AOM
        + **PROM**: AOM Prometheus
        + **NATIVE_PROM**: native Prometheus
        """
        return pulumi.get(self, "metric_query_mode")

    @_builtins.property
    @pulumi.getter(name="metricStatisticMethod")
    def metric_statistic_method(self) -> _builtins.str:
        """
        Indicates the metric statistics method to be used.
        Value can be as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        return pulumi.get(self, "metric_statistic_method")

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> _builtins.str:
        """
        Indicates the metric unit.
        """
        return pulumi.get(self, "metric_unit")

    @_builtins.property
    @pulumi.getter(name="mixPromql")
    def mix_promql(self) -> _builtins.str:
        """
        Indicates the promQL of a combined operation.
        """
        return pulumi.get(self, "mix_promql")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Indicates the operator.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def promql(self) -> _builtins.str:
        """
        Indicates the prometheus statement.
        """
        return pulumi.get(self, "promql")

    @_builtins.property
    @pulumi.getter(name="promqlExprs")
    def promql_exprs(self) -> Sequence[_builtins.str]:
        """
        Indicates the prometheus statement template.
        """
        return pulumi.get(self, "promql_exprs")

    @_builtins.property
    @pulumi.getter(name="promqlFor")
    def promql_for(self) -> _builtins.str:
        """
        Indicates the native Prometheus monitoring duration.
        """
        return pulumi.get(self, "promql_for")

    @_builtins.property
    @pulumi.getter(name="queryMatch")
    def query_match(self) -> _builtins.str:
        """
        Indicates the query filter criteria.
        """
        return pulumi.get(self, "query_match")

    @_builtins.property
    @pulumi.getter(name="queryParam")
    def query_param(self) -> _builtins.str:
        """
        Indicates the query parameters.
        """
        return pulumi.get(self, "query_param")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Mapping[str, _builtins.str]:
        """
        Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> _builtins.str:
        """
        Indicates the check interval.
        """
        return pulumi.get(self, "trigger_interval")

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> _builtins.str:
        """
        Indicates the number of consecutive periods.
        """
        return pulumi.get(self, "trigger_times")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        Indicates the trigger type.
        Value can be as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 alarm_template_spec_lists: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListResult'],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 templatings: Sequence['outputs.GetAlarmRulesTemplatesTemplateTemplatingResult'],
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListArgs'] alarm_template_spec_lists: Indicates the alarm template spec list.
               The alarm_template_spec_list structure is documented below.
        :param _builtins.str created_at: Indicates the template create time.
        :param _builtins.str description: Indicates the variable description.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the templates belong.
        :param _builtins.str id: Indicates the template ID.
        :param _builtins.str name: Indicates the variable name.
        :param Sequence['GetAlarmRulesTemplatesTemplateTemplatingArgs'] templatings: Indicates the variable list.
               The templating structure is documented below.
        :param _builtins.str type: Indicates the variable type.
        :param _builtins.str updated_at: Indicates the template update time.
        """
        pulumi.set(__self__, "alarm_template_spec_lists", alarm_template_spec_lists)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "templatings", templatings)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="alarmTemplateSpecLists")
    def alarm_template_spec_lists(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListResult']:
        """
        Indicates the alarm template spec list.
        The alarm_template_spec_list structure is documented below.
        """
        return pulumi.get(self, "alarm_template_spec_lists")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the template create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the variable description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the templates belong.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the template ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the variable name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def templatings(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateTemplatingResult']:
        """
        Indicates the variable list.
        The templating structure is documented below.
        """
        return pulumi.get(self, "templatings")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the variable type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the template update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListResult(dict):
    def __init__(__self__, *,
                 alarm_notifications: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmNotificationResult'],
                 alarm_template_spec_items: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemResult'],
                 related_cce_clusters: Sequence[_builtins.str],
                 related_cloud_service: _builtins.str,
                 related_prometheus_instances: Sequence[_builtins.str]):
        """
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmNotificationArgs'] alarm_notifications: Indicates the alarm notification.
               The alarm_notification structure is documented
               below.
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs'] alarm_template_spec_items: Indicates the alarm template spec items.
               The alarm_template_spec_items structure
               is documented below.
        :param Sequence[_builtins.str] related_cce_clusters: Indicates the related CCE clusters.
        :param _builtins.str related_cloud_service: Indicates the related cloud service.
        :param Sequence[_builtins.str] related_prometheus_instances: Indicates the related prometheus instances.
        """
        pulumi.set(__self__, "alarm_notifications", alarm_notifications)
        pulumi.set(__self__, "alarm_template_spec_items", alarm_template_spec_items)
        pulumi.set(__self__, "related_cce_clusters", related_cce_clusters)
        pulumi.set(__self__, "related_cloud_service", related_cloud_service)
        pulumi.set(__self__, "related_prometheus_instances", related_prometheus_instances)

    @_builtins.property
    @pulumi.getter(name="alarmNotifications")
    def alarm_notifications(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmNotificationResult']:
        """
        Indicates the alarm notification.
        The alarm_notification structure is documented
        below.
        """
        return pulumi.get(self, "alarm_notifications")

    @_builtins.property
    @pulumi.getter(name="alarmTemplateSpecItems")
    def alarm_template_spec_items(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemResult']:
        """
        Indicates the alarm template spec items.
        The alarm_template_spec_items structure
        is documented below.
        """
        return pulumi.get(self, "alarm_template_spec_items")

    @_builtins.property
    @pulumi.getter(name="relatedCceClusters")
    def related_cce_clusters(self) -> Sequence[_builtins.str]:
        """
        Indicates the related CCE clusters.
        """
        return pulumi.get(self, "related_cce_clusters")

    @_builtins.property
    @pulumi.getter(name="relatedCloudService")
    def related_cloud_service(self) -> _builtins.str:
        """
        Indicates the related cloud service.
        """
        return pulumi.get(self, "related_cloud_service")

    @_builtins.property
    @pulumi.getter(name="relatedPrometheusInstances")
    def related_prometheus_instances(self) -> Sequence[_builtins.str]:
        """
        Indicates the related prometheus instances.
        """
        return pulumi.get(self, "related_prometheus_instances")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmNotificationResult(dict):
    def __init__(__self__, *,
                 bind_notification_rule_id: _builtins.str,
                 notification_enable: _builtins.bool,
                 notification_type: _builtins.str,
                 notify_frequency: _builtins.str,
                 notify_resolved: _builtins.bool,
                 notify_triggered: _builtins.bool,
                 route_group_enable: _builtins.bool,
                 route_group_rule: _builtins.str):
        """
        :param _builtins.str bind_notification_rule_id: Indicates the alarm action rule ID.
        :param _builtins.bool notification_enable: Indicates whether the alarm action rule enabled.
        :param _builtins.str notification_type: Indicates the notification type.
               Value can be as follows:
               + **direct**: direct alarm reporting
               + **alarm_policy**: alarm reporting after noise reduction
        :param _builtins.str notify_frequency: Indicates the notification frequency.
        :param _builtins.bool notify_resolved: Indicates whether the notification enabled when an alarm is cleared.
        :param _builtins.bool notify_triggered: Indicates whether the notification enabled when an alarm is triggered.
        :param _builtins.bool route_group_enable: Indicates whether the grouping rule enabled.
        :param _builtins.str route_group_rule: Indicates the grouping rule name.
        """
        pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        pulumi.set(__self__, "notification_enable", notification_enable)
        pulumi.set(__self__, "notification_type", notification_type)
        pulumi.set(__self__, "notify_frequency", notify_frequency)
        pulumi.set(__self__, "notify_resolved", notify_resolved)
        pulumi.set(__self__, "notify_triggered", notify_triggered)
        pulumi.set(__self__, "route_group_enable", route_group_enable)
        pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> _builtins.str:
        """
        Indicates the alarm action rule ID.
        """
        return pulumi.get(self, "bind_notification_rule_id")

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> _builtins.bool:
        """
        Indicates whether the alarm action rule enabled.
        """
        return pulumi.get(self, "notification_enable")

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> _builtins.str:
        """
        Indicates the notification type.
        Value can be as follows:
        + **direct**: direct alarm reporting
        + **alarm_policy**: alarm reporting after noise reduction
        """
        return pulumi.get(self, "notification_type")

    @_builtins.property
    @pulumi.getter(name="notifyFrequency")
    def notify_frequency(self) -> _builtins.str:
        """
        Indicates the notification frequency.
        """
        return pulumi.get(self, "notify_frequency")

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> _builtins.bool:
        """
        Indicates whether the notification enabled when an alarm is cleared.
        """
        return pulumi.get(self, "notify_resolved")

    @_builtins.property
    @pulumi.getter(name="notifyTriggered")
    def notify_triggered(self) -> _builtins.bool:
        """
        Indicates whether the notification enabled when an alarm is triggered.
        """
        return pulumi.get(self, "notify_triggered")

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> _builtins.bool:
        """
        Indicates whether the grouping rule enabled.
        """
        return pulumi.get(self, "route_group_enable")

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> _builtins.str:
        """
        Indicates the grouping rule name.
        """
        return pulumi.get(self, "route_group_rule")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemResult(dict):
    def __init__(__self__, *,
                 alarm_rule_description: _builtins.str,
                 alarm_rule_name: _builtins.str,
                 alarm_rule_type: _builtins.str,
                 event_alarm_specs: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecResult'],
                 metric_alarm_specs: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecResult']):
        """
        :param _builtins.str alarm_rule_description: Indicates the alarm rule description.
        :param _builtins.str alarm_rule_name: Indicates the alarm rule name.
        :param _builtins.str alarm_rule_type: Indicates the alarm rule type.
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs'] event_alarm_specs: Indicates the event alarm spec.
               The event_alarm_spec
               structure is documented below.
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs'] metric_alarm_specs: Indicates the metric alarm spec.
               The metric_alarm_spec
               structure is documented below.
        """
        pulumi.set(__self__, "alarm_rule_description", alarm_rule_description)
        pulumi.set(__self__, "alarm_rule_name", alarm_rule_name)
        pulumi.set(__self__, "alarm_rule_type", alarm_rule_type)
        pulumi.set(__self__, "event_alarm_specs", event_alarm_specs)
        pulumi.set(__self__, "metric_alarm_specs", metric_alarm_specs)

    @_builtins.property
    @pulumi.getter(name="alarmRuleDescription")
    def alarm_rule_description(self) -> _builtins.str:
        """
        Indicates the alarm rule description.
        """
        return pulumi.get(self, "alarm_rule_description")

    @_builtins.property
    @pulumi.getter(name="alarmRuleName")
    def alarm_rule_name(self) -> _builtins.str:
        """
        Indicates the alarm rule name.
        """
        return pulumi.get(self, "alarm_rule_name")

    @_builtins.property
    @pulumi.getter(name="alarmRuleType")
    def alarm_rule_type(self) -> _builtins.str:
        """
        Indicates the alarm rule type.
        """
        return pulumi.get(self, "alarm_rule_type")

    @_builtins.property
    @pulumi.getter(name="eventAlarmSpecs")
    def event_alarm_specs(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecResult']:
        """
        Indicates the event alarm spec.
        The event_alarm_spec
        structure is documented below.
        """
        return pulumi.get(self, "event_alarm_specs")

    @_builtins.property
    @pulumi.getter(name="metricAlarmSpecs")
    def metric_alarm_specs(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecResult']:
        """
        Indicates the metric alarm spec.
        The metric_alarm_spec
        structure is documented below.
        """
        return pulumi.get(self, "metric_alarm_specs")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecResult(dict):
    def __init__(__self__, *,
                 alarm_source: _builtins.str,
                 alarm_subtype: _builtins.str,
                 event_source: _builtins.str,
                 monitor_object_templates: Sequence[_builtins.str],
                 monitor_objects: Sequence[Mapping[str, _builtins.str]],
                 trigger_conditions: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionResult']):
        """
        :param _builtins.str alarm_source: Indicates the alarm source.
        :param _builtins.str alarm_subtype: Indicates the alarm subtype.
        :param _builtins.str event_source: Indicates the event source.
        :param Sequence[_builtins.str] monitor_object_templates: Indicates the monitor object templates.
        :param Sequence[Mapping[str, _builtins.str]] monitor_objects: Indicates the monitor objects.
               Value can be as follows:
               + **event_type**: notification type
               + **event_severity**: alarm severity
               + **event_name**: event name
               + **namespace**: namespace
               + **clusterId**: cluster ID
               + **customField**: user-defined field
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs'] trigger_conditions: Indicates the trigger conditions.
               The trigger_conditions
               structure is documented below.
        """
        pulumi.set(__self__, "alarm_source", alarm_source)
        pulumi.set(__self__, "alarm_subtype", alarm_subtype)
        pulumi.set(__self__, "event_source", event_source)
        pulumi.set(__self__, "monitor_object_templates", monitor_object_templates)
        pulumi.set(__self__, "monitor_objects", monitor_objects)
        pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> _builtins.str:
        """
        Indicates the alarm source.
        """
        return pulumi.get(self, "alarm_source")

    @_builtins.property
    @pulumi.getter(name="alarmSubtype")
    def alarm_subtype(self) -> _builtins.str:
        """
        Indicates the alarm subtype.
        """
        return pulumi.get(self, "alarm_subtype")

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> _builtins.str:
        """
        Indicates the event source.
        """
        return pulumi.get(self, "event_source")

    @_builtins.property
    @pulumi.getter(name="monitorObjectTemplates")
    def monitor_object_templates(self) -> Sequence[_builtins.str]:
        """
        Indicates the monitor object templates.
        """
        return pulumi.get(self, "monitor_object_templates")

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Sequence[Mapping[str, _builtins.str]]:
        """
        Indicates the monitor objects.
        Value can be as follows:
        + **event_type**: notification type
        + **event_severity**: alarm severity
        + **event_name**: event name
        + **namespace**: namespace
        + **clusterId**: cluster ID
        + **customField**: user-defined field
        """
        return pulumi.get(self, "monitor_objects")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionResult']:
        """
        Indicates the trigger conditions.
        The trigger_conditions
        structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionResult(dict):
    def __init__(__self__, *,
                 aggregation_window: _builtins.int,
                 event_name: _builtins.str,
                 frequency: _builtins.str,
                 operator: _builtins.str,
                 thresholds: Mapping[str, _builtins.int],
                 trigger_type: _builtins.str):
        """
        :param _builtins.int aggregation_window: Indicates the statistical period.
        :param _builtins.str event_name: Indicates the event name.
        :param _builtins.str frequency: Indicates the event alarm notification frequency.
        :param _builtins.str operator: Indicates the operator.
        :param Mapping[str, _builtins.int] thresholds: Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        :param _builtins.str trigger_type: Indicates the trigger type.
               Value can be as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "aggregation_window", aggregation_window)
        pulumi.set(__self__, "event_name", event_name)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "thresholds", thresholds)
        pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> _builtins.int:
        """
        Indicates the statistical period.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> _builtins.str:
        """
        Indicates the event name.
        """
        return pulumi.get(self, "event_name")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        Indicates the event alarm notification frequency.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Indicates the operator.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Mapping[str, _builtins.int]:
        """
        Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        Indicates the trigger type.
        Value can be as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecResult(dict):
    def __init__(__self__, *,
                 alarm_source: _builtins.str,
                 alarm_subtype: _builtins.str,
                 alarm_tags: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagResult'],
                 monitor_type: _builtins.str,
                 no_data_conditions: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionResult'],
                 recovery_conditions: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionResult'],
                 trigger_conditions: Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionResult']):
        """
        :param _builtins.str alarm_source: Indicates the alarm source.
        :param _builtins.str alarm_subtype: Indicates the alarm subtype.
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagArgs'] alarm_tags: Indicates the alarm tags.
               The alarm_tags
               structure is documented below.
        :param _builtins.str monitor_type: Indicates the monitor_type.
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionArgs'] no_data_conditions: Indicates the no data conditions.
               The no_data_conditions
               structure is documented below.
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionArgs'] recovery_conditions: Indicates the recovery conditions.
               The recovery_conditions
               structure is documented below.
        :param Sequence['GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs'] trigger_conditions: Indicates the trigger conditions.
               The trigger_conditions
               structure is documented below.
        """
        pulumi.set(__self__, "alarm_source", alarm_source)
        pulumi.set(__self__, "alarm_subtype", alarm_subtype)
        pulumi.set(__self__, "alarm_tags", alarm_tags)
        pulumi.set(__self__, "monitor_type", monitor_type)
        pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> _builtins.str:
        """
        Indicates the alarm source.
        """
        return pulumi.get(self, "alarm_source")

    @_builtins.property
    @pulumi.getter(name="alarmSubtype")
    def alarm_subtype(self) -> _builtins.str:
        """
        Indicates the alarm subtype.
        """
        return pulumi.get(self, "alarm_subtype")

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagResult']:
        """
        Indicates the alarm tags.
        The alarm_tags
        structure is documented below.
        """
        return pulumi.get(self, "alarm_tags")

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> _builtins.str:
        """
        Indicates the monitor_type.
        """
        return pulumi.get(self, "monitor_type")

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionResult']:
        """
        Indicates the no data conditions.
        The no_data_conditions
        structure is documented below.
        """
        return pulumi.get(self, "no_data_conditions")

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionResult']:
        """
        Indicates the recovery conditions.
        The recovery_conditions
        structure is documented below.
        """
        return pulumi.get(self, "recovery_conditions")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionResult']:
        """
        Indicates the trigger conditions.
        The trigger_conditions
        structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagResult(dict):
    def __init__(__self__, *,
                 auto_tags: Sequence[_builtins.str],
                 custom_annotations: Sequence[_builtins.str],
                 custom_tags: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] auto_tags: Indicates the automatic tag.
        :param Sequence[_builtins.str] custom_annotations: Indicates the alarm annotation.
        :param Sequence[_builtins.str] custom_tags: Indicates the custom tag.
        """
        pulumi.set(__self__, "auto_tags", auto_tags)
        pulumi.set(__self__, "custom_annotations", custom_annotations)
        pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Sequence[_builtins.str]:
        """
        Indicates the automatic tag.
        """
        return pulumi.get(self, "auto_tags")

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Sequence[_builtins.str]:
        """
        Indicates the alarm annotation.
        """
        return pulumi.get(self, "custom_annotations")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Sequence[_builtins.str]:
        """
        Indicates the custom tag.
        """
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionResult(dict):
    def __init__(__self__, *,
                 no_data_alert_state: _builtins.str,
                 no_data_timeframe: _builtins.int,
                 notify_no_data: _builtins.bool):
        """
        :param _builtins.str no_data_alert_state: Indicates the status of the threshold rule when the data is insufficient.
               Value can be as follows:
               + **no_data**: A notification indicating insufficient data is sent.
               + **alerting**: An alarm is triggered.
               + **ok**: No exception occurs.
               + **pre_state**: Retain the previous state.
        :param _builtins.int no_data_timeframe: Indicates the number of periods without data.
        :param _builtins.bool notify_no_data: Indicates whether to send a notification when data is insufficient.
        """
        pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> _builtins.str:
        """
        Indicates the status of the threshold rule when the data is insufficient.
        Value can be as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        return pulumi.get(self, "no_data_alert_state")

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> _builtins.int:
        """
        Indicates the number of periods without data.
        """
        return pulumi.get(self, "no_data_timeframe")

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> _builtins.bool:
        """
        Indicates whether to send a notification when data is insufficient.
        """
        return pulumi.get(self, "notify_no_data")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionResult(dict):
    def __init__(__self__, *,
                 recovery_timeframe: _builtins.int):
        """
        :param _builtins.int recovery_timeframe: Indicates the number of consecutive periods for which the trigger condition is not met to clear
               an alarm.
        """
        pulumi.set(__self__, "recovery_timeframe", recovery_timeframe)

    @_builtins.property
    @pulumi.getter(name="recoveryTimeframe")
    def recovery_timeframe(self) -> _builtins.int:
        """
        Indicates the number of consecutive periods for which the trigger condition is not met to clear
        an alarm.
        """
        return pulumi.get(self, "recovery_timeframe")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionResult(dict):
    def __init__(__self__, *,
                 aggregate_type: _builtins.str,
                 aggregation_type: _builtins.str,
                 aggregation_window: _builtins.str,
                 aom_monitor_level: _builtins.str,
                 expression: _builtins.str,
                 metric_labels: Sequence[_builtins.str],
                 metric_name: _builtins.str,
                 metric_namespace: _builtins.str,
                 metric_query_mode: _builtins.str,
                 metric_statistic_method: _builtins.str,
                 metric_unit: _builtins.str,
                 mix_promql: _builtins.str,
                 operator: _builtins.str,
                 promql: _builtins.str,
                 promql_exprs: Sequence[_builtins.str],
                 promql_for: _builtins.str,
                 query_match: _builtins.str,
                 thresholds: Mapping[str, _builtins.str],
                 trigger_interval: _builtins.str,
                 trigger_times: _builtins.str,
                 trigger_type: _builtins.str):
        """
        :param _builtins.str aggregate_type: Indicates the aggregation mode.
               Value can be **by**, **avg**, **max**, **min** and **sum**.
        :param _builtins.str aggregation_type: Indicates the statistical mode.
               Value can be **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        :param _builtins.str aggregation_window: Indicates the statistical period.
        :param _builtins.str aom_monitor_level: Indicates the monitoring layer.
        :param _builtins.str expression: Indicates the expression of a combined operation.
        :param Sequence[_builtins.str] metric_labels: Indicates the metric dimension.
        :param _builtins.str metric_name: Indicates the metric name.
        :param _builtins.str metric_namespace: Indicates the metric namespace.
        :param _builtins.str metric_query_mode: Indicates the metric query mode.
               Value can be as follows:
               + **AOM**: native AOM
               + **PROM**: AOM Prometheus
               + **NATIVE_PROM**: native Prometheus
        :param _builtins.str metric_statistic_method: Indicates the metric statistics method to be used.
               Value can be as follows:
               + **single**: single metric
               + **mix**: multi-metric combined operations
        :param _builtins.str metric_unit: Indicates the metric unit.
        :param _builtins.str mix_promql: Indicates the promQL of a combined operation.
        :param _builtins.str operator: Indicates the operator.
        :param _builtins.str promql: Indicates the prometheus statement.
        :param Sequence[_builtins.str] promql_exprs: Indicates the prometheus statement template.
        :param _builtins.str promql_for: Indicates the native Prometheus monitoring duration.
        :param _builtins.str query_match: Indicates the query filter criteria.
        :param Mapping[str, _builtins.str] thresholds: Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        :param _builtins.str trigger_interval: Indicates the check interval.
        :param _builtins.str trigger_times: Indicates the number of consecutive periods.
        :param _builtins.str trigger_type: Indicates the trigger type.
               Value can be as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "aggregate_type", aggregate_type)
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        pulumi.set(__self__, "aggregation_window", aggregation_window)
        pulumi.set(__self__, "aom_monitor_level", aom_monitor_level)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "metric_labels", metric_labels)
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        pulumi.set(__self__, "metric_statistic_method", metric_statistic_method)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "mix_promql", mix_promql)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "promql", promql)
        pulumi.set(__self__, "promql_exprs", promql_exprs)
        pulumi.set(__self__, "promql_for", promql_for)
        pulumi.set(__self__, "query_match", query_match)
        pulumi.set(__self__, "thresholds", thresholds)
        pulumi.set(__self__, "trigger_interval", trigger_interval)
        pulumi.set(__self__, "trigger_times", trigger_times)
        pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="aggregateType")
    def aggregate_type(self) -> _builtins.str:
        """
        Indicates the aggregation mode.
        Value can be **by**, **avg**, **max**, **min** and **sum**.
        """
        return pulumi.get(self, "aggregate_type")

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> _builtins.str:
        """
        Indicates the statistical mode.
        Value can be **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        return pulumi.get(self, "aggregation_type")

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> _builtins.str:
        """
        Indicates the statistical period.
        """
        return pulumi.get(self, "aggregation_window")

    @_builtins.property
    @pulumi.getter(name="aomMonitorLevel")
    def aom_monitor_level(self) -> _builtins.str:
        """
        Indicates the monitoring layer.
        """
        return pulumi.get(self, "aom_monitor_level")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Indicates the expression of a combined operation.
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Sequence[_builtins.str]:
        """
        Indicates the metric dimension.
        """
        return pulumi.get(self, "metric_labels")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Indicates the metric name.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> _builtins.str:
        """
        Indicates the metric namespace.
        """
        return pulumi.get(self, "metric_namespace")

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> _builtins.str:
        """
        Indicates the metric query mode.
        Value can be as follows:
        + **AOM**: native AOM
        + **PROM**: AOM Prometheus
        + **NATIVE_PROM**: native Prometheus
        """
        return pulumi.get(self, "metric_query_mode")

    @_builtins.property
    @pulumi.getter(name="metricStatisticMethod")
    def metric_statistic_method(self) -> _builtins.str:
        """
        Indicates the metric statistics method to be used.
        Value can be as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        return pulumi.get(self, "metric_statistic_method")

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> _builtins.str:
        """
        Indicates the metric unit.
        """
        return pulumi.get(self, "metric_unit")

    @_builtins.property
    @pulumi.getter(name="mixPromql")
    def mix_promql(self) -> _builtins.str:
        """
        Indicates the promQL of a combined operation.
        """
        return pulumi.get(self, "mix_promql")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Indicates the operator.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def promql(self) -> _builtins.str:
        """
        Indicates the prometheus statement.
        """
        return pulumi.get(self, "promql")

    @_builtins.property
    @pulumi.getter(name="promqlExprs")
    def promql_exprs(self) -> Sequence[_builtins.str]:
        """
        Indicates the prometheus statement template.
        """
        return pulumi.get(self, "promql_exprs")

    @_builtins.property
    @pulumi.getter(name="promqlFor")
    def promql_for(self) -> _builtins.str:
        """
        Indicates the native Prometheus monitoring duration.
        """
        return pulumi.get(self, "promql_for")

    @_builtins.property
    @pulumi.getter(name="queryMatch")
    def query_match(self) -> _builtins.str:
        """
        Indicates the query filter criteria.
        """
        return pulumi.get(self, "query_match")

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Mapping[str, _builtins.str]:
        """
        Key-value pair. The key indicates the alarm severity while the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> _builtins.str:
        """
        Indicates the check interval.
        """
        return pulumi.get(self, "trigger_interval")

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> _builtins.str:
        """
        Indicates the number of consecutive periods.
        """
        return pulumi.get(self, "trigger_times")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        Indicates the trigger type.
        Value can be as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateTemplatingResult(dict):
    def __init__(__self__, *,
                 lists: Sequence['outputs.GetAlarmRulesTemplatesTemplateTemplatingListResult']):
        """
        :param Sequence['GetAlarmRulesTemplatesTemplateTemplatingListArgs'] lists: Indicates the variable list.
               The list structure is documented below.
        """
        pulumi.set(__self__, "lists", lists)

    @_builtins.property
    @pulumi.getter
    def lists(self) -> Sequence['outputs.GetAlarmRulesTemplatesTemplateTemplatingListResult']:
        """
        Indicates the variable list.
        The list structure is documented below.
        """
        return pulumi.get(self, "lists")


@pulumi.output_type
class GetAlarmRulesTemplatesTemplateTemplatingListResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 query: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: Indicates the variable description.
        :param _builtins.str name: Indicates the variable name.
        :param _builtins.str query: Indicates the variable value.
        :param _builtins.str type: Indicates the variable type.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the variable description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the variable name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        """
        Indicates the variable value.
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the variable type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAlarmSilenceRulesRuleResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 name: _builtins.str,
                 silence_conditions: Sequence['outputs.GetAlarmSilenceRulesRuleSilenceConditionResult'],
                 silence_times: Sequence['outputs.GetAlarmSilenceRulesRuleSilenceTimeResult'],
                 time_zone: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time of the rule.
        :param _builtins.str description: Indicates the description of the rule.
        :param _builtins.str name: Indicates the rule name.
        :param Sequence['GetAlarmSilenceRulesRuleSilenceConditionArgs'] silence_conditions: Indicates the silence conditions of the rule.
               The silence_conditions structure is documented below.
        :param Sequence['GetAlarmSilenceRulesRuleSilenceTimeArgs'] silence_times: Indicates the silence time of the rule.
               The silence_time structure is documented below.
        :param _builtins.str time_zone: Indicates the time zone of the rule.
        :param _builtins.str updated_at: Indicates the update time of the rule.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "silence_conditions", silence_conditions)
        pulumi.set(__self__, "silence_times", silence_times)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time of the rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="silenceConditions")
    def silence_conditions(self) -> Sequence['outputs.GetAlarmSilenceRulesRuleSilenceConditionResult']:
        """
        Indicates the silence conditions of the rule.
        The silence_conditions structure is documented below.
        """
        return pulumi.get(self, "silence_conditions")

    @_builtins.property
    @pulumi.getter(name="silenceTimes")
    def silence_times(self) -> Sequence['outputs.GetAlarmSilenceRulesRuleSilenceTimeResult']:
        """
        Indicates the silence time of the rule.
        The silence_time structure is documented below.
        """
        return pulumi.get(self, "silence_times")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Indicates the time zone of the rule.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the update time of the rule.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetAlarmSilenceRulesRuleSilenceConditionResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetAlarmSilenceRulesRuleSilenceConditionConditionResult']):
        """
        :param Sequence['GetAlarmSilenceRulesRuleSilenceConditionConditionArgs'] conditions: Indicates the serial conditions.
               The conditions structure is documented below.
        """
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetAlarmSilenceRulesRuleSilenceConditionConditionResult']:
        """
        Indicates the serial conditions.
        The conditions structure is documented below.
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class GetAlarmSilenceRulesRuleSilenceConditionConditionResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 operate: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Indicates the key of the match condition.
        :param _builtins.str operate: Indicates the operate of the match condition.
        :param Sequence[_builtins.str] values: Indicates the value list of the match condition.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operate", operate)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Indicates the key of the match condition.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operate(self) -> _builtins.str:
        """
        Indicates the operate of the match condition.
        """
        return pulumi.get(self, "operate")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Indicates the value list of the match condition.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAlarmSilenceRulesRuleSilenceTimeResult(dict):
    def __init__(__self__, *,
                 ends_at: _builtins.int,
                 scopes: Sequence[_builtins.int],
                 starts_at: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int ends_at: Indicates the end time of the rule.
        :param Sequence[_builtins.int] scopes: Indicates the silence time of the rule.
        :param _builtins.int starts_at: Indicates the start time of the rule.
        :param _builtins.str type: Indicates the effective time type of the rule.
        """
        pulumi.set(__self__, "ends_at", ends_at)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "starts_at", starts_at)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="endsAt")
    def ends_at(self) -> _builtins.int:
        """
        Indicates the end time of the rule.
        """
        return pulumi.get(self, "ends_at")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.int]:
        """
        Indicates the silence time of the rule.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="startsAt")
    def starts_at(self) -> _builtins.int:
        """
        Indicates the start time of the rule.
        """
        return pulumi.get(self, "starts_at")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Indicates the effective time type of the rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCloudServiceAuthorizationsAuthorizationResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[_builtins.str],
                 service: _builtins.str,
                 status: _builtins.bool):
        """
        :param Sequence[_builtins.str] role_names: Indicates the role names list.
        :param _builtins.str service: Indicates the authorization service.
        :param _builtins.bool status: Indicates the authorization status.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        Indicates the role names list.
        """
        return pulumi.get(self, "role_names")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Indicates the authorization service.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.bool:
        """
        Indicates the authorization status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetDashboardsDashboardResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 created_by: _builtins.str,
                 dashboard_tags: Sequence[Mapping[str, _builtins.str]],
                 dashboard_title: _builtins.str,
                 dashboard_title_en: _builtins.str,
                 dashboard_type: _builtins.str,
                 display: _builtins.bool,
                 enterprise_project_id: _builtins.str,
                 folder_id: _builtins.str,
                 folder_title: _builtins.str,
                 id: _builtins.str,
                 is_favorite: _builtins.bool,
                 updated_at: _builtins.str,
                 updated_by: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time of the dashboard.
        :param _builtins.str created_by: Indicates the creator of the dashboard.
        :param Sequence[Mapping[str, _builtins.str]] dashboard_tags: Indicates the dashboard tags.
        :param _builtins.str dashboard_title: Indicates the dashboard title.
        :param _builtins.str dashboard_title_en: Indicates the dashboard English title.
        :param _builtins.str dashboard_type: Specifies the dashboard type.
        :param _builtins.bool display: Indicates whether the dashboard is displayed.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the dashboard belongs.
        :param _builtins.str folder_id: Indicates the folder ID to which the dashboard belongs.
        :param _builtins.str folder_title: Indicates the folder name to which the dashboard belongs.
        :param _builtins.str id: Indicates the dashboard ID.
        :param _builtins.bool is_favorite: Indicates whether the dashboard is favorited.
        :param _builtins.str updated_at: Indicates the update time of the dashboard.
        :param _builtins.str updated_by: Indicates the updator of the dashboard.
        :param _builtins.str version: Indicates the dashboard version.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "dashboard_tags", dashboard_tags)
        pulumi.set(__self__, "dashboard_title", dashboard_title)
        pulumi.set(__self__, "dashboard_title_en", dashboard_title_en)
        pulumi.set(__self__, "dashboard_type", dashboard_type)
        pulumi.set(__self__, "display", display)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "folder_id", folder_id)
        pulumi.set(__self__, "folder_title", folder_title)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_favorite", is_favorite)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "updated_by", updated_by)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time of the dashboard.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        Indicates the creator of the dashboard.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="dashboardTags")
    def dashboard_tags(self) -> Sequence[Mapping[str, _builtins.str]]:
        """
        Indicates the dashboard tags.
        """
        return pulumi.get(self, "dashboard_tags")

    @_builtins.property
    @pulumi.getter(name="dashboardTitle")
    def dashboard_title(self) -> _builtins.str:
        """
        Indicates the dashboard title.
        """
        return pulumi.get(self, "dashboard_title")

    @_builtins.property
    @pulumi.getter(name="dashboardTitleEn")
    def dashboard_title_en(self) -> _builtins.str:
        """
        Indicates the dashboard English title.
        """
        return pulumi.get(self, "dashboard_title_en")

    @_builtins.property
    @pulumi.getter(name="dashboardType")
    def dashboard_type(self) -> _builtins.str:
        """
        Specifies the dashboard type.
        """
        return pulumi.get(self, "dashboard_type")

    @_builtins.property
    @pulumi.getter
    def display(self) -> _builtins.bool:
        """
        Indicates whether the dashboard is displayed.
        """
        return pulumi.get(self, "display")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the dashboard belongs.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> _builtins.str:
        """
        Indicates the folder ID to which the dashboard belongs.
        """
        return pulumi.get(self, "folder_id")

    @_builtins.property
    @pulumi.getter(name="folderTitle")
    def folder_title(self) -> _builtins.str:
        """
        Indicates the folder name to which the dashboard belongs.
        """
        return pulumi.get(self, "folder_title")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the dashboard ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isFavorite")
    def is_favorite(self) -> _builtins.bool:
        """
        Indicates whether the dashboard is favorited.
        """
        return pulumi.get(self, "is_favorite")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the update time of the dashboard.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> _builtins.str:
        """
        Indicates the updator of the dashboard.
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Indicates the dashboard version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetDashboardsFoldersFolderResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 created_by: _builtins.str,
                 dashboard_ids: Sequence[_builtins.str],
                 display: _builtins.bool,
                 enterprise_project_id: _builtins.str,
                 folder_title: _builtins.str,
                 folder_title_en: _builtins.str,
                 id: _builtins.str,
                 is_template: _builtins.bool,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time of the folder.
        :param _builtins.str created_by: Indicates the creator of the folder.
        :param Sequence[_builtins.str] dashboard_ids: Indicates the dashboard IDs under the folder.
        :param _builtins.bool display: Indicates whether to display the folder.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the folder belongs.
        :param _builtins.str folder_title: Indicates the folder title.
        :param _builtins.str folder_title_en: Indicates the folder English title.
        :param _builtins.str id: Indicates the folder ID.
        :param _builtins.bool is_template: Indicates whether the folder is default.
        :param _builtins.str updated_at: Indicates the update time of the folder.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "dashboard_ids", dashboard_ids)
        pulumi.set(__self__, "display", display)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "folder_title", folder_title)
        pulumi.set(__self__, "folder_title_en", folder_title_en)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_template", is_template)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time of the folder.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        Indicates the creator of the folder.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="dashboardIds")
    def dashboard_ids(self) -> Sequence[_builtins.str]:
        """
        Indicates the dashboard IDs under the folder.
        """
        return pulumi.get(self, "dashboard_ids")

    @_builtins.property
    @pulumi.getter
    def display(self) -> _builtins.bool:
        """
        Indicates whether to display the folder.
        """
        return pulumi.get(self, "display")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the folder belongs.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="folderTitle")
    def folder_title(self) -> _builtins.str:
        """
        Indicates the folder title.
        """
        return pulumi.get(self, "folder_title")

    @_builtins.property
    @pulumi.getter(name="folderTitleEn")
    def folder_title_en(self) -> _builtins.str:
        """
        Indicates the folder English title.
        """
        return pulumi.get(self, "folder_title_en")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the folder ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isTemplate")
    def is_template(self) -> _builtins.bool:
        """
        Indicates whether the folder is default.
        """
        return pulumi.get(self, "is_template")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the update time of the folder.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetMessageTemplatesMessageTemplateResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 locale: _builtins.str,
                 name: _builtins.str,
                 source: _builtins.str,
                 templates: Sequence['outputs.GetMessageTemplatesMessageTemplateTemplateResult'],
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the message template create time.
        :param _builtins.str description: Indicates the meesage template description.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the templates belong.
        :param _builtins.str locale: Indicates the meesage template language.
        :param _builtins.str name: Indicates the template name.
        :param _builtins.str source: Indicates the template type.
               + If it is empty, means it is a metric or event template.
               + If it is **LTS**, means it is a log template.
        :param Sequence['GetMessageTemplatesMessageTemplateTemplateArgs'] templates: Indicates the templates.
               The templates structure is documented below.
        :param _builtins.str updated_at: Indicates the message template update time.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "templates", templates)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the message template create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the meesage template description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the templates belong.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> _builtins.str:
        """
        Indicates the meesage template language.
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the template name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Indicates the template type.
        + If it is empty, means it is a metric or event template.
        + If it is **LTS**, means it is a log template.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Sequence['outputs.GetMessageTemplatesMessageTemplateTemplateResult']:
        """
        Indicates the templates.
        The templates structure is documented below.
        """
        return pulumi.get(self, "templates")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the message template update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetMessageTemplatesMessageTemplateTemplateResult(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 sub_type: _builtins.str,
                 topic: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str content: Indicates the content of the template.
        :param _builtins.str sub_type: Indicates the subscription type of the template.
        :param _builtins.str topic: Indicates the topic of the template.
        :param _builtins.str version: Indicates the version of the template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "sub_type", sub_type)
        pulumi.set(__self__, "topic", topic)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Indicates the content of the template.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> _builtins.str:
        """
        Indicates the subscription type of the template.
        """
        return pulumi.get(self, "sub_type")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Indicates the topic of the template.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Indicates the version of the template.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMultiAccountAggregationRulesRuleResult(dict):
    def __init__(__self__, *,
                 accounts: Sequence['outputs.GetMultiAccountAggregationRulesRuleAccountResult'],
                 instance_id: _builtins.str,
                 send_to_source_account: _builtins.bool,
                 services: Sequence['outputs.GetMultiAccountAggregationRulesRuleServiceResult']):
        """
        :param Sequence['GetMultiAccountAggregationRulesRuleAccountArgs'] accounts: Indicates the accounts list.
               The accounts structure is documented below.
        :param _builtins.str instance_id: Indicates the prometheus instance ID.
        :param _builtins.bool send_to_source_account: Indicates whether the member accounts retain metric data after they are connected to the
               prometheus instance for aggregation.
        :param Sequence['GetMultiAccountAggregationRulesRuleServiceArgs'] services: Indicates the services list.
               The services structure is documented below.
        """
        pulumi.set(__self__, "accounts", accounts)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "send_to_source_account", send_to_source_account)
        pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def accounts(self) -> Sequence['outputs.GetMultiAccountAggregationRulesRuleAccountResult']:
        """
        Indicates the accounts list.
        The accounts structure is documented below.
        """
        return pulumi.get(self, "accounts")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Indicates the prometheus instance ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="sendToSourceAccount")
    def send_to_source_account(self) -> _builtins.bool:
        """
        Indicates whether the member accounts retain metric data after they are connected to the
        prometheus instance for aggregation.
        """
        return pulumi.get(self, "send_to_source_account")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence['outputs.GetMultiAccountAggregationRulesRuleServiceResult']:
        """
        Indicates the services list.
        The services structure is documented below.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class GetMultiAccountAggregationRulesRuleAccountResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 join_method: _builtins.str,
                 joined_at: _builtins.str,
                 name: _builtins.str,
                 urn: _builtins.str):
        """
        :param _builtins.str id: Indicates the account ID.
        :param _builtins.str join_method: Indicates the method how the account joined in the organization.
        :param _builtins.str joined_at: Indicates the time when the account joined in the organization.
        :param _builtins.str name: Indicates the account name.
        :param _builtins.str urn: Indicates the uniform resource name of the account.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "join_method", join_method)
        pulumi.set(__self__, "joined_at", joined_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the account ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="joinMethod")
    def join_method(self) -> _builtins.str:
        """
        Indicates the method how the account joined in the organization.
        """
        return pulumi.get(self, "join_method")

    @_builtins.property
    @pulumi.getter(name="joinedAt")
    def joined_at(self) -> _builtins.str:
        """
        Indicates the time when the account joined in the organization.
        """
        return pulumi.get(self, "joined_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the account name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        Indicates the uniform resource name of the account.
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class GetMultiAccountAggregationRulesRuleServiceResult(dict):
    def __init__(__self__, *,
                 metrics: Sequence[_builtins.str],
                 service: _builtins.str):
        """
        :param Sequence[_builtins.str] metrics: Indicates the metrics List.
        :param _builtins.str service: Indicates the service name.
        """
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Sequence[_builtins.str]:
        """
        Indicates the metrics List.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Indicates the service name.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class GetOrganizationAccountsAccountResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 join_method: _builtins.str,
                 joined_at: _builtins.str,
                 name: _builtins.str,
                 urn: _builtins.str):
        """
        :param _builtins.str id: Indicates the account ID.
        :param _builtins.str join_method: Indicates the method how the account joined in the organization.
        :param _builtins.str joined_at: Indicates the time when the account joined in the organization.
        :param _builtins.str name: Indicates the account name.
        :param _builtins.str urn: Indicates the uniform resource name of the account.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "join_method", join_method)
        pulumi.set(__self__, "joined_at", joined_at)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the account ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="joinMethod")
    def join_method(self) -> _builtins.str:
        """
        Indicates the method how the account joined in the organization.
        """
        return pulumi.get(self, "join_method")

    @_builtins.property
    @pulumi.getter(name="joinedAt")
    def joined_at(self) -> _builtins.str:
        """
        Indicates the time when the account joined in the organization.
        """
        return pulumi.get(self, "joined_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the account name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        Indicates the uniform resource name of the account.
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class GetPromInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 is_deleted_tag: _builtins.str,
                 prom_http_api_endpoint: _builtins.str,
                 prom_name: _builtins.str,
                 prom_status: _builtins.str,
                 prom_type: _builtins.str,
                 prom_version: _builtins.str,
                 remote_read_url: _builtins.str,
                 remote_write_url: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time of the prometheus instance.
        :param _builtins.str deleted_at: Indicates the delete time of the prometheus instance.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the prometheus instance belongs.
               If specifies it as **all_granted_eps**, means to query instances in all enterprise projects.
        :param _builtins.str id: Indicates the prometheus instance ID.
        :param _builtins.str is_deleted_tag: Indicates whether the prometheus is deleted.
        :param _builtins.str prom_http_api_endpoint: Indicates the URL for calling the prometheus instance.
        :param _builtins.str prom_name: Indicates the prometheus instance name.
        :param _builtins.str prom_status: Specifies the prometheus instance status.
               Valid values are **DELETED**, **NORMAL** and **ALL**.
        :param _builtins.str prom_type: Specifies the prometheus instance type. Valid values are **default**, **ECS**,
               **VPC**, **CCE**, **REMOTE_WRITE**, **KUBERNETES**, **CLOUD_SERVICE** and **ACROSS_ACCOUNT**.
        :param _builtins.str prom_version: Indicates the prometheus instance version.
        :param _builtins.str remote_read_url: Indicates the remote read address of the prometheus instance.
        :param _builtins.str remote_write_url: Indicates the remote write address of the prometheus instance.
        :param _builtins.str updated_at: Indicates the update time of the prometheus instance.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_deleted_tag", is_deleted_tag)
        pulumi.set(__self__, "prom_http_api_endpoint", prom_http_api_endpoint)
        pulumi.set(__self__, "prom_name", prom_name)
        pulumi.set(__self__, "prom_status", prom_status)
        pulumi.set(__self__, "prom_type", prom_type)
        pulumi.set(__self__, "prom_version", prom_version)
        pulumi.set(__self__, "remote_read_url", remote_read_url)
        pulumi.set(__self__, "remote_write_url", remote_write_url)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time of the prometheus instance.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Indicates the delete time of the prometheus instance.
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the prometheus instance belongs.
        If specifies it as **all_granted_eps**, means to query instances in all enterprise projects.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the prometheus instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDeletedTag")
    def is_deleted_tag(self) -> _builtins.str:
        """
        Indicates whether the prometheus is deleted.
        """
        return pulumi.get(self, "is_deleted_tag")

    @_builtins.property
    @pulumi.getter(name="promHttpApiEndpoint")
    def prom_http_api_endpoint(self) -> _builtins.str:
        """
        Indicates the URL for calling the prometheus instance.
        """
        return pulumi.get(self, "prom_http_api_endpoint")

    @_builtins.property
    @pulumi.getter(name="promName")
    def prom_name(self) -> _builtins.str:
        """
        Indicates the prometheus instance name.
        """
        return pulumi.get(self, "prom_name")

    @_builtins.property
    @pulumi.getter(name="promStatus")
    def prom_status(self) -> _builtins.str:
        """
        Specifies the prometheus instance status.
        Valid values are **DELETED**, **NORMAL** and **ALL**.
        """
        return pulumi.get(self, "prom_status")

    @_builtins.property
    @pulumi.getter(name="promType")
    def prom_type(self) -> _builtins.str:
        """
        Specifies the prometheus instance type. Valid values are **default**, **ECS**,
        **VPC**, **CCE**, **REMOTE_WRITE**, **KUBERNETES**, **CLOUD_SERVICE** and **ACROSS_ACCOUNT**.
        """
        return pulumi.get(self, "prom_type")

    @_builtins.property
    @pulumi.getter(name="promVersion")
    def prom_version(self) -> _builtins.str:
        """
        Indicates the prometheus instance version.
        """
        return pulumi.get(self, "prom_version")

    @_builtins.property
    @pulumi.getter(name="remoteReadUrl")
    def remote_read_url(self) -> _builtins.str:
        """
        Indicates the remote read address of the prometheus instance.
        """
        return pulumi.get(self, "remote_read_url")

    @_builtins.property
    @pulumi.getter(name="remoteWriteUrl")
    def remote_write_url(self) -> _builtins.str:
        """
        Indicates the remote write address of the prometheus instance.
        """
        return pulumi.get(self, "remote_write_url")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the update time of the prometheus instance.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetServiceDiscoveryRulesRuleResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 detect_log_enabled: _builtins.bool,
                 discovery_rule_enabled: _builtins.bool,
                 discovery_rules: Sequence['outputs.GetServiceDiscoveryRulesRuleDiscoveryRuleResult'],
                 id: _builtins.str,
                 is_default_rule: _builtins.bool,
                 log_file_suffixes: Sequence[_builtins.str],
                 log_path_rules: Sequence['outputs.GetServiceDiscoveryRulesRuleLogPathRuleResult'],
                 name: _builtins.str,
                 name_rules: Sequence['outputs.GetServiceDiscoveryRulesRuleNameRuleResult'],
                 priority: _builtins.int,
                 service_type: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time of the rule.
        :param _builtins.str description: Indicates the description of the rule.
        :param _builtins.bool detect_log_enabled: Indicates whether the log collection is enabled.
        :param _builtins.bool discovery_rule_enabled: Indicates whether the rule is enabled.
        :param Sequence['GetServiceDiscoveryRulesRuleDiscoveryRuleArgs'] discovery_rules: Indicates the discovery rule.
               The discovery_rules structure is documented below.
        :param _builtins.str id: Indicates the rule ID.
        :param _builtins.bool is_default_rule: Indicates whether the rule is the default one.
        :param Sequence[_builtins.str] log_file_suffixes: Indicates the log file suffix.
        :param Sequence['GetServiceDiscoveryRulesRuleLogPathRuleArgs'] log_path_rules: Indicates the log path configuration rule.
               The log_path_rules structure is documented below.
        :param _builtins.str name: Indicates the rule name.
        :param Sequence['GetServiceDiscoveryRulesRuleNameRuleArgs'] name_rules: Indicates the naming rules for discovered services and applications.
               The name_rules structure is documented below.
        :param _builtins.int priority: Indicates the rule priority.
        :param _builtins.str service_type: Indicates the service type.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "detect_log_enabled", detect_log_enabled)
        pulumi.set(__self__, "discovery_rule_enabled", discovery_rule_enabled)
        pulumi.set(__self__, "discovery_rules", discovery_rules)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default_rule", is_default_rule)
        pulumi.set(__self__, "log_file_suffixes", log_file_suffixes)
        pulumi.set(__self__, "log_path_rules", log_path_rules)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "name_rules", name_rules)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "service_type", service_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time of the rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Indicates the description of the rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="detectLogEnabled")
    def detect_log_enabled(self) -> _builtins.bool:
        """
        Indicates whether the log collection is enabled.
        """
        return pulumi.get(self, "detect_log_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryRuleEnabled")
    def discovery_rule_enabled(self) -> _builtins.bool:
        """
        Indicates whether the rule is enabled.
        """
        return pulumi.get(self, "discovery_rule_enabled")

    @_builtins.property
    @pulumi.getter(name="discoveryRules")
    def discovery_rules(self) -> Sequence['outputs.GetServiceDiscoveryRulesRuleDiscoveryRuleResult']:
        """
        Indicates the discovery rule.
        The discovery_rules structure is documented below.
        """
        return pulumi.get(self, "discovery_rules")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the rule ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDefaultRule")
    def is_default_rule(self) -> _builtins.bool:
        """
        Indicates whether the rule is the default one.
        """
        return pulumi.get(self, "is_default_rule")

    @_builtins.property
    @pulumi.getter(name="logFileSuffixes")
    def log_file_suffixes(self) -> Sequence[_builtins.str]:
        """
        Indicates the log file suffix.
        """
        return pulumi.get(self, "log_file_suffixes")

    @_builtins.property
    @pulumi.getter(name="logPathRules")
    def log_path_rules(self) -> Sequence['outputs.GetServiceDiscoveryRulesRuleLogPathRuleResult']:
        """
        Indicates the log path configuration rule.
        The log_path_rules structure is documented below.
        """
        return pulumi.get(self, "log_path_rules")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Indicates the rule name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nameRules")
    def name_rules(self) -> Sequence['outputs.GetServiceDiscoveryRulesRuleNameRuleResult']:
        """
        Indicates the naming rules for discovered services and applications.
        The name_rules structure is documented below.
        """
        return pulumi.get(self, "name_rules")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Indicates the rule priority.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> _builtins.str:
        """
        Indicates the service type.
        """
        return pulumi.get(self, "service_type")


@pulumi.output_type
class GetServiceDiscoveryRulesRuleDiscoveryRuleResult(dict):
    def __init__(__self__, *,
                 check_contents: Sequence[_builtins.str],
                 check_mode: _builtins.str,
                 check_type: _builtins.str):
        """
        :param Sequence[_builtins.str] check_contents: Indicates the matched value.
        :param _builtins.str check_mode: Indicates the match condition.
        :param _builtins.str check_type: Indicates the match type.
        """
        pulumi.set(__self__, "check_contents", check_contents)
        pulumi.set(__self__, "check_mode", check_mode)
        pulumi.set(__self__, "check_type", check_type)

    @_builtins.property
    @pulumi.getter(name="checkContents")
    def check_contents(self) -> Sequence[_builtins.str]:
        """
        Indicates the matched value.
        """
        return pulumi.get(self, "check_contents")

    @_builtins.property
    @pulumi.getter(name="checkMode")
    def check_mode(self) -> _builtins.str:
        """
        Indicates the match condition.
        """
        return pulumi.get(self, "check_mode")

    @_builtins.property
    @pulumi.getter(name="checkType")
    def check_type(self) -> _builtins.str:
        """
        Indicates the match type.
        """
        return pulumi.get(self, "check_type")


@pulumi.output_type
class GetServiceDiscoveryRulesRuleLogPathRuleResult(dict):
    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 name_type: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] args: Indicates the input value.
        :param _builtins.str name_type: Indicates the value type.
        :param Sequence[_builtins.str] values: Indicates the application name.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        Indicates the input value.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> _builtins.str:
        """
        Indicates the value type.
        """
        return pulumi.get(self, "name_type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Indicates the application name.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetServiceDiscoveryRulesRuleNameRuleResult(dict):
    def __init__(__self__, *,
                 application_name_rules: Sequence['outputs.GetServiceDiscoveryRulesRuleNameRuleApplicationNameRuleResult'],
                 service_name_rules: Sequence['outputs.GetServiceDiscoveryRulesRuleNameRuleServiceNameRuleResult']):
        """
        :param Sequence['GetServiceDiscoveryRulesRuleNameRuleApplicationNameRuleArgs'] application_name_rules: Indicates the application name rule.
               The basic_name_rule structure is documented below.
        :param Sequence['GetServiceDiscoveryRulesRuleNameRuleServiceNameRuleArgs'] service_name_rules: Indicates the service name rule.
               The basic_name_rule structure is documented below.
        """
        pulumi.set(__self__, "application_name_rules", application_name_rules)
        pulumi.set(__self__, "service_name_rules", service_name_rules)

    @_builtins.property
    @pulumi.getter(name="applicationNameRules")
    def application_name_rules(self) -> Sequence['outputs.GetServiceDiscoveryRulesRuleNameRuleApplicationNameRuleResult']:
        """
        Indicates the application name rule.
        The basic_name_rule structure is documented below.
        """
        return pulumi.get(self, "application_name_rules")

    @_builtins.property
    @pulumi.getter(name="serviceNameRules")
    def service_name_rules(self) -> Sequence['outputs.GetServiceDiscoveryRulesRuleNameRuleServiceNameRuleResult']:
        """
        Indicates the service name rule.
        The basic_name_rule structure is documented below.
        """
        return pulumi.get(self, "service_name_rules")


@pulumi.output_type
class GetServiceDiscoveryRulesRuleNameRuleApplicationNameRuleResult(dict):
    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 name_type: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] args: Indicates the input value.
        :param _builtins.str name_type: Indicates the value type.
        :param Sequence[_builtins.str] values: Indicates the application name.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        Indicates the input value.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> _builtins.str:
        """
        Indicates the value type.
        """
        return pulumi.get(self, "name_type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Indicates the application name.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetServiceDiscoveryRulesRuleNameRuleServiceNameRuleResult(dict):
    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 name_type: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] args: Indicates the input value.
        :param _builtins.str name_type: Indicates the value type.
        :param Sequence[_builtins.str] values: Indicates the application name.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        Indicates the input value.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> _builtins.str:
        """
        Indicates the value type.
        """
        return pulumi.get(self, "name_type")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Indicates the application name.
        """
        return pulumi.get(self, "values")


