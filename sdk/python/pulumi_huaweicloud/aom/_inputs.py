# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AlarmActionRuleSmnTopicArgs',
    'AlarmActionRuleSmnTopicArgsDict',
    'AlarmGroupRuleDetailArgs',
    'AlarmGroupRuleDetailArgsDict',
    'AlarmGroupRuleDetailMatchArgs',
    'AlarmGroupRuleDetailMatchArgsDict',
    'AlarmPolicyAlarmNotificationArgs',
    'AlarmPolicyAlarmNotificationArgsDict',
    'AlarmPolicyEventAlarmSpecArgs',
    'AlarmPolicyEventAlarmSpecArgsDict',
    'AlarmPolicyEventAlarmSpecAlarmTagArgs',
    'AlarmPolicyEventAlarmSpecAlarmTagArgsDict',
    'AlarmPolicyEventAlarmSpecNoDataConditionArgs',
    'AlarmPolicyEventAlarmSpecNoDataConditionArgsDict',
    'AlarmPolicyMetricAlarmSpecArgs',
    'AlarmPolicyMetricAlarmSpecArgsDict',
    'AlarmPolicyMetricAlarmSpecAlarmTagArgs',
    'AlarmPolicyMetricAlarmSpecAlarmTagArgsDict',
    'AlarmPolicyMetricAlarmSpecNoDataConditionArgs',
    'AlarmPolicyMetricAlarmSpecNoDataConditionArgsDict',
    'AlarmPolicyMetricAlarmSpecTriggerConditionArgs',
    'AlarmPolicyMetricAlarmSpecTriggerConditionArgsDict',
    'AlarmRuleDimensionArgs',
    'AlarmRuleDimensionArgsDict',
    'AlarmRuleV4AlarmNotificationsArgs',
    'AlarmRuleV4AlarmNotificationsArgsDict',
    'AlarmRuleV4EventAlarmSpecArgs',
    'AlarmRuleV4EventAlarmSpecArgsDict',
    'AlarmRuleV4EventAlarmSpecTriggerConditionArgs',
    'AlarmRuleV4EventAlarmSpecTriggerConditionArgsDict',
    'AlarmRuleV4MetricAlarmSpecArgs',
    'AlarmRuleV4MetricAlarmSpecArgsDict',
    'AlarmRuleV4MetricAlarmSpecAlarmTagsArgs',
    'AlarmRuleV4MetricAlarmSpecAlarmTagsArgsDict',
    'AlarmRuleV4MetricAlarmSpecNoDataConditionsArgs',
    'AlarmRuleV4MetricAlarmSpecNoDataConditionsArgsDict',
    'AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgs',
    'AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgsDict',
    'AlarmRuleV4MetricAlarmSpecTriggerConditionArgs',
    'AlarmRuleV4MetricAlarmSpecTriggerConditionArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgsDict',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs',
    'AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgsDict',
    'AlarmRulesTemplateTemplatingArgs',
    'AlarmRulesTemplateTemplatingArgsDict',
    'AlarmRulesTemplateTemplatingListArgs',
    'AlarmRulesTemplateTemplatingListArgsDict',
    'AlarmSilenceRuleSilenceConditionArgs',
    'AlarmSilenceRuleSilenceConditionArgsDict',
    'AlarmSilenceRuleSilenceConditionConditionArgs',
    'AlarmSilenceRuleSilenceConditionConditionArgsDict',
    'AlarmSilenceRuleSilenceTimeArgs',
    'AlarmSilenceRuleSilenceTimeArgsDict',
    'EnvironmentEnvTagArgs',
    'EnvironmentEnvTagArgsDict',
    'MessageTemplateTemplateArgs',
    'MessageTemplateTemplateArgsDict',
    'MultiAccountAggregationRuleAccountArgs',
    'MultiAccountAggregationRuleAccountArgsDict',
    'MultiAccountAggregationRuleServiceArgs',
    'MultiAccountAggregationRuleServiceArgsDict',
    'PrometheusInstancePromForCloudServiceArgs',
    'PrometheusInstancePromForCloudServiceArgsDict',
    'ServiceDiscoveryRuleDiscoveryRuleArgs',
    'ServiceDiscoveryRuleDiscoveryRuleArgsDict',
    'ServiceDiscoveryRuleLogPathRuleArgs',
    'ServiceDiscoveryRuleLogPathRuleArgsDict',
    'ServiceDiscoveryRuleNameRulesArgs',
    'ServiceDiscoveryRuleNameRulesArgsDict',
    'ServiceDiscoveryRuleNameRulesApplicationNameRuleArgs',
    'ServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict',
    'ServiceDiscoveryRuleNameRulesServiceNameRuleArgs',
    'ServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict',
]

MYPY = False

if not MYPY:
    class AlarmActionRuleSmnTopicArgsDict(TypedDict):
        topic_urn: pulumi.Input[_builtins.str]
        """
        Specifies the SMN topic URN.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the SMN topic name.
        """
elif False:
    AlarmActionRuleSmnTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmActionRuleSmnTopicArgs:
    def __init__(__self__, *,
                 topic_urn: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] topic_urn: Specifies the SMN topic URN.
        :param pulumi.Input[_builtins.str] name: Specifies the SMN topic name.
        """
        pulumi.set(__self__, "topic_urn", topic_urn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the SMN topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_urn", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the SMN topic name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AlarmGroupRuleDetailArgsDict(TypedDict):
        bind_notification_rule_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the action rule IDs.
        """
        matches: pulumi.Input[Sequence[pulumi.Input['AlarmGroupRuleDetailMatchArgsDict']]]
        """
        Specifies the matching conditions list.
        The match structure is documented below.

        <a name="block--detail--match"></a>
        The `match` block supports:
        """
elif False:
    AlarmGroupRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmGroupRuleDetailArgs:
    def __init__(__self__, *,
                 bind_notification_rule_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 matches: pulumi.Input[Sequence[pulumi.Input['AlarmGroupRuleDetailMatchArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bind_notification_rule_ids: Specifies the action rule IDs.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmGroupRuleDetailMatchArgs']]] matches: Specifies the matching conditions list.
               The match structure is documented below.
               
               <a name="block--detail--match"></a>
               The `match` block supports:
        """
        pulumi.set(__self__, "bind_notification_rule_ids", bind_notification_rule_ids)
        pulumi.set(__self__, "matches", matches)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleIds")
    def bind_notification_rule_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the action rule IDs.
        """
        return pulumi.get(self, "bind_notification_rule_ids")

    @bind_notification_rule_ids.setter
    def bind_notification_rule_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "bind_notification_rule_ids", value)

    @_builtins.property
    @pulumi.getter
    def matches(self) -> pulumi.Input[Sequence[pulumi.Input['AlarmGroupRuleDetailMatchArgs']]]:
        """
        Specifies the matching conditions list.
        The match structure is documented below.

        <a name="block--detail--match"></a>
        The `match` block supports:
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: pulumi.Input[Sequence[pulumi.Input['AlarmGroupRuleDetailMatchArgs']]]):
        pulumi.set(self, "matches", value)


if not MYPY:
    class AlarmGroupRuleDetailMatchArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the matching condition key.
        Valid value are as follows, or using specific key means taking tag as condition:
        + **event_severity**: event severity
        + **notification_scene**: notification scene
        + **resource_provider**: alarm source
        + **resource_type**: resource type
        """
        operate: pulumi.Input[_builtins.str]
        """
        Specifies the matching condition operator. Valid values are **EQUALS**, **REGEX**, **EXIST**.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the matching condition value.
        + If `operate` is **EXIST**, it should be empty.
        + If `operate` is **REGEX**, it should be a regex expression.
        + If `operate` is **EQUALS**, it depends on `key`, can be as follows:
        - If `key` is **event_severity**, it can be **Critical**, **Major**, **Minor**, **Info**.
        - If `key` is **notification_scene**, it can be **notify_resolved**, **notify_triggered**.
        - If `key` is **resource_provider**, it can be specific alarm source.
        - If `key` is **resource_type**, it can be **cce-cluster**, **cluster**, **clusters-clustercert**, **clusters-nodepools**,
        **clusters-nodes**, **configmaps**, **deployments**, **ingresses**, **jobs**, **node**, **pods**,
        **podsecuritypolicies**, **releases**, **rolebindings**, **roles**, **routes**, **secrets**, **service**.
        - If `key` is specific key, it can be specific values.
        """
elif False:
    AlarmGroupRuleDetailMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmGroupRuleDetailMatchArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operate: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the matching condition key.
               Valid value are as follows, or using specific key means taking tag as condition:
               + **event_severity**: event severity
               + **notification_scene**: notification scene
               + **resource_provider**: alarm source
               + **resource_type**: resource type
        :param pulumi.Input[_builtins.str] operate: Specifies the matching condition operator. Valid values are **EQUALS**, **REGEX**, **EXIST**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Specifies the matching condition value.
               + If `operate` is **EXIST**, it should be empty.
               + If `operate` is **REGEX**, it should be a regex expression.
               + If `operate` is **EQUALS**, it depends on `key`, can be as follows:
               - If `key` is **event_severity**, it can be **Critical**, **Major**, **Minor**, **Info**.
               - If `key` is **notification_scene**, it can be **notify_resolved**, **notify_triggered**.
               - If `key` is **resource_provider**, it can be specific alarm source.
               - If `key` is **resource_type**, it can be **cce-cluster**, **cluster**, **clusters-clustercert**, **clusters-nodepools**,
               **clusters-nodes**, **configmaps**, **deployments**, **ingresses**, **jobs**, **node**, **pods**,
               **podsecuritypolicies**, **releases**, **rolebindings**, **roles**, **routes**, **secrets**, **service**.
               - If `key` is specific key, it can be specific values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operate", operate)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the matching condition key.
        Valid value are as follows, or using specific key means taking tag as condition:
        + **event_severity**: event severity
        + **notification_scene**: notification scene
        + **resource_provider**: alarm source
        + **resource_type**: resource type
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operate(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the matching condition operator. Valid values are **EQUALS**, **REGEX**, **EXIST**.
        """
        return pulumi.get(self, "operate")

    @operate.setter
    def operate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operate", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the matching condition value.
        + If `operate` is **EXIST**, it should be empty.
        + If `operate` is **REGEX**, it should be a regex expression.
        + If `operate` is **EQUALS**, it depends on `key`, can be as follows:
        - If `key` is **event_severity**, it can be **Critical**, **Major**, **Minor**, **Info**.
        - If `key` is **notification_scene**, it can be **notify_resolved**, **notify_triggered**.
        - If `key` is **resource_provider**, it can be specific alarm source.
        - If `key` is **resource_type**, it can be **cce-cluster**, **cluster**, **clusters-clustercert**, **clusters-nodepools**,
        **clusters-nodes**, **configmaps**, **deployments**, **ingresses**, **jobs**, **node**, **pods**,
        **podsecuritypolicies**, **releases**, **rolebindings**, **roles**, **routes**, **secrets**, **service**.
        - If `key` is specific key, it can be specific values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlarmPolicyAlarmNotificationArgsDict(TypedDict):
        bind_notification_rule_id: NotRequired[pulumi.Input[_builtins.str]]
        inhibit_enable: NotRequired[pulumi.Input[_builtins.bool]]
        inhibit_rule: NotRequired[pulumi.Input[_builtins.str]]
        notification_enable: NotRequired[pulumi.Input[_builtins.bool]]
        notification_type: NotRequired[pulumi.Input[_builtins.str]]
        notify_resolved: NotRequired[pulumi.Input[_builtins.bool]]
        route_group_enable: NotRequired[pulumi.Input[_builtins.bool]]
        route_group_rule: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AlarmPolicyAlarmNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyAlarmNotificationArgs:
    def __init__(__self__, *,
                 bind_notification_rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 inhibit_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 inhibit_rule: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 notification_type: Optional[pulumi.Input[_builtins.str]] = None,
                 notify_resolved: Optional[pulumi.Input[_builtins.bool]] = None,
                 route_group_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 route_group_rule: Optional[pulumi.Input[_builtins.str]] = None):
        if bind_notification_rule_id is not None:
            pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        if inhibit_enable is not None:
            pulumi.set(__self__, "inhibit_enable", inhibit_enable)
        if inhibit_rule is not None:
            pulumi.set(__self__, "inhibit_rule", inhibit_rule)
        if notification_enable is not None:
            pulumi.set(__self__, "notification_enable", notification_enable)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)
        if notify_resolved is not None:
            pulumi.set(__self__, "notify_resolved", notify_resolved)
        if route_group_enable is not None:
            pulumi.set(__self__, "route_group_enable", route_group_enable)
        if route_group_rule is not None:
            pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bind_notification_rule_id")

    @bind_notification_rule_id.setter
    def bind_notification_rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_notification_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="inhibitEnable")
    def inhibit_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "inhibit_enable")

    @inhibit_enable.setter
    def inhibit_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "inhibit_enable", value)

    @_builtins.property
    @pulumi.getter(name="inhibitRule")
    def inhibit_rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "inhibit_rule")

    @inhibit_rule.setter
    def inhibit_rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inhibit_rule", value)

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "notification_enable")

    @notification_enable.setter
    def notification_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notification_enable", value)

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notification_type", value)

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "notify_resolved")

    @notify_resolved.setter
    def notify_resolved(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_resolved", value)

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "route_group_enable")

    @route_group_enable.setter
    def route_group_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_group_enable", value)

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "route_group_rule")

    @route_group_rule.setter
    def route_group_rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_group_rule", value)


if not MYPY:
    class AlarmPolicyEventAlarmSpecArgsDict(TypedDict):
        alarm_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecAlarmTagArgsDict']]]]
        event_source: NotRequired[pulumi.Input[_builtins.str]]
        monitor_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        no_data_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecNoDataConditionArgsDict']]]]
elif False:
    AlarmPolicyEventAlarmSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyEventAlarmSpecArgs:
    def __init__(__self__, *,
                 alarm_tags: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecAlarmTagArgs']]]] = None,
                 event_source: Optional[pulumi.Input[_builtins.str]] = None,
                 monitor_objects: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 no_data_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecNoDataConditionArgs']]]] = None):
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if event_source is not None:
            pulumi.set(__self__, "event_source", event_source)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecAlarmTagArgs']]]]:
        return pulumi.get(self, "alarm_tags")

    @alarm_tags.setter
    def alarm_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecAlarmTagArgs']]]]):
        pulumi.set(self, "alarm_tags", value)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_source", value)

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        return pulumi.get(self, "monitor_objects")

    @monitor_objects.setter
    def monitor_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "monitor_objects", value)

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecNoDataConditionArgs']]]]:
        return pulumi.get(self, "no_data_conditions")

    @no_data_conditions.setter
    def no_data_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyEventAlarmSpecNoDataConditionArgs']]]]):
        pulumi.set(self, "no_data_conditions", value)


if not MYPY:
    class AlarmPolicyEventAlarmSpecAlarmTagArgsDict(TypedDict):
        auto_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        custom_annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        custom_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AlarmPolicyEventAlarmSpecAlarmTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyEventAlarmSpecAlarmTagArgs:
    def __init__(__self__, *,
                 auto_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_annotations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "auto_tags")

    @auto_tags.setter
    def auto_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "auto_tags", value)

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "custom_annotations")

    @custom_annotations.setter
    def custom_annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_annotations", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class AlarmPolicyEventAlarmSpecNoDataConditionArgsDict(TypedDict):
        no_data_alert_state: NotRequired[pulumi.Input[_builtins.str]]
        no_data_timeframe: NotRequired[pulumi.Input[_builtins.int]]
        notify_no_data: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    AlarmPolicyEventAlarmSpecNoDataConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyEventAlarmSpecNoDataConditionArgs:
    def __init__(__self__, *,
                 no_data_alert_state: Optional[pulumi.Input[_builtins.str]] = None,
                 no_data_timeframe: Optional[pulumi.Input[_builtins.int]] = None,
                 notify_no_data: Optional[pulumi.Input[_builtins.bool]] = None):
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "no_data_alert_state")

    @no_data_alert_state.setter
    def no_data_alert_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_data_alert_state", value)

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "no_data_timeframe")

    @no_data_timeframe.setter
    def no_data_timeframe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "no_data_timeframe", value)

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "notify_no_data")

    @notify_no_data.setter
    def notify_no_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_no_data", value)


if not MYPY:
    class AlarmPolicyMetricAlarmSpecArgsDict(TypedDict):
        monitor_type: pulumi.Input[_builtins.str]
        alarm_rule_template_bind_enable: NotRequired[pulumi.Input[_builtins.bool]]
        alarm_rule_template_id: NotRequired[pulumi.Input[_builtins.str]]
        alarm_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecAlarmTagArgsDict']]]]
        metric_kind: NotRequired[pulumi.Input[_builtins.str]]
        monitor_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        no_data_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecNoDataConditionArgsDict']]]]
        recovery_conditions: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]
        resource_kind: NotRequired[pulumi.Input[_builtins.str]]
        trigger_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecTriggerConditionArgsDict']]]]
elif False:
    AlarmPolicyMetricAlarmSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyMetricAlarmSpecArgs:
    def __init__(__self__, *,
                 monitor_type: pulumi.Input[_builtins.str],
                 alarm_rule_template_bind_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 alarm_rule_template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 alarm_tags: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecAlarmTagArgs']]]] = None,
                 metric_kind: Optional[pulumi.Input[_builtins.str]] = None,
                 monitor_objects: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 no_data_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecNoDataConditionArgs']]]] = None,
                 recovery_conditions: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]] = None,
                 resource_kind: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecTriggerConditionArgs']]]] = None):
        pulumi.set(__self__, "monitor_type", monitor_type)
        if alarm_rule_template_bind_enable is not None:
            pulumi.set(__self__, "alarm_rule_template_bind_enable", alarm_rule_template_bind_enable)
        if alarm_rule_template_id is not None:
            pulumi.set(__self__, "alarm_rule_template_id", alarm_rule_template_id)
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if metric_kind is not None:
            pulumi.set(__self__, "metric_kind", metric_kind)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        if recovery_conditions is not None:
            pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        if resource_kind is not None:
            pulumi.set(__self__, "resource_kind", resource_kind)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "monitor_type")

    @monitor_type.setter
    def monitor_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "monitor_type", value)

    @_builtins.property
    @pulumi.getter(name="alarmRuleTemplateBindEnable")
    def alarm_rule_template_bind_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "alarm_rule_template_bind_enable")

    @alarm_rule_template_bind_enable.setter
    def alarm_rule_template_bind_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "alarm_rule_template_bind_enable", value)

    @_builtins.property
    @pulumi.getter(name="alarmRuleTemplateId")
    def alarm_rule_template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "alarm_rule_template_id")

    @alarm_rule_template_id.setter
    def alarm_rule_template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_rule_template_id", value)

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecAlarmTagArgs']]]]:
        return pulumi.get(self, "alarm_tags")

    @alarm_tags.setter
    def alarm_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecAlarmTagArgs']]]]):
        pulumi.set(self, "alarm_tags", value)

    @_builtins.property
    @pulumi.getter(name="metricKind")
    def metric_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_kind")

    @metric_kind.setter
    def metric_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_kind", value)

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        return pulumi.get(self, "monitor_objects")

    @monitor_objects.setter
    def monitor_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "monitor_objects", value)

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecNoDataConditionArgs']]]]:
        return pulumi.get(self, "no_data_conditions")

    @no_data_conditions.setter
    def no_data_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecNoDataConditionArgs']]]]):
        pulumi.set(self, "no_data_conditions", value)

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "recovery_conditions")

    @recovery_conditions.setter
    def recovery_conditions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "recovery_conditions", value)

    @_builtins.property
    @pulumi.getter(name="resourceKind")
    def resource_kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_kind")

    @resource_kind.setter
    def resource_kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_kind", value)

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecTriggerConditionArgs']]]]:
        return pulumi.get(self, "trigger_conditions")

    @trigger_conditions.setter
    def trigger_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmPolicyMetricAlarmSpecTriggerConditionArgs']]]]):
        pulumi.set(self, "trigger_conditions", value)


if not MYPY:
    class AlarmPolicyMetricAlarmSpecAlarmTagArgsDict(TypedDict):
        auto_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        custom_annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        custom_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    AlarmPolicyMetricAlarmSpecAlarmTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyMetricAlarmSpecAlarmTagArgs:
    def __init__(__self__, *,
                 auto_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_annotations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "auto_tags")

    @auto_tags.setter
    def auto_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "auto_tags", value)

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "custom_annotations")

    @custom_annotations.setter
    def custom_annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_annotations", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class AlarmPolicyMetricAlarmSpecNoDataConditionArgsDict(TypedDict):
        no_data_alert_state: NotRequired[pulumi.Input[_builtins.str]]
        no_data_timeframe: NotRequired[pulumi.Input[_builtins.int]]
        notify_no_data: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    AlarmPolicyMetricAlarmSpecNoDataConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyMetricAlarmSpecNoDataConditionArgs:
    def __init__(__self__, *,
                 no_data_alert_state: Optional[pulumi.Input[_builtins.str]] = None,
                 no_data_timeframe: Optional[pulumi.Input[_builtins.int]] = None,
                 notify_no_data: Optional[pulumi.Input[_builtins.bool]] = None):
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "no_data_alert_state")

    @no_data_alert_state.setter
    def no_data_alert_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_data_alert_state", value)

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "no_data_timeframe")

    @no_data_timeframe.setter
    def no_data_timeframe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "no_data_timeframe", value)

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "notify_no_data")

    @notify_no_data.setter
    def notify_no_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_no_data", value)


if not MYPY:
    class AlarmPolicyMetricAlarmSpecTriggerConditionArgsDict(TypedDict):
        aggregation_type: NotRequired[pulumi.Input[_builtins.str]]
        aggregation_window: NotRequired[pulumi.Input[_builtins.str]]
        metric_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        metric_namespace: NotRequired[pulumi.Input[_builtins.str]]
        metric_query_mode: NotRequired[pulumi.Input[_builtins.str]]
        metric_unit: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        promql: NotRequired[pulumi.Input[_builtins.str]]
        thresholds: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        trigger_interval: NotRequired[pulumi.Input[_builtins.str]]
        trigger_times: NotRequired[pulumi.Input[_builtins.int]]
        trigger_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AlarmPolicyMetricAlarmSpecTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmPolicyMetricAlarmSpecTriggerConditionArgs:
    def __init__(__self__, *,
                 aggregation_type: Optional[pulumi.Input[_builtins.str]] = None,
                 aggregation_window: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_query_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 promql: Optional[pulumi.Input[_builtins.str]] = None,
                 thresholds: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 trigger_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_times: Optional[pulumi.Input[_builtins.int]] = None,
                 trigger_type: Optional[pulumi.Input[_builtins.str]] = None):
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if metric_labels is not None:
            pulumi.set(__self__, "metric_labels", metric_labels)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_query_mode is not None:
            pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        if metric_unit is not None:
            pulumi.set(__self__, "metric_unit", metric_unit)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if promql is not None:
            pulumi.set(__self__, "promql", promql)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)
        if trigger_interval is not None:
            pulumi.set(__self__, "trigger_interval", trigger_interval)
        if trigger_times is not None:
            pulumi.set(__self__, "trigger_times", trigger_times)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "aggregation_window")

    @aggregation_window.setter
    def aggregation_window(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregation_window", value)

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "metric_labels")

    @metric_labels.setter
    def metric_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metric_labels", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_query_mode")

    @metric_query_mode.setter
    def metric_query_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_query_mode", value)

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_unit", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def promql(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "promql")

    @promql.setter
    def promql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "promql", value)

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "thresholds", value)

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trigger_interval")

    @trigger_interval.setter
    def trigger_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_interval", value)

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "trigger_times")

    @trigger_times.setter
    def trigger_times(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "trigger_times", value)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_type", value)


if not MYPY:
    class AlarmRuleDimensionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the dimension name. Changing this creates a new resource.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the dimension value. Changing this creates a new resource.

        > **NOTE:** You can get more information about `metric_name`, `namespace`, `unit` and `dimensions`
        from [Metric Overview](https://support.huaweicloud.com/intl/en-us/productdesc-aom/aom_06_0014.html).
        """
elif False:
    AlarmRuleDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the dimension name. Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] value: Specifies the dimension value. Changing this creates a new resource.
               
               > **NOTE:** You can get more information about `metric_name`, `namespace`, `unit` and `dimensions`
               from [Metric Overview](https://support.huaweicloud.com/intl/en-us/productdesc-aom/aom_06_0014.html).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension name. Changing this creates a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the dimension value. Changing this creates a new resource.

        > **NOTE:** You can get more information about `metric_name`, `namespace`, `unit` and `dimensions`
        from [Metric Overview](https://support.huaweicloud.com/intl/en-us/productdesc-aom/aom_06_0014.html).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlarmRuleV4AlarmNotificationsArgsDict(TypedDict):
        notification_type: pulumi.Input[_builtins.str]
        """
        Specifies the notification type.
        Valid values are as follows:
        + **direct**: Direct alarm reporting.
        + **alarm_policy**: Alarm reporting after noise reduction.
        """
        bind_notification_rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm action rule ID.
        It's required if `notification_enable` is **true**.
        """
        notification_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable an alarm action rule. Defaults to **false**.
        If the `notification_type` is **direct**, set this parameter to **true**.
        """
        notify_frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the notification frequency.
        If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
        If the `notification_type` is **direct**, set this parameter to any of the following:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day

        <a name="block--event_alarm_spec"></a>
        The `event_alarm_spec` block supports:
        """
        notify_resolved: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to send a notification when an alarm is cleared.
        Defaults to **false**.
        """
        notify_triggered: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to send a notification when an alarm is triggered.
        Defaults to **false**.
        """
        route_group_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the grouping rule. Defaults to **false**.
        If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        """
        route_group_rule: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the grouping rule name.
        It's required if `route_group_enable` is **true**.
        """
elif False:
    AlarmRuleV4AlarmNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4AlarmNotificationsArgs:
    def __init__(__self__, *,
                 notification_type: pulumi.Input[_builtins.str],
                 bind_notification_rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 notify_frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 notify_resolved: Optional[pulumi.Input[_builtins.bool]] = None,
                 notify_triggered: Optional[pulumi.Input[_builtins.bool]] = None,
                 route_group_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 route_group_rule: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] notification_type: Specifies the notification type.
               Valid values are as follows:
               + **direct**: Direct alarm reporting.
               + **alarm_policy**: Alarm reporting after noise reduction.
        :param pulumi.Input[_builtins.str] bind_notification_rule_id: Specifies the alarm action rule ID.
               It's required if `notification_enable` is **true**.
        :param pulumi.Input[_builtins.bool] notification_enable: Specifies whether to enable an alarm action rule. Defaults to **false**.
               If the `notification_type` is **direct**, set this parameter to **true**.
        :param pulumi.Input[_builtins.str] notify_frequency: Specifies the notification frequency.
               If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
               If the `notification_type` is **direct**, set this parameter to any of the following:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
               
               <a name="block--event_alarm_spec"></a>
               The `event_alarm_spec` block supports:
        :param pulumi.Input[_builtins.bool] notify_resolved: Specifies whether to send a notification when an alarm is cleared.
               Defaults to **false**.
        :param pulumi.Input[_builtins.bool] notify_triggered: Specifies whether to send a notification when an alarm is triggered.
               Defaults to **false**.
        :param pulumi.Input[_builtins.bool] route_group_enable: Specifies whether to enable the grouping rule. Defaults to **false**.
               If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        :param pulumi.Input[_builtins.str] route_group_rule: Specifies the grouping rule name.
               It's required if `route_group_enable` is **true**.
        """
        pulumi.set(__self__, "notification_type", notification_type)
        if bind_notification_rule_id is not None:
            pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        if notification_enable is not None:
            pulumi.set(__self__, "notification_enable", notification_enable)
        if notify_frequency is not None:
            pulumi.set(__self__, "notify_frequency", notify_frequency)
        if notify_resolved is not None:
            pulumi.set(__self__, "notify_resolved", notify_resolved)
        if notify_triggered is not None:
            pulumi.set(__self__, "notify_triggered", notify_triggered)
        if route_group_enable is not None:
            pulumi.set(__self__, "route_group_enable", route_group_enable)
        if route_group_rule is not None:
            pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification type.
        Valid values are as follows:
        + **direct**: Direct alarm reporting.
        + **alarm_policy**: Alarm reporting after noise reduction.
        """
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "notification_type", value)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm action rule ID.
        It's required if `notification_enable` is **true**.
        """
        return pulumi.get(self, "bind_notification_rule_id")

    @bind_notification_rule_id.setter
    def bind_notification_rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_notification_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable an alarm action rule. Defaults to **false**.
        If the `notification_type` is **direct**, set this parameter to **true**.
        """
        return pulumi.get(self, "notification_enable")

    @notification_enable.setter
    def notification_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notification_enable", value)

    @_builtins.property
    @pulumi.getter(name="notifyFrequency")
    def notify_frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the notification frequency.
        If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
        If the `notification_type` is **direct**, set this parameter to any of the following:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day

        <a name="block--event_alarm_spec"></a>
        The `event_alarm_spec` block supports:
        """
        return pulumi.get(self, "notify_frequency")

    @notify_frequency.setter
    def notify_frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notify_frequency", value)

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to send a notification when an alarm is cleared.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_resolved")

    @notify_resolved.setter
    def notify_resolved(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_resolved", value)

    @_builtins.property
    @pulumi.getter(name="notifyTriggered")
    def notify_triggered(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to send a notification when an alarm is triggered.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_triggered")

    @notify_triggered.setter
    def notify_triggered(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_triggered", value)

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the grouping rule. Defaults to **false**.
        If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        """
        return pulumi.get(self, "route_group_enable")

    @route_group_enable.setter
    def route_group_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_group_enable", value)

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the grouping rule name.
        It's required if `route_group_enable` is **true**.
        """
        return pulumi.get(self, "route_group_rule")

    @route_group_rule.setter
    def route_group_rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_group_rule", value)


if not MYPY:
    class AlarmRuleV4EventAlarmSpecArgsDict(TypedDict):
        alarm_source: pulumi.Input[_builtins.str]
        """
        Specifies the alarm rule source.
        Valid values are **systemEvent** and **customEvent**.
        Changing this creates a new resource.
        """
        event_source: pulumi.Input[_builtins.str]
        """
        Specifies the alarm source.
        Valid values are **RDS**, **EVS**, **CCE**, **LTS** and **AOM**.
        """
        monitor_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        Specifies the monitored objects. It's an array of Map objects.

        <a name="block--metric_alarm_spec--recovery_conditions"></a>
        The `recovery_conditions` block supports:
        """
        trigger_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4EventAlarmSpecTriggerConditionArgsDict']]]]
        """
        Specifies the trigger conditions.
        The trigger_conditions structure is documented below.
        """
elif False:
    AlarmRuleV4EventAlarmSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4EventAlarmSpecArgs:
    def __init__(__self__, *,
                 alarm_source: pulumi.Input[_builtins.str],
                 event_source: pulumi.Input[_builtins.str],
                 monitor_objects: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 trigger_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4EventAlarmSpecTriggerConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] alarm_source: Specifies the alarm rule source.
               Valid values are **systemEvent** and **customEvent**.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] event_source: Specifies the alarm source.
               Valid values are **RDS**, **EVS**, **CCE**, **LTS** and **AOM**.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] monitor_objects: Specifies the monitored objects. It's an array of Map objects.
               
               <a name="block--metric_alarm_spec--recovery_conditions"></a>
               The `recovery_conditions` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4EventAlarmSpecTriggerConditionArgs']]] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions structure is documented below.
        """
        pulumi.set(__self__, "alarm_source", alarm_source)
        pulumi.set(__self__, "event_source", event_source)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the alarm rule source.
        Valid values are **systemEvent** and **customEvent**.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "alarm_source")

    @alarm_source.setter
    def alarm_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm_source", value)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the alarm source.
        Valid values are **RDS**, **EVS**, **CCE**, **LTS** and **AOM**.
        """
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_source", value)

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        Specifies the monitored objects. It's an array of Map objects.

        <a name="block--metric_alarm_spec--recovery_conditions"></a>
        The `recovery_conditions` block supports:
        """
        return pulumi.get(self, "monitor_objects")

    @monitor_objects.setter
    def monitor_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "monitor_objects", value)

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4EventAlarmSpecTriggerConditionArgs']]]]:
        """
        Specifies the trigger conditions.
        The trigger_conditions structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")

    @trigger_conditions.setter
    def trigger_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4EventAlarmSpecTriggerConditionArgs']]]]):
        pulumi.set(self, "trigger_conditions", value)


if not MYPY:
    class AlarmRuleV4EventAlarmSpecTriggerConditionArgsDict(TypedDict):
        trigger_type: pulumi.Input[_builtins.str]
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        aggregation_window: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        event_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event name.
        """
        frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event alarm notification frequency. Leave this parameter empty if
        `trigger_type` is set to **immediately**. Valid values are as follows:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        thresholds: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
elif False:
    AlarmRuleV4EventAlarmSpecTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4EventAlarmSpecTriggerConditionArgs:
    def __init__(__self__, *,
                 trigger_type: pulumi.Input[_builtins.str],
                 aggregation_window: Optional[pulumi.Input[_builtins.int]] = None,
                 event_name: Optional[pulumi.Input[_builtins.str]] = None,
                 frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 thresholds: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.str] trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        :param pulumi.Input[_builtins.int] aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param pulumi.Input[_builtins.str] event_name: Specifies the event name.
        :param pulumi.Input[_builtins.str] frequency: Specifies the event alarm notification frequency. Leave this parameter empty if
               `trigger_type` is set to **immediately**. Valid values are as follows:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
        :param pulumi.Input[_builtins.str] operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        """
        pulumi.set(__self__, "trigger_type", trigger_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if event_name is not None:
            pulumi.set(__self__, "event_name", event_name)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trigger_type", value)

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @aggregation_window.setter
    def aggregation_window(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "aggregation_window", value)

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event name.
        """
        return pulumi.get(self, "event_name")

    @event_name.setter
    def event_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_name", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event alarm notification frequency. Leave this parameter empty if
        `trigger_type` is set to **immediately**. Valid values are as follows:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "thresholds", value)


if not MYPY:
    class AlarmRuleV4MetricAlarmSpecArgsDict(TypedDict):
        monitor_type: pulumi.Input[_builtins.str]
        """
        Specifies the monitoring type.
        Valid values are as follows:
        + **all_metric**: Select metrics from all metrics.
        + **promql**: Select metrics using PromQL.

        Changing this creates a new resource.
        """
        recovery_conditions: pulumi.Input['AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgsDict']
        """
        Specifies the alarm clearance condition.
        The recovery_conditions structure is documented below.
        """
        alarm_tags: NotRequired[pulumi.Input['AlarmRuleV4MetricAlarmSpecAlarmTagsArgsDict']]
        """
        Specifies the alarm tags.
        The alarm_tags structure is documented below.
        """
        monitor_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        Specifies the monitored objects. It's an array of Map objects.

        <a name="block--metric_alarm_spec--recovery_conditions"></a>
        The `recovery_conditions` block supports:
        """
        no_data_conditions: NotRequired[pulumi.Input['AlarmRuleV4MetricAlarmSpecNoDataConditionsArgsDict']]
        """
        Specifies the action taken for insufficient data.
        The no_data_conditions structure is documented below.
        """
        trigger_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4MetricAlarmSpecTriggerConditionArgsDict']]]]
        """
        Specifies the trigger conditions.
        The trigger_conditions structure is documented below.
        """
elif False:
    AlarmRuleV4MetricAlarmSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4MetricAlarmSpecArgs:
    def __init__(__self__, *,
                 monitor_type: pulumi.Input[_builtins.str],
                 recovery_conditions: pulumi.Input['AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgs'],
                 alarm_tags: Optional[pulumi.Input['AlarmRuleV4MetricAlarmSpecAlarmTagsArgs']] = None,
                 monitor_objects: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 no_data_conditions: Optional[pulumi.Input['AlarmRuleV4MetricAlarmSpecNoDataConditionsArgs']] = None,
                 trigger_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4MetricAlarmSpecTriggerConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] monitor_type: Specifies the monitoring type.
               Valid values are as follows:
               + **all_metric**: Select metrics from all metrics.
               + **promql**: Select metrics using PromQL.
               
               Changing this creates a new resource.
        :param pulumi.Input['AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgs'] recovery_conditions: Specifies the alarm clearance condition.
               The recovery_conditions structure is documented below.
        :param pulumi.Input['AlarmRuleV4MetricAlarmSpecAlarmTagsArgs'] alarm_tags: Specifies the alarm tags.
               The alarm_tags structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] monitor_objects: Specifies the monitored objects. It's an array of Map objects.
               
               <a name="block--metric_alarm_spec--recovery_conditions"></a>
               The `recovery_conditions` block supports:
        :param pulumi.Input['AlarmRuleV4MetricAlarmSpecNoDataConditionsArgs'] no_data_conditions: Specifies the action taken for insufficient data.
               The no_data_conditions structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4MetricAlarmSpecTriggerConditionArgs']]] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions structure is documented below.
        """
        pulumi.set(__self__, "monitor_type", monitor_type)
        pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the monitoring type.
        Valid values are as follows:
        + **all_metric**: Select metrics from all metrics.
        + **promql**: Select metrics using PromQL.

        Changing this creates a new resource.
        """
        return pulumi.get(self, "monitor_type")

    @monitor_type.setter
    def monitor_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "monitor_type", value)

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> pulumi.Input['AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgs']:
        """
        Specifies the alarm clearance condition.
        The recovery_conditions structure is documented below.
        """
        return pulumi.get(self, "recovery_conditions")

    @recovery_conditions.setter
    def recovery_conditions(self, value: pulumi.Input['AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgs']):
        pulumi.set(self, "recovery_conditions", value)

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional[pulumi.Input['AlarmRuleV4MetricAlarmSpecAlarmTagsArgs']]:
        """
        Specifies the alarm tags.
        The alarm_tags structure is documented below.
        """
        return pulumi.get(self, "alarm_tags")

    @alarm_tags.setter
    def alarm_tags(self, value: Optional[pulumi.Input['AlarmRuleV4MetricAlarmSpecAlarmTagsArgs']]):
        pulumi.set(self, "alarm_tags", value)

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        Specifies the monitored objects. It's an array of Map objects.

        <a name="block--metric_alarm_spec--recovery_conditions"></a>
        The `recovery_conditions` block supports:
        """
        return pulumi.get(self, "monitor_objects")

    @monitor_objects.setter
    def monitor_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "monitor_objects", value)

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional[pulumi.Input['AlarmRuleV4MetricAlarmSpecNoDataConditionsArgs']]:
        """
        Specifies the action taken for insufficient data.
        The no_data_conditions structure is documented below.
        """
        return pulumi.get(self, "no_data_conditions")

    @no_data_conditions.setter
    def no_data_conditions(self, value: Optional[pulumi.Input['AlarmRuleV4MetricAlarmSpecNoDataConditionsArgs']]):
        pulumi.set(self, "no_data_conditions", value)

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4MetricAlarmSpecTriggerConditionArgs']]]]:
        """
        Specifies the trigger conditions.
        The trigger_conditions structure is documented below.
        """
        return pulumi.get(self, "trigger_conditions")

    @trigger_conditions.setter
    def trigger_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRuleV4MetricAlarmSpecTriggerConditionArgs']]]]):
        pulumi.set(self, "trigger_conditions", value)


if not MYPY:
    class AlarmRuleV4MetricAlarmSpecAlarmTagsArgsDict(TypedDict):
        auto_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the automatic tag.
        """
        custom_annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the custom tag.
        """
        custom_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the alarm annotation.

        <a name="block--metric_alarm_spec--no_data_conditions"></a>
        The `no_data_conditions` block supports:
        """
elif False:
    AlarmRuleV4MetricAlarmSpecAlarmTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4MetricAlarmSpecAlarmTagsArgs:
    def __init__(__self__, *,
                 auto_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_annotations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] auto_tags: Specifies the automatic tag.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_annotations: Specifies the custom tag.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_tags: Specifies the alarm annotation.
               
               <a name="block--metric_alarm_spec--no_data_conditions"></a>
               The `no_data_conditions` block supports:
        """
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the automatic tag.
        """
        return pulumi.get(self, "auto_tags")

    @auto_tags.setter
    def auto_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "auto_tags", value)

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the custom tag.
        """
        return pulumi.get(self, "custom_annotations")

    @custom_annotations.setter
    def custom_annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_annotations", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the alarm annotation.

        <a name="block--metric_alarm_spec--no_data_conditions"></a>
        The `no_data_conditions` block supports:
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class AlarmRuleV4MetricAlarmSpecNoDataConditionsArgsDict(TypedDict):
        no_data_alert_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the status of the threshold rule when the data is insufficient.
        Valid values are as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        no_data_timeframe: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of periods without data.
        """
        notify_no_data: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to send a notification when data is insufficient.
        Defaults to **false**.
        """
elif False:
    AlarmRuleV4MetricAlarmSpecNoDataConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4MetricAlarmSpecNoDataConditionsArgs:
    def __init__(__self__, *,
                 no_data_alert_state: Optional[pulumi.Input[_builtins.str]] = None,
                 no_data_timeframe: Optional[pulumi.Input[_builtins.int]] = None,
                 notify_no_data: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] no_data_alert_state: Specifies the status of the threshold rule when the data is insufficient.
               Valid values are as follows:
               + **no_data**: A notification indicating insufficient data is sent.
               + **alerting**: An alarm is triggered.
               + **ok**: No exception occurs.
               + **pre_state**: Retain the previous state.
        :param pulumi.Input[_builtins.int] no_data_timeframe: Specifies the number of periods without data.
        :param pulumi.Input[_builtins.bool] notify_no_data: Specifies whether to send a notification when data is insufficient.
               Defaults to **false**.
        """
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the status of the threshold rule when the data is insufficient.
        Valid values are as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        return pulumi.get(self, "no_data_alert_state")

    @no_data_alert_state.setter
    def no_data_alert_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_data_alert_state", value)

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of periods without data.
        """
        return pulumi.get(self, "no_data_timeframe")

    @no_data_timeframe.setter
    def no_data_timeframe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "no_data_timeframe", value)

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to send a notification when data is insufficient.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_no_data")

    @notify_no_data.setter
    def notify_no_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_no_data", value)


if not MYPY:
    class AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgsDict(TypedDict):
        recovery_timeframe: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of consecutive periods for which the trigger condition is
        not met to clear an alarm.

        <a name="block--metric_alarm_spec--trigger_conditions"></a>
        The `trigger_conditions` block supports:
        """
elif False:
    AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4MetricAlarmSpecRecoveryConditionsArgs:
    def __init__(__self__, *,
                 recovery_timeframe: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] recovery_timeframe: Specifies the number of consecutive periods for which the trigger condition is
               not met to clear an alarm.
               
               <a name="block--metric_alarm_spec--trigger_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if recovery_timeframe is not None:
            pulumi.set(__self__, "recovery_timeframe", recovery_timeframe)

    @_builtins.property
    @pulumi.getter(name="recoveryTimeframe")
    def recovery_timeframe(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of consecutive periods for which the trigger condition is
        not met to clear an alarm.

        <a name="block--metric_alarm_spec--trigger_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "recovery_timeframe")

    @recovery_timeframe.setter
    def recovery_timeframe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recovery_timeframe", value)


if not MYPY:
    class AlarmRuleV4MetricAlarmSpecTriggerConditionArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        """
        Specifies the metric name.
        """
        metric_query_mode: pulumi.Input[_builtins.str]
        """
        Specifies the metric query mode.
        Valid values are as follows:
        + **AOM**: native AOM
        + **PROM**: AOM prometheus
        + **NATIVE_PROM**: native prometheus
        """
        promql: pulumi.Input[_builtins.str]
        """
        Specifies the prometheus statement.
        """
        aggregate_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the aggregation mode.
        Valid values are **by**, **avg**, **max**, **min** and **sum**.
        """
        aggregation_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the statistical mode.
        Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        aggregation_window: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        aom_monitor_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the monitoring layer.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the expression of a combined operation.
        """
        metric_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the metric dimension.
        """
        metric_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric namespace.
        """
        metric_statistic_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric statistics method to be used when you set
        Configuration Mode to Select from all metrics during alarm rule setting.
        Valid values are as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        metric_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric unit.
        """
        mix_promql: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the promQL of a combined operation.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        promql_exprs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the prometheus statement template.
        """
        promql_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the native prometheus monitoring duration.
        """
        query_match: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the query filter criteria.
        """
        query_param: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the query parameters.
        """
        thresholds: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        trigger_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the check interval.
        Valid values are as follows:
        + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
        + If `trigger_type` is set to **DAILY**, set 00:00–23:00. Example: **03:00**.
        + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:00–23:00.
        Example: **1 03:00** indicates 03:00 on every Monday.
        + If `trigger_type` is set to **CRON**, specify a standard cron expression.
        + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 1–59 min, or 1–24 h.
        Example: **15s**, **30s**, **1min**, or **1h**.
        """
        trigger_times: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of consecutive periods.

        <a name="block--metric_alarm_spec--alarm_tags"></a>
        The `alarm_tags` block supports:
        """
        trigger_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
elif False:
    AlarmRuleV4MetricAlarmSpecTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRuleV4MetricAlarmSpecTriggerConditionArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 metric_query_mode: pulumi.Input[_builtins.str],
                 promql: pulumi.Input[_builtins.str],
                 aggregate_type: Optional[pulumi.Input[_builtins.str]] = None,
                 aggregation_type: Optional[pulumi.Input[_builtins.str]] = None,
                 aggregation_window: Optional[pulumi.Input[_builtins.str]] = None,
                 aom_monitor_level: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 metric_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_statistic_method: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 mix_promql: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 promql_exprs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 promql_for: Optional[pulumi.Input[_builtins.str]] = None,
                 query_match: Optional[pulumi.Input[_builtins.str]] = None,
                 query_param: Optional[pulumi.Input[_builtins.str]] = None,
                 thresholds: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 trigger_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_times: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metric_name: Specifies the metric name.
        :param pulumi.Input[_builtins.str] metric_query_mode: Specifies the metric query mode.
               Valid values are as follows:
               + **AOM**: native AOM
               + **PROM**: AOM prometheus
               + **NATIVE_PROM**: native prometheus
        :param pulumi.Input[_builtins.str] promql: Specifies the prometheus statement.
        :param pulumi.Input[_builtins.str] aggregate_type: Specifies the aggregation mode.
               Valid values are **by**, **avg**, **max**, **min** and **sum**.
        :param pulumi.Input[_builtins.str] aggregation_type: Specifies the statistical mode.
               Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        :param pulumi.Input[_builtins.str] aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param pulumi.Input[_builtins.str] aom_monitor_level: Specifies the monitoring layer.
        :param pulumi.Input[_builtins.str] expression: Specifies the expression of a combined operation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metric_labels: Specifies the metric dimension.
        :param pulumi.Input[_builtins.str] metric_namespace: Specifies the metric namespace.
        :param pulumi.Input[_builtins.str] metric_statistic_method: Specifies the metric statistics method to be used when you set
               Configuration Mode to Select from all metrics during alarm rule setting.
               Valid values are as follows:
               + **single**: single metric
               + **mix**: multi-metric combined operations
        :param pulumi.Input[_builtins.str] metric_unit: Specifies the metric unit.
        :param pulumi.Input[_builtins.str] mix_promql: Specifies the promQL of a combined operation.
        :param pulumi.Input[_builtins.str] operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] promql_exprs: Specifies the prometheus statement template.
        :param pulumi.Input[_builtins.str] promql_for: Specifies the native prometheus monitoring duration.
        :param pulumi.Input[_builtins.str] query_match: Specifies the query filter criteria.
        :param pulumi.Input[_builtins.str] query_param: Specifies the query parameters.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        :param pulumi.Input[_builtins.str] trigger_interval: Specifies the check interval.
               Valid values are as follows:
               + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
               + If `trigger_type` is set to **DAILY**, set 00:00–23:00. Example: **03:00**.
               + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:00–23:00.
               Example: **1 03:00** indicates 03:00 on every Monday.
               + If `trigger_type` is set to **CRON**, specify a standard cron expression.
               + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 1–59 min, or 1–24 h.
               Example: **15s**, **30s**, **1min**, or **1h**.
        :param pulumi.Input[_builtins.str] trigger_times: Specifies the number of consecutive periods.
               
               <a name="block--metric_alarm_spec--alarm_tags"></a>
               The `alarm_tags` block supports:
        :param pulumi.Input[_builtins.str] trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        pulumi.set(__self__, "promql", promql)
        if aggregate_type is not None:
            pulumi.set(__self__, "aggregate_type", aggregate_type)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if aom_monitor_level is not None:
            pulumi.set(__self__, "aom_monitor_level", aom_monitor_level)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if metric_labels is not None:
            pulumi.set(__self__, "metric_labels", metric_labels)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_statistic_method is not None:
            pulumi.set(__self__, "metric_statistic_method", metric_statistic_method)
        if metric_unit is not None:
            pulumi.set(__self__, "metric_unit", metric_unit)
        if mix_promql is not None:
            pulumi.set(__self__, "mix_promql", mix_promql)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if promql_exprs is not None:
            pulumi.set(__self__, "promql_exprs", promql_exprs)
        if promql_for is not None:
            pulumi.set(__self__, "promql_for", promql_for)
        if query_match is not None:
            pulumi.set(__self__, "query_match", query_match)
        if query_param is not None:
            pulumi.set(__self__, "query_param", query_param)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)
        if trigger_interval is not None:
            pulumi.set(__self__, "trigger_interval", trigger_interval)
        if trigger_times is not None:
            pulumi.set(__self__, "trigger_times", trigger_times)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the metric query mode.
        Valid values are as follows:
        + **AOM**: native AOM
        + **PROM**: AOM prometheus
        + **NATIVE_PROM**: native prometheus
        """
        return pulumi.get(self, "metric_query_mode")

    @metric_query_mode.setter
    def metric_query_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_query_mode", value)

    @_builtins.property
    @pulumi.getter
    def promql(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the prometheus statement.
        """
        return pulumi.get(self, "promql")

    @promql.setter
    def promql(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "promql", value)

    @_builtins.property
    @pulumi.getter(name="aggregateType")
    def aggregate_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the aggregation mode.
        Valid values are **by**, **avg**, **max**, **min** and **sum**.
        """
        return pulumi.get(self, "aggregate_type")

    @aggregate_type.setter
    def aggregate_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregate_type", value)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the statistical mode.
        Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @aggregation_window.setter
    def aggregation_window(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregation_window", value)

    @_builtins.property
    @pulumi.getter(name="aomMonitorLevel")
    def aom_monitor_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the monitoring layer.
        """
        return pulumi.get(self, "aom_monitor_level")

    @aom_monitor_level.setter
    def aom_monitor_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aom_monitor_level", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the expression of a combined operation.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the metric dimension.
        """
        return pulumi.get(self, "metric_labels")

    @metric_labels.setter
    def metric_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metric_labels", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric namespace.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricStatisticMethod")
    def metric_statistic_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric statistics method to be used when you set
        Configuration Mode to Select from all metrics during alarm rule setting.
        Valid values are as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        return pulumi.get(self, "metric_statistic_method")

    @metric_statistic_method.setter
    def metric_statistic_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_statistic_method", value)

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric unit.
        """
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_unit", value)

    @_builtins.property
    @pulumi.getter(name="mixPromql")
    def mix_promql(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the promQL of a combined operation.
        """
        return pulumi.get(self, "mix_promql")

    @mix_promql.setter
    def mix_promql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mix_promql", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter(name="promqlExprs")
    def promql_exprs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the prometheus statement template.
        """
        return pulumi.get(self, "promql_exprs")

    @promql_exprs.setter
    def promql_exprs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "promql_exprs", value)

    @_builtins.property
    @pulumi.getter(name="promqlFor")
    def promql_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the native prometheus monitoring duration.
        """
        return pulumi.get(self, "promql_for")

    @promql_for.setter
    def promql_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "promql_for", value)

    @_builtins.property
    @pulumi.getter(name="queryMatch")
    def query_match(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the query filter criteria.
        """
        return pulumi.get(self, "query_match")

    @query_match.setter
    def query_match(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_match", value)

    @_builtins.property
    @pulumi.getter(name="queryParam")
    def query_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the query parameters.
        """
        return pulumi.get(self, "query_param")

    @query_param.setter
    def query_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_param", value)

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "thresholds", value)

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the check interval.
        Valid values are as follows:
        + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
        + If `trigger_type` is set to **DAILY**, set 00:00–23:00. Example: **03:00**.
        + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:00–23:00.
        Example: **1 03:00** indicates 03:00 on every Monday.
        + If `trigger_type` is set to **CRON**, specify a standard cron expression.
        + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 1–59 min, or 1–24 h.
        Example: **15s**, **30s**, **1min**, or **1h**.
        """
        return pulumi.get(self, "trigger_interval")

    @trigger_interval.setter
    def trigger_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_interval", value)

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of consecutive periods.

        <a name="block--metric_alarm_spec--alarm_tags"></a>
        The `alarm_tags` block supports:
        """
        return pulumi.get(self, "trigger_times")

    @trigger_times.setter
    def trigger_times(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_times", value)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_type", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListArgsDict(TypedDict):
        alarm_notification: NotRequired[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgsDict']]
        """
        Specifies the alarm notification.
        The alarm_notification structure is documented below.
        """
        alarm_template_spec_items: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgsDict']]]]
        """
        Specifies the alarm template spec items.
        The alarm_template_spec_items structure is documented below.

        <a name="alarm_template_spec_list--alarm_notification"></a>
        The `alarm_notification` block supports:
        """
        related_cce_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the related cce clusters of the alarm rules.
        """
        related_cloud_service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the related cloud service of the alarm rules.
        """
        related_prometheus_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the related prometheus instances of the alarm rules.
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListArgs:
    def __init__(__self__, *,
                 alarm_notification: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgs']] = None,
                 alarm_template_spec_items: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs']]]] = None,
                 related_cce_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 related_cloud_service: Optional[pulumi.Input[_builtins.str]] = None,
                 related_prometheus_instances: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgs'] alarm_notification: Specifies the alarm notification.
               The alarm_notification structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs']]] alarm_template_spec_items: Specifies the alarm template spec items.
               The alarm_template_spec_items structure is documented below.
               
               <a name="alarm_template_spec_list--alarm_notification"></a>
               The `alarm_notification` block supports:
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] related_cce_clusters: Specifies the related cce clusters of the alarm rules.
        :param pulumi.Input[_builtins.str] related_cloud_service: Specifies the related cloud service of the alarm rules.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] related_prometheus_instances: Specifies the related prometheus instances of the alarm rules.
        """
        if alarm_notification is not None:
            pulumi.set(__self__, "alarm_notification", alarm_notification)
        if alarm_template_spec_items is not None:
            pulumi.set(__self__, "alarm_template_spec_items", alarm_template_spec_items)
        if related_cce_clusters is not None:
            pulumi.set(__self__, "related_cce_clusters", related_cce_clusters)
        if related_cloud_service is not None:
            pulumi.set(__self__, "related_cloud_service", related_cloud_service)
        if related_prometheus_instances is not None:
            pulumi.set(__self__, "related_prometheus_instances", related_prometheus_instances)

    @_builtins.property
    @pulumi.getter(name="alarmNotification")
    def alarm_notification(self) -> Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgs']]:
        """
        Specifies the alarm notification.
        The alarm_notification structure is documented below.
        """
        return pulumi.get(self, "alarm_notification")

    @alarm_notification.setter
    def alarm_notification(self, value: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgs']]):
        pulumi.set(self, "alarm_notification", value)

    @_builtins.property
    @pulumi.getter(name="alarmTemplateSpecItems")
    def alarm_template_spec_items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs']]]]:
        """
        Specifies the alarm template spec items.
        The alarm_template_spec_items structure is documented below.

        <a name="alarm_template_spec_list--alarm_notification"></a>
        The `alarm_notification` block supports:
        """
        return pulumi.get(self, "alarm_template_spec_items")

    @alarm_template_spec_items.setter
    def alarm_template_spec_items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs']]]]):
        pulumi.set(self, "alarm_template_spec_items", value)

    @_builtins.property
    @pulumi.getter(name="relatedCceClusters")
    def related_cce_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the related cce clusters of the alarm rules.
        """
        return pulumi.get(self, "related_cce_clusters")

    @related_cce_clusters.setter
    def related_cce_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "related_cce_clusters", value)

    @_builtins.property
    @pulumi.getter(name="relatedCloudService")
    def related_cloud_service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the related cloud service of the alarm rules.
        """
        return pulumi.get(self, "related_cloud_service")

    @related_cloud_service.setter
    def related_cloud_service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "related_cloud_service", value)

    @_builtins.property
    @pulumi.getter(name="relatedPrometheusInstances")
    def related_prometheus_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the related prometheus instances of the alarm rules.
        """
        return pulumi.get(self, "related_prometheus_instances")

    @related_prometheus_instances.setter
    def related_prometheus_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "related_prometheus_instances", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgsDict(TypedDict):
        notification_type: pulumi.Input[_builtins.str]
        """
        Specifies the notification type.
        Valid values are as follows:
        + **direct**: Direct alarm reporting.
        + **alarm_policy**: Alarm reporting after noise reduction.
        """
        bind_notification_rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm action rule ID.
        It's required if `notification_enable` is **true**.
        """
        notification_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable an alarm action rule. Defaults to **false**.
        If the `notification_type` is **direct**, set this parameter to **true**.
        """
        notify_frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the notification frequency.
        If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
        If the `notification_type` is **direct**, set this parameter to any of the following:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day

        <a name="alarm_template_spec_list--alarm_template_spec_items"></a>
        The `alarm_template_spec_items` block supports:
        """
        notify_resolved: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to send a notification when an alarm is cleared.
        Defaults to **false**.
        """
        notify_triggered: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to send a notification when an alarm is triggered.
        Defaults to **false**.
        """
        route_group_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the grouping rule. Defaults to **false**.
        If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        """
        route_group_rule: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the grouping rule name.
        It's required if `route_group_enable` is **true**.
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmNotificationArgs:
    def __init__(__self__, *,
                 notification_type: pulumi.Input[_builtins.str],
                 bind_notification_rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 notify_frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 notify_resolved: Optional[pulumi.Input[_builtins.bool]] = None,
                 notify_triggered: Optional[pulumi.Input[_builtins.bool]] = None,
                 route_group_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 route_group_rule: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] notification_type: Specifies the notification type.
               Valid values are as follows:
               + **direct**: Direct alarm reporting.
               + **alarm_policy**: Alarm reporting after noise reduction.
        :param pulumi.Input[_builtins.str] bind_notification_rule_id: Specifies the alarm action rule ID.
               It's required if `notification_enable` is **true**.
        :param pulumi.Input[_builtins.bool] notification_enable: Specifies whether to enable an alarm action rule. Defaults to **false**.
               If the `notification_type` is **direct**, set this parameter to **true**.
        :param pulumi.Input[_builtins.str] notify_frequency: Specifies the notification frequency.
               If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
               If the `notification_type` is **direct**, set this parameter to any of the following:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
               
               <a name="alarm_template_spec_list--alarm_template_spec_items"></a>
               The `alarm_template_spec_items` block supports:
        :param pulumi.Input[_builtins.bool] notify_resolved: Specifies whether to send a notification when an alarm is cleared.
               Defaults to **false**.
        :param pulumi.Input[_builtins.bool] notify_triggered: Specifies whether to send a notification when an alarm is triggered.
               Defaults to **false**.
        :param pulumi.Input[_builtins.bool] route_group_enable: Specifies whether to enable the grouping rule. Defaults to **false**.
               If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        :param pulumi.Input[_builtins.str] route_group_rule: Specifies the grouping rule name.
               It's required if `route_group_enable` is **true**.
        """
        pulumi.set(__self__, "notification_type", notification_type)
        if bind_notification_rule_id is not None:
            pulumi.set(__self__, "bind_notification_rule_id", bind_notification_rule_id)
        if notification_enable is not None:
            pulumi.set(__self__, "notification_enable", notification_enable)
        if notify_frequency is not None:
            pulumi.set(__self__, "notify_frequency", notify_frequency)
        if notify_resolved is not None:
            pulumi.set(__self__, "notify_resolved", notify_resolved)
        if notify_triggered is not None:
            pulumi.set(__self__, "notify_triggered", notify_triggered)
        if route_group_enable is not None:
            pulumi.set(__self__, "route_group_enable", route_group_enable)
        if route_group_rule is not None:
            pulumi.set(__self__, "route_group_rule", route_group_rule)

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification type.
        Valid values are as follows:
        + **direct**: Direct alarm reporting.
        + **alarm_policy**: Alarm reporting after noise reduction.
        """
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "notification_type", value)

    @_builtins.property
    @pulumi.getter(name="bindNotificationRuleId")
    def bind_notification_rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm action rule ID.
        It's required if `notification_enable` is **true**.
        """
        return pulumi.get(self, "bind_notification_rule_id")

    @bind_notification_rule_id.setter
    def bind_notification_rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bind_notification_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="notificationEnable")
    def notification_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable an alarm action rule. Defaults to **false**.
        If the `notification_type` is **direct**, set this parameter to **true**.
        """
        return pulumi.get(self, "notification_enable")

    @notification_enable.setter
    def notification_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notification_enable", value)

    @_builtins.property
    @pulumi.getter(name="notifyFrequency")
    def notify_frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the notification frequency.
        If the `notification_type` is **alarm_policy**, set this parameter to **-1**.
        If the `notification_type` is **direct**, set this parameter to any of the following:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day

        <a name="alarm_template_spec_list--alarm_template_spec_items"></a>
        The `alarm_template_spec_items` block supports:
        """
        return pulumi.get(self, "notify_frequency")

    @notify_frequency.setter
    def notify_frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notify_frequency", value)

    @_builtins.property
    @pulumi.getter(name="notifyResolved")
    def notify_resolved(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to send a notification when an alarm is cleared.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_resolved")

    @notify_resolved.setter
    def notify_resolved(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_resolved", value)

    @_builtins.property
    @pulumi.getter(name="notifyTriggered")
    def notify_triggered(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to send a notification when an alarm is triggered.
        Defaults to **false**.
        """
        return pulumi.get(self, "notify_triggered")

    @notify_triggered.setter
    def notify_triggered(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_triggered", value)

    @_builtins.property
    @pulumi.getter(name="routeGroupEnable")
    def route_group_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the grouping rule. Defaults to **false**.
        If the `notification_type` is **alarm_policy**, set this parameter to **true**.
        """
        return pulumi.get(self, "route_group_enable")

    @route_group_enable.setter
    def route_group_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "route_group_enable", value)

    @_builtins.property
    @pulumi.getter(name="routeGroupRule")
    def route_group_rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the grouping rule name.
        It's required if `route_group_enable` is **true**.
        """
        return pulumi.get(self, "route_group_rule")

    @route_group_rule.setter
    def route_group_rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "route_group_rule", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgsDict(TypedDict):
        alarm_rule_name: pulumi.Input[_builtins.str]
        """
        Specifies the alarm rule name.
        """
        alarm_rule_type: pulumi.Input[_builtins.str]
        """
        Specifies the alarm rule type.
        Valid values are as follows:
        + **metric**: metric alarm rule
        + **event**: event alarm rule
        """
        alarm_rule_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm rule description.
        """
        event_alarm_spec: NotRequired[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgsDict']]
        """
        Specifies the event alarm spec.
        The event_alarm_spec structure is documented
        below.
        """
        metric_alarm_spec: NotRequired[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgsDict']]
        """
        Specifies the metric alarm spec.
        The metric_alarm_spec structure is
        documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--event_alarm_spec"></a>
        The `event_alarm_spec` block supports:
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemArgs:
    def __init__(__self__, *,
                 alarm_rule_name: pulumi.Input[_builtins.str],
                 alarm_rule_type: pulumi.Input[_builtins.str],
                 alarm_rule_description: Optional[pulumi.Input[_builtins.str]] = None,
                 event_alarm_spec: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs']] = None,
                 metric_alarm_spec: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] alarm_rule_name: Specifies the alarm rule name.
        :param pulumi.Input[_builtins.str] alarm_rule_type: Specifies the alarm rule type.
               Valid values are as follows:
               + **metric**: metric alarm rule
               + **event**: event alarm rule
        :param pulumi.Input[_builtins.str] alarm_rule_description: Specifies the alarm rule description.
        :param pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs'] event_alarm_spec: Specifies the event alarm spec.
               The event_alarm_spec structure is documented
               below.
        :param pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs'] metric_alarm_spec: Specifies the metric alarm spec.
               The metric_alarm_spec structure is
               documented below.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--event_alarm_spec"></a>
               The `event_alarm_spec` block supports:
        """
        pulumi.set(__self__, "alarm_rule_name", alarm_rule_name)
        pulumi.set(__self__, "alarm_rule_type", alarm_rule_type)
        if alarm_rule_description is not None:
            pulumi.set(__self__, "alarm_rule_description", alarm_rule_description)
        if event_alarm_spec is not None:
            pulumi.set(__self__, "event_alarm_spec", event_alarm_spec)
        if metric_alarm_spec is not None:
            pulumi.set(__self__, "metric_alarm_spec", metric_alarm_spec)

    @_builtins.property
    @pulumi.getter(name="alarmRuleName")
    def alarm_rule_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the alarm rule name.
        """
        return pulumi.get(self, "alarm_rule_name")

    @alarm_rule_name.setter
    def alarm_rule_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm_rule_name", value)

    @_builtins.property
    @pulumi.getter(name="alarmRuleType")
    def alarm_rule_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the alarm rule type.
        Valid values are as follows:
        + **metric**: metric alarm rule
        + **event**: event alarm rule
        """
        return pulumi.get(self, "alarm_rule_type")

    @alarm_rule_type.setter
    def alarm_rule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "alarm_rule_type", value)

    @_builtins.property
    @pulumi.getter(name="alarmRuleDescription")
    def alarm_rule_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm rule description.
        """
        return pulumi.get(self, "alarm_rule_description")

    @alarm_rule_description.setter
    def alarm_rule_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_rule_description", value)

    @_builtins.property
    @pulumi.getter(name="eventAlarmSpec")
    def event_alarm_spec(self) -> Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs']]:
        """
        Specifies the event alarm spec.
        The event_alarm_spec structure is documented
        below.
        """
        return pulumi.get(self, "event_alarm_spec")

    @event_alarm_spec.setter
    def event_alarm_spec(self, value: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs']]):
        pulumi.set(self, "event_alarm_spec", value)

    @_builtins.property
    @pulumi.getter(name="metricAlarmSpec")
    def metric_alarm_spec(self) -> Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs']]:
        """
        Specifies the metric alarm spec.
        The metric_alarm_spec structure is
        documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--event_alarm_spec"></a>
        The `event_alarm_spec` block supports:
        """
        return pulumi.get(self, "metric_alarm_spec")

    @metric_alarm_spec.setter
    def metric_alarm_spec(self, value: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs']]):
        pulumi.set(self, "metric_alarm_spec", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgsDict(TypedDict):
        alarm_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm source.
        """
        alarm_subtype: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm subtype.
        """
        event_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm source.
        """
        monitor_object_templates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the monitor object templates.
        """
        monitor_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        Specifies the monitored objects. It's an array of map objects.
        Key-value pair, key can be as follows:
        + **event_type**: notification type
        + **event_severity**: alarm severity
        + **event_name**: event name
        + **namespace**: namespace
        + **clusterId**: cluster ID
        + **customField**: user-defined field
        """
        trigger_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgsDict']]]]
        """
        Specifies the trigger conditions.
        The trigger_conditions
        structure is documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
        The `trigger_conditions` block supports:
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecArgs:
    def __init__(__self__, *,
                 alarm_source: Optional[pulumi.Input[_builtins.str]] = None,
                 alarm_subtype: Optional[pulumi.Input[_builtins.str]] = None,
                 event_source: Optional[pulumi.Input[_builtins.str]] = None,
                 monitor_object_templates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 monitor_objects: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 trigger_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] alarm_source: Specifies the alarm source.
        :param pulumi.Input[_builtins.str] alarm_subtype: Specifies the alarm subtype.
        :param pulumi.Input[_builtins.str] event_source: Specifies the alarm source.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] monitor_object_templates: Specifies the monitor object templates.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] monitor_objects: Specifies the monitored objects. It's an array of map objects.
               Key-value pair, key can be as follows:
               + **event_type**: notification type
               + **event_severity**: alarm severity
               + **event_name**: event name
               + **namespace**: namespace
               + **clusterId**: cluster ID
               + **customField**: user-defined field
        :param pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs']]] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions
               structure is documented below.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
               The `trigger_conditions` block supports:
        """
        if alarm_source is not None:
            pulumi.set(__self__, "alarm_source", alarm_source)
        if alarm_subtype is not None:
            pulumi.set(__self__, "alarm_subtype", alarm_subtype)
        if event_source is not None:
            pulumi.set(__self__, "event_source", event_source)
        if monitor_object_templates is not None:
            pulumi.set(__self__, "monitor_object_templates", monitor_object_templates)
        if monitor_objects is not None:
            pulumi.set(__self__, "monitor_objects", monitor_objects)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm source.
        """
        return pulumi.get(self, "alarm_source")

    @alarm_source.setter
    def alarm_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_source", value)

    @_builtins.property
    @pulumi.getter(name="alarmSubtype")
    def alarm_subtype(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm subtype.
        """
        return pulumi.get(self, "alarm_subtype")

    @alarm_subtype.setter
    def alarm_subtype(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_subtype", value)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm source.
        """
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_source", value)

    @_builtins.property
    @pulumi.getter(name="monitorObjectTemplates")
    def monitor_object_templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the monitor object templates.
        """
        return pulumi.get(self, "monitor_object_templates")

    @monitor_object_templates.setter
    def monitor_object_templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "monitor_object_templates", value)

    @_builtins.property
    @pulumi.getter(name="monitorObjects")
    def monitor_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        Specifies the monitored objects. It's an array of map objects.
        Key-value pair, key can be as follows:
        + **event_type**: notification type
        + **event_severity**: alarm severity
        + **event_name**: event name
        + **namespace**: namespace
        + **clusterId**: cluster ID
        + **customField**: user-defined field
        """
        return pulumi.get(self, "monitor_objects")

    @monitor_objects.setter
    def monitor_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "monitor_objects", value)

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs']]]]:
        """
        Specifies the trigger conditions.
        The trigger_conditions
        structure is documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "trigger_conditions")

    @trigger_conditions.setter
    def trigger_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs']]]]):
        pulumi.set(self, "trigger_conditions", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgsDict(TypedDict):
        trigger_type: pulumi.Input[_builtins.str]
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        aggregation_window: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        event_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event name.
        """
        frequency: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event alarm notification frequency. Leave this parameter empty if
        `trigger_type` is set to **immediately**. Valid values are as follows:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        thresholds: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemEventAlarmSpecTriggerConditionArgs:
    def __init__(__self__, *,
                 trigger_type: pulumi.Input[_builtins.str],
                 aggregation_window: Optional[pulumi.Input[_builtins.int]] = None,
                 event_name: Optional[pulumi.Input[_builtins.str]] = None,
                 frequency: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 thresholds: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.str] trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        :param pulumi.Input[_builtins.int] aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param pulumi.Input[_builtins.str] event_name: Specifies the event name.
        :param pulumi.Input[_builtins.str] frequency: Specifies the event alarm notification frequency. Leave this parameter empty if
               `trigger_type` is set to **immediately**. Valid values are as follows:
               + **0**: alarm sent only once
               + **300**: every 5 minutes
               + **600**: every 10 minutes
               + **900**: every 15 minutes
               + **1800**: every 30 minutes
               + **3600**: every hour
               + **10800**: every 3 hours
               + **21600**: every 6 hours
               + **43200**: every 12 hours
               + **86400**: every day
        :param pulumi.Input[_builtins.str] operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        """
        pulumi.set(__self__, "trigger_type", trigger_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if event_name is not None:
            pulumi.set(__self__, "event_name", event_name)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "trigger_type", value)

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @aggregation_window.setter
    def aggregation_window(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "aggregation_window", value)

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event name.
        """
        return pulumi.get(self, "event_name")

    @event_name.setter
    def event_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_name", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event alarm notification frequency. Leave this parameter empty if
        `trigger_type` is set to **immediately**. Valid values are as follows:
        + **0**: alarm sent only once
        + **300**: every 5 minutes
        + **600**: every 10 minutes
        + **900**: every 15 minutes
        + **1800**: every 30 minutes
        + **3600**: every hour
        + **10800**: every 3 hours
        + **21600**: every 6 hours
        + **43200**: every 12 hours
        + **86400**: every day
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "thresholds", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgsDict(TypedDict):
        alarm_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm source.
        """
        alarm_subtype: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alarm subtype.
        """
        alarm_tags: NotRequired[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgsDict']]
        """
        Specifies the alarm tags.
        The alarm_tags structure
        is documented below.
        """
        monitor_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the monitor type.
        """
        no_data_conditions: NotRequired[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgsDict']]
        """
        Specifies the no data conditions.
        The no_data_conditions
        structure is documented below.
        """
        recovery_conditions: NotRequired[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgsDict']]
        """
        Specifies the recovery conditions.
        The recovery_conditions
        structure is documented below.
        """
        trigger_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgsDict']]]]
        """
        Specifies the trigger conditions.
        The trigger_conditions
        structure is documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
        The `trigger_conditions` block supports:
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecArgs:
    def __init__(__self__, *,
                 alarm_source: Optional[pulumi.Input[_builtins.str]] = None,
                 alarm_subtype: Optional[pulumi.Input[_builtins.str]] = None,
                 alarm_tags: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgs']] = None,
                 monitor_type: Optional[pulumi.Input[_builtins.str]] = None,
                 no_data_conditions: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgs']] = None,
                 recovery_conditions: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgs']] = None,
                 trigger_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] alarm_source: Specifies the alarm source.
        :param pulumi.Input[_builtins.str] alarm_subtype: Specifies the alarm subtype.
        :param pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgs'] alarm_tags: Specifies the alarm tags.
               The alarm_tags structure
               is documented below.
        :param pulumi.Input[_builtins.str] monitor_type: Specifies the monitor type.
        :param pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgs'] no_data_conditions: Specifies the no data conditions.
               The no_data_conditions
               structure is documented below.
        :param pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgs'] recovery_conditions: Specifies the recovery conditions.
               The recovery_conditions
               structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs']]] trigger_conditions: Specifies the trigger conditions.
               The trigger_conditions
               structure is documented below.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
               The `trigger_conditions` block supports:
        """
        if alarm_source is not None:
            pulumi.set(__self__, "alarm_source", alarm_source)
        if alarm_subtype is not None:
            pulumi.set(__self__, "alarm_subtype", alarm_subtype)
        if alarm_tags is not None:
            pulumi.set(__self__, "alarm_tags", alarm_tags)
        if monitor_type is not None:
            pulumi.set(__self__, "monitor_type", monitor_type)
        if no_data_conditions is not None:
            pulumi.set(__self__, "no_data_conditions", no_data_conditions)
        if recovery_conditions is not None:
            pulumi.set(__self__, "recovery_conditions", recovery_conditions)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="alarmSource")
    def alarm_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm source.
        """
        return pulumi.get(self, "alarm_source")

    @alarm_source.setter
    def alarm_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_source", value)

    @_builtins.property
    @pulumi.getter(name="alarmSubtype")
    def alarm_subtype(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alarm subtype.
        """
        return pulumi.get(self, "alarm_subtype")

    @alarm_subtype.setter
    def alarm_subtype(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alarm_subtype", value)

    @_builtins.property
    @pulumi.getter(name="alarmTags")
    def alarm_tags(self) -> Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgs']]:
        """
        Specifies the alarm tags.
        The alarm_tags structure
        is documented below.
        """
        return pulumi.get(self, "alarm_tags")

    @alarm_tags.setter
    def alarm_tags(self, value: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgs']]):
        pulumi.set(self, "alarm_tags", value)

    @_builtins.property
    @pulumi.getter(name="monitorType")
    def monitor_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the monitor type.
        """
        return pulumi.get(self, "monitor_type")

    @monitor_type.setter
    def monitor_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "monitor_type", value)

    @_builtins.property
    @pulumi.getter(name="noDataConditions")
    def no_data_conditions(self) -> Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgs']]:
        """
        Specifies the no data conditions.
        The no_data_conditions
        structure is documented below.
        """
        return pulumi.get(self, "no_data_conditions")

    @no_data_conditions.setter
    def no_data_conditions(self, value: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgs']]):
        pulumi.set(self, "no_data_conditions", value)

    @_builtins.property
    @pulumi.getter(name="recoveryConditions")
    def recovery_conditions(self) -> Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgs']]:
        """
        Specifies the recovery conditions.
        The recovery_conditions
        structure is documented below.
        """
        return pulumi.get(self, "recovery_conditions")

    @recovery_conditions.setter
    def recovery_conditions(self, value: Optional[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgs']]):
        pulumi.set(self, "recovery_conditions", value)

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs']]]]:
        """
        Specifies the trigger conditions.
        The trigger_conditions
        structure is documented below.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--alarm_tags"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "trigger_conditions")

    @trigger_conditions.setter
    def trigger_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs']]]]):
        pulumi.set(self, "trigger_conditions", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgsDict(TypedDict):
        auto_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the automatic tag.
        """
        custom_annotations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the custom tag.
        """
        custom_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the alarm annotation.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--no_data_conditions"></a>
        The `trigger_conditions` block supports:
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecAlarmTagsArgs:
    def __init__(__self__, *,
                 auto_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_annotations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] auto_tags: Specifies the automatic tag.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_annotations: Specifies the custom tag.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] custom_tags: Specifies the alarm annotation.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--no_data_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if auto_tags is not None:
            pulumi.set(__self__, "auto_tags", auto_tags)
        if custom_annotations is not None:
            pulumi.set(__self__, "custom_annotations", custom_annotations)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="autoTags")
    def auto_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the automatic tag.
        """
        return pulumi.get(self, "auto_tags")

    @auto_tags.setter
    def auto_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "auto_tags", value)

    @_builtins.property
    @pulumi.getter(name="customAnnotations")
    def custom_annotations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the custom tag.
        """
        return pulumi.get(self, "custom_annotations")

    @custom_annotations.setter
    def custom_annotations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_annotations", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the alarm annotation.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--no_data_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgsDict(TypedDict):
        no_data_alert_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the status of the threshold rule when the data is insufficient.
        Valid values are as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        no_data_timeframe: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of periods without data.
        """
        notify_no_data: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to send a notification when data is insufficient.
        Defaults to **false**.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--recovery_conditions"></a>
        The `trigger_conditions` block supports:
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecNoDataConditionsArgs:
    def __init__(__self__, *,
                 no_data_alert_state: Optional[pulumi.Input[_builtins.str]] = None,
                 no_data_timeframe: Optional[pulumi.Input[_builtins.int]] = None,
                 notify_no_data: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] no_data_alert_state: Specifies the status of the threshold rule when the data is insufficient.
               Valid values are as follows:
               + **no_data**: A notification indicating insufficient data is sent.
               + **alerting**: An alarm is triggered.
               + **ok**: No exception occurs.
               + **pre_state**: Retain the previous state.
        :param pulumi.Input[_builtins.int] no_data_timeframe: Specifies the number of periods without data.
        :param pulumi.Input[_builtins.bool] notify_no_data: Specifies whether to send a notification when data is insufficient.
               Defaults to **false**.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--recovery_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if no_data_alert_state is not None:
            pulumi.set(__self__, "no_data_alert_state", no_data_alert_state)
        if no_data_timeframe is not None:
            pulumi.set(__self__, "no_data_timeframe", no_data_timeframe)
        if notify_no_data is not None:
            pulumi.set(__self__, "notify_no_data", notify_no_data)

    @_builtins.property
    @pulumi.getter(name="noDataAlertState")
    def no_data_alert_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the status of the threshold rule when the data is insufficient.
        Valid values are as follows:
        + **no_data**: A notification indicating insufficient data is sent.
        + **alerting**: An alarm is triggered.
        + **ok**: No exception occurs.
        + **pre_state**: Retain the previous state.
        """
        return pulumi.get(self, "no_data_alert_state")

    @no_data_alert_state.setter
    def no_data_alert_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_data_alert_state", value)

    @_builtins.property
    @pulumi.getter(name="noDataTimeframe")
    def no_data_timeframe(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of periods without data.
        """
        return pulumi.get(self, "no_data_timeframe")

    @no_data_timeframe.setter
    def no_data_timeframe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "no_data_timeframe", value)

    @_builtins.property
    @pulumi.getter(name="notifyNoData")
    def notify_no_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to send a notification when data is insufficient.
        Defaults to **false**.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--recovery_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "notify_no_data")

    @notify_no_data.setter
    def notify_no_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "notify_no_data", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgsDict(TypedDict):
        recovery_timeframe: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of consecutive periods for which the trigger condition is
        not met to clear an alarm.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--trigger_conditions"></a>
        The `trigger_conditions` block supports:
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecRecoveryConditionsArgs:
    def __init__(__self__, *,
                 recovery_timeframe: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] recovery_timeframe: Specifies the number of consecutive periods for which the trigger condition is
               not met to clear an alarm.
               
               <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--trigger_conditions"></a>
               The `trigger_conditions` block supports:
        """
        if recovery_timeframe is not None:
            pulumi.set(__self__, "recovery_timeframe", recovery_timeframe)

    @_builtins.property
    @pulumi.getter(name="recoveryTimeframe")
    def recovery_timeframe(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of consecutive periods for which the trigger condition is
        not met to clear an alarm.

        <a name="alarm_template_spec_list--alarm_template_spec_items--metric_alarm_spec--trigger_conditions"></a>
        The `trigger_conditions` block supports:
        """
        return pulumi.get(self, "recovery_timeframe")

    @recovery_timeframe.setter
    def recovery_timeframe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recovery_timeframe", value)


if not MYPY:
    class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgsDict(TypedDict):
        metric_query_mode: pulumi.Input[_builtins.str]
        """
        Specifies the metric query mode.
        Valid values are as follows:
        + **AOM**: native AOM
        + **PROM**: AOM prometheus
        + **NATIVE_PROM**: native prometheus
        """
        aggregate_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the aggregation mode.
        Valid values are **by**, **avg**, **max**, **min** and **sum**.
        """
        aggregation_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the statistical mode.
        Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        aggregation_window: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        aom_monitor_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the monitoring layer.
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the expression of a combined operation.
        """
        metric_labels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the metric dimension.
        """
        metric_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric name.
        """
        metric_namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric namespace.
        """
        metric_statistic_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric statistics method to be used when you set
        Configuration Mode to Select from all metrics during alarm rule setting.
        Valid values are as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        metric_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the metric unit.
        """
        mix_promql: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the promQL of a combined operation.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        promql: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prometheus statement.
        """
        promql_exprs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the prometheus statement template.
        """
        promql_for: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the native prometheus monitoring duration.
        """
        query_match: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the query filter criteria.
        """
        thresholds: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        trigger_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the check interval.
        Valid values are as follows:
        + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
        + If `trigger_type` is set to **DAILY**, set 00:00–23:00. Example: **03:00**.
        + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:00–23:00.
        Example: **1 03:00** indicates 03:00 on every Monday.
        + If `trigger_type` is set to **CRON**, specify a standard cron expression.
        + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 1–59 min, or 1–24 h.
        Example: **15s**, **30s**, **1min**, or **1h**.
        """
        trigger_times: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of consecutive periods.

        <a name="templating"></a>
        The `templating` block supports:
        """
        trigger_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
elif False:
    AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateAlarmTemplateSpecListAlarmTemplateSpecItemMetricAlarmSpecTriggerConditionArgs:
    def __init__(__self__, *,
                 metric_query_mode: pulumi.Input[_builtins.str],
                 aggregate_type: Optional[pulumi.Input[_builtins.str]] = None,
                 aggregation_type: Optional[pulumi.Input[_builtins.str]] = None,
                 aggregation_window: Optional[pulumi.Input[_builtins.str]] = None,
                 aom_monitor_level: Optional[pulumi.Input[_builtins.str]] = None,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_labels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 metric_name: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_statistic_method: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 mix_promql: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 promql: Optional[pulumi.Input[_builtins.str]] = None,
                 promql_exprs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 promql_for: Optional[pulumi.Input[_builtins.str]] = None,
                 query_match: Optional[pulumi.Input[_builtins.str]] = None,
                 thresholds: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 trigger_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_times: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metric_query_mode: Specifies the metric query mode.
               Valid values are as follows:
               + **AOM**: native AOM
               + **PROM**: AOM prometheus
               + **NATIVE_PROM**: native prometheus
        :param pulumi.Input[_builtins.str] aggregate_type: Specifies the aggregation mode.
               Valid values are **by**, **avg**, **max**, **min** and **sum**.
        :param pulumi.Input[_builtins.str] aggregation_type: Specifies the statistical mode.
               Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        :param pulumi.Input[_builtins.str] aggregation_window: Specifies the statistical period.
               Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        :param pulumi.Input[_builtins.str] aom_monitor_level: Specifies the monitoring layer.
        :param pulumi.Input[_builtins.str] expression: Specifies the expression of a combined operation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metric_labels: Specifies the metric dimension.
        :param pulumi.Input[_builtins.str] metric_name: Specifies the metric name.
        :param pulumi.Input[_builtins.str] metric_namespace: Specifies the metric namespace.
        :param pulumi.Input[_builtins.str] metric_statistic_method: Specifies the metric statistics method to be used when you set
               Configuration Mode to Select from all metrics during alarm rule setting.
               Valid values are as follows:
               + **single**: single metric
               + **mix**: multi-metric combined operations
        :param pulumi.Input[_builtins.str] metric_unit: Specifies the metric unit.
        :param pulumi.Input[_builtins.str] mix_promql: Specifies the promQL of a combined operation.
        :param pulumi.Input[_builtins.str] operator: Specifies the operator. Options: >, <, =, >=, and <=.
        :param pulumi.Input[_builtins.str] promql: Specifies the prometheus statement.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] promql_exprs: Specifies the prometheus statement template.
        :param pulumi.Input[_builtins.str] promql_for: Specifies the native prometheus monitoring duration.
        :param pulumi.Input[_builtins.str] query_match: Specifies the query filter criteria.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] thresholds: Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
               the value indicates the alarm threshold.
        :param pulumi.Input[_builtins.str] trigger_interval: Specifies the check interval.
               Valid values are as follows:
               + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
               + If `trigger_type` is set to **DAILY**, set 00:00–23:00. Example: **03:00**.
               + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:00–23:00.
               Example: **1 03:00** indicates 03:00 on every Monday.
               + If `trigger_type` is set to **CRON**, specify a standard cron expression.
               + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 1–59 min, or 1–24 h.
               Example: **15s**, **30s**, **1min**, or **1h**.
        :param pulumi.Input[_builtins.str] trigger_times: Specifies the number of consecutive periods.
               
               <a name="templating"></a>
               The `templating` block supports:
        :param pulumi.Input[_builtins.str] trigger_type: Specifies the trigger type.
               Valid values are as follows:
               + **FIXED_RATE**: fixed interval
               + **HOURLY**: every hour
               + **DAILY**: every day
               + **WEEKLY**: every week
               + **CRON**: Cron expression
        """
        pulumi.set(__self__, "metric_query_mode", metric_query_mode)
        if aggregate_type is not None:
            pulumi.set(__self__, "aggregate_type", aggregate_type)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if aggregation_window is not None:
            pulumi.set(__self__, "aggregation_window", aggregation_window)
        if aom_monitor_level is not None:
            pulumi.set(__self__, "aom_monitor_level", aom_monitor_level)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if metric_labels is not None:
            pulumi.set(__self__, "metric_labels", metric_labels)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if metric_statistic_method is not None:
            pulumi.set(__self__, "metric_statistic_method", metric_statistic_method)
        if metric_unit is not None:
            pulumi.set(__self__, "metric_unit", metric_unit)
        if mix_promql is not None:
            pulumi.set(__self__, "mix_promql", mix_promql)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if promql is not None:
            pulumi.set(__self__, "promql", promql)
        if promql_exprs is not None:
            pulumi.set(__self__, "promql_exprs", promql_exprs)
        if promql_for is not None:
            pulumi.set(__self__, "promql_for", promql_for)
        if query_match is not None:
            pulumi.set(__self__, "query_match", query_match)
        if thresholds is not None:
            pulumi.set(__self__, "thresholds", thresholds)
        if trigger_interval is not None:
            pulumi.set(__self__, "trigger_interval", trigger_interval)
        if trigger_times is not None:
            pulumi.set(__self__, "trigger_times", trigger_times)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="metricQueryMode")
    def metric_query_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the metric query mode.
        Valid values are as follows:
        + **AOM**: native AOM
        + **PROM**: AOM prometheus
        + **NATIVE_PROM**: native prometheus
        """
        return pulumi.get(self, "metric_query_mode")

    @metric_query_mode.setter
    def metric_query_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_query_mode", value)

    @_builtins.property
    @pulumi.getter(name="aggregateType")
    def aggregate_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the aggregation mode.
        Valid values are **by**, **avg**, **max**, **min** and **sum**.
        """
        return pulumi.get(self, "aggregate_type")

    @aggregate_type.setter
    def aggregate_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregate_type", value)

    @_builtins.property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the statistical mode.
        Valid values are **average**, **minimum**, **maximum**, **sum** and **sampleCount**.
        """
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregation_type", value)

    @_builtins.property
    @pulumi.getter(name="aggregationWindow")
    def aggregation_window(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the statistical period.
        Valid values are **15s**, **30s**, **1m**, **5m**, **15m** and **1h**.
        """
        return pulumi.get(self, "aggregation_window")

    @aggregation_window.setter
    def aggregation_window(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aggregation_window", value)

    @_builtins.property
    @pulumi.getter(name="aomMonitorLevel")
    def aom_monitor_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the monitoring layer.
        """
        return pulumi.get(self, "aom_monitor_level")

    @aom_monitor_level.setter
    def aom_monitor_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aom_monitor_level", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the expression of a combined operation.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="metricLabels")
    def metric_labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the metric dimension.
        """
        return pulumi.get(self, "metric_labels")

    @metric_labels.setter
    def metric_labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metric_labels", value)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric namespace.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricStatisticMethod")
    def metric_statistic_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric statistics method to be used when you set
        Configuration Mode to Select from all metrics during alarm rule setting.
        Valid values are as follows:
        + **single**: single metric
        + **mix**: multi-metric combined operations
        """
        return pulumi.get(self, "metric_statistic_method")

    @metric_statistic_method.setter
    def metric_statistic_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_statistic_method", value)

    @_builtins.property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the metric unit.
        """
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_unit", value)

    @_builtins.property
    @pulumi.getter(name="mixPromql")
    def mix_promql(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the promQL of a combined operation.
        """
        return pulumi.get(self, "mix_promql")

    @mix_promql.setter
    def mix_promql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mix_promql", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operator. Options: >, <, =, >=, and <=.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def promql(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prometheus statement.
        """
        return pulumi.get(self, "promql")

    @promql.setter
    def promql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "promql", value)

    @_builtins.property
    @pulumi.getter(name="promqlExprs")
    def promql_exprs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the prometheus statement template.
        """
        return pulumi.get(self, "promql_exprs")

    @promql_exprs.setter
    def promql_exprs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "promql_exprs", value)

    @_builtins.property
    @pulumi.getter(name="promqlFor")
    def promql_for(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the native prometheus monitoring duration.
        """
        return pulumi.get(self, "promql_for")

    @promql_for.setter
    def promql_for(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "promql_for", value)

    @_builtins.property
    @pulumi.getter(name="queryMatch")
    def query_match(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the query filter criteria.
        """
        return pulumi.get(self, "query_match")

    @query_match.setter
    def query_match(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_match", value)

    @_builtins.property
    @pulumi.getter
    def thresholds(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the thresholds. Key-value pair. The key indicates the alarm severity while
        the value indicates the alarm threshold.
        """
        return pulumi.get(self, "thresholds")

    @thresholds.setter
    def thresholds(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "thresholds", value)

    @_builtins.property
    @pulumi.getter(name="triggerInterval")
    def trigger_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the check interval.
        Valid values are as follows:
        + If `trigger_type` is set to **HOURLY**, set this parameter to empty.
        + If `trigger_type` is set to **DAILY**, set 00:00–23:00. Example: **03:00**.
        + If `trigger_type` is set to **WEEKLY**, select a day in a week and then select 00:00–23:00.
        Example: **1 03:00** indicates 03:00 on every Monday.
        + If `trigger_type` is set to **CRON**, specify a standard cron expression.
        + If `trigger_type` is set to **FIXED_RATE**, select 15s, 30s, 1–59 min, or 1–24 h.
        Example: **15s**, **30s**, **1min**, or **1h**.
        """
        return pulumi.get(self, "trigger_interval")

    @trigger_interval.setter
    def trigger_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_interval", value)

    @_builtins.property
    @pulumi.getter(name="triggerTimes")
    def trigger_times(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of consecutive periods.

        <a name="templating"></a>
        The `templating` block supports:
        """
        return pulumi.get(self, "trigger_times")

    @trigger_times.setter
    def trigger_times(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_times", value)

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the trigger type.
        Valid values are as follows:
        + **FIXED_RATE**: fixed interval
        + **HOURLY**: every hour
        + **DAILY**: every day
        + **WEEKLY**: every week
        + **CRON**: Cron expression
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_type", value)


if not MYPY:
    class AlarmRulesTemplateTemplatingArgsDict(TypedDict):
        lists: pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateTemplatingListArgsDict']]]
        """
        Specifies the
        The list structure is documented below.

        <a name="templating--list"></a>
        The `list` block supports:
        """
elif False:
    AlarmRulesTemplateTemplatingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateTemplatingArgs:
    def __init__(__self__, *,
                 lists: pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateTemplatingListArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateTemplatingListArgs']]] lists: Specifies the
               The list structure is documented below.
               
               <a name="templating--list"></a>
               The `list` block supports:
        """
        pulumi.set(__self__, "lists", lists)

    @_builtins.property
    @pulumi.getter
    def lists(self) -> pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateTemplatingListArgs']]]:
        """
        Specifies the
        The list structure is documented below.

        <a name="templating--list"></a>
        The `list` block supports:
        """
        return pulumi.get(self, "lists")

    @lists.setter
    def lists(self, value: pulumi.Input[Sequence[pulumi.Input['AlarmRulesTemplateTemplatingListArgs']]]):
        pulumi.set(self, "lists", value)


if not MYPY:
    class AlarmRulesTemplateTemplatingListArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description.
        """
        query: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the query.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type.
        """
elif False:
    AlarmRulesTemplateTemplatingListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmRulesTemplateTemplatingListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 query: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.str] description: Specifies the description.
        :param pulumi.Input[_builtins.str] query: Specifies the query.
        :param pulumi.Input[_builtins.str] type: Specifies the type.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the query.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AlarmSilenceRuleSilenceConditionArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['AlarmSilenceRuleSilenceConditionConditionArgsDict']]]
        """
        Specifies the serial conditions.
        A maximum of 10 conditions are allowed.
        The conditions structure is documented below.

        <a name="conditions"></a>
        The `conditions` block supports:
        """
elif False:
    AlarmSilenceRuleSilenceConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmSilenceRuleSilenceConditionArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['AlarmSilenceRuleSilenceConditionConditionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlarmSilenceRuleSilenceConditionConditionArgs']]] conditions: Specifies the serial conditions.
               A maximum of 10 conditions are allowed.
               The conditions structure is documented below.
               
               <a name="conditions"></a>
               The `conditions` block supports:
        """
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['AlarmSilenceRuleSilenceConditionConditionArgs']]]:
        """
        Specifies the serial conditions.
        A maximum of 10 conditions are allowed.
        The conditions structure is documented below.

        <a name="conditions"></a>
        The `conditions` block supports:
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['AlarmSilenceRuleSilenceConditionConditionArgs']]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class AlarmSilenceRuleSilenceConditionConditionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key of the match condition.
        """
        operate: pulumi.Input[_builtins.str]
        """
        Specifies the operate of the match condition.
        The value can be: **EQUALS**, **REGEX** and **EXIST**.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the value list of the match condition.
        A maximum of 5 values are allowed. This should be empty when the value of operate is *EXIST**.
        """
elif False:
    AlarmSilenceRuleSilenceConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmSilenceRuleSilenceConditionConditionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operate: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key of the match condition.
        :param pulumi.Input[_builtins.str] operate: Specifies the operate of the match condition.
               The value can be: **EQUALS**, **REGEX** and **EXIST**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Specifies the value list of the match condition.
               A maximum of 5 values are allowed. This should be empty when the value of operate is *EXIST**.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operate", operate)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key of the match condition.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operate(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the operate of the match condition.
        The value can be: **EQUALS**, **REGEX** and **EXIST**.
        """
        return pulumi.get(self, "operate")

    @operate.setter
    def operate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operate", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the value list of the match condition.
        A maximum of 5 values are allowed. This should be empty when the value of operate is *EXIST**.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AlarmSilenceRuleSilenceTimeArgsDict(TypedDict):
        starts_at: pulumi.Input[_builtins.int]
        """
        Specifies the start time of the silence rule.
        When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
        which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
        or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the effective time type of the silence rule.
        The value can be: **FIXED**, **DAILY**, **WEEKLY** and **MONTHLY**.
        """
        ends_at: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the end time of the silence rule.
        When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
        which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
        or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Specifies the silence time of the rule.
        It's required when the type is **WEEKLY** or **MONTHLY**.

        <a name="silence_conditions"></a>
        The `silence_conditions` block supports:
        """
elif False:
    AlarmSilenceRuleSilenceTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlarmSilenceRuleSilenceTimeArgs:
    def __init__(__self__, *,
                 starts_at: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 ends_at: Optional[pulumi.Input[_builtins.int]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.int] starts_at: Specifies the start time of the silence rule.
               When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
               which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
               or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        :param pulumi.Input[_builtins.str] type: Specifies the effective time type of the silence rule.
               The value can be: **FIXED**, **DAILY**, **WEEKLY** and **MONTHLY**.
        :param pulumi.Input[_builtins.int] ends_at: Specifies the end time of the silence rule.
               When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
               which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
               or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] scopes: Specifies the silence time of the rule.
               It's required when the type is **WEEKLY** or **MONTHLY**.
               
               <a name="silence_conditions"></a>
               The `silence_conditions` block supports:
        """
        pulumi.set(__self__, "starts_at", starts_at)
        pulumi.set(__self__, "type", type)
        if ends_at is not None:
            pulumi.set(__self__, "ends_at", ends_at)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter(name="startsAt")
    def starts_at(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the start time of the silence rule.
        When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
        which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
        or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        """
        return pulumi.get(self, "starts_at")

    @starts_at.setter
    def starts_at(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "starts_at", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the effective time type of the silence rule.
        The value can be: **FIXED**, **DAILY**, **WEEKLY** and **MONTHLY**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="endsAt")
    def ends_at(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the end time of the silence rule.
        When the `type` is **FIXED**, the value is a time stamp, e.g. **1684466549755**,
        which indicates **2023-05-19 11:22:29.755**. When the `type` is **DAILY**, **WEEKLY**
        or **MONTHLY**, the value range is `0` to `86,399`, which indicates **00:00:00** to **23:59:59**.
        """
        return pulumi.get(self, "ends_at")

    @ends_at.setter
    def ends_at(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ends_at", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Specifies the silence time of the rule.
        It's required when the type is **WEEKLY** or **MONTHLY**.

        <a name="silence_conditions"></a>
        The `silence_conditions` block supports:
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class EnvironmentEnvTagArgsDict(TypedDict):
        tag_id: NotRequired[pulumi.Input[_builtins.str]]
        tag_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EnvironmentEnvTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentEnvTagArgs:
    def __init__(__self__, *,
                 tag_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_name: Optional[pulumi.Input[_builtins.str]] = None):
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @_builtins.property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_id", value)

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag_name", value)


if not MYPY:
    class MessageTemplateTemplateArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        Specifies the content of the template.
        """
        sub_type: pulumi.Input[_builtins.str]
        """
        Specifies the subscription type of the template.
        Valid value are **email**, **sms**, **wechat**, **dingding**, **webhook**, **voice**, **espace**, **feishu**, **welink**.
        """
        topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the topic of the template.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the version of the template.
        """
elif False:
    MessageTemplateTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MessageTemplateTemplateArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 sub_type: pulumi.Input[_builtins.str],
                 topic: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: Specifies the content of the template.
        :param pulumi.Input[_builtins.str] sub_type: Specifies the subscription type of the template.
               Valid value are **email**, **sms**, **wechat**, **dingding**, **webhook**, **voice**, **espace**, **feishu**, **welink**.
        :param pulumi.Input[_builtins.str] topic: Specifies the topic of the template.
        :param pulumi.Input[_builtins.str] version: Specifies the version of the template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "sub_type", sub_type)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the content of the template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the subscription type of the template.
        Valid value are **email**, **sms**, **wechat**, **dingding**, **webhook**, **voice**, **espace**, **feishu**, **welink**.
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sub_type", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the topic of the template.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the version of the template.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MultiAccountAggregationRuleAccountArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the account ID.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the account name.
        """
        join_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the method how the account joined in the organization.
        """
        joined_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time when the account joined in the organization.

        <a name="services_struct"></a>
        The `services` block supports:
        """
        urn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the uniform resource name of the account.
        """
elif False:
    MultiAccountAggregationRuleAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiAccountAggregationRuleAccountArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 join_method: Optional[pulumi.Input[_builtins.str]] = None,
                 joined_at: Optional[pulumi.Input[_builtins.str]] = None,
                 urn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the account ID.
        :param pulumi.Input[_builtins.str] name: Specifies the account name.
        :param pulumi.Input[_builtins.str] join_method: Specifies the method how the account joined in the organization.
        :param pulumi.Input[_builtins.str] joined_at: Specifies the time when the account joined in the organization.
               
               <a name="services_struct"></a>
               The `services` block supports:
        :param pulumi.Input[_builtins.str] urn: Specifies the uniform resource name of the account.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        if join_method is not None:
            pulumi.set(__self__, "join_method", join_method)
        if joined_at is not None:
            pulumi.set(__self__, "joined_at", joined_at)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the account ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the account name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="joinMethod")
    def join_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the method how the account joined in the organization.
        """
        return pulumi.get(self, "join_method")

    @join_method.setter
    def join_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "join_method", value)

    @_builtins.property
    @pulumi.getter(name="joinedAt")
    def joined_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time when the account joined in the organization.

        <a name="services_struct"></a>
        The `services` block supports:
        """
        return pulumi.get(self, "joined_at")

    @joined_at.setter
    def joined_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "joined_at", value)

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the uniform resource name of the account.
        """
        return pulumi.get(self, "urn")

    @urn.setter
    def urn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "urn", value)


if not MYPY:
    class MultiAccountAggregationRuleServiceArgsDict(TypedDict):
        metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the metrics List.
        """
        service: pulumi.Input[_builtins.str]
        """
        Specifies the service name.
        """
elif False:
    MultiAccountAggregationRuleServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiAccountAggregationRuleServiceArgs:
    def __init__(__self__, *,
                 metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 service: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metrics: Specifies the metrics List.
        :param pulumi.Input[_builtins.str] service: Specifies the service name.
        """
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the metrics List.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the service name.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)


if not MYPY:
    class PrometheusInstancePromForCloudServiceArgsDict(TypedDict):
        ces_metric_namespaces: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PrometheusInstancePromForCloudServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusInstancePromForCloudServiceArgs:
    def __init__(__self__, *,
                 ces_metric_namespaces: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "ces_metric_namespaces", ces_metric_namespaces)

    @_builtins.property
    @pulumi.getter(name="cesMetricNamespaces")
    def ces_metric_namespaces(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "ces_metric_namespaces")

    @ces_metric_namespaces.setter
    def ces_metric_namespaces(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ces_metric_namespaces", value)


if not MYPY:
    class ServiceDiscoveryRuleDiscoveryRuleArgsDict(TypedDict):
        check_contents: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the matched value. This is a list of strings.
        """
        check_mode: pulumi.Input[_builtins.str]
        """
        Specifies the match condition. The values can be **contain** and **equals**.
        """
        check_type: pulumi.Input[_builtins.str]
        """
        Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
        """
elif False:
    ServiceDiscoveryRuleDiscoveryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDiscoveryRuleDiscoveryRuleArgs:
    def __init__(__self__, *,
                 check_contents: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 check_mode: pulumi.Input[_builtins.str],
                 check_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] check_contents: Specifies the matched value. This is a list of strings.
        :param pulumi.Input[_builtins.str] check_mode: Specifies the match condition. The values can be **contain** and **equals**.
        :param pulumi.Input[_builtins.str] check_type: Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
        """
        pulumi.set(__self__, "check_contents", check_contents)
        pulumi.set(__self__, "check_mode", check_mode)
        pulumi.set(__self__, "check_type", check_type)

    @_builtins.property
    @pulumi.getter(name="checkContents")
    def check_contents(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the matched value. This is a list of strings.
        """
        return pulumi.get(self, "check_contents")

    @check_contents.setter
    def check_contents(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "check_contents", value)

    @_builtins.property
    @pulumi.getter(name="checkMode")
    def check_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match condition. The values can be **contain** and **equals**.
        """
        return pulumi.get(self, "check_mode")

    @check_mode.setter
    def check_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "check_mode", value)

    @_builtins.property
    @pulumi.getter(name="checkType")
    def check_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the match type. The values can be **cmdLine**, **env** and **scope**.
        """
        return pulumi.get(self, "check_type")

    @check_type.setter
    def check_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "check_type", value)


if not MYPY:
    class ServiceDiscoveryRuleLogPathRuleArgsDict(TypedDict):
        args: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the command. This is a list of strings.
        """
        name_type: pulumi.Input[_builtins.str]
        """
        Specifies the value type, which can be **cmdLineHash**.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the log path. This is a list of strings.
        """
elif False:
    ServiceDiscoveryRuleLogPathRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDiscoveryRuleLogPathRuleArgs:
    def __init__(__self__, *,
                 args: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name_type: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Specifies the command. This is a list of strings.
        :param pulumi.Input[_builtins.str] name_type: Specifies the value type, which can be **cmdLineHash**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Specifies the log path. This is a list of strings.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the command. This is a list of strings.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value type, which can be **cmdLineHash**.
        """
        return pulumi.get(self, "name_type")

    @name_type.setter
    def name_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name_type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the log path. This is a list of strings.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ServiceDiscoveryRuleNameRulesArgsDict(TypedDict):
        application_name_rules: pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict']]]
        """
        Specifies the application name rule. If the value of `name_type` is
        **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
        the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"], indicating that
        the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the format of
        ["fix"], indicating that the application name is suffixed with fix. If the value of `name_type` is **cmdLineHash**,
        `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
        ser when the startup command is 0001. The object structure is documented below.

        <a name="basic_name_rule_object"></a>
        The `service_name_rule` block and `application_name_rule` block support:
        """
        service_name_rules: pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict']]]
        """
        Specifies the service name rule. If there are multiple objects in the array,
        the character strings extracted from these objects constitute the service name. If the value of `name_type` is
        **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
        in the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"],
        indicating that the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the
        format of ["fix"], indicating that the service name is suffixed with fix. If the value of `name_type` is
        **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
        service name is ser when the startup command is 0001. The object structure is
        documented below.
        """
elif False:
    ServiceDiscoveryRuleNameRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDiscoveryRuleNameRulesArgs:
    def __init__(__self__, *,
                 application_name_rules: pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesApplicationNameRuleArgs']]],
                 service_name_rules: pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesServiceNameRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesApplicationNameRuleArgs']]] application_name_rules: Specifies the application name rule. If the value of `name_type` is
               **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
               the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"], indicating that
               the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the format of
               ["fix"], indicating that the application name is suffixed with fix. If the value of `name_type` is **cmdLineHash**,
               `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
               ser when the startup command is 0001. The object structure is documented below.
               
               <a name="basic_name_rule_object"></a>
               The `service_name_rule` block and `application_name_rule` block support:
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesServiceNameRuleArgs']]] service_name_rules: Specifies the service name rule. If there are multiple objects in the array,
               the character strings extracted from these objects constitute the service name. If the value of `name_type` is
               **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
               in the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"],
               indicating that the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the
               format of ["fix"], indicating that the service name is suffixed with fix. If the value of `name_type` is
               **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
               service name is ser when the startup command is 0001. The object structure is
               documented below.
        """
        pulumi.set(__self__, "application_name_rules", application_name_rules)
        pulumi.set(__self__, "service_name_rules", service_name_rules)

    @_builtins.property
    @pulumi.getter(name="applicationNameRules")
    def application_name_rules(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesApplicationNameRuleArgs']]]:
        """
        Specifies the application name rule. If the value of `name_type` is
        **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end in
        the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"], indicating that
        the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the format of
        ["fix"], indicating that the application name is suffixed with fix. If the value of `name_type` is **cmdLineHash**,
        `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the application name is
        ser when the startup command is 0001. The object structure is documented below.

        <a name="basic_name_rule_object"></a>
        The `service_name_rule` block and `application_name_rule` block support:
        """
        return pulumi.get(self, "application_name_rules")

    @application_name_rules.setter
    def application_name_rules(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesApplicationNameRuleArgs']]]):
        pulumi.set(self, "application_name_rules", value)

    @_builtins.property
    @pulumi.getter(name="serviceNameRules")
    def service_name_rules(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesServiceNameRuleArgs']]]:
        """
        Specifies the service name rule. If there are multiple objects in the array,
        the character strings extracted from these objects constitute the service name. If the value of `name_type` is
        **cmdLine**, `args` is in the format of ["start", "end"], indicating that the characters between start and end
        in the command are extracted. If the value of `name_type` is **env**, `args` is in the format of ["aa"],
        indicating that the environment variable named aa is extracted. If the value of `name_type` is **str**, `args` is in the
        format of ["fix"], indicating that the service name is suffixed with fix. If the value of `name_type` is
        **cmdLineHash**, `args` is in the format of ["0001"] and `value` is in the format of ["ser"], indicating that the
        service name is ser when the startup command is 0001. The object structure is
        documented below.
        """
        return pulumi.get(self, "service_name_rules")

    @service_name_rules.setter
    def service_name_rules(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDiscoveryRuleNameRulesServiceNameRuleArgs']]]):
        pulumi.set(self, "service_name_rules", value)


if not MYPY:
    class ServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict(TypedDict):
        args: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the input value.
        """
        name_type: pulumi.Input[_builtins.str]
        """
        Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
        and **str**.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the application name, which is mandatory only when the value of `name_type` is
        **cmdLineHash**.
        """
elif False:
    ServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDiscoveryRuleNameRulesApplicationNameRuleArgs:
    def __init__(__self__, *,
                 args: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name_type: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Specifies the input value.
        :param pulumi.Input[_builtins.str] name_type: Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
               and **str**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Specifies the application name, which is mandatory only when the value of `name_type` is
               **cmdLineHash**.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the input value.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
        and **str**.
        """
        return pulumi.get(self, "name_type")

    @name_type.setter
    def name_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name_type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the application name, which is mandatory only when the value of `name_type` is
        **cmdLineHash**.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict(TypedDict):
        args: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the input value.
        """
        name_type: pulumi.Input[_builtins.str]
        """
        Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
        and **str**.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the application name, which is mandatory only when the value of `name_type` is
        **cmdLineHash**.
        """
elif False:
    ServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDiscoveryRuleNameRulesServiceNameRuleArgs:
    def __init__(__self__, *,
                 args: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name_type: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Specifies the input value.
        :param pulumi.Input[_builtins.str] name_type: Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
               and **str**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Specifies the application name, which is mandatory only when the value of `name_type` is
               **cmdLineHash**.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def args(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the input value.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="nameType")
    def name_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value type. The value can be **cmdLineHash**, **cmdLine**, **env**
        and **str**.
        """
        return pulumi.get(self, "name_type")

    @name_type.setter
    def name_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name_type", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the application name, which is mandatory only when the value of `name_type` is
        **cmdLineHash**.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


