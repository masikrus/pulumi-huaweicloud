# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GraphEncryptionArgs',
    'GraphEncryptionArgsDict',
    'GraphLtsOperationTraceArgs',
    'GraphLtsOperationTraceArgsDict',
    'GraphPublicIpArgs',
    'GraphPublicIpArgsDict',
    'GraphVertexIdTypeArgs',
    'GraphVertexIdTypeArgsDict',
    'MetadataEncryptionArgs',
    'MetadataEncryptionArgsDict',
    'MetadataGesMetadataArgs',
    'MetadataGesMetadataArgsDict',
    'MetadataGesMetadataLabelArgs',
    'MetadataGesMetadataLabelArgsDict',
]

MYPY = False

if not MYPY:
    class GraphEncryptionArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable data encryption. The value can be true or false.
        The default value is false.
        """
        master_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the customer master key created by DEW in the project corresponding
        to the graph creation.

        <a name="GesGraph_LtsOperationTrace"></a>
        The `LtsOperationTrace` block supports:
        """
elif False:
    GraphEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphEncryptionArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 master_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether to enable data encryption. The value can be true or false.
               The default value is false.
        :param pulumi.Input[_builtins.str] master_key_id: ID of the customer master key created by DEW in the project corresponding
               to the graph creation.
               
               <a name="GesGraph_LtsOperationTrace"></a>
               The `LtsOperationTrace` block supports:
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if master_key_id is not None:
            pulumi.set(__self__, "master_key_id", master_key_id)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable data encryption. The value can be true or false.
        The default value is false.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="masterKeyId")
    def master_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the customer master key created by DEW in the project corresponding
        to the graph creation.

        <a name="GesGraph_LtsOperationTrace"></a>
        The `LtsOperationTrace` block supports:
        """
        return pulumi.get(self, "master_key_id")

    @master_key_id.setter
    def master_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_key_id", value)


if not MYPY:
    class GraphLtsOperationTraceArgsDict(TypedDict):
        audit_log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        LTS log group name.  

        <a name="GesGraph_vertexIdType"></a>
        The `vertexIdType` block supports:
        """
        enable_audit: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable graph audit. The default value is false.
        """
elif False:
    GraphLtsOperationTraceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphLtsOperationTraceArgs:
    def __init__(__self__, *,
                 audit_log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_audit: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audit_log_group_name: LTS log group name.  
               
               <a name="GesGraph_vertexIdType"></a>
               The `vertexIdType` block supports:
        :param pulumi.Input[_builtins.bool] enable_audit: Whether to enable graph audit. The default value is false.
        """
        if audit_log_group_name is not None:
            pulumi.set(__self__, "audit_log_group_name", audit_log_group_name)
        if enable_audit is not None:
            pulumi.set(__self__, "enable_audit", enable_audit)

    @_builtins.property
    @pulumi.getter(name="auditLogGroupName")
    def audit_log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        LTS log group name.  

        <a name="GesGraph_vertexIdType"></a>
        The `vertexIdType` block supports:
        """
        return pulumi.get(self, "audit_log_group_name")

    @audit_log_group_name.setter
    def audit_log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audit_log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="enableAudit")
    def enable_audit(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable graph audit. The default value is false.
        """
        return pulumi.get(self, "enable_audit")

    @enable_audit.setter
    def enable_audit(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_audit", value)


if not MYPY:
    class GraphPublicIpArgsDict(TypedDict):
        eip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP ID.  

        <a name="GesGraph_Encryption"></a>
        The `Encryption` block supports:
        """
        public_bind_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bind type of public IP.  
        The valid value are **auto_assign**, and **bind_existing**.
        """
elif False:
    GraphPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphPublicIpArgs:
    def __init__(__self__, *,
                 eip_id: Optional[pulumi.Input[_builtins.str]] = None,
                 public_bind_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] eip_id: The EIP ID.  
               
               <a name="GesGraph_Encryption"></a>
               The `Encryption` block supports:
        :param pulumi.Input[_builtins.str] public_bind_type: The bind type of public IP.  
               The valid value are **auto_assign**, and **bind_existing**.
        """
        if eip_id is not None:
            pulumi.set(__self__, "eip_id", eip_id)
        if public_bind_type is not None:
            pulumi.set(__self__, "public_bind_type", public_bind_type)

    @_builtins.property
    @pulumi.getter(name="eipId")
    def eip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP ID.  

        <a name="GesGraph_Encryption"></a>
        The `Encryption` block supports:
        """
        return pulumi.get(self, "eip_id")

    @eip_id.setter
    def eip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip_id", value)

    @_builtins.property
    @pulumi.getter(name="publicBindType")
    def public_bind_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bind type of public IP.  
        The valid value are **auto_assign**, and **bind_existing**.
        """
        return pulumi.get(self, "public_bind_type")

    @public_bind_type.setter
    def public_bind_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_bind_type", value)


if not MYPY:
    class GraphVertexIdTypeArgsDict(TypedDict):
        id_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of ID.  
        This parameter is mandatory if **id_type** is **fixedLengthString**. The value ranges from 1 to 128.
        """
        id_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vertex ID type.  
        Value options are as follows:
        + **fixedLengthString**: Vertex IDs are used for internal storage and compute.
        Specify the length limit. If the IDs are too long, the query performance can be reduced.
        Specify the length limit based on your dataset vertex IDs.
        + **hash**: Vertex IDs are converted into hash code for storage and compute.
        There is no limit on the ID length. However, there is an extremely low probability, approximately 10^(-43),
        that the vertex IDs will conflict. If you cannot determine the maximum length of a vertex ID,
        set this parameter to Hash.
        """
elif False:
    GraphVertexIdTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphVertexIdTypeArgs:
    def __init__(__self__, *,
                 id_length: Optional[pulumi.Input[_builtins.int]] = None,
                 id_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] id_length: The length of ID.  
               This parameter is mandatory if **id_type** is **fixedLengthString**. The value ranges from 1 to 128.
        :param pulumi.Input[_builtins.str] id_type: Vertex ID type.  
               Value options are as follows:
               + **fixedLengthString**: Vertex IDs are used for internal storage and compute.
               Specify the length limit. If the IDs are too long, the query performance can be reduced.
               Specify the length limit based on your dataset vertex IDs.
               + **hash**: Vertex IDs are converted into hash code for storage and compute.
               There is no limit on the ID length. However, there is an extremely low probability, approximately 10^(-43),
               that the vertex IDs will conflict. If you cannot determine the maximum length of a vertex ID,
               set this parameter to Hash.
        """
        if id_length is not None:
            pulumi.set(__self__, "id_length", id_length)
        if id_type is not None:
            pulumi.set(__self__, "id_type", id_type)

    @_builtins.property
    @pulumi.getter(name="idLength")
    def id_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of ID.  
        This parameter is mandatory if **id_type** is **fixedLengthString**. The value ranges from 1 to 128.
        """
        return pulumi.get(self, "id_length")

    @id_length.setter
    def id_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "id_length", value)

    @_builtins.property
    @pulumi.getter(name="idType")
    def id_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vertex ID type.  
        Value options are as follows:
        + **fixedLengthString**: Vertex IDs are used for internal storage and compute.
        Specify the length limit. If the IDs are too long, the query performance can be reduced.
        Specify the length limit based on your dataset vertex IDs.
        + **hash**: Vertex IDs are converted into hash code for storage and compute.
        There is no limit on the ID length. However, there is an extremely low probability, approximately 10^(-43),
        that the vertex IDs will conflict. If you cannot determine the maximum length of a vertex ID,
        set this parameter to Hash.
        """
        return pulumi.get(self, "id_type")

    @id_type.setter
    def id_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id_type", value)


if not MYPY:
    class MetadataEncryptionArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable data encryption The value can be true or false.
        The default value is false.
        """
        master_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the customer master key created by DEW in the project where
        the graph is created.
        """
elif False:
    MetadataEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataEncryptionArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 master_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether to enable data encryption The value can be true or false.
               The default value is false.
        :param pulumi.Input[_builtins.str] master_key_id: ID of the customer master key created by DEW in the project where
               the graph is created.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if master_key_id is not None:
            pulumi.set(__self__, "master_key_id", master_key_id)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable data encryption The value can be true or false.
        The default value is false.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="masterKeyId")
    def master_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the customer master key created by DEW in the project where
        the graph is created.
        """
        return pulumi.get(self, "master_key_id")

    @master_key_id.setter
    def master_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "master_key_id", value)


if not MYPY:
    class MetadataGesMetadataArgsDict(TypedDict):
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetadataGesMetadataLabelArgsDict']]]]
        """
        Label list.  
        For details, see [data formats](https://support.huaweicloud.com/intl/en-us/usermanual-ges/ges_01_0153.html).
        The Labels structure is documented below.

        <a name="GesMetadata_MetadataLabels"></a>
        The `MetadataLabels` block supports:
        """
elif False:
    MetadataGesMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataGesMetadataArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataGesMetadataLabelArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetadataGesMetadataLabelArgs']]] labels: Label list.  
               For details, see [data formats](https://support.huaweicloud.com/intl/en-us/usermanual-ges/ges_01_0153.html).
               The Labels structure is documented below.
               
               <a name="GesMetadata_MetadataLabels"></a>
               The `MetadataLabels` block supports:
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetadataGesMetadataLabelArgs']]]]:
        """
        Label list.  
        For details, see [data formats](https://support.huaweicloud.com/intl/en-us/usermanual-ges/ges_01_0153.html).
        The Labels structure is documented below.

        <a name="GesMetadata_MetadataLabels"></a>
        The `MetadataLabels` block supports:
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataGesMetadataLabelArgs']]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class MetadataGesMetadataLabelArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a label.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        The list of label properties. A property refers to the data format of a single
        property and contains some fields.
        For details, see [data formats](https://support.huaweicloud.com/intl/en-us/usermanual-ges/ges_01_0153.html).

        <a name="GesMetadata_Encryption"></a>
        The `Encryption` block supports:
        """
elif False:
    MetadataGesMetadataLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataGesMetadataLabelArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of a label.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] properties: The list of label properties. A property refers to the data format of a single
               property and contains some fields.
               For details, see [data formats](https://support.huaweicloud.com/intl/en-us/usermanual-ges/ges_01_0153.html).
               
               <a name="GesMetadata_Encryption"></a>
               The `Encryption` block supports:
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a label.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        The list of label properties. A property refers to the data format of a single
        property and contains some fields.
        For details, see [data formats](https://support.huaweicloud.com/intl/en-us/usermanual-ges/ges_01_0153.html).

        <a name="GesMetadata_Encryption"></a>
        The `Encryption` block supports:
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "properties", value)


