# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConnectionKafkaDetailArgs',
    'ConnectionKafkaDetailArgsDict',
    'EventBatchActionEventArgs',
    'EventBatchActionEventArgsDict',
    'EventStreamOptionArgs',
    'EventStreamOptionArgsDict',
    'EventStreamOptionBatchWindowArgs',
    'EventStreamOptionBatchWindowArgsDict',
    'EventStreamRuleConfigArgs',
    'EventStreamRuleConfigArgsDict',
    'EventStreamRuleConfigTransformArgs',
    'EventStreamRuleConfigTransformArgsDict',
    'EventStreamSinkArgs',
    'EventStreamSinkArgsDict',
    'EventStreamSourceArgs',
    'EventStreamSourceArgsDict',
    'EventSubscriptionSourceArgs',
    'EventSubscriptionSourceArgsDict',
    'EventSubscriptionTargetArgs',
    'EventSubscriptionTargetArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectionKafkaDetailArgsDict(TypedDict):
        connect_address: pulumi.Input[_builtins.str]
        """
        Specifies the IP address of the kafka instance.

        Changing this parameter will create a new resource.
        """
        instance_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the kafka instance.

        Changing this parameter will create a new resource.
        """
        acks: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of confirmation signals the prouder needs to receive
        to consider the message sent successfully. The acks represents the availability of data backup.
        The value can be:
        + **0**: Indicates that the producer does not need to wait for any confirmation of received information,
        the backup will be immediately added to the socket buffer and considered to have been sent.
        There is no guarantee that the server has successfully received the data in this case,
        and the retry configuration will not take effect and the feedback offset will always be set to -1.

        + **1**: Indicates that at least waiting for the leader to successfully write the data to the local log,
        but not waiting for all followers to successfully write the data. If the follower fails to successfully
        backup the data and the leader cannot provide services at this time, the message will be lost.

        + **all**: Indicates that the leader needs to wait for all backups in the ISR to be successfully written to the log.
        As long as any backup survives, the data will not be lost.

        Defaults to **1**.

        Changing this parameter will create a new resource.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the password of the kafka instance.

        Changing this parameter will create a new resource.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the user name of the kafka instance.

        Changing this parameter will create a new resource.
        """
elif False:
    ConnectionKafkaDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaDetailArgs:
    def __init__(__self__, *,
                 connect_address: pulumi.Input[_builtins.str],
                 instance_id: pulumi.Input[_builtins.str],
                 acks: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] connect_address: Specifies the IP address of the kafka instance.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] instance_id: Specifies the ID of the kafka instance.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] acks: Specifies the number of confirmation signals the prouder needs to receive
               to consider the message sent successfully. The acks represents the availability of data backup.
               The value can be:
               + **0**: Indicates that the producer does not need to wait for any confirmation of received information,
               the backup will be immediately added to the socket buffer and considered to have been sent.
               There is no guarantee that the server has successfully received the data in this case,
               and the retry configuration will not take effect and the feedback offset will always be set to -1.
               
               + **1**: Indicates that at least waiting for the leader to successfully write the data to the local log,
               but not waiting for all followers to successfully write the data. If the follower fails to successfully
               backup the data and the leader cannot provide services at this time, the message will be lost.
               
               + **all**: Indicates that the leader needs to wait for all backups in the ISR to be successfully written to the log.
               As long as any backup survives, the data will not be lost.
               
               Defaults to **1**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] password: Specifies the password of the kafka instance.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] user_name: Specifies the user name of the kafka instance.
               
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "connect_address", connect_address)
        pulumi.set(__self__, "instance_id", instance_id)
        if acks is not None:
            pulumi.set(__self__, "acks", acks)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="connectAddress")
    def connect_address(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP address of the kafka instance.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "connect_address")

    @connect_address.setter
    def connect_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connect_address", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the kafka instance.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def acks(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of confirmation signals the prouder needs to receive
        to consider the message sent successfully. The acks represents the availability of data backup.
        The value can be:
        + **0**: Indicates that the producer does not need to wait for any confirmation of received information,
        the backup will be immediately added to the socket buffer and considered to have been sent.
        There is no guarantee that the server has successfully received the data in this case,
        and the retry configuration will not take effect and the feedback offset will always be set to -1.

        + **1**: Indicates that at least waiting for the leader to successfully write the data to the local log,
        but not waiting for all followers to successfully write the data. If the follower fails to successfully
        backup the data and the leader cannot provide services at this time, the message will be lost.

        + **all**: Indicates that the leader needs to wait for all backups in the ISR to be successfully written to the log.
        As long as any backup survives, the data will not be lost.

        Defaults to **1**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "acks")

    @acks.setter
    def acks(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acks", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the password of the kafka instance.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the user name of the kafka instance.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class EventBatchActionEventArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the event.
        """
        source: pulumi.Input[_builtins.str]
        """
        Specifies the name of the event source.  
        For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc3986#section-4.1)
        """
        spec_version: pulumi.Input[_builtins.str]
        """
        Specifies the CloudEvents protocol version.  
        The spec version must follow the pattern `major.minor`
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the event.
        """
        data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the payload content of the event, in JSON format.  
        The content of data must follow the data schema description.
        """
        data_content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the content type of the event data.  
        For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc2046)
        """
        data_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URI of the event data schema.  
        For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc3986#section-4.3)
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the subject of the event.
        """
        time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time when the event occurred, in UTC format.
        """
elif False:
    EventBatchActionEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventBatchActionEventArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 spec_version: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 data: Optional[pulumi.Input[_builtins.str]] = None,
                 data_content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 data_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the event.
        :param pulumi.Input[_builtins.str] source: Specifies the name of the event source.  
               For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc3986#section-4.1)
        :param pulumi.Input[_builtins.str] spec_version: Specifies the CloudEvents protocol version.  
               The spec version must follow the pattern `major.minor`
        :param pulumi.Input[_builtins.str] type: Specifies the type of the event.
        :param pulumi.Input[_builtins.str] data: Specifies the payload content of the event, in JSON format.  
               The content of data must follow the data schema description.
        :param pulumi.Input[_builtins.str] data_content_type: Specifies the content type of the event data.  
               For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc2046)
        :param pulumi.Input[_builtins.str] data_schema: Specifies the URI of the event data schema.  
               For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc3986#section-4.3)
        :param pulumi.Input[_builtins.str] subject: Specifies the subject of the event.
        :param pulumi.Input[_builtins.str] time: Specifies the time when the event occurred, in UTC format.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "spec_version", spec_version)
        pulumi.set(__self__, "type", type)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if data_content_type is not None:
            pulumi.set(__self__, "data_content_type", data_content_type)
        if data_schema is not None:
            pulumi.set(__self__, "data_schema", data_schema)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the event.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the event source.  
        For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc3986#section-4.1)
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="specVersion")
    def spec_version(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the CloudEvents protocol version.  
        The spec version must follow the pattern `major.minor`
        """
        return pulumi.get(self, "spec_version")

    @spec_version.setter
    def spec_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "spec_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the event.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the payload content of the event, in JSON format.  
        The content of data must follow the data schema description.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="dataContentType")
    def data_content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the content type of the event data.  
        For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc2046)
        """
        return pulumi.get(self, "data_content_type")

    @data_content_type.setter
    def data_content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_content_type", value)

    @_builtins.property
    @pulumi.getter(name="dataSchema")
    def data_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URI of the event data schema.  
        For the detail, please following [reference documentation](https://tools.ietf.org/html/rfc3986#section-4.3)
        """
        return pulumi.get(self, "data_schema")

    @data_schema.setter
    def data_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_schema", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the subject of the event.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time when the event occurred, in UTC format.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class EventStreamOptionArgsDict(TypedDict):
        batch_window: pulumi.Input['EventStreamOptionBatchWindowArgsDict']
        """
        Specifies the configuration of the batch push.
        The transform structure is documented below.

        <a name="stream_option_batch_window"></a>
        The `batch_window` block supports:
        """
        thread_num: pulumi.Input[_builtins.int]
        """
        Specifies the number of concurrent threads.
        """
elif False:
    EventStreamOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventStreamOptionArgs:
    def __init__(__self__, *,
                 batch_window: pulumi.Input['EventStreamOptionBatchWindowArgs'],
                 thread_num: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input['EventStreamOptionBatchWindowArgs'] batch_window: Specifies the configuration of the batch push.
               The transform structure is documented below.
               
               <a name="stream_option_batch_window"></a>
               The `batch_window` block supports:
        :param pulumi.Input[_builtins.int] thread_num: Specifies the number of concurrent threads.
        """
        pulumi.set(__self__, "batch_window", batch_window)
        pulumi.set(__self__, "thread_num", thread_num)

    @_builtins.property
    @pulumi.getter(name="batchWindow")
    def batch_window(self) -> pulumi.Input['EventStreamOptionBatchWindowArgs']:
        """
        Specifies the configuration of the batch push.
        The transform structure is documented below.

        <a name="stream_option_batch_window"></a>
        The `batch_window` block supports:
        """
        return pulumi.get(self, "batch_window")

    @batch_window.setter
    def batch_window(self, value: pulumi.Input['EventStreamOptionBatchWindowArgs']):
        pulumi.set(self, "batch_window", value)

    @_builtins.property
    @pulumi.getter(name="threadNum")
    def thread_num(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of concurrent threads.
        """
        return pulumi.get(self, "thread_num")

    @thread_num.setter
    def thread_num(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "thread_num", value)


if not MYPY:
    class EventStreamOptionBatchWindowArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Specifies the number of items pushed in batches.  
        The valid value is range from `1` to `10,000`.
        """
        interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the interval of the batch push.  
        The valid value is range from `1` to `15`.
        """
        time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of retries.
        """
elif False:
    EventStreamOptionBatchWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventStreamOptionBatchWindowArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 interval: Optional[pulumi.Input[_builtins.int]] = None,
                 time: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Specifies the number of items pushed in batches.  
               The valid value is range from `1` to `10,000`.
        :param pulumi.Input[_builtins.int] interval: Specifies the interval of the batch push.  
               The valid value is range from `1` to `15`.
        :param pulumi.Input[_builtins.int] time: Specifies the number of retries.
        """
        pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of items pushed in batches.  
        The valid value is range from `1` to `10,000`.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the interval of the batch push.  
        The valid value is range from `1` to `15`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of retries.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class EventStreamRuleConfigArgsDict(TypedDict):
        transform: pulumi.Input['EventStreamRuleConfigTransformArgsDict']
        """
        Specifies the configuration detail of the transform rule.  
        The transform structure is documented below.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the configuration detail of the filter rule, in JSON format.

        <a name="stream_rule_config_transform"></a>
        The `transform` block supports:
        """
elif False:
    EventStreamRuleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventStreamRuleConfigArgs:
    def __init__(__self__, *,
                 transform: pulumi.Input['EventStreamRuleConfigTransformArgs'],
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['EventStreamRuleConfigTransformArgs'] transform: Specifies the configuration detail of the transform rule.  
               The transform structure is documented below.
        :param pulumi.Input[_builtins.str] filter: Specifies the configuration detail of the filter rule, in JSON format.
               
               <a name="stream_rule_config_transform"></a>
               The `transform` block supports:
        """
        pulumi.set(__self__, "transform", transform)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def transform(self) -> pulumi.Input['EventStreamRuleConfigTransformArgs']:
        """
        Specifies the configuration detail of the transform rule.  
        The transform structure is documented below.
        """
        return pulumi.get(self, "transform")

    @transform.setter
    def transform(self, value: pulumi.Input['EventStreamRuleConfigTransformArgs']):
        pulumi.set(self, "transform", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the configuration detail of the filter rule, in JSON format.

        <a name="stream_rule_config_transform"></a>
        The `transform` block supports:
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class EventStreamRuleConfigTransformArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of transform rule.  
        The valid values are as follows:
        + **ORIGINAL**
        + **CONSTANT**
        + **VARIABLE**
        """
        template: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the template definition of the rule content.  
        It's only valid for variable type rules and supports references to defined variables.
        The string length does not exceed `2,048` characters.

        <a name="stream_option"></a>
        The `option` block supports:
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the rule content definition.
        + When the constant type rule is used, the field is a constant content definition
        + when the variable type rule is used, it is a variable definition, and the content must be a JSON object string.
        - A maximum of `100` variables are supported, and nested structure definitions are not supported.
        - Variable names are composed of letters, numbers, dots, underscores, and dashes. They must start with a letter or
        number and cannot start with `HC.`, and the length should not exceed `64` characters.
        - variable value Expressions support constants or JsonPath expressions, and the string length does not exceed
        `1,024` characters.
        """
elif False:
    EventStreamRuleConfigTransformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventStreamRuleConfigTransformArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 template: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of transform rule.  
               The valid values are as follows:
               + **ORIGINAL**
               + **CONSTANT**
               + **VARIABLE**
        :param pulumi.Input[_builtins.str] template: Specifies the template definition of the rule content.  
               It's only valid for variable type rules and supports references to defined variables.
               The string length does not exceed `2,048` characters.
               
               <a name="stream_option"></a>
               The `option` block supports:
        :param pulumi.Input[_builtins.str] value: Specifies the rule content definition.
               + When the constant type rule is used, the field is a constant content definition
               + when the variable type rule is used, it is a variable definition, and the content must be a JSON object string.
               - A maximum of `100` variables are supported, and nested structure definitions are not supported.
               - Variable names are composed of letters, numbers, dots, underscores, and dashes. They must start with a letter or
               number and cannot start with `HC.`, and the length should not exceed `64` characters.
               - variable value Expressions support constants or JsonPath expressions, and the string length does not exceed
               `1,024` characters.
        """
        pulumi.set(__self__, "type", type)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of transform rule.  
        The valid values are as follows:
        + **ORIGINAL**
        + **CONSTANT**
        + **VARIABLE**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the template definition of the rule content.  
        It's only valid for variable type rules and supports references to defined variables.
        The string length does not exceed `2,048` characters.

        <a name="stream_option"></a>
        The `option` block supports:
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the rule content definition.
        + When the constant type rule is used, the field is a constant content definition
        + when the variable type rule is used, it is a variable definition, and the content must be a JSON object string.
        - A maximum of `100` variables are supported, and nested structure definitions are not supported.
        - Variable names are composed of letters, numbers, dots, underscores, and dashes. They must start with a letter or
        number and cannot start with `HC.`, and the length should not exceed `64` characters.
        - variable value Expressions support constants or JsonPath expressions, and the string length does not exceed
        `1,024` characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventStreamSinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the event target type.  
        The valid values are as follows:
        + **HC.FunctionGraph**
        + **HC.Kafka**
        """
        functiongraph: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event target configuration detail for FunctionGraph type, in JSON
        format.
        """
        kafka: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event target configuration detail for DMS Kafka type, in JSON format.

        > Exactly one of `functiongraph` and `kafka` must be provided.

        <a name="stream_rule_config"></a>
        The `rule_config` block supports:
        """
elif False:
    EventStreamSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventStreamSinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 functiongraph: Optional[pulumi.Input[_builtins.str]] = None,
                 kafka: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the event target type.  
               The valid values are as follows:
               + **HC.FunctionGraph**
               + **HC.Kafka**
        :param pulumi.Input[_builtins.str] functiongraph: Specifies the event target configuration detail for FunctionGraph type, in JSON
               format.
        :param pulumi.Input[_builtins.str] kafka: Specifies the event target configuration detail for DMS Kafka type, in JSON format.
               
               > Exactly one of `functiongraph` and `kafka` must be provided.
               
               <a name="stream_rule_config"></a>
               The `rule_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        if functiongraph is not None:
            pulumi.set(__self__, "functiongraph", functiongraph)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the event target type.  
        The valid values are as follows:
        + **HC.FunctionGraph**
        + **HC.Kafka**
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def functiongraph(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event target configuration detail for FunctionGraph type, in JSON
        format.
        """
        return pulumi.get(self, "functiongraph")

    @functiongraph.setter
    def functiongraph(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "functiongraph", value)

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event target configuration detail for DMS Kafka type, in JSON format.

        > Exactly one of `functiongraph` and `kafka` must be provided.

        <a name="stream_rule_config"></a>
        The `rule_config` block supports:
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kafka", value)


if not MYPY:
    class EventStreamSourceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the event target type.  
        The valid values are as follows:
        + **HC.FunctionGraph**
        + **HC.Kafka**
        """
        community_rocketmq: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event source configuration detail for community RocketMQ type,
        in JSON format.
        """
        dms_rocketmq: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event source configuration detail for DMS RocketMQ type, in JSON
        format.

        > Exactly one of `kafka`, `mobile_rocketmq`, `community_rocketmq` and `dms_rocketmq` must be provided.

        <a name="stream_sink"></a>
        The `targets` block supports:
        """
        kafka: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event target configuration detail for DMS Kafka type, in JSON format.

        > Exactly one of `functiongraph` and `kafka` must be provided.

        <a name="stream_rule_config"></a>
        The `rule_config` block supports:
        """
        mobile_rocketmq: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event source configuration detail for mobile RocketMQ type, in
        JSON format.
        """
elif False:
    EventStreamSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventStreamSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 community_rocketmq: Optional[pulumi.Input[_builtins.str]] = None,
                 dms_rocketmq: Optional[pulumi.Input[_builtins.str]] = None,
                 kafka: Optional[pulumi.Input[_builtins.str]] = None,
                 mobile_rocketmq: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the event target type.  
               The valid values are as follows:
               + **HC.FunctionGraph**
               + **HC.Kafka**
        :param pulumi.Input[_builtins.str] community_rocketmq: Specifies the event source configuration detail for community RocketMQ type,
               in JSON format.
        :param pulumi.Input[_builtins.str] dms_rocketmq: Specifies the event source configuration detail for DMS RocketMQ type, in JSON
               format.
               
               > Exactly one of `kafka`, `mobile_rocketmq`, `community_rocketmq` and `dms_rocketmq` must be provided.
               
               <a name="stream_sink"></a>
               The `targets` block supports:
        :param pulumi.Input[_builtins.str] kafka: Specifies the event target configuration detail for DMS Kafka type, in JSON format.
               
               > Exactly one of `functiongraph` and `kafka` must be provided.
               
               <a name="stream_rule_config"></a>
               The `rule_config` block supports:
        :param pulumi.Input[_builtins.str] mobile_rocketmq: Specifies the event source configuration detail for mobile RocketMQ type, in
               JSON format.
        """
        pulumi.set(__self__, "name", name)
        if community_rocketmq is not None:
            pulumi.set(__self__, "community_rocketmq", community_rocketmq)
        if dms_rocketmq is not None:
            pulumi.set(__self__, "dms_rocketmq", dms_rocketmq)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if mobile_rocketmq is not None:
            pulumi.set(__self__, "mobile_rocketmq", mobile_rocketmq)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the event target type.  
        The valid values are as follows:
        + **HC.FunctionGraph**
        + **HC.Kafka**
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="communityRocketmq")
    def community_rocketmq(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event source configuration detail for community RocketMQ type,
        in JSON format.
        """
        return pulumi.get(self, "community_rocketmq")

    @community_rocketmq.setter
    def community_rocketmq(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "community_rocketmq", value)

    @_builtins.property
    @pulumi.getter(name="dmsRocketmq")
    def dms_rocketmq(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event source configuration detail for DMS RocketMQ type, in JSON
        format.

        > Exactly one of `kafka`, `mobile_rocketmq`, `community_rocketmq` and `dms_rocketmq` must be provided.

        <a name="stream_sink"></a>
        The `targets` block supports:
        """
        return pulumi.get(self, "dms_rocketmq")

    @dms_rocketmq.setter
    def dms_rocketmq(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dms_rocketmq", value)

    @_builtins.property
    @pulumi.getter
    def kafka(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event target configuration detail for DMS Kafka type, in JSON format.

        > Exactly one of `functiongraph` and `kafka` must be provided.

        <a name="stream_rule_config"></a>
        The `rule_config` block supports:
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kafka", value)

    @_builtins.property
    @pulumi.getter(name="mobileRocketmq")
    def mobile_rocketmq(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event source configuration detail for mobile RocketMQ type, in
        JSON format.
        """
        return pulumi.get(self, "mobile_rocketmq")

    @mobile_rocketmq.setter
    def mobile_rocketmq(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mobile_rocketmq", value)


if not MYPY:
    class EventSubscriptionSourceArgsDict(TypedDict):
        filter_rule: pulumi.Input[_builtins.str]
        """
        Specifies the filter rule of the event source, in JSON format.
        The valid length is limited from `1` to `2,048`.

        > The JSON result (`detail` and `filter_rule`) returned by the EG service may be different from the definition of the
        resource created (especially the official event source). Changes can be handled by `lifecycle.ignore_changes` or
        manual synchronization.

        <a name="subscription_targets"></a>
        The `targets` block supports:
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the event target.
        The valid length is limited from `1` to `128`.
        """
        provider_type: pulumi.Input[_builtins.str]
        """
        Specifies the provider type of the event target.
        The valid values are as follows:
        + **CUSTOM**
        + **OFFICIAL**
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The (UTC) creation time of the event target, in RFC3339 format.
        """
        detail: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the configuration detail of the event target, in JSON format.
        The valid length is limited from `1` to `1,024`.
        """
        detail_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name (key) of the target detail configuration.
        The valid values are as follows:
        + **detail**: Custom event targets and FunctionGraph event targets are used.
        + **smn_detail**: SMN event targets are used.
        + **kafka_detail**: DMS kafka event targets are used.
        + **eg_detail**: EG event targets are used.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the custom ID of the event target, in UUID format.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The (UTC) update time of the event target, in RFC3339 format.
        """
elif False:
    EventSubscriptionSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionSourceArgs:
    def __init__(__self__, *,
                 filter_rule: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 provider_type: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 detail_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] filter_rule: Specifies the filter rule of the event source, in JSON format.
               The valid length is limited from `1` to `2,048`.
               
               > The JSON result (`detail` and `filter_rule`) returned by the EG service may be different from the definition of the
               resource created (especially the official event source). Changes can be handled by `lifecycle.ignore_changes` or
               manual synchronization.
               
               <a name="subscription_targets"></a>
               The `targets` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the name of the event target.
               The valid length is limited from `1` to `128`.
        :param pulumi.Input[_builtins.str] provider_type: Specifies the provider type of the event target.
               The valid values are as follows:
               + **CUSTOM**
               + **OFFICIAL**
        :param pulumi.Input[_builtins.str] created_at: The (UTC) creation time of the event target, in RFC3339 format.
        :param pulumi.Input[_builtins.str] detail: Specifies the configuration detail of the event target, in JSON format.
               The valid length is limited from `1` to `1,024`.
        :param pulumi.Input[_builtins.str] detail_name: Specifies the name (key) of the target detail configuration.
               The valid values are as follows:
               + **detail**: Custom event targets and FunctionGraph event targets are used.
               + **smn_detail**: SMN event targets are used.
               + **kafka_detail**: DMS kafka event targets are used.
               + **eg_detail**: EG event targets are used.
        :param pulumi.Input[_builtins.str] id: Specifies the custom ID of the event target, in UUID format.
        :param pulumi.Input[_builtins.str] updated_at: The (UTC) update time of the event target, in RFC3339 format.
        """
        pulumi.set(__self__, "filter_rule", filter_rule)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_type", provider_type)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if detail_name is not None:
            pulumi.set(__self__, "detail_name", detail_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="filterRule")
    def filter_rule(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the filter rule of the event source, in JSON format.
        The valid length is limited from `1` to `2,048`.

        > The JSON result (`detail` and `filter_rule`) returned by the EG service may be different from the definition of the
        resource created (especially the official event source). Changes can be handled by `lifecycle.ignore_changes` or
        manual synchronization.

        <a name="subscription_targets"></a>
        The `targets` block supports:
        """
        return pulumi.get(self, "filter_rule")

    @filter_rule.setter
    def filter_rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filter_rule", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the event target.
        The valid length is limited from `1` to `128`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the provider type of the event target.
        The valid values are as follows:
        + **CUSTOM**
        + **OFFICIAL**
        """
        return pulumi.get(self, "provider_type")

    @provider_type.setter
    def provider_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_type", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The (UTC) creation time of the event target, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the configuration detail of the event target, in JSON format.
        The valid length is limited from `1` to `1,024`.
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter(name="detailName")
    def detail_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name (key) of the target detail configuration.
        The valid values are as follows:
        + **detail**: Custom event targets and FunctionGraph event targets are used.
        + **smn_detail**: SMN event targets are used.
        + **kafka_detail**: DMS kafka event targets are used.
        + **eg_detail**: EG event targets are used.
        """
        return pulumi.get(self, "detail_name")

    @detail_name.setter
    def detail_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the custom ID of the event target, in UUID format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The (UTC) update time of the event target, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class EventSubscriptionTargetArgsDict(TypedDict):
        detail: pulumi.Input[_builtins.str]
        """
        Specifies the configuration detail of the event target, in JSON format.
        The valid length is limited from `1` to `1,024`.
        """
        detail_name: pulumi.Input[_builtins.str]
        """
        Specifies the name (key) of the target detail configuration.
        The valid values are as follows:
        + **detail**: Custom event targets and FunctionGraph event targets are used.
        + **smn_detail**: SMN event targets are used.
        + **kafka_detail**: DMS kafka event targets are used.
        + **eg_detail**: EG event targets are used.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the event target.
        The valid length is limited from `1` to `128`.
        """
        provider_type: pulumi.Input[_builtins.str]
        """
        Specifies the provider type of the event target.
        The valid values are as follows:
        + **CUSTOM**
        + **OFFICIAL**
        """
        transform: pulumi.Input[_builtins.str]
        """
        Specifies the transform configuration of the event target, in JSON format.
        """
        connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the connection ID of the EG event target.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The (UTC) creation time of the event target, in RFC3339 format.
        """
        dead_letter_queue: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the specified queue to which failure events sent, in JSON format.

        > The JSON result (`detail`, `transform`and `dead_letter_queue`) returned by the EG service may be different from the
        definition of the resource created (especially the official event target). Changes can be handled by
        `lifecycle.ignore_changes` or manual synchronization.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the custom ID of the event target, in UUID format.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The (UTC) update time of the event target, in RFC3339 format.
        """
elif False:
    EventSubscriptionTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventSubscriptionTargetArgs:
    def __init__(__self__, *,
                 detail: pulumi.Input[_builtins.str],
                 detail_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 provider_type: pulumi.Input[_builtins.str],
                 transform: pulumi.Input[_builtins.str],
                 connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 dead_letter_queue: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] detail: Specifies the configuration detail of the event target, in JSON format.
               The valid length is limited from `1` to `1,024`.
        :param pulumi.Input[_builtins.str] detail_name: Specifies the name (key) of the target detail configuration.
               The valid values are as follows:
               + **detail**: Custom event targets and FunctionGraph event targets are used.
               + **smn_detail**: SMN event targets are used.
               + **kafka_detail**: DMS kafka event targets are used.
               + **eg_detail**: EG event targets are used.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the event target.
               The valid length is limited from `1` to `128`.
        :param pulumi.Input[_builtins.str] provider_type: Specifies the provider type of the event target.
               The valid values are as follows:
               + **CUSTOM**
               + **OFFICIAL**
        :param pulumi.Input[_builtins.str] transform: Specifies the transform configuration of the event target, in JSON format.
        :param pulumi.Input[_builtins.str] connection_id: Specifies the connection ID of the EG event target.
        :param pulumi.Input[_builtins.str] created_at: The (UTC) creation time of the event target, in RFC3339 format.
        :param pulumi.Input[_builtins.str] dead_letter_queue: Specifies the specified queue to which failure events sent, in JSON format.
               
               > The JSON result (`detail`, `transform`and `dead_letter_queue`) returned by the EG service may be different from the
               definition of the resource created (especially the official event target). Changes can be handled by
               `lifecycle.ignore_changes` or manual synchronization.
        :param pulumi.Input[_builtins.str] id: Specifies the custom ID of the event target, in UUID format.
        :param pulumi.Input[_builtins.str] updated_at: The (UTC) update time of the event target, in RFC3339 format.
        """
        pulumi.set(__self__, "detail", detail)
        pulumi.set(__self__, "detail_name", detail_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_type", provider_type)
        pulumi.set(__self__, "transform", transform)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if dead_letter_queue is not None:
            pulumi.set(__self__, "dead_letter_queue", dead_letter_queue)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the configuration detail of the event target, in JSON format.
        The valid length is limited from `1` to `1,024`.
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter(name="detailName")
    def detail_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name (key) of the target detail configuration.
        The valid values are as follows:
        + **detail**: Custom event targets and FunctionGraph event targets are used.
        + **smn_detail**: SMN event targets are used.
        + **kafka_detail**: DMS kafka event targets are used.
        + **eg_detail**: EG event targets are used.
        """
        return pulumi.get(self, "detail_name")

    @detail_name.setter
    def detail_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "detail_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the event target.
        The valid length is limited from `1` to `128`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the provider type of the event target.
        The valid values are as follows:
        + **CUSTOM**
        + **OFFICIAL**
        """
        return pulumi.get(self, "provider_type")

    @provider_type.setter
    def provider_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_type", value)

    @_builtins.property
    @pulumi.getter
    def transform(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the transform configuration of the event target, in JSON format.
        """
        return pulumi.get(self, "transform")

    @transform.setter
    def transform(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "transform", value)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the connection ID of the EG event target.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_id", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The (UTC) creation time of the event target, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="deadLetterQueue")
    def dead_letter_queue(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the specified queue to which failure events sent, in JSON format.

        > The JSON result (`detail`, `transform`and `dead_letter_queue`) returned by the EG service may be different from the
        definition of the resource created (especially the official event target). Changes can be handled by
        `lifecycle.ignore_changes` or manual synchronization.
        """
        return pulumi.get(self, "dead_letter_queue")

    @dead_letter_queue.setter
    def dead_letter_queue(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dead_letter_queue", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the custom ID of the event target, in UUID format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The (UTC) update time of the event target, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


