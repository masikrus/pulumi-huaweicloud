# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetResourcesByTagsResult',
    'AwaitableGetResourcesByTagsResult',
    'get_resources_by_tags',
    'get_resources_by_tags_output',
]

@pulumi.output_type
class GetResourcesByTagsResult:
    """
    A collection of values returned by getResourcesByTags.
    """
    def __init__(__self__, action=None, id=None, matches=None, not_tags=None, not_tags_anies=None, region=None, resource_type=None, resources=None, sys_tags=None, tags=None, tags_anies=None, total_count=None):
        if action and not isinstance(action, str):
            raise TypeError("Expected argument 'action' to be a str")
        pulumi.set(__self__, "action", action)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if matches and not isinstance(matches, list):
            raise TypeError("Expected argument 'matches' to be a list")
        pulumi.set(__self__, "matches", matches)
        if not_tags and not isinstance(not_tags, list):
            raise TypeError("Expected argument 'not_tags' to be a list")
        pulumi.set(__self__, "not_tags", not_tags)
        if not_tags_anies and not isinstance(not_tags_anies, list):
            raise TypeError("Expected argument 'not_tags_anies' to be a list")
        pulumi.set(__self__, "not_tags_anies", not_tags_anies)
        if region and not isinstance(region, str):
            raise TypeError("Expected argument 'region' to be a str")
        pulumi.set(__self__, "region", region)
        if resource_type and not isinstance(resource_type, str):
            raise TypeError("Expected argument 'resource_type' to be a str")
        pulumi.set(__self__, "resource_type", resource_type)
        if resources and not isinstance(resources, list):
            raise TypeError("Expected argument 'resources' to be a list")
        pulumi.set(__self__, "resources", resources)
        if sys_tags and not isinstance(sys_tags, list):
            raise TypeError("Expected argument 'sys_tags' to be a list")
        pulumi.set(__self__, "sys_tags", sys_tags)
        if tags and not isinstance(tags, list):
            raise TypeError("Expected argument 'tags' to be a list")
        pulumi.set(__self__, "tags", tags)
        if tags_anies and not isinstance(tags_anies, list):
            raise TypeError("Expected argument 'tags_anies' to be a list")
        pulumi.set(__self__, "tags_anies", tags_anies)
        if total_count and not isinstance(total_count, int):
            raise TypeError("Expected argument 'total_count' to be a int")
        pulumi.set(__self__, "total_count", total_count)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def matches(self) -> Optional[Sequence['outputs.GetResourcesByTagsMatchResult']]:
        return pulumi.get(self, "matches")

    @_builtins.property
    @pulumi.getter(name="notTags")
    def not_tags(self) -> Optional[Sequence['outputs.GetResourcesByTagsNotTagResult']]:
        return pulumi.get(self, "not_tags")

    @_builtins.property
    @pulumi.getter(name="notTagsAnies")
    def not_tags_anies(self) -> Optional[Sequence['outputs.GetResourcesByTagsNotTagsAnyResult']]:
        return pulumi.get(self, "not_tags_anies")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetResourcesByTagsResourceResult']:
        """
        Indicates the list of resources.
        The resources structure is documented below.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="sysTags")
    def sys_tags(self) -> Optional[Sequence['outputs.GetResourcesByTagsSysTagResult']]:
        """
        Indicates the list of queried system tags.
        The sys_tags structure is documented below.
        """
        return pulumi.get(self, "sys_tags")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetResourcesByTagsTagResult']]:
        """
        Indicates the list of queried tags.
        The tags structure is documented below.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tagsAnies")
    def tags_anies(self) -> Optional[Sequence['outputs.GetResourcesByTagsTagsAnyResult']]:
        return pulumi.get(self, "tags_anies")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        Indicates the total number of resources.
        """
        return pulumi.get(self, "total_count")


class AwaitableGetResourcesByTagsResult(GetResourcesByTagsResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetResourcesByTagsResult(
            action=self.action,
            id=self.id,
            matches=self.matches,
            not_tags=self.not_tags,
            not_tags_anies=self.not_tags_anies,
            region=self.region,
            resource_type=self.resource_type,
            resources=self.resources,
            sys_tags=self.sys_tags,
            tags=self.tags,
            tags_anies=self.tags_anies,
            total_count=self.total_count)


def get_resources_by_tags(action: Optional[_builtins.str] = None,
                          matches: Optional[Sequence[Union['GetResourcesByTagsMatchArgs', 'GetResourcesByTagsMatchArgsDict']]] = None,
                          not_tags: Optional[Sequence[Union['GetResourcesByTagsNotTagArgs', 'GetResourcesByTagsNotTagArgsDict']]] = None,
                          not_tags_anies: Optional[Sequence[Union['GetResourcesByTagsNotTagsAnyArgs', 'GetResourcesByTagsNotTagsAnyArgsDict']]] = None,
                          region: Optional[_builtins.str] = None,
                          resource_type: Optional[_builtins.str] = None,
                          sys_tags: Optional[Sequence[Union['GetResourcesByTagsSysTagArgs', 'GetResourcesByTagsSysTagArgsDict']]] = None,
                          tags: Optional[Sequence[Union['GetResourcesByTagsTagArgs', 'GetResourcesByTagsTagArgsDict']]] = None,
                          tags_anies: Optional[Sequence[Union['GetResourcesByTagsTagsAnyArgs', 'GetResourcesByTagsTagsAnyArgsDict']]] = None,
                          opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetResourcesByTagsResult:
    """
    Use this data source to get the list of DC resources by tag.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_huaweicloud as huaweicloud

    config = pulumi.Config()
    resource_type = config.require_object("resourceType")
    test = huaweicloud.dc.get_resources_by_tags(resource_type=resource_type,
        action="filter")
    ```


    :param _builtins.str action: Specifies the operate action. Value options:
           + **filter**: indicates pagination query
           + **count**: indicates that the total number of query results meeting the search criteria will be returned.
    :param Sequence[Union['GetResourcesByTagsMatchArgs', 'GetResourcesByTagsMatchArgsDict']] matches: Specifies the search criteria. The tag key is the parameter to match, for example,
           **resource_name**. The tag value indicates the value to be matched. This field is a fixed dictionary value. Determine
           whether fuzzy match is required based on different fields. For example, if key is **resource_name**, fuzzy search
           (case-insensitive) is used by default. If value is an empty string, exact match is used. If key is **resource_id**,
           exact match is used. Only **resource_name** for key is supported. Other key values will be available later.
           The matches structure is documented below.
    :param Sequence[Union['GetResourcesByTagsNotTagArgs', 'GetResourcesByTagsNotTagArgsDict']] not_tags: Specifies the excluded tags. Each tag contains a maximum of 10 keys, and each key contains
           a maximum of 10 values. The structure body cannot be missing, and the key cannot be left blank or set to an empty string.
           Each tag key must be unique, and each tag value of a tag must also be unique. Resources not identified by different keys
           are in AND relationship, and values in one tag are in OR relationship. If not_tags_any is not specified, all resources
           will be returned.
           The not_tags structure is documented below.
    :param Sequence[Union['GetResourcesByTagsNotTagsAnyArgs', 'GetResourcesByTagsNotTagsAnyArgsDict']] not_tags_anies: Specifies any excluded tags. Each tag contains a maximum of 10 keys, and each key
           contains a maximum of 10 values. The structure body cannot be missing, and the key cannot be left blank or set to an
           empty string. Each tag key must be unique, and each tag value of a tag must also be unique. Resources not identified
           by different keys are in OR relationship, and values in one tag are in OR relationship. If not_tags_any is not specified,
           all resources will be returned.
           The not_tags_any structure is documented below.
    :param _builtins.str region: Specifies the region in which to query the resource.
           If omitted, the provider-level region will be used.
    :param _builtins.str resource_type: Specifies the direct Connect resource type. Value options:
           + **dc-directconnect**: direct connect connection
           + **dc-vgw**: virtual gateway
           + **dc-vif**: virtual interface
    :param Sequence[Union['GetResourcesByTagsSysTagArgs', 'GetResourcesByTagsSysTagArgsDict']] sys_tags: Specifies the system tags. Only users with the op_service permission can use this parameter
           to filter resources. Only one tag structure is contained when this API is called by Tag Management Service (TMS). The
           key is **_sys_enterprise_project_id**, and the value is the enterprise project ID list. Currently, each key can contain
           only one value. 0 indicates the default enterprise project. sys_tags and tenant tag filtering conditions
           (`without_any_tag`, `tags`, `tags_any`, `not_tags`, and `not_tags_any`) cannot be used at the same time.
           The sys_tags structure is documented below.
           
           <a name="matches_struct"></a>
           The `matches` block supports:
    :param Sequence[Union['GetResourcesByTagsTagArgs', 'GetResourcesByTagsTagArgsDict']] tags: Specifies the tags. A maximum of 10 keys can be queried at a time, and each key can contain
           a maximum of 10 values. The structure body must be included. The tag key cannot be left blank or be an empty string.
           Each tag key must be unique, and each tag value of a tag must also be unique. Resources identified by different keys
           are in AND relationship, and values in one tag are in OR relationship. If no tag filtering criteria is specified, full
           data is returned.
           The tags structure is documented below.
    :param Sequence[Union['GetResourcesByTagsTagsAnyArgs', 'GetResourcesByTagsTagsAnyArgsDict']] tags_anies: Specifies any included tags. Each tag contains a maximum of 10 keys, and each key contains
           a maximum of 10 values. The structure body cannot be missing, and the key cannot be left blank or set to an empty string.
           Each tag key must be unique, and each tag value of a tag must also be unique. Resources identified by different keys are
           in OR relationship, and values in one tag are in OR relationship. If not_tags_any is not specified, all resources will
           be returned.
           The tags_any structure is documented below.
    """
    __args__ = dict()
    __args__['action'] = action
    __args__['matches'] = matches
    __args__['notTags'] = not_tags
    __args__['notTagsAnies'] = not_tags_anies
    __args__['region'] = region
    __args__['resourceType'] = resource_type
    __args__['sysTags'] = sys_tags
    __args__['tags'] = tags
    __args__['tagsAnies'] = tags_anies
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('huaweicloud:dc/getResourcesByTags:getResourcesByTags', __args__, opts=opts, typ=GetResourcesByTagsResult).value

    return AwaitableGetResourcesByTagsResult(
        action=pulumi.get(__ret__, 'action'),
        id=pulumi.get(__ret__, 'id'),
        matches=pulumi.get(__ret__, 'matches'),
        not_tags=pulumi.get(__ret__, 'not_tags'),
        not_tags_anies=pulumi.get(__ret__, 'not_tags_anies'),
        region=pulumi.get(__ret__, 'region'),
        resource_type=pulumi.get(__ret__, 'resource_type'),
        resources=pulumi.get(__ret__, 'resources'),
        sys_tags=pulumi.get(__ret__, 'sys_tags'),
        tags=pulumi.get(__ret__, 'tags'),
        tags_anies=pulumi.get(__ret__, 'tags_anies'),
        total_count=pulumi.get(__ret__, 'total_count'))
def get_resources_by_tags_output(action: Optional[pulumi.Input[_builtins.str]] = None,
                                 matches: Optional[pulumi.Input[Optional[Sequence[Union['GetResourcesByTagsMatchArgs', 'GetResourcesByTagsMatchArgsDict']]]]] = None,
                                 not_tags: Optional[pulumi.Input[Optional[Sequence[Union['GetResourcesByTagsNotTagArgs', 'GetResourcesByTagsNotTagArgsDict']]]]] = None,
                                 not_tags_anies: Optional[pulumi.Input[Optional[Sequence[Union['GetResourcesByTagsNotTagsAnyArgs', 'GetResourcesByTagsNotTagsAnyArgsDict']]]]] = None,
                                 region: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                                 sys_tags: Optional[pulumi.Input[Optional[Sequence[Union['GetResourcesByTagsSysTagArgs', 'GetResourcesByTagsSysTagArgsDict']]]]] = None,
                                 tags: Optional[pulumi.Input[Optional[Sequence[Union['GetResourcesByTagsTagArgs', 'GetResourcesByTagsTagArgsDict']]]]] = None,
                                 tags_anies: Optional[pulumi.Input[Optional[Sequence[Union['GetResourcesByTagsTagsAnyArgs', 'GetResourcesByTagsTagsAnyArgsDict']]]]] = None,
                                 opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetResourcesByTagsResult]:
    """
    Use this data source to get the list of DC resources by tag.

    ## Example Usage

    ```python
    import pulumi
    import pulumi_huaweicloud as huaweicloud

    config = pulumi.Config()
    resource_type = config.require_object("resourceType")
    test = huaweicloud.dc.get_resources_by_tags(resource_type=resource_type,
        action="filter")
    ```


    :param _builtins.str action: Specifies the operate action. Value options:
           + **filter**: indicates pagination query
           + **count**: indicates that the total number of query results meeting the search criteria will be returned.
    :param Sequence[Union['GetResourcesByTagsMatchArgs', 'GetResourcesByTagsMatchArgsDict']] matches: Specifies the search criteria. The tag key is the parameter to match, for example,
           **resource_name**. The tag value indicates the value to be matched. This field is a fixed dictionary value. Determine
           whether fuzzy match is required based on different fields. For example, if key is **resource_name**, fuzzy search
           (case-insensitive) is used by default. If value is an empty string, exact match is used. If key is **resource_id**,
           exact match is used. Only **resource_name** for key is supported. Other key values will be available later.
           The matches structure is documented below.
    :param Sequence[Union['GetResourcesByTagsNotTagArgs', 'GetResourcesByTagsNotTagArgsDict']] not_tags: Specifies the excluded tags. Each tag contains a maximum of 10 keys, and each key contains
           a maximum of 10 values. The structure body cannot be missing, and the key cannot be left blank or set to an empty string.
           Each tag key must be unique, and each tag value of a tag must also be unique. Resources not identified by different keys
           are in AND relationship, and values in one tag are in OR relationship. If not_tags_any is not specified, all resources
           will be returned.
           The not_tags structure is documented below.
    :param Sequence[Union['GetResourcesByTagsNotTagsAnyArgs', 'GetResourcesByTagsNotTagsAnyArgsDict']] not_tags_anies: Specifies any excluded tags. Each tag contains a maximum of 10 keys, and each key
           contains a maximum of 10 values. The structure body cannot be missing, and the key cannot be left blank or set to an
           empty string. Each tag key must be unique, and each tag value of a tag must also be unique. Resources not identified
           by different keys are in OR relationship, and values in one tag are in OR relationship. If not_tags_any is not specified,
           all resources will be returned.
           The not_tags_any structure is documented below.
    :param _builtins.str region: Specifies the region in which to query the resource.
           If omitted, the provider-level region will be used.
    :param _builtins.str resource_type: Specifies the direct Connect resource type. Value options:
           + **dc-directconnect**: direct connect connection
           + **dc-vgw**: virtual gateway
           + **dc-vif**: virtual interface
    :param Sequence[Union['GetResourcesByTagsSysTagArgs', 'GetResourcesByTagsSysTagArgsDict']] sys_tags: Specifies the system tags. Only users with the op_service permission can use this parameter
           to filter resources. Only one tag structure is contained when this API is called by Tag Management Service (TMS). The
           key is **_sys_enterprise_project_id**, and the value is the enterprise project ID list. Currently, each key can contain
           only one value. 0 indicates the default enterprise project. sys_tags and tenant tag filtering conditions
           (`without_any_tag`, `tags`, `tags_any`, `not_tags`, and `not_tags_any`) cannot be used at the same time.
           The sys_tags structure is documented below.
           
           <a name="matches_struct"></a>
           The `matches` block supports:
    :param Sequence[Union['GetResourcesByTagsTagArgs', 'GetResourcesByTagsTagArgsDict']] tags: Specifies the tags. A maximum of 10 keys can be queried at a time, and each key can contain
           a maximum of 10 values. The structure body must be included. The tag key cannot be left blank or be an empty string.
           Each tag key must be unique, and each tag value of a tag must also be unique. Resources identified by different keys
           are in AND relationship, and values in one tag are in OR relationship. If no tag filtering criteria is specified, full
           data is returned.
           The tags structure is documented below.
    :param Sequence[Union['GetResourcesByTagsTagsAnyArgs', 'GetResourcesByTagsTagsAnyArgsDict']] tags_anies: Specifies any included tags. Each tag contains a maximum of 10 keys, and each key contains
           a maximum of 10 values. The structure body cannot be missing, and the key cannot be left blank or set to an empty string.
           Each tag key must be unique, and each tag value of a tag must also be unique. Resources identified by different keys are
           in OR relationship, and values in one tag are in OR relationship. If not_tags_any is not specified, all resources will
           be returned.
           The tags_any structure is documented below.
    """
    __args__ = dict()
    __args__['action'] = action
    __args__['matches'] = matches
    __args__['notTags'] = not_tags
    __args__['notTagsAnies'] = not_tags_anies
    __args__['region'] = region
    __args__['resourceType'] = resource_type
    __args__['sysTags'] = sys_tags
    __args__['tags'] = tags
    __args__['tagsAnies'] = tags_anies
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('huaweicloud:dc/getResourcesByTags:getResourcesByTags', __args__, opts=opts, typ=GetResourcesByTagsResult)
    return __ret__.apply(lambda __response__: GetResourcesByTagsResult(
        action=pulumi.get(__response__, 'action'),
        id=pulumi.get(__response__, 'id'),
        matches=pulumi.get(__response__, 'matches'),
        not_tags=pulumi.get(__response__, 'not_tags'),
        not_tags_anies=pulumi.get(__response__, 'not_tags_anies'),
        region=pulumi.get(__response__, 'region'),
        resource_type=pulumi.get(__response__, 'resource_type'),
        resources=pulumi.get(__response__, 'resources'),
        sys_tags=pulumi.get(__response__, 'sys_tags'),
        tags=pulumi.get(__response__, 'tags'),
        tags_anies=pulumi.get(__response__, 'tags_anies'),
        total_count=pulumi.get(__response__, 'total_count')))
