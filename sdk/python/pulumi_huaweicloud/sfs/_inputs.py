# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FileSystemAccessRuleArgs',
    'FileSystemAccessRuleArgsDict',
    'FileSystemV2AccessRuleArgs',
    'FileSystemV2AccessRuleArgsDict',
    'TurboDuTaskDirUsageArgs',
    'TurboDuTaskDirUsageArgsDict',
    'TurboDuTaskDirUsageFileCountArgs',
    'TurboDuTaskDirUsageFileCountArgsDict',
    'TurboObsTargetObsArgs',
    'TurboObsTargetObsArgsDict',
    'TurboObsTargetObsAttributesArgs',
    'TurboObsTargetObsAttributesArgsDict',
    'TurboObsTargetObsPolicyArgs',
    'TurboObsTargetObsPolicyArgsDict',
    'TurboObsTargetObsPolicyAutoExportPolicyArgs',
    'TurboObsTargetObsPolicyAutoExportPolicyArgsDict',
    'GetTurbosByTagsMatchArgs',
    'GetTurbosByTagsMatchArgsDict',
    'GetTurbosByTagsTagArgs',
    'GetTurbosByTagsTagArgsDict',
]

MYPY = False

if not MYPY:
    class FileSystemAccessRuleArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the access level of the shared file system. Possible values are *ro* (
        read-only)
        and *rw* (read-write). The default value is *rw* (read/write). Changing this will create a new access rule.
        """
        access_rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The UUID of the share access rule.
        """
        access_to: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value that defines the access rule. The value contains 1 to 255
        characters. Changing this will create a new access rule. The value varies according to the scenario:
        + Set the VPC ID in VPC authorization scenarios.
        + Set this parameter in IP address authorization scenario:
        - For an NFS shared file system, the value in the format of *VPC_ID#IP_address#priority#user_permission*.
        For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#100#all_squash,root_squash.
        - For a CIFS shared file system, the value in the format of *VPC_ID#IP_address#priority*.
        For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#0.

        > **NOTE:** If you want to create more access rules, please using
        huaweicloud_sfs_access_rule.
        """
        access_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of the share access rule. The default value is *cert*. Changing
        this will create a new access rule.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the share access rule.
        """
elif False:
    FileSystemAccessRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemAccessRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 access_to: Optional[pulumi.Input[_builtins.str]] = None,
                 access_type: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_level: Specifies the access level of the shared file system. Possible values are *ro* (
               read-only)
               and *rw* (read-write). The default value is *rw* (read/write). Changing this will create a new access rule.
        :param pulumi.Input[_builtins.str] access_rule_id: The UUID of the share access rule.
        :param pulumi.Input[_builtins.str] access_to: Specifies the value that defines the access rule. The value contains 1 to 255
               characters. Changing this will create a new access rule. The value varies according to the scenario:
               + Set the VPC ID in VPC authorization scenarios.
               + Set this parameter in IP address authorization scenario:
               - For an NFS shared file system, the value in the format of *VPC_ID#IP_address#priority#user_permission*.
               For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#100#all_squash,root_squash.
               - For a CIFS shared file system, the value in the format of *VPC_ID#IP_address#priority*.
               For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#0.
               
               > **NOTE:** If you want to create more access rules, please using
               huaweicloud_sfs_access_rule.
        :param pulumi.Input[_builtins.str] access_type: Specifies the type of the share access rule. The default value is *cert*. Changing
               this will create a new access rule.
        :param pulumi.Input[_builtins.str] status: The status of the share access rule.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_rule_id is not None:
            pulumi.set(__self__, "access_rule_id", access_rule_id)
        if access_to is not None:
            pulumi.set(__self__, "access_to", access_to)
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the access level of the shared file system. Possible values are *ro* (
        read-only)
        and *rw* (read-write). The default value is *rw* (read/write). Changing this will create a new access rule.
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessRuleId")
    def access_rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The UUID of the share access rule.
        """
        return pulumi.get(self, "access_rule_id")

    @access_rule_id.setter
    def access_rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="accessTo")
    def access_to(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value that defines the access rule. The value contains 1 to 255
        characters. Changing this will create a new access rule. The value varies according to the scenario:
        + Set the VPC ID in VPC authorization scenarios.
        + Set this parameter in IP address authorization scenario:
        - For an NFS shared file system, the value in the format of *VPC_ID#IP_address#priority#user_permission*.
        For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#100#all_squash,root_squash.
        - For a CIFS shared file system, the value in the format of *VPC_ID#IP_address#priority*.
        For example, 0157b53f-4974-4e80-91c9-098532bcaf00#2.2.2.2/16#0.

        > **NOTE:** If you want to create more access rules, please using
        huaweicloud_sfs_access_rule.
        """
        return pulumi.get(self, "access_to")

    @access_to.setter
    def access_to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_to", value)

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the share access rule. The default value is *cert*. Changing
        this will create a new access rule.
        """
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the share access rule.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FileSystemV2AccessRuleArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[_builtins.str]]
        access_rule_id: NotRequired[pulumi.Input[_builtins.str]]
        access_to: NotRequired[pulumi.Input[_builtins.str]]
        access_type: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FileSystemV2AccessRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemV2AccessRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[_builtins.str]] = None,
                 access_rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 access_to: Optional[pulumi.Input[_builtins.str]] = None,
                 access_type: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_rule_id is not None:
            pulumi.set(__self__, "access_rule_id", access_rule_id)
        if access_to is not None:
            pulumi.set(__self__, "access_to", access_to)
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_level", value)

    @_builtins.property
    @pulumi.getter(name="accessRuleId")
    def access_rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "access_rule_id")

    @access_rule_id.setter
    def access_rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_rule_id", value)

    @_builtins.property
    @pulumi.getter(name="accessTo")
    def access_to(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "access_to")

    @access_to.setter
    def access_to(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_to", value)

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class TurboDuTaskDirUsageArgsDict(TypedDict):
        file_counts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TurboDuTaskDirUsageFileCountArgsDict']]]]
        """
        The total number of files in the directory.
        The file_count structure is documented below.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The error messages.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the full path to a legal directory in the file system.
        The length of a single level directory is not allowed to exceed `255`, and the length of the full path is not allowed
        to exceed `4,096`.
        Changing this creates a new resource.
        """
        used_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The used capacity, in byte.
        """
elif False:
    TurboDuTaskDirUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TurboDuTaskDirUsageArgs:
    def __init__(__self__, *,
                 file_counts: Optional[pulumi.Input[Sequence[pulumi.Input['TurboDuTaskDirUsageFileCountArgs']]]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 used_capacity: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TurboDuTaskDirUsageFileCountArgs']]] file_counts: The total number of files in the directory.
               The file_count structure is documented below.
        :param pulumi.Input[_builtins.str] message: The error messages.
        :param pulumi.Input[_builtins.str] path: Specifies the full path to a legal directory in the file system.
               The length of a single level directory is not allowed to exceed `255`, and the length of the full path is not allowed
               to exceed `4,096`.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.int] used_capacity: The used capacity, in byte.
        """
        if file_counts is not None:
            pulumi.set(__self__, "file_counts", file_counts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if used_capacity is not None:
            pulumi.set(__self__, "used_capacity", used_capacity)

    @_builtins.property
    @pulumi.getter(name="fileCounts")
    def file_counts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TurboDuTaskDirUsageFileCountArgs']]]]:
        """
        The total number of files in the directory.
        The file_count structure is documented below.
        """
        return pulumi.get(self, "file_counts")

    @file_counts.setter
    def file_counts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TurboDuTaskDirUsageFileCountArgs']]]]):
        pulumi.set(self, "file_counts", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The error messages.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the full path to a legal directory in the file system.
        The length of a single level directory is not allowed to exceed `255`, and the length of the full path is not allowed
        to exceed `4,096`.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="usedCapacity")
    def used_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The used capacity, in byte.
        """
        return pulumi.get(self, "used_capacity")

    @used_capacity.setter
    def used_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "used_capacity", value)


if not MYPY:
    class TurboDuTaskDirUsageFileCountArgsDict(TypedDict):
        block: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of block devices.
        """
        char: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of character devices.
        """
        dir: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of directories.
        """
        pipe: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of pipe files.
        """
        regular: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of common files.
        """
        socket: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of sockets.
        """
        symlink: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of symbolic links.
        """
elif False:
    TurboDuTaskDirUsageFileCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TurboDuTaskDirUsageFileCountArgs:
    def __init__(__self__, *,
                 block: Optional[pulumi.Input[_builtins.int]] = None,
                 char: Optional[pulumi.Input[_builtins.int]] = None,
                 dir: Optional[pulumi.Input[_builtins.int]] = None,
                 pipe: Optional[pulumi.Input[_builtins.int]] = None,
                 regular: Optional[pulumi.Input[_builtins.int]] = None,
                 socket: Optional[pulumi.Input[_builtins.int]] = None,
                 symlink: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] block: The number of block devices.
        :param pulumi.Input[_builtins.int] char: The number of character devices.
        :param pulumi.Input[_builtins.int] dir: The number of directories.
        :param pulumi.Input[_builtins.int] pipe: The number of pipe files.
        :param pulumi.Input[_builtins.int] regular: The number of common files.
        :param pulumi.Input[_builtins.int] socket: The number of sockets.
        :param pulumi.Input[_builtins.int] symlink: The number of symbolic links.
        """
        if block is not None:
            pulumi.set(__self__, "block", block)
        if char is not None:
            pulumi.set(__self__, "char", char)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if regular is not None:
            pulumi.set(__self__, "regular", regular)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if symlink is not None:
            pulumi.set(__self__, "symlink", symlink)

    @_builtins.property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of block devices.
        """
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block", value)

    @_builtins.property
    @pulumi.getter
    def char(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of character devices.
        """
        return pulumi.get(self, "char")

    @char.setter
    def char(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "char", value)

    @_builtins.property
    @pulumi.getter
    def dir(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of directories.
        """
        return pulumi.get(self, "dir")

    @dir.setter
    def dir(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dir", value)

    @_builtins.property
    @pulumi.getter
    def pipe(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of pipe files.
        """
        return pulumi.get(self, "pipe")

    @pipe.setter
    def pipe(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pipe", value)

    @_builtins.property
    @pulumi.getter
    def regular(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of common files.
        """
        return pulumi.get(self, "regular")

    @regular.setter
    def regular(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "regular", value)

    @_builtins.property
    @pulumi.getter
    def socket(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of sockets.
        """
        return pulumi.get(self, "socket")

    @socket.setter
    def socket(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "socket", value)

    @_builtins.property
    @pulumi.getter
    def symlink(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of symbolic links.
        """
        return pulumi.get(self, "symlink")

    @symlink.setter
    def symlink(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "symlink", value)


if not MYPY:
    class TurboObsTargetObsArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Specifies the name of the OBS bucket.

        > Before configuring OBS linkage, please configure bucket policies on the access control page of the OBS bucket and
        set bucket policies for sub users who need to access the OBS bucket: current bucket, all objects in the bucket,
        all operations.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        Specifies the domain name of the region where the OBS bucket belongs.
        """
        attributes: NotRequired[pulumi.Input['TurboObsTargetObsAttributesArgsDict']]
        """
        Specifies the attributes of the storage backend.
        The paramater is not supported for the file systems which are created on or before June 30, 2024 and not upgraded.
        Please submit a service ticket if you need it. [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html)
        The attributes structure is documented below.

        <a name="obs_policy"></a>
        The `policy` block supports:
        """
        policy: NotRequired[pulumi.Input['TurboObsTargetObsPolicyArgsDict']]
        """
        Specifies the auto synchronization policy of the storage backend.
        The policy structure is documented below.
        """
elif False:
    TurboObsTargetObsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TurboObsTargetObsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 attributes: Optional[pulumi.Input['TurboObsTargetObsAttributesArgs']] = None,
                 policy: Optional[pulumi.Input['TurboObsTargetObsPolicyArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Specifies the name of the OBS bucket.
               
               > Before configuring OBS linkage, please configure bucket policies on the access control page of the OBS bucket and
               set bucket policies for sub users who need to access the OBS bucket: current bucket, all objects in the bucket,
               all operations.
        :param pulumi.Input[_builtins.str] endpoint: Specifies the domain name of the region where the OBS bucket belongs.
        :param pulumi.Input['TurboObsTargetObsAttributesArgs'] attributes: Specifies the attributes of the storage backend.
               The paramater is not supported for the file systems which are created on or before June 30, 2024 and not upgraded.
               Please submit a service ticket if you need it. [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html)
               The attributes structure is documented below.
               
               <a name="obs_policy"></a>
               The `policy` block supports:
        :param pulumi.Input['TurboObsTargetObsPolicyArgs'] policy: Specifies the auto synchronization policy of the storage backend.
               The policy structure is documented below.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "endpoint", endpoint)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the OBS bucket.

        > Before configuring OBS linkage, please configure bucket policies on the access control page of the OBS bucket and
        set bucket policies for sub users who need to access the OBS bucket: current bucket, all objects in the bucket,
        all operations.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the domain name of the region where the OBS bucket belongs.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input['TurboObsTargetObsAttributesArgs']]:
        """
        Specifies the attributes of the storage backend.
        The paramater is not supported for the file systems which are created on or before June 30, 2024 and not upgraded.
        Please submit a service ticket if you need it. [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html)
        The attributes structure is documented below.

        <a name="obs_policy"></a>
        The `policy` block supports:
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input['TurboObsTargetObsAttributesArgs']]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['TurboObsTargetObsPolicyArgs']]:
        """
        Specifies the auto synchronization policy of the storage backend.
        The policy structure is documented below.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['TurboObsTargetObsPolicyArgs']]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class TurboObsTargetObsAttributesArgsDict(TypedDict):
        dir_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the permissions on the imported directory.
        The valid value ranges from `0` to `777`.

        > For more details about the fields, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-sfsturbo/CreateBackendTarget.html).
        """
        file_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the permissions on the imported file.
        The valid value ranges from `0` to `777`.
        """
        gid: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the ID of the user group to which the imported object belongs.
        Default value is `0`. The valid value ranges from `0` to `4,294,967,294`.
        """
        uid: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the ID of the user who owns the imported object. Default value is `0`.
        The valid value ranges from `0` to `4,294,967,294`.
        """
elif False:
    TurboObsTargetObsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TurboObsTargetObsAttributesArgs:
    def __init__(__self__, *,
                 dir_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 file_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gid: Optional[pulumi.Input[_builtins.int]] = None,
                 uid: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] dir_mode: Specifies the permissions on the imported directory.
               The valid value ranges from `0` to `777`.
               
               > For more details about the fields, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-sfsturbo/CreateBackendTarget.html).
        :param pulumi.Input[_builtins.str] file_mode: Specifies the permissions on the imported file.
               The valid value ranges from `0` to `777`.
        :param pulumi.Input[_builtins.int] gid: Specifies the ID of the user group to which the imported object belongs.
               Default value is `0`. The valid value ranges from `0` to `4,294,967,294`.
        :param pulumi.Input[_builtins.int] uid: Specifies the ID of the user who owns the imported object. Default value is `0`.
               The valid value ranges from `0` to `4,294,967,294`.
        """
        if dir_mode is not None:
            pulumi.set(__self__, "dir_mode", dir_mode)
        if file_mode is not None:
            pulumi.set(__self__, "file_mode", file_mode)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="dirMode")
    def dir_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the permissions on the imported directory.
        The valid value ranges from `0` to `777`.

        > For more details about the fields, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-sfsturbo/CreateBackendTarget.html).
        """
        return pulumi.get(self, "dir_mode")

    @dir_mode.setter
    def dir_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dir_mode", value)

    @_builtins.property
    @pulumi.getter(name="fileMode")
    def file_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the permissions on the imported file.
        The valid value ranges from `0` to `777`.
        """
        return pulumi.get(self, "file_mode")

    @file_mode.setter
    def file_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_mode", value)

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the ID of the user group to which the imported object belongs.
        Default value is `0`. The valid value ranges from `0` to `4,294,967,294`.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gid", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the ID of the user who owns the imported object. Default value is `0`.
        The valid value ranges from `0` to `4,294,967,294`.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class TurboObsTargetObsPolicyArgsDict(TypedDict):
        auto_export_policy: NotRequired[pulumi.Input['TurboObsTargetObsPolicyAutoExportPolicyArgsDict']]
        """
        Specifies the auto export policy of the storage backend.
        If enabled, all update made on the file system will be automatically exported to the OBS bucket.
        The auto_export_policy structure is documented below.

        <a name="obs_export_policy"></a>
        The `attributes` block supports:
        """
elif False:
    TurboObsTargetObsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TurboObsTargetObsPolicyArgs:
    def __init__(__self__, *,
                 auto_export_policy: Optional[pulumi.Input['TurboObsTargetObsPolicyAutoExportPolicyArgs']] = None):
        """
        :param pulumi.Input['TurboObsTargetObsPolicyAutoExportPolicyArgs'] auto_export_policy: Specifies the auto export policy of the storage backend.
               If enabled, all update made on the file system will be automatically exported to the OBS bucket.
               The auto_export_policy structure is documented below.
               
               <a name="obs_export_policy"></a>
               The `attributes` block supports:
        """
        if auto_export_policy is not None:
            pulumi.set(__self__, "auto_export_policy", auto_export_policy)

    @_builtins.property
    @pulumi.getter(name="autoExportPolicy")
    def auto_export_policy(self) -> Optional[pulumi.Input['TurboObsTargetObsPolicyAutoExportPolicyArgs']]:
        """
        Specifies the auto export policy of the storage backend.
        If enabled, all update made on the file system will be automatically exported to the OBS bucket.
        The auto_export_policy structure is documented below.

        <a name="obs_export_policy"></a>
        The `attributes` block supports:
        """
        return pulumi.get(self, "auto_export_policy")

    @auto_export_policy.setter
    def auto_export_policy(self, value: Optional[pulumi.Input['TurboObsTargetObsPolicyAutoExportPolicyArgs']]):
        pulumi.set(self, "auto_export_policy", value)


if not MYPY:
    class TurboObsTargetObsPolicyAutoExportPolicyArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the type of the data automatically exported to the OBS bucket.
        The valid values are as follows:
        + **NEW**: Indicate add new data. Files created and then modified in the SFS Turbo interworking directory. Any data
        or metadata modifications made will be automatically synchronized to the OBS bucket.
        + **CHANGED**: Indicate modify data. Files previously imported from the OBS bucket and then modified in the SFS Turbo
        interworking directory. Any data or metadata modifications made will be automatically synchronized to the OBS bucket.
        + **DELETED**: Indicate delete data. Files deleted from the SFS Turbo interworking directory. Deletions will be
        automatically synchronized to the OBS bucket, and only such files that were previously exported to the bucket will be
        deleted.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prefix to be matched in the storage backend.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the suffix to be matched in the storage backend.

        <a name="obs_attributes"></a>
        The `auto_export_policy` block supports:
        """
elif False:
    TurboObsTargetObsPolicyAutoExportPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TurboObsTargetObsPolicyAutoExportPolicyArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] events: Specifies the type of the data automatically exported to the OBS bucket.
               The valid values are as follows:
               + **NEW**: Indicate add new data. Files created and then modified in the SFS Turbo interworking directory. Any data
               or metadata modifications made will be automatically synchronized to the OBS bucket.
               + **CHANGED**: Indicate modify data. Files previously imported from the OBS bucket and then modified in the SFS Turbo
               interworking directory. Any data or metadata modifications made will be automatically synchronized to the OBS bucket.
               + **DELETED**: Indicate delete data. Files deleted from the SFS Turbo interworking directory. Deletions will be
               automatically synchronized to the OBS bucket, and only such files that were previously exported to the bucket will be
               deleted.
        :param pulumi.Input[_builtins.str] prefix: Specifies the prefix to be matched in the storage backend.
        :param pulumi.Input[_builtins.str] suffix: Specifies the suffix to be matched in the storage backend.
               
               <a name="obs_attributes"></a>
               The `auto_export_policy` block supports:
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the type of the data automatically exported to the OBS bucket.
        The valid values are as follows:
        + **NEW**: Indicate add new data. Files created and then modified in the SFS Turbo interworking directory. Any data
        or metadata modifications made will be automatically synchronized to the OBS bucket.
        + **CHANGED**: Indicate modify data. Files previously imported from the OBS bucket and then modified in the SFS Turbo
        interworking directory. Any data or metadata modifications made will be automatically synchronized to the OBS bucket.
        + **DELETED**: Indicate delete data. Files deleted from the SFS Turbo interworking directory. Deletions will be
        automatically synchronized to the OBS bucket, and only such files that were previously exported to the bucket will be
        deleted.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prefix to be matched in the storage backend.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the suffix to be matched in the storage backend.

        <a name="obs_attributes"></a>
        The `auto_export_policy` block supports:
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class GetTurbosByTagsMatchArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the matches.
        Currently, only **resource_name** is supported.
        """
        value: _builtins.str
        """
        Specifies the value of the matches.
        If the `value` ends with `*`, prefix search will be performed. e.g. `sfsturbo*` indicates all resources whose names
        start with **sfsturbo** will be returned.
        """
elif False:
    GetTurbosByTagsMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTurbosByTagsMatchArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key of the matches.
               Currently, only **resource_name** is supported.
        :param _builtins.str value: Specifies the value of the matches.
               If the `value` ends with `*`, prefix search will be performed. e.g. `sfsturbo*` indicates all resources whose names
               start with **sfsturbo** will be returned.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the matches.
        Currently, only **resource_name** is supported.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the matches.
        If the `value` ends with `*`, prefix search will be performed. e.g. `sfsturbo*` indicates all resources whose names
        start with **sfsturbo** will be returned.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetTurbosByTagsTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the matches.
        Currently, only **resource_name** is supported.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the values list of the tags.
        Each value can contain a maximum of `255` characters. An empty list for values indicates any value.

        <a name="turbos_matches"></a>
        The `matches` block supports:
        """
elif False:
    GetTurbosByTagsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTurbosByTagsTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the key of the matches.
               Currently, only **resource_name** is supported.
        :param Sequence[_builtins.str] values: Specifies the values list of the tags.
               Each value can contain a maximum of `255` characters. An empty list for values indicates any value.
               
               <a name="turbos_matches"></a>
               The `matches` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the matches.
        Currently, only **resource_name** is supported.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the values list of the tags.
        Each value can contain a maximum of `255` characters. An empty list for values indicates any value.

        <a name="turbos_matches"></a>
        The `matches` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


