# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ComponentActionMetadataArgs',
    'ComponentActionMetadataArgsDict',
    'ComponentConfigurationArgs',
    'ComponentConfigurationArgsDict',
    'ComponentConfigurationsItemArgs',
    'ComponentConfigurationsItemArgsDict',
    'ComponentDeploymentMetadataArgs',
    'ComponentDeploymentMetadataArgsDict',
    'ComponentMetadataArgs',
    'ComponentMetadataArgsDict',
    'ComponentSpecArgs',
    'ComponentSpecArgsDict',
    'ComponentSpecBuildArgs',
    'ComponentSpecBuildArgsDict',
    'ComponentSpecBuildArchiveArgs',
    'ComponentSpecBuildArchiveArgsDict',
    'ComponentSpecResourceLimitArgs',
    'ComponentSpecResourceLimitArgsDict',
    'ComponentSpecSourceArgs',
    'ComponentSpecSourceArgsDict',
    'ComponentSpecSourceCodeArgs',
    'ComponentSpecSourceCodeArgsDict',
    'NotificationRuleNotificationArgs',
    'NotificationRuleNotificationArgsDict',
    'NotificationRuleScopeArgs',
    'NotificationRuleScopeArgsDict',
    'NotificationRuleTriggerPolicyArgs',
    'NotificationRuleTriggerPolicyArgsDict',
    'TimerRuleApplicationArgs',
    'TimerRuleApplicationArgsDict',
    'TimerRuleComponentArgs',
    'TimerRuleComponentArgsDict',
]

MYPY = False

if not MYPY:
    class ComponentActionMetadataArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the action name.  
        The valid values are as follows:
        + **deploy**
        + **configure**
        + **upgrade**
        + **rollback**
        + **start**
        + **restart**
        + **stop**
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the key/value pairs parameters related to the component to be operated.  
        Currently, only `version` is supported.

        > If the `annotations` parameter specified in this resource is inconsistent with the `cae.Component` resource,
        you can handle the changes in the `cae.Component` resource by `lifecycle.ignore_changes` or manual synchronization.
        """
elif False:
    ComponentActionMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentActionMetadataArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the action name.  
               The valid values are as follows:
               + **deploy**
               + **configure**
               + **upgrade**
               + **rollback**
               + **start**
               + **restart**
               + **stop**
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Specifies the key/value pairs parameters related to the component to be operated.  
               Currently, only `version` is supported.
               
               > If the `annotations` parameter specified in this resource is inconsistent with the `cae.Component` resource,
               you can handle the changes in the `cae.Component` resource by `lifecycle.ignore_changes` or manual synchronization.
        """
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the action name.  
        The valid values are as follows:
        + **deploy**
        + **configure**
        + **upgrade**
        + **rollback**
        + **start**
        + **restart**
        + **stop**
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the key/value pairs parameters related to the component to be operated.  
        Currently, only `version` is supported.

        > If the `annotations` parameter specified in this resource is inconsistent with the `cae.Component` resource,
        you can handle the changes in the `cae.Component` resource by `lifecycle.ignore_changes` or manual synchronization.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)


if not MYPY:
    class ComponentConfigurationArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        Specifies the configuration detail, in JSON format.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationData).
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the component configuration.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
elif False:
    ComponentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentConfigurationArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: Specifies the configuration detail, in JSON format.  
               Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationData).
        :param pulumi.Input[_builtins.str] type: Specifies the type of the component configuration.  
               Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the configuration detail, in JSON format.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationData).
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the component configuration.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ComponentConfigurationsItemArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        Specifies the configuration detail, in JSON format.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationData).
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the configuration.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
elif False:
    ComponentConfigurationsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentConfigurationsItemArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: Specifies the configuration detail, in JSON format.  
               Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationData).
        :param pulumi.Input[_builtins.str] type: Specifies the type of the configuration.  
               Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the configuration detail, in JSON format.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationData).
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the configuration.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ComponentDeploymentMetadataArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The action name.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The key/value pairs parameters related to the component to be operated.
        """
elif False:
    ComponentDeploymentMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentDeploymentMetadataArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The action name.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: The key/value pairs parameters related to the component to be operated.
        """
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The action name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The key/value pairs parameters related to the component to be operated.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)


if not MYPY:
    class ComponentMetadataArgsDict(TypedDict):
        annotations: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Specifies the key/value pairs parameters related to the component.
        Currently, only `version` is supported and required.
        The format is `A.B.C` or `A.B.C.D`, A, B, C and D must be integer. e.g.`1.0.0` or `1.0.0.0`

        <a name="component_spec"></a>
        The `spec` block supports:
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the component.
        The name can contain `4` to `32` characters, only lowercase letters, digits, and hyphens (-) allowed.
        The name must start with a lowercase letter and end with lowercase letters and digits.
        """
elif False:
    ComponentMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentMetadataArgs:
    def __init__(__self__, *,
                 annotations: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Specifies the key/value pairs parameters related to the component.
               Currently, only `version` is supported and required.
               The format is `A.B.C` or `A.B.C.D`, A, B, C and D must be integer. e.g.`1.0.0` or `1.0.0.0`
               
               <a name="component_spec"></a>
               The `spec` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the name of the component.
               The name can contain `4` to `32` characters, only lowercase letters, digits, and hyphens (-) allowed.
               The name must start with a lowercase letter and end with lowercase letters and digits.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Specifies the key/value pairs parameters related to the component.
        Currently, only `version` is supported and required.
        The format is `A.B.C` or `A.B.C.D`, A, B, C and D must be integer. e.g.`1.0.0` or `1.0.0.0`

        <a name="component_spec"></a>
        The `spec` block supports:
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the component.
        The name can contain `4` to `32` characters, only lowercase letters, digits, and hyphens (-) allowed.
        The name must start with a lowercase letter and end with lowercase letters and digits.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ComponentSpecArgsDict(TypedDict):
        replica: pulumi.Input[_builtins.int]
        """
        Specifies the instance number of the component. The valid value ranges from `1` to `99`.
        """
        resource_limit: pulumi.Input['ComponentSpecResourceLimitArgsDict']
        """
        Specifies instance specification corresponding to the component.
        The resource_limit structure is documented below.
        """
        runtime: pulumi.Input[_builtins.str]
        """
        Specifies the component runtime to match. The valid values are **Docker**, **Java8**,
        **Java11**, **Java17**, **Tomcat8**, **Tomcat9**, **Python3**, **Nodejs8**, **Nodejs14**, **Nodejs16**, and **Php7**.
        """
        source: pulumi.Input['ComponentSpecSourceArgsDict']
        """
        Specifies the code source configuration information corresponding to the component.
        The source structure is documented below.
        """
        build: NotRequired[pulumi.Input['ComponentSpecBuildArgsDict']]
        """
        Specifies the build information of the code source corresponding to the component.
        The build structure is documented below.

        <a name="component_spec_resource_limit"></a>
        The `resource_limit` block supports:
        """
elif False:
    ComponentSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentSpecArgs:
    def __init__(__self__, *,
                 replica: pulumi.Input[_builtins.int],
                 resource_limit: pulumi.Input['ComponentSpecResourceLimitArgs'],
                 runtime: pulumi.Input[_builtins.str],
                 source: pulumi.Input['ComponentSpecSourceArgs'],
                 build: Optional[pulumi.Input['ComponentSpecBuildArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] replica: Specifies the instance number of the component. The valid value ranges from `1` to `99`.
        :param pulumi.Input['ComponentSpecResourceLimitArgs'] resource_limit: Specifies instance specification corresponding to the component.
               The resource_limit structure is documented below.
        :param pulumi.Input[_builtins.str] runtime: Specifies the component runtime to match. The valid values are **Docker**, **Java8**,
               **Java11**, **Java17**, **Tomcat8**, **Tomcat9**, **Python3**, **Nodejs8**, **Nodejs14**, **Nodejs16**, and **Php7**.
        :param pulumi.Input['ComponentSpecSourceArgs'] source: Specifies the code source configuration information corresponding to the component.
               The source structure is documented below.
        :param pulumi.Input['ComponentSpecBuildArgs'] build: Specifies the build information of the code source corresponding to the component.
               The build structure is documented below.
               
               <a name="component_spec_resource_limit"></a>
               The `resource_limit` block supports:
        """
        pulumi.set(__self__, "replica", replica)
        pulumi.set(__self__, "resource_limit", resource_limit)
        pulumi.set(__self__, "runtime", runtime)
        pulumi.set(__self__, "source", source)
        if build is not None:
            pulumi.set(__self__, "build", build)

    @_builtins.property
    @pulumi.getter
    def replica(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the instance number of the component. The valid value ranges from `1` to `99`.
        """
        return pulumi.get(self, "replica")

    @replica.setter
    def replica(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "replica", value)

    @_builtins.property
    @pulumi.getter(name="resourceLimit")
    def resource_limit(self) -> pulumi.Input['ComponentSpecResourceLimitArgs']:
        """
        Specifies instance specification corresponding to the component.
        The resource_limit structure is documented below.
        """
        return pulumi.get(self, "resource_limit")

    @resource_limit.setter
    def resource_limit(self, value: pulumi.Input['ComponentSpecResourceLimitArgs']):
        pulumi.set(self, "resource_limit", value)

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the component runtime to match. The valid values are **Docker**, **Java8**,
        **Java11**, **Java17**, **Tomcat8**, **Tomcat9**, **Python3**, **Nodejs8**, **Nodejs14**, **Nodejs16**, and **Php7**.
        """
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "runtime", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input['ComponentSpecSourceArgs']:
        """
        Specifies the code source configuration information corresponding to the component.
        The source structure is documented below.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['ComponentSpecSourceArgs']):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def build(self) -> Optional[pulumi.Input['ComponentSpecBuildArgs']]:
        """
        Specifies the build information of the code source corresponding to the component.
        The build structure is documented below.

        <a name="component_spec_resource_limit"></a>
        The `resource_limit` block supports:
        """
        return pulumi.get(self, "build")

    @build.setter
    def build(self, value: Optional[pulumi.Input['ComponentSpecBuildArgs']]):
        pulumi.set(self, "build", value)


if not MYPY:
    class ComponentSpecBuildArgsDict(TypedDict):
        archive: pulumi.Input['ComponentSpecBuildArchiveArgsDict']
        """
        Specifies product configuration after building the code source corresponding to component.
        The archive structure is documented below.
        """
        parameters: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Specifies the key/value pairs configuration information required to build the code source
        corresponding to the component.
        It is required when `source.type` is **code** or **softwarePackage**.
        + **base_image**: Base image address.
        + **build_cmd**: Custom build command.
        + **dockerfile_content**: Custom dockerfile content.
        + **dockerfile_path**: Custom dockerfile file path.
        + **artifact_name**: Select and run the specified JAR package from multiple JAR packages generated during Maven build.
        The JAR package end with **.jar**. Fuzzy match is supported. e.g. `demo-1.0.jar`, `demo*.jar`.

        > `build_cmd`, `dockerfile_path` and `artifact_name` parameters are valid only when `source.type` is set to `code`.
        `dockerfile_path` and `artifact_name` parameters can't be set at the same time.
        `dockerfile_content` is valid only when `source.type` is set to `softwarePackage`.

        <a name="component_spec_build_archive"></a>
        The `archive` block supports:
        """
elif False:
    ComponentSpecBuildArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentSpecBuildArgs:
    def __init__(__self__, *,
                 archive: pulumi.Input['ComponentSpecBuildArchiveArgs'],
                 parameters: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input['ComponentSpecBuildArchiveArgs'] archive: Specifies product configuration after building the code source corresponding to component.
               The archive structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameters: Specifies the key/value pairs configuration information required to build the code source
               corresponding to the component.
               It is required when `source.type` is **code** or **softwarePackage**.
               + **base_image**: Base image address.
               + **build_cmd**: Custom build command.
               + **dockerfile_content**: Custom dockerfile content.
               + **dockerfile_path**: Custom dockerfile file path.
               + **artifact_name**: Select and run the specified JAR package from multiple JAR packages generated during Maven build.
               The JAR package end with **.jar**. Fuzzy match is supported. e.g. `demo-1.0.jar`, `demo*.jar`.
               
               > `build_cmd`, `dockerfile_path` and `artifact_name` parameters are valid only when `source.type` is set to `code`.
               `dockerfile_path` and `artifact_name` parameters can't be set at the same time.
               `dockerfile_content` is valid only when `source.type` is set to `softwarePackage`.
               
               <a name="component_spec_build_archive"></a>
               The `archive` block supports:
        """
        pulumi.set(__self__, "archive", archive)
        pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> pulumi.Input['ComponentSpecBuildArchiveArgs']:
        """
        Specifies product configuration after building the code source corresponding to component.
        The archive structure is documented below.
        """
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: pulumi.Input['ComponentSpecBuildArchiveArgs']):
        pulumi.set(self, "archive", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Specifies the key/value pairs configuration information required to build the code source
        corresponding to the component.
        It is required when `source.type` is **code** or **softwarePackage**.
        + **base_image**: Base image address.
        + **build_cmd**: Custom build command.
        + **dockerfile_content**: Custom dockerfile content.
        + **dockerfile_path**: Custom dockerfile file path.
        + **artifact_name**: Select and run the specified JAR package from multiple JAR packages generated during Maven build.
        The JAR package end with **.jar**. Fuzzy match is supported. e.g. `demo-1.0.jar`, `demo*.jar`.

        > `build_cmd`, `dockerfile_path` and `artifact_name` parameters are valid only when `source.type` is set to `code`.
        `dockerfile_path` and `artifact_name` parameters can't be set at the same time.
        `dockerfile_content` is valid only when `source.type` is set to `softwarePackage`.

        <a name="component_spec_build_archive"></a>
        The `archive` block supports:
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class ComponentSpecBuildArchiveArgsDict(TypedDict):
        artifact_namespace: pulumi.Input[_builtins.str]
        """
        Specifies the name of the SWR organization after the code source
        corresponding to component is built.

        <a name="component_configurations"></a>
        The `configurations` block supports:
        """
elif False:
    ComponentSpecBuildArchiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentSpecBuildArchiveArgs:
    def __init__(__self__, *,
                 artifact_namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] artifact_namespace: Specifies the name of the SWR organization after the code source
               corresponding to component is built.
               
               <a name="component_configurations"></a>
               The `configurations` block supports:
        """
        pulumi.set(__self__, "artifact_namespace", artifact_namespace)

    @_builtins.property
    @pulumi.getter(name="artifactNamespace")
    def artifact_namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the SWR organization after the code source
        corresponding to component is built.

        <a name="component_configurations"></a>
        The `configurations` block supports:
        """
        return pulumi.get(self, "artifact_namespace")

    @artifact_namespace.setter
    def artifact_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "artifact_namespace", value)


if not MYPY:
    class ComponentSpecResourceLimitArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.str]
        """
        Specifies CPU core. The valid values are **500m**, **1000m** and **2000m**.
        """
        memory: pulumi.Input[_builtins.str]
        """
        Specifies memory size. The valid values are **1Gi**, **2Gi** and **4Gi**.

        > If `cpu` parameter is set to `500m`, this parameter cannot be set to `4Gi`.

        <a name="component_spec_source"></a>
        The `source` block supports:
        """
elif False:
    ComponentSpecResourceLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentSpecResourceLimitArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.str],
                 memory: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cpu: Specifies CPU core. The valid values are **500m**, **1000m** and **2000m**.
        :param pulumi.Input[_builtins.str] memory: Specifies memory size. The valid values are **1Gi**, **2Gi** and **4Gi**.
               
               > If `cpu` parameter is set to `500m`, this parameter cannot be set to `4Gi`.
               
               <a name="component_spec_source"></a>
               The `source` block supports:
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies CPU core. The valid values are **500m**, **1000m** and **2000m**.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies memory size. The valid values are **1Gi**, **2Gi** and **4Gi**.

        > If `cpu` parameter is set to `500m`, this parameter cannot be set to `4Gi`.

        <a name="component_spec_source"></a>
        The `source` block supports:
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class ComponentSpecSourceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the component configuration.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
        url: pulumi.Input[_builtins.str]
        """
        Specifies code source URL corresponding to the component.
        + When `type` is **image**, the URL represents image URL.
        + When `type` is **code**, the URL represents Git URL.
        + When `type` is **softwarePackage**, the URL represents software package URL.
        """
        code: NotRequired[pulumi.Input['ComponentSpecSourceCodeArgsDict']]
        """
        Specifies code source repository.
        The code structure is documented below.

        <a name="component_spec_source_code"></a>
        The `code` block supports:
        """
        sub_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the subtype corresponding to the code source.
        If the `source.type` is set to `code`, the `sub_type` parameter means different code repositories.
        The valid values are `DevCloud`, `GitHub`, `GitLab`, `Gitee` and `Bitbucket`.
        If the `source.type` is set to `softwarePackage`, the `sub_type` parameter means different software package repositories.
        The valid values are `BinObs` and `BinDevCloud`.

        > The parameter is required when `source.type` is set to `code` or `softwarePackage`.
        """
elif False:
    ComponentSpecSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentSpecSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 code: Optional[pulumi.Input['ComponentSpecSourceCodeArgs']] = None,
                 sub_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of the component configuration.  
               Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        :param pulumi.Input[_builtins.str] url: Specifies code source URL corresponding to the component.
               + When `type` is **image**, the URL represents image URL.
               + When `type` is **code**, the URL represents Git URL.
               + When `type` is **softwarePackage**, the URL represents software package URL.
        :param pulumi.Input['ComponentSpecSourceCodeArgs'] code: Specifies code source repository.
               The code structure is documented below.
               
               <a name="component_spec_source_code"></a>
               The `code` block supports:
        :param pulumi.Input[_builtins.str] sub_type: Specifies the subtype corresponding to the code source.
               If the `source.type` is set to `code`, the `sub_type` parameter means different code repositories.
               The valid values are `DevCloud`, `GitHub`, `GitLab`, `Gitee` and `Bitbucket`.
               If the `source.type` is set to `softwarePackage`, the `sub_type` parameter means different software package repositories.
               The valid values are `BinObs` and `BinDevCloud`.
               
               > The parameter is required when `source.type` is set to `code` or `softwarePackage`.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the component configuration.  
        Please following [reference documentation](https://support.huaweicloud.com/api-cae/CreateComponentConfiguration.html#CreateComponentConfiguration__request_ConfigurationItem).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies code source URL corresponding to the component.
        + When `type` is **image**, the URL represents image URL.
        + When `type` is **code**, the URL represents Git URL.
        + When `type` is **softwarePackage**, the URL represents software package URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input['ComponentSpecSourceCodeArgs']]:
        """
        Specifies code source repository.
        The code structure is documented below.

        <a name="component_spec_source_code"></a>
        The `code` block supports:
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input['ComponentSpecSourceCodeArgs']]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the subtype corresponding to the code source.
        If the `source.type` is set to `code`, the `sub_type` parameter means different code repositories.
        The valid values are `DevCloud`, `GitHub`, `GitLab`, `Gitee` and `Bitbucket`.
        If the `source.type` is set to `softwarePackage`, the `sub_type` parameter means different software package repositories.
        The valid values are `BinObs` and `BinDevCloud`.

        > The parameter is required when `source.type` is set to `code` or `softwarePackage`.
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_type", value)


if not MYPY:
    class ComponentSpecSourceCodeArgsDict(TypedDict):
        auth_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of authorization corresponding to the code source.
        """
        branch: pulumi.Input[_builtins.str]
        """
        Specifies the branch name of code source repository.
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Specifies the username or organization corresponding to the code source repository.

        <a name="component_spec_build"></a>
        The `build` block supports:
        """
elif False:
    ComponentSpecSourceCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComponentSpecSourceCodeArgs:
    def __init__(__self__, *,
                 auth_name: pulumi.Input[_builtins.str],
                 branch: pulumi.Input[_builtins.str],
                 namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_name: Specifies the name of authorization corresponding to the code source.
        :param pulumi.Input[_builtins.str] branch: Specifies the branch name of code source repository.
        :param pulumi.Input[_builtins.str] namespace: Specifies the username or organization corresponding to the code source repository.
               
               <a name="component_spec_build"></a>
               The `build` block supports:
        """
        pulumi.set(__self__, "auth_name", auth_name)
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="authName")
    def auth_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of authorization corresponding to the code source.
        """
        return pulumi.get(self, "auth_name")

    @auth_name.setter
    def auth_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_name", value)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the branch name of code source repository.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the username or organization corresponding to the code source repository.

        <a name="component_spec_build"></a>
        The `build` block supports:
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class NotificationRuleNotificationArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Specifies the endpoint of the event notification.
        Changing this creates a new resource.
        + If `notification.type` is set to **sms**, the endpoint is a phone number.
        + If `notification.type` is set to **email**, the endpoint is a email address.
        + If `notification.type` is set to **wechat**, the endpoint is a webhook address starting with
        `https://qyapi.weixin.qq.com/cgi-bin/webhook/send`.
        you want to use this parameter, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html)
        to submit a service ticket to apply for it.
        For details about how to obtain a WeCom subscription endpoint, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/smn_faq/smn_faq_0027.html).
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Specifies the protocol of the event notification.
        Changing this creates a new resource.
        The valid values are as follows:
        + **sms**
        + **email**
        + **wechat**
        """
        template: pulumi.Input[_builtins.str]
        """
        Specifies the template language of the event notification.
        Changing this creates a new resource.
        The valid values are as follows:
        + **EN**
        + **ZH**

        <a name="notification_rule_scope"></a>
        The `scope` block supports:
        """
elif False:
    NotificationRuleNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationRuleNotificationArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str],
                 template: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] endpoint: Specifies the endpoint of the event notification.
               Changing this creates a new resource.
               + If `notification.type` is set to **sms**, the endpoint is a phone number.
               + If `notification.type` is set to **email**, the endpoint is a email address.
               + If `notification.type` is set to **wechat**, the endpoint is a webhook address starting with
               `https://qyapi.weixin.qq.com/cgi-bin/webhook/send`.
               you want to use this parameter, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html)
               to submit a service ticket to apply for it.
               For details about how to obtain a WeCom subscription endpoint, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/smn_faq/smn_faq_0027.html).
        :param pulumi.Input[_builtins.str] protocol: Specifies the protocol of the event notification.
               Changing this creates a new resource.
               The valid values are as follows:
               + **sms**
               + **email**
               + **wechat**
        :param pulumi.Input[_builtins.str] template: Specifies the template language of the event notification.
               Changing this creates a new resource.
               The valid values are as follows:
               + **EN**
               + **ZH**
               
               <a name="notification_rule_scope"></a>
               The `scope` block supports:
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the endpoint of the event notification.
        Changing this creates a new resource.
        + If `notification.type` is set to **sms**, the endpoint is a phone number.
        + If `notification.type` is set to **email**, the endpoint is a email address.
        + If `notification.type` is set to **wechat**, the endpoint is a webhook address starting with
        `https://qyapi.weixin.qq.com/cgi-bin/webhook/send`.
        you want to use this parameter, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html)
        to submit a service ticket to apply for it.
        For details about how to obtain a WeCom subscription endpoint, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/smn_faq/smn_faq_0027.html).
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the protocol of the event notification.
        Changing this creates a new resource.
        The valid values are as follows:
        + **sms**
        + **email**
        + **wechat**
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the template language of the event notification.
        Changing this creates a new resource.
        The valid values are as follows:
        + **EN**
        + **ZH**

        <a name="notification_rule_scope"></a>
        The `scope` block supports:
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template", value)


if not MYPY:
    class NotificationRuleScopeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the trigger.  
        The valid values are as follows:
        + **accumulative**
        + **immediately**
        """
        applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of the applications IDs.  
        This parameter is required and available only when the `scope.type` parameter is set to **applications**.
        """
        components: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of the components IDs.  
        This parameter is required and available only when the `scope.type` parameter is set to **components**.

        <a name="notification_rule_trigger_policy"></a>
        The `trigger_policy` block supports:
        """
        environments: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of the environment IDs.  
        This parameter is required and available only when the `scope.type` parameter is set to **environments**.
        """
elif False:
    NotificationRuleScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationRuleScopeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of the trigger.  
               The valid values are as follows:
               + **accumulative**
               + **immediately**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] applications: Specifies the list of the applications IDs.  
               This parameter is required and available only when the `scope.type` parameter is set to **applications**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] components: Specifies the list of the components IDs.  
               This parameter is required and available only when the `scope.type` parameter is set to **components**.
               
               <a name="notification_rule_trigger_policy"></a>
               The `trigger_policy` block supports:
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] environments: Specifies the list of the environment IDs.  
               This parameter is required and available only when the `scope.type` parameter is set to **environments**.
        """
        pulumi.set(__self__, "type", type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the trigger.  
        The valid values are as follows:
        + **accumulative**
        + **immediately**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of the applications IDs.  
        This parameter is required and available only when the `scope.type` parameter is set to **applications**.
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "applications", value)

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of the components IDs.  
        This parameter is required and available only when the `scope.type` parameter is set to **components**.

        <a name="notification_rule_trigger_policy"></a>
        The `trigger_policy` block supports:
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "components", value)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of the environment IDs.  
        This parameter is required and available only when the `scope.type` parameter is set to **environments**.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environments", value)


if not MYPY:
    class NotificationRuleTriggerPolicyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the trigger.  
        The valid values are as follows:
        + **accumulative**
        + **immediately**
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of times the event occurred.  
        The valid value ranges from `1` to `100`.
        This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the condition of the event notification.  
        The valid values are **>** and **>=**.
        This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the trigger period of the event. The unit is second.  
        This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        The valid values are as follows:
        + **300**
        + **1200**
        + **3600**
        + **14400**
        + **86400**
        """
elif False:
    NotificationRuleTriggerPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationRuleTriggerPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of the trigger.  
               The valid values are as follows:
               + **accumulative**
               + **immediately**
        :param pulumi.Input[_builtins.int] count: Specifies the number of times the event occurred.  
               The valid value ranges from `1` to `100`.
               This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        :param pulumi.Input[_builtins.str] operator: Specifies the condition of the event notification.  
               The valid values are **>** and **>=**.
               This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        :param pulumi.Input[_builtins.int] period: Specifies the trigger period of the event. The unit is second.  
               This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
               The valid values are as follows:
               + **300**
               + **1200**
               + **3600**
               + **14400**
               + **86400**
        """
        pulumi.set(__self__, "type", type)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the trigger.  
        The valid values are as follows:
        + **accumulative**
        + **immediately**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of times the event occurred.  
        The valid value ranges from `1` to `100`.
        This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the condition of the event notification.  
        The valid values are **>** and **>=**.
        This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the trigger period of the event. The unit is second.  
        This parameter is required and available only when the `trigger_policy.type` parameter is set to **accumulative**.
        The valid values are as follows:
        + **300**
        + **1200**
        + **3600**
        + **14400**
        + **86400**
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class TimerRuleApplicationArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the component.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the component.
        """
elif False:
    TimerRuleApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TimerRuleApplicationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the component.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the component.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the component.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TimerRuleComponentArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the component.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the component.
        """
elif False:
    TimerRuleComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TimerRuleComponentArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the component.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the component.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the component.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


