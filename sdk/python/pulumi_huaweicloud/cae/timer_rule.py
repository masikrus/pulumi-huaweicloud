# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['TimerRuleArgs', 'TimerRule']

@pulumi.input_type
class TimerRuleArgs:
    def __init__(__self__, *,
                 cron: pulumi.Input[_builtins.str],
                 effective_policy: pulumi.Input[_builtins.str],
                 effective_range: pulumi.Input[_builtins.str],
                 environment_id: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a TimerRule resource.
        :param pulumi.Input[_builtins.str] cron: Specifies the cron expression of the timer rule.  
               The triggered time of the rule must be at least two minutes later than the current time.
               When `effective_policy` is set to **periodic**, the rule can only be executed by week of day.
        :param pulumi.Input[_builtins.str] effective_policy: Specifies the effective policy of the timer rule.  
               The valid values are as follows:
               + **onetime**: The rule is executed only once.
               + **periodic**: The rule is executed periodically.
        :param pulumi.Input[_builtins.str] effective_range: Specifies the effective range of the timer rule.  
               The valid values are as follows:
               + **environment**: The rule takes effect for all components in the environment.
               + **application**: The rule takes effect for all components in the application.
               + **component**: The rule takes effect for the specified components.
        :param pulumi.Input[_builtins.str] environment_id: Specifies the ID of the CAE environment.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] status: Specifies the status of the timer rule.  
               The valid values are as follows:
               + **on**
               + **off**
        :param pulumi.Input[_builtins.str] type: Specifies the type of the timer rule.  
               The valid values are as follows:
               + **stop**: The components will be started in batches. The components that have been started are not affected.
               + **start**: The components will be stopped in batches. The components that have been stopped are not affected.
        :param pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]] applications: Specifies the list of the applications in which the timer rule takes effect.  
               The applications structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **application**.
        :param pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]] components: Specifies the list of the components in which the timer rule takes effect.  
               The components structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **component**.
               
               <a name="timer_rule_applications"></a>
               The `applications` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the name of the component.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used.
               Changing this creates a new resource.
        """
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "effective_policy", effective_policy)
        pulumi.set(__self__, "effective_range", effective_range)
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the cron expression of the timer rule.  
        The triggered time of the rule must be at least two minutes later than the current time.
        When `effective_policy` is set to **periodic**, the rule can only be executed by week of day.
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron", value)

    @_builtins.property
    @pulumi.getter(name="effectivePolicy")
    def effective_policy(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the effective policy of the timer rule.  
        The valid values are as follows:
        + **onetime**: The rule is executed only once.
        + **periodic**: The rule is executed periodically.
        """
        return pulumi.get(self, "effective_policy")

    @effective_policy.setter
    def effective_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effective_policy", value)

    @_builtins.property
    @pulumi.getter(name="effectiveRange")
    def effective_range(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the effective range of the timer rule.  
        The valid values are as follows:
        + **environment**: The rule takes effect for all components in the environment.
        + **application**: The rule takes effect for all components in the application.
        + **component**: The rule takes effect for the specified components.
        """
        return pulumi.get(self, "effective_range")

    @effective_range.setter
    def effective_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effective_range", value)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the CAE environment.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "environment_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the status of the timer rule.  
        The valid values are as follows:
        + **on**
        + **off**
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the timer rule.  
        The valid values are as follows:
        + **stop**: The components will be started in batches. The components that have been started are not affected.
        + **start**: The components will be stopped in batches. The components that have been stopped are not affected.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]]]:
        """
        Specifies the list of the applications in which the timer rule takes effect.  
        The applications structure is documented below.
        This parameter is required and available only when the `effective_range` parameter is set to **application**.
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]]]):
        pulumi.set(self, "applications", value)

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]]]:
        """
        Specifies the list of the components in which the timer rule takes effect.  
        The components structure is documented below.
        This parameter is required and available only when the `effective_range` parameter is set to **component**.

        <a name="timer_rule_applications"></a>
        The `applications` block supports:
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]]]):
        pulumi.set(self, "components", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the resource.
        If omitted, the provider-level region will be used.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class _TimerRuleState:
    def __init__(__self__, *,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]]] = None,
                 cron: Optional[pulumi.Input[_builtins.str]] = None,
                 effective_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 effective_range: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering TimerRule resources.
        :param pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]] applications: Specifies the list of the applications in which the timer rule takes effect.  
               The applications structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **application**.
        :param pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]] components: Specifies the list of the components in which the timer rule takes effect.  
               The components structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **component**.
               
               <a name="timer_rule_applications"></a>
               The `applications` block supports:
        :param pulumi.Input[_builtins.str] cron: Specifies the cron expression of the timer rule.  
               The triggered time of the rule must be at least two minutes later than the current time.
               When `effective_policy` is set to **periodic**, the rule can only be executed by week of day.
        :param pulumi.Input[_builtins.str] effective_policy: Specifies the effective policy of the timer rule.  
               The valid values are as follows:
               + **onetime**: The rule is executed only once.
               + **periodic**: The rule is executed periodically.
        :param pulumi.Input[_builtins.str] effective_range: Specifies the effective range of the timer rule.  
               The valid values are as follows:
               + **environment**: The rule takes effect for all components in the environment.
               + **application**: The rule takes effect for all components in the application.
               + **component**: The rule takes effect for the specified components.
        :param pulumi.Input[_builtins.str] environment_id: Specifies the ID of the CAE environment.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the component.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] status: Specifies the status of the timer rule.  
               The valid values are as follows:
               + **on**
               + **off**
        :param pulumi.Input[_builtins.str] type: Specifies the type of the timer rule.  
               The valid values are as follows:
               + **stop**: The components will be started in batches. The components that have been started are not affected.
               + **start**: The components will be stopped in batches. The components that have been stopped are not affected.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if components is not None:
            pulumi.set(__self__, "components", components)
        if cron is not None:
            pulumi.set(__self__, "cron", cron)
        if effective_policy is not None:
            pulumi.set(__self__, "effective_policy", effective_policy)
        if effective_range is not None:
            pulumi.set(__self__, "effective_range", effective_range)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]]]:
        """
        Specifies the list of the applications in which the timer rule takes effect.  
        The applications structure is documented below.
        This parameter is required and available only when the `effective_range` parameter is set to **application**.
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleApplicationArgs']]]]):
        pulumi.set(self, "applications", value)

    @_builtins.property
    @pulumi.getter
    def components(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]]]:
        """
        Specifies the list of the components in which the timer rule takes effect.  
        The components structure is documented below.
        This parameter is required and available only when the `effective_range` parameter is set to **component**.

        <a name="timer_rule_applications"></a>
        The `applications` block supports:
        """
        return pulumi.get(self, "components")

    @components.setter
    def components(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimerRuleComponentArgs']]]]):
        pulumi.set(self, "components", value)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cron expression of the timer rule.  
        The triggered time of the rule must be at least two minutes later than the current time.
        When `effective_policy` is set to **periodic**, the rule can only be executed by week of day.
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron", value)

    @_builtins.property
    @pulumi.getter(name="effectivePolicy")
    def effective_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the effective policy of the timer rule.  
        The valid values are as follows:
        + **onetime**: The rule is executed only once.
        + **periodic**: The rule is executed periodically.
        """
        return pulumi.get(self, "effective_policy")

    @effective_policy.setter
    def effective_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_policy", value)

    @_builtins.property
    @pulumi.getter(name="effectiveRange")
    def effective_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the effective range of the timer rule.  
        The valid values are as follows:
        + **environment**: The rule takes effect for all components in the environment.
        + **application**: The rule takes effect for all components in the application.
        + **component**: The rule takes effect for the specified components.
        """
        return pulumi.get(self, "effective_range")

    @effective_range.setter
    def effective_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_range", value)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the CAE environment.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the resource.
        If omitted, the provider-level region will be used.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the status of the timer rule.  
        The valid values are as follows:
        + **on**
        + **off**
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the timer rule.  
        The valid values are as follows:
        + **stop**: The components will be started in batches. The components that have been started are not affected.
        + **start**: The components will be stopped in batches. The components that have been stopped are not affected.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


@pulumi.type_token("huaweicloud:cae/timerRule:TimerRule")
class TimerRule(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleApplicationArgs', 'TimerRuleApplicationArgsDict']]]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleComponentArgs', 'TimerRuleComponentArgsDict']]]]] = None,
                 cron: Optional[pulumi.Input[_builtins.str]] = None,
                 effective_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 effective_range: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        Use this resource to manage a timer rule for starting and stopping components within HuaweiCloud.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        environment_id = config.require_object("environmentId")
        rule_name = config.require_object("ruleName")
        cron = config.require_object("cron")
        component_configurations = config.require_object("componentConfigurations")
        test = huaweicloud.cae.TimerRule("test",
            components=[{
                "id": entry["value"]["id"],
                "name": entry["value"]["name"],
            } for entry in [{"key": k, "value": v} for k, v in component_configurations]],
            environment_id=environment_id,
            name=rule_name,
            type="start",
            status="on",
            effective_range="component",
            effective_policy="onetime",
            cron=cron)
        ```

        ## Import

        The resource can be imported using `environment_id` and `name`, separated by a slash (/), e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:cae/timerRule:TimerRule test <environment_id>/<name>
        ```

        Note that the imported state may not be identical to your resource definition, due to some attributes missing from the

        API response, security or some other reason.

        The missing attributes include: `status`.

        It is generally recommended running `pulumi preview` after importing the resource.

        You can then decide if changes should be applied to the resource, or the resource definition should be updated to

        align with the resource. Also you can ignore changes as below.

        hcl

        resource "huaweicloud_cae_timer_rule" "test" {

          ...

          lifecycle {

            ignore_changes = [
            
              status,
            
            ]

          }

        }

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleApplicationArgs', 'TimerRuleApplicationArgsDict']]]] applications: Specifies the list of the applications in which the timer rule takes effect.  
               The applications structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **application**.
        :param pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleComponentArgs', 'TimerRuleComponentArgsDict']]]] components: Specifies the list of the components in which the timer rule takes effect.  
               The components structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **component**.
               
               <a name="timer_rule_applications"></a>
               The `applications` block supports:
        :param pulumi.Input[_builtins.str] cron: Specifies the cron expression of the timer rule.  
               The triggered time of the rule must be at least two minutes later than the current time.
               When `effective_policy` is set to **periodic**, the rule can only be executed by week of day.
        :param pulumi.Input[_builtins.str] effective_policy: Specifies the effective policy of the timer rule.  
               The valid values are as follows:
               + **onetime**: The rule is executed only once.
               + **periodic**: The rule is executed periodically.
        :param pulumi.Input[_builtins.str] effective_range: Specifies the effective range of the timer rule.  
               The valid values are as follows:
               + **environment**: The rule takes effect for all components in the environment.
               + **application**: The rule takes effect for all components in the application.
               + **component**: The rule takes effect for the specified components.
        :param pulumi.Input[_builtins.str] environment_id: Specifies the ID of the CAE environment.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the component.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] status: Specifies the status of the timer rule.  
               The valid values are as follows:
               + **on**
               + **off**
        :param pulumi.Input[_builtins.str] type: Specifies the type of the timer rule.  
               The valid values are as follows:
               + **stop**: The components will be started in batches. The components that have been started are not affected.
               + **start**: The components will be stopped in batches. The components that have been stopped are not affected.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: TimerRuleArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Use this resource to manage a timer rule for starting and stopping components within HuaweiCloud.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        environment_id = config.require_object("environmentId")
        rule_name = config.require_object("ruleName")
        cron = config.require_object("cron")
        component_configurations = config.require_object("componentConfigurations")
        test = huaweicloud.cae.TimerRule("test",
            components=[{
                "id": entry["value"]["id"],
                "name": entry["value"]["name"],
            } for entry in [{"key": k, "value": v} for k, v in component_configurations]],
            environment_id=environment_id,
            name=rule_name,
            type="start",
            status="on",
            effective_range="component",
            effective_policy="onetime",
            cron=cron)
        ```

        ## Import

        The resource can be imported using `environment_id` and `name`, separated by a slash (/), e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:cae/timerRule:TimerRule test <environment_id>/<name>
        ```

        Note that the imported state may not be identical to your resource definition, due to some attributes missing from the

        API response, security or some other reason.

        The missing attributes include: `status`.

        It is generally recommended running `pulumi preview` after importing the resource.

        You can then decide if changes should be applied to the resource, or the resource definition should be updated to

        align with the resource. Also you can ignore changes as below.

        hcl

        resource "huaweicloud_cae_timer_rule" "test" {

          ...

          lifecycle {

            ignore_changes = [
            
              status,
            
            ]

          }

        }

        :param str resource_name: The name of the resource.
        :param TimerRuleArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(TimerRuleArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleApplicationArgs', 'TimerRuleApplicationArgsDict']]]]] = None,
                 components: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleComponentArgs', 'TimerRuleComponentArgsDict']]]]] = None,
                 cron: Optional[pulumi.Input[_builtins.str]] = None,
                 effective_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 effective_range: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = TimerRuleArgs.__new__(TimerRuleArgs)

            __props__.__dict__["applications"] = applications
            __props__.__dict__["components"] = components
            if cron is None and not opts.urn:
                raise TypeError("Missing required property 'cron'")
            __props__.__dict__["cron"] = cron
            if effective_policy is None and not opts.urn:
                raise TypeError("Missing required property 'effective_policy'")
            __props__.__dict__["effective_policy"] = effective_policy
            if effective_range is None and not opts.urn:
                raise TypeError("Missing required property 'effective_range'")
            __props__.__dict__["effective_range"] = effective_range
            if environment_id is None and not opts.urn:
                raise TypeError("Missing required property 'environment_id'")
            __props__.__dict__["environment_id"] = environment_id
            __props__.__dict__["name"] = name
            __props__.__dict__["region"] = region
            if status is None and not opts.urn:
                raise TypeError("Missing required property 'status'")
            __props__.__dict__["status"] = status
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
        super(TimerRule, __self__).__init__(
            'huaweicloud:cae/timerRule:TimerRule',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            applications: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleApplicationArgs', 'TimerRuleApplicationArgsDict']]]]] = None,
            components: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleComponentArgs', 'TimerRuleComponentArgsDict']]]]] = None,
            cron: Optional[pulumi.Input[_builtins.str]] = None,
            effective_policy: Optional[pulumi.Input[_builtins.str]] = None,
            effective_range: Optional[pulumi.Input[_builtins.str]] = None,
            environment_id: Optional[pulumi.Input[_builtins.str]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            region: Optional[pulumi.Input[_builtins.str]] = None,
            status: Optional[pulumi.Input[_builtins.str]] = None,
            type: Optional[pulumi.Input[_builtins.str]] = None) -> 'TimerRule':
        """
        Get an existing TimerRule resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleApplicationArgs', 'TimerRuleApplicationArgsDict']]]] applications: Specifies the list of the applications in which the timer rule takes effect.  
               The applications structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **application**.
        :param pulumi.Input[Sequence[pulumi.Input[Union['TimerRuleComponentArgs', 'TimerRuleComponentArgsDict']]]] components: Specifies the list of the components in which the timer rule takes effect.  
               The components structure is documented below.
               This parameter is required and available only when the `effective_range` parameter is set to **component**.
               
               <a name="timer_rule_applications"></a>
               The `applications` block supports:
        :param pulumi.Input[_builtins.str] cron: Specifies the cron expression of the timer rule.  
               The triggered time of the rule must be at least two minutes later than the current time.
               When `effective_policy` is set to **periodic**, the rule can only be executed by week of day.
        :param pulumi.Input[_builtins.str] effective_policy: Specifies the effective policy of the timer rule.  
               The valid values are as follows:
               + **onetime**: The rule is executed only once.
               + **periodic**: The rule is executed periodically.
        :param pulumi.Input[_builtins.str] effective_range: Specifies the effective range of the timer rule.  
               The valid values are as follows:
               + **environment**: The rule takes effect for all components in the environment.
               + **application**: The rule takes effect for all components in the application.
               + **component**: The rule takes effect for the specified components.
        :param pulumi.Input[_builtins.str] environment_id: Specifies the ID of the CAE environment.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the component.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] status: Specifies the status of the timer rule.  
               The valid values are as follows:
               + **on**
               + **off**
        :param pulumi.Input[_builtins.str] type: Specifies the type of the timer rule.  
               The valid values are as follows:
               + **stop**: The components will be started in batches. The components that have been started are not affected.
               + **start**: The components will be stopped in batches. The components that have been stopped are not affected.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _TimerRuleState.__new__(_TimerRuleState)

        __props__.__dict__["applications"] = applications
        __props__.__dict__["components"] = components
        __props__.__dict__["cron"] = cron
        __props__.__dict__["effective_policy"] = effective_policy
        __props__.__dict__["effective_range"] = effective_range
        __props__.__dict__["environment_id"] = environment_id
        __props__.__dict__["name"] = name
        __props__.__dict__["region"] = region
        __props__.__dict__["status"] = status
        __props__.__dict__["type"] = type
        return TimerRule(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter
    def applications(self) -> pulumi.Output[Optional[Sequence['outputs.TimerRuleApplication']]]:
        """
        Specifies the list of the applications in which the timer rule takes effect.  
        The applications structure is documented below.
        This parameter is required and available only when the `effective_range` parameter is set to **application**.
        """
        return pulumi.get(self, "applications")

    @_builtins.property
    @pulumi.getter
    def components(self) -> pulumi.Output[Optional[Sequence['outputs.TimerRuleComponent']]]:
        """
        Specifies the list of the components in which the timer rule takes effect.  
        The components structure is documented below.
        This parameter is required and available only when the `effective_range` parameter is set to **component**.

        <a name="timer_rule_applications"></a>
        The `applications` block supports:
        """
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the cron expression of the timer rule.  
        The triggered time of the rule must be at least two minutes later than the current time.
        When `effective_policy` is set to **periodic**, the rule can only be executed by week of day.
        """
        return pulumi.get(self, "cron")

    @_builtins.property
    @pulumi.getter(name="effectivePolicy")
    def effective_policy(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the effective policy of the timer rule.  
        The valid values are as follows:
        + **onetime**: The rule is executed only once.
        + **periodic**: The rule is executed periodically.
        """
        return pulumi.get(self, "effective_policy")

    @_builtins.property
    @pulumi.getter(name="effectiveRange")
    def effective_range(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the effective range of the timer rule.  
        The valid values are as follows:
        + **environment**: The rule takes effect for all components in the environment.
        + **application**: The rule takes effect for all components in the application.
        + **component**: The rule takes effect for the specified components.
        """
        return pulumi.get(self, "effective_range")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the ID of the CAE environment.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the region in which to create the resource.
        If omitted, the provider-level region will be used.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the status of the timer rule.  
        The valid values are as follows:
        + **on**
        + **off**
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the type of the timer rule.  
        The valid values are as follows:
        + **stop**: The components will be started in batches. The components that have been started are not affected.
        + **start**: The components will be stopped in batches. The components that have been stopped are not affected.
        """
        return pulumi.get(self, "type")

