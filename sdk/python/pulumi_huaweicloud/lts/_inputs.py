# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccessRuleFileArgs',
    'AccessRuleFileArgsDict',
    'AccessRuleFileLogStreamInfoArgs',
    'AccessRuleFileLogStreamInfoArgsDict',
    'AomAccessAccessRuleArgs',
    'AomAccessAccessRuleArgsDict',
    'CceAccessAccessConfigArgs',
    'CceAccessAccessConfigArgsDict',
    'CceAccessAccessConfigMultiLogFormatArgs',
    'CceAccessAccessConfigMultiLogFormatArgsDict',
    'CceAccessAccessConfigSingleLogFormatArgs',
    'CceAccessAccessConfigSingleLogFormatArgsDict',
    'CceAccessAccessConfigWindowsLogInfoArgs',
    'CceAccessAccessConfigWindowsLogInfoArgsDict',
    'CceAccessDemoFieldArgs',
    'CceAccessDemoFieldArgsDict',
    'CceAccessProcessorArgs',
    'CceAccessProcessorArgsDict',
    'HostAccessAccessConfigArgs',
    'HostAccessAccessConfigArgsDict',
    'HostAccessAccessConfigMultiLogFormatArgs',
    'HostAccessAccessConfigMultiLogFormatArgsDict',
    'HostAccessAccessConfigSingleLogFormatArgs',
    'HostAccessAccessConfigSingleLogFormatArgsDict',
    'HostAccessAccessConfigWindowsLogInfoArgs',
    'HostAccessAccessConfigWindowsLogInfoArgsDict',
    'HostAccessDemoFieldArgs',
    'HostAccessDemoFieldArgsDict',
    'HostAccessProcessorArgs',
    'HostAccessProcessorArgsDict',
    'KeywordsAlarmRuleFrequencyArgs',
    'KeywordsAlarmRuleFrequencyArgsDict',
    'KeywordsAlarmRuleKeywordsRequestArgs',
    'KeywordsAlarmRuleKeywordsRequestArgsDict',
    'KeywordsAlarmRuleNotificationRuleArgs',
    'KeywordsAlarmRuleNotificationRuleArgsDict',
    'KeywordsAlarmRuleNotificationRuleTopicArgs',
    'KeywordsAlarmRuleNotificationRuleTopicArgsDict',
    'KeywordsAlarmRuleNotificationSaveRuleArgs',
    'KeywordsAlarmRuleNotificationSaveRuleArgsDict',
    'KeywordsAlarmRuleNotificationSaveRuleTopicArgs',
    'KeywordsAlarmRuleNotificationSaveRuleTopicArgsDict',
    'LogConvergeLogMappingConfigArgs',
    'LogConvergeLogMappingConfigArgsDict',
    'LogConvergeLogMappingConfigLogStreamConfigArgs',
    'LogConvergeLogMappingConfigLogStreamConfigArgsDict',
    'MetricRuleAggregatorArgs',
    'MetricRuleAggregatorArgsDict',
    'MetricRuleFilterArgs',
    'MetricRuleFilterArgsDict',
    'MetricRuleFilterFilterArgs',
    'MetricRuleFilterFilterArgsDict',
    'MetricRuleFilterFilterFilterArgs',
    'MetricRuleFilterFilterFilterArgsDict',
    'MetricRuleSamplerArgs',
    'MetricRuleSamplerArgsDict',
    'MetricRuleSinkArgs',
    'MetricRuleSinkArgsDict',
    'NotificationTemplateTemplateArgs',
    'NotificationTemplateTemplateArgsDict',
    'RegisterKafkaInstanceConnectInfoArgs',
    'RegisterKafkaInstanceConnectInfoArgsDict',
    'SqlAlarmRuleFrequencyArgs',
    'SqlAlarmRuleFrequencyArgsDict',
    'SqlAlarmRuleNotificationRuleArgs',
    'SqlAlarmRuleNotificationRuleArgsDict',
    'SqlAlarmRuleNotificationRuleTopicArgs',
    'SqlAlarmRuleNotificationRuleTopicArgsDict',
    'SqlAlarmRuleNotificationSaveRuleArgs',
    'SqlAlarmRuleNotificationSaveRuleArgsDict',
    'SqlAlarmRuleNotificationSaveRuleTopicArgs',
    'SqlAlarmRuleNotificationSaveRuleTopicArgsDict',
    'SqlAlarmRuleSqlRequestArgs',
    'SqlAlarmRuleSqlRequestArgsDict',
    'StreamIndexConfigurationFieldArgs',
    'StreamIndexConfigurationFieldArgsDict',
    'StreamIndexConfigurationFieldLtsSubFieldsInfoListArgs',
    'StreamIndexConfigurationFieldLtsSubFieldsInfoListArgsDict',
    'StreamIndexConfigurationFullTextIndexArgs',
    'StreamIndexConfigurationFullTextIndexArgsDict',
    'StructTemplateDemoFieldArgs',
    'StructTemplateDemoFieldArgsDict',
    'StructTemplateTagFieldArgs',
    'StructTemplateTagFieldArgsDict',
    'StructingTemplateDemoFieldArgs',
    'StructingTemplateDemoFieldArgsDict',
    'StructingTemplateTagFieldArgs',
    'StructingTemplateTagFieldArgsDict',
    'StructuringConfigurationDemoFieldArgs',
    'StructuringConfigurationDemoFieldArgsDict',
    'StructuringConfigurationTagFieldArgs',
    'StructuringConfigurationTagFieldArgsDict',
    'StructuringCustomConfigurationDemoFieldArgs',
    'StructuringCustomConfigurationDemoFieldArgsDict',
    'StructuringCustomConfigurationTagFieldArgs',
    'StructuringCustomConfigurationTagFieldArgsDict',
    'TransferLogStreamArgs',
    'TransferLogStreamArgsDict',
    'TransferLogTransferInfoArgs',
    'TransferLogTransferInfoArgsDict',
    'TransferLogTransferInfoLogAgencyTransferArgs',
    'TransferLogTransferInfoLogAgencyTransferArgsDict',
    'TransferLogTransferInfoLogTransferDetailArgs',
    'TransferLogTransferInfoLogTransferDetailArgsDict',
    'GetAlarmsSortArgs',
    'GetAlarmsSortArgsDict',
    'GetHostsFilterArgs',
    'GetHostsFilterArgsDict',
]

MYPY = False

if not MYPY:
    class AccessRuleFileArgsDict(TypedDict):
        file_name: pulumi.Input[_builtins.str]
        log_stream_infos: pulumi.Input[Sequence[pulumi.Input['AccessRuleFileLogStreamInfoArgsDict']]]
elif False:
    AccessRuleFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessRuleFileArgs:
    def __init__(__self__, *,
                 file_name: pulumi.Input[_builtins.str],
                 log_stream_infos: pulumi.Input[Sequence[pulumi.Input['AccessRuleFileLogStreamInfoArgs']]]):
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "log_stream_infos", log_stream_infos)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_name", value)

    @_builtins.property
    @pulumi.getter(name="logStreamInfos")
    def log_stream_infos(self) -> pulumi.Input[Sequence[pulumi.Input['AccessRuleFileLogStreamInfoArgs']]]:
        return pulumi.get(self, "log_stream_infos")

    @log_stream_infos.setter
    def log_stream_infos(self, value: pulumi.Input[Sequence[pulumi.Input['AccessRuleFileLogStreamInfoArgs']]]):
        pulumi.set(self, "log_stream_infos", value)


if not MYPY:
    class AccessRuleFileLogStreamInfoArgsDict(TypedDict):
        target_log_group_id: pulumi.Input[_builtins.str]
        target_log_group_name: pulumi.Input[_builtins.str]
        target_log_stream_id: pulumi.Input[_builtins.str]
        target_log_stream_name: pulumi.Input[_builtins.str]
elif False:
    AccessRuleFileLogStreamInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessRuleFileLogStreamInfoArgs:
    def __init__(__self__, *,
                 target_log_group_id: pulumi.Input[_builtins.str],
                 target_log_group_name: pulumi.Input[_builtins.str],
                 target_log_stream_id: pulumi.Input[_builtins.str],
                 target_log_stream_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "target_log_group_id", target_log_group_id)
        pulumi.set(__self__, "target_log_group_name", target_log_group_name)
        pulumi.set(__self__, "target_log_stream_id", target_log_stream_id)
        pulumi.set(__self__, "target_log_stream_name", target_log_stream_name)

    @_builtins.property
    @pulumi.getter(name="targetLogGroupId")
    def target_log_group_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_log_group_id")

    @target_log_group_id.setter
    def target_log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="targetLogGroupName")
    def target_log_group_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_log_group_name")

    @target_log_group_name.setter
    def target_log_group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="targetLogStreamId")
    def target_log_stream_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_log_stream_id")

    @target_log_stream_id.setter
    def target_log_stream_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_log_stream_id", value)

    @_builtins.property
    @pulumi.getter(name="targetLogStreamName")
    def target_log_stream_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target_log_stream_name")

    @target_log_stream_name.setter
    def target_log_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_log_stream_name", value)


if not MYPY:
    class AomAccessAccessRuleArgsDict(TypedDict):
        file_name: pulumi.Input[_builtins.str]
        """
        Specifies the path name.
        + When collecting access all logs, set this field to `__ALL_FILES__`.
        + When collecting specify log paths, the matching rule should be `^\\/[A-Za-z0-9.*_\\/-]+|stdout\\.log|`, such as
        `/test/*` or `/test/demo.log`. Up to two asterisks (*) are allowed.
        """
        log_group_id: pulumi.Input[_builtins.str]
        """
        Specifies the log group ID.
        """
        log_group_name: pulumi.Input[_builtins.str]
        """
        Specifies the log group name.
        """
        log_stream_id: pulumi.Input[_builtins.str]
        """
        Specifies the log stream ID.
        """
        log_stream_name: pulumi.Input[_builtins.str]
        """
        Specifies the log stream name.
        """
elif False:
    AomAccessAccessRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AomAccessAccessRuleArgs:
    def __init__(__self__, *,
                 file_name: pulumi.Input[_builtins.str],
                 log_group_id: pulumi.Input[_builtins.str],
                 log_group_name: pulumi.Input[_builtins.str],
                 log_stream_id: pulumi.Input[_builtins.str],
                 log_stream_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] file_name: Specifies the path name.
               + When collecting access all logs, set this field to `__ALL_FILES__`.
               + When collecting specify log paths, the matching rule should be `^\\/[A-Za-z0-9.*_\\/-]+|stdout\\.log|`, such as
               `/test/*` or `/test/demo.log`. Up to two asterisks (*) are allowed.
        :param pulumi.Input[_builtins.str] log_group_id: Specifies the log group ID.
        :param pulumi.Input[_builtins.str] log_group_name: Specifies the log group name.
        :param pulumi.Input[_builtins.str] log_stream_id: Specifies the log stream ID.
        :param pulumi.Input[_builtins.str] log_stream_name: Specifies the log stream name.
        """
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the path name.
        + When collecting access all logs, set this field to `__ALL_FILES__`.
        + When collecting specify log paths, the matching rule should be `^\\/[A-Za-z0-9.*_\\/-]+|stdout\\.log|`, such as
        `/test/*` or `/test/demo.log`. Up to two asterisks (*) are allowed.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_name", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log group ID.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log group name.
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log stream ID.
        """
        return pulumi.get(self, "log_stream_id")

    @log_stream_id.setter
    def log_stream_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_stream_id", value)

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log stream name.
        """
        return pulumi.get(self, "log_stream_name")

    @log_stream_name.setter
    def log_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_stream_name", value)


if not MYPY:
    class CceAccessAccessConfigArgsDict(TypedDict):
        path_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the CCE access. The options are as follows:
        + **container_stdout**
        + **container_file**
        + **host_file**
        """
        black_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the collection path blacklist.
        """
        container_name_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the regular expression matching of kubernetes container names.
        LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
        leave this field empty.
        """
        custom_key_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the custom key/value pairs of the CCE access.  
        Changing this creates a new resource.
        """
        exclude_envs: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the environment variable blacklist. A maximum of `30` tags can be
        created. The key names must be unique. LTS will exclude all containers with environment variables containing either
        an environment variable key with an empty corresponding environment variable value, or an environment variable key
        with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
        expression matching.
        """
        exclude_envs_logical: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the logical relationship between multiple environment variable
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        exclude_k8s_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the kubernetes label blacklist. A maximum of `30` tags can be
        created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
        excluded. If labelValue is not empty, only containers whose K8s label contains `LabelKey=LabelValue` are excluded.
        LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
        OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
        """
        exclude_k8s_labels_logical: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the logical relationship between multiple kubernetes label
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        exclude_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the container label blacklist. A maximum of `30` tags can be created.
        The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
        excluded. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
        excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
        are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
        """
        exclude_labels_logical: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the logical relationship between multiple container label
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        include_envs: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the environment variable whitelist. A maximum of `30` tags can be
        created. The key names must be unique. LTS will match all containers with environment variables containing either
        an environment variable key with an empty corresponding environment variable value, or an environment variable key
        with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
        expression matching.
        """
        include_envs_logical: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the logical relationship between multiple environment variable
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        include_k8s_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the kubernetes label whitelist. A maximum of `30` tags can be
        created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
        matched. If labelValue is not empty, only containers whose K8s Label contains `LabelKey=LabelValue` are matched.
        LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
        OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
        """
        include_k8s_labels_logical: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the logical relationship between multiple kubernetes label
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        include_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the container label whitelist. A maximum of `30` tags can be created.
        The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
        matched. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
        matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
        are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
        """
        include_labels_logical: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the logical relationship between multiple container label
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        log_envs: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the environment variable tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
        corresponding environment variable value. For example, if you enter `app` as the key and `app_alias` as the value,
        when the kubernetes environment variable contains `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        log_k8s: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the kubernetes label log tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
        value. For example, if you enter `app` as the key and `app_alias` as the value, when the K8s label contains
        `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        log_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the container label log tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
        label value. For example, if you enter `app` as the key and `app_alias` as the value, when the Container label
        contains `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        multi_log_format: NotRequired[pulumi.Input['CceAccessAccessConfigMultiLogFormatArgsDict']]
        """
        Specifies the configuration multi-line logs. Multiple lines of exception log
        events can be displayed as a single log event. This is helpful when you check logs to locate problems.
        The multi_log_format structure is documented below.

        > `single_log_format` or `multi_log_format` must be specified.
        """
        name_space_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the regular expression matching of kubernetes namespaces.
        LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
        leave this field empty.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the collection paths. Required when `path_type` is **container_file**
        or **host_file**.
        """
        pod_name_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the regular expression matching of kubernetes pods.
        LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
        leave this field empty.
        """
        repeat_collect: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to allow repeated file collection.  
        Defaults to **false**.
        + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
        This function is available only to certain ICAgent versions, please refer to the documentation.
        + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.
        """
        single_log_format: NotRequired[pulumi.Input['CceAccessAccessConfigSingleLogFormatArgsDict']]
        """
        Specifies the configuration single-line logs. Each log line is displayed
        as a single log event.
        The single_log_format structure is documented below.
        """
        stderr: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether error output is standard. Default is **false**.

        >  If the value of `path_type` is **container_stdout**, `stdout` or `stderr` must be **true**.
        """
        stdout: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether output is standard. Default is false.
        """
        system_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of system built-in fields of the CCE access.  
        Changing this creates a new resource.
        If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
        the system as **pathfile**.
        If `system_fields` is specified, **pathFile** must be included.
        The valid values are as follows:
        + **pathFile**
        + **hostName**
        + **hostId**
        + **hostIP**
        + **hostIPv6**
        + **clusterId**
        + **podName**
        + **appName**
        + **containerName**
        + **nameSpace**
        + **category**
        + **serviceID**
        + **podIp**
        + **clusterName**
        + **workloadType**
        + **image_name**

        > These parameters include `name_space_regex`, `pod_name_regex`, `container_name_regex`, `log_labels`,
        `include_labels_logical`, `include_labels`, `exclude_labels_logical`, `exclude_labels`, `log_envs`,
        `include_envs_logical`, `include_envs`, `exclude_envs_logical`, `exclude_envs`, `log_k8s`,
        `include_k8s_labels_logical`, `include_k8s_labels`, `exclude_k8s_labels_logical` and
        `exclude_k8s_labels` are available, only `path_type` is not **host_file**.

        <a name="block_access_config_single_log_format"></a>
        The `single_log_format` block supports:
        """
        windows_log_info: NotRequired[pulumi.Input['CceAccessAccessConfigWindowsLogInfoArgsDict']]
        """
        Specifies the configuration of Windows event logs. Required when
        `path_type` is **container_file** or **container_stdout**.
        The windows_log_info structure is documented below.
        """
elif False:
    CceAccessAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceAccessAccessConfigArgs:
    def __init__(__self__, *,
                 path_type: pulumi.Input[_builtins.str],
                 black_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 container_name_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_key_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 exclude_envs: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 exclude_envs_logical: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_k8s_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 exclude_k8s_labels_logical: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 exclude_labels_logical: Optional[pulumi.Input[_builtins.str]] = None,
                 include_envs: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 include_envs_logical: Optional[pulumi.Input[_builtins.str]] = None,
                 include_k8s_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 include_k8s_labels_logical: Optional[pulumi.Input[_builtins.str]] = None,
                 include_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 include_labels_logical: Optional[pulumi.Input[_builtins.str]] = None,
                 log_envs: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 log_k8s: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 log_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 multi_log_format: Optional[pulumi.Input['CceAccessAccessConfigMultiLogFormatArgs']] = None,
                 name_space_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pod_name_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 repeat_collect: Optional[pulumi.Input[_builtins.bool]] = None,
                 single_log_format: Optional[pulumi.Input['CceAccessAccessConfigSingleLogFormatArgs']] = None,
                 stderr: Optional[pulumi.Input[_builtins.bool]] = None,
                 stdout: Optional[pulumi.Input[_builtins.bool]] = None,
                 system_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 windows_log_info: Optional[pulumi.Input['CceAccessAccessConfigWindowsLogInfoArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] path_type: Specifies the type of the CCE access. The options are as follows:
               + **container_stdout**
               + **container_file**
               + **host_file**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] black_paths: Specifies the collection path blacklist.
        :param pulumi.Input[_builtins.str] container_name_regex: Specifies the regular expression matching of kubernetes container names.
               LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
               leave this field empty.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_key_value: Specifies the custom key/value pairs of the CCE access.  
               Changing this creates a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] exclude_envs: Specifies the environment variable blacklist. A maximum of `30` tags can be
               created. The key names must be unique. LTS will exclude all containers with environment variables containing either
               an environment variable key with an empty corresponding environment variable value, or an environment variable key
               with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
               expression matching.
        :param pulumi.Input[_builtins.str] exclude_envs_logical: Specifies the logical relationship between multiple environment variable
               blacklists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] exclude_k8s_labels: Specifies the kubernetes label blacklist. A maximum of `30` tags can be
               created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
               excluded. If labelValue is not empty, only containers whose K8s label contains `LabelKey=LabelValue` are excluded.
               LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
               OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
        :param pulumi.Input[_builtins.str] exclude_k8s_labels_logical: Specifies the logical relationship between multiple kubernetes label
               blacklists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] exclude_labels: Specifies the container label blacklist. A maximum of `30` tags can be created.
               The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
               excluded. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
               excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
               are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
        :param pulumi.Input[_builtins.str] exclude_labels_logical: Specifies the logical relationship between multiple container label
               blacklists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] include_envs: Specifies the environment variable whitelist. A maximum of `30` tags can be
               created. The key names must be unique. LTS will match all containers with environment variables containing either
               an environment variable key with an empty corresponding environment variable value, or an environment variable key
               with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
               expression matching.
        :param pulumi.Input[_builtins.str] include_envs_logical: Specifies the logical relationship between multiple environment variable
               whitelists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] include_k8s_labels: Specifies the kubernetes label whitelist. A maximum of `30` tags can be
               created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
               matched. If labelValue is not empty, only containers whose K8s Label contains `LabelKey=LabelValue` are matched.
               LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
               OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
        :param pulumi.Input[_builtins.str] include_k8s_labels_logical: Specifies the logical relationship between multiple kubernetes label
               whitelists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] include_labels: Specifies the container label whitelist. A maximum of `30` tags can be created.
               The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
               matched. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
               matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
               are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
        :param pulumi.Input[_builtins.str] include_labels_logical: Specifies the logical relationship between multiple container label
               whitelists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] log_envs: Specifies the environment variable tag. A maximum of `30` tags can be created.
               The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
               corresponding environment variable value. For example, if you enter `app` as the key and `app_alias` as the value,
               when the kubernetes environment variable contains `app=lts`, `{app_alias: lts}` will be added to the log.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] log_k8s: Specifies the kubernetes label log tag. A maximum of `30` tags can be created.
               The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
               value. For example, if you enter `app` as the key and `app_alias` as the value, when the K8s label contains
               `app=lts`, `{app_alias: lts}` will be added to the log.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] log_labels: Specifies the container label log tag. A maximum of `30` tags can be created.
               The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
               label value. For example, if you enter `app` as the key and `app_alias` as the value, when the Container label
               contains `app=lts`, `{app_alias: lts}` will be added to the log.
        :param pulumi.Input['CceAccessAccessConfigMultiLogFormatArgs'] multi_log_format: Specifies the configuration multi-line logs. Multiple lines of exception log
               events can be displayed as a single log event. This is helpful when you check logs to locate problems.
               The multi_log_format structure is documented below.
               
               > `single_log_format` or `multi_log_format` must be specified.
        :param pulumi.Input[_builtins.str] name_space_regex: Specifies the regular expression matching of kubernetes namespaces.
               LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
               leave this field empty.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] paths: Specifies the collection paths. Required when `path_type` is **container_file**
               or **host_file**.
        :param pulumi.Input[_builtins.str] pod_name_regex: Specifies the regular expression matching of kubernetes pods.
               LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
               leave this field empty.
        :param pulumi.Input[_builtins.bool] repeat_collect: Specifies whether to allow repeated file collection.  
               Defaults to **false**.
               + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
               This function is available only to certain ICAgent versions, please refer to the documentation.
               + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.
        :param pulumi.Input['CceAccessAccessConfigSingleLogFormatArgs'] single_log_format: Specifies the configuration single-line logs. Each log line is displayed
               as a single log event.
               The single_log_format structure is documented below.
        :param pulumi.Input[_builtins.bool] stderr: Specifies whether error output is standard. Default is **false**.
               
               >  If the value of `path_type` is **container_stdout**, `stdout` or `stderr` must be **true**.
        :param pulumi.Input[_builtins.bool] stdout: Specifies whether output is standard. Default is false.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] system_fields: Specifies the list of system built-in fields of the CCE access.  
               Changing this creates a new resource.
               If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
               the system as **pathfile**.
               If `system_fields` is specified, **pathFile** must be included.
               The valid values are as follows:
               + **pathFile**
               + **hostName**
               + **hostId**
               + **hostIP**
               + **hostIPv6**
               + **clusterId**
               + **podName**
               + **appName**
               + **containerName**
               + **nameSpace**
               + **category**
               + **serviceID**
               + **podIp**
               + **clusterName**
               + **workloadType**
               + **image_name**
               
               > These parameters include `name_space_regex`, `pod_name_regex`, `container_name_regex`, `log_labels`,
               `include_labels_logical`, `include_labels`, `exclude_labels_logical`, `exclude_labels`, `log_envs`,
               `include_envs_logical`, `include_envs`, `exclude_envs_logical`, `exclude_envs`, `log_k8s`,
               `include_k8s_labels_logical`, `include_k8s_labels`, `exclude_k8s_labels_logical` and
               `exclude_k8s_labels` are available, only `path_type` is not **host_file**.
               
               <a name="block_access_config_single_log_format"></a>
               The `single_log_format` block supports:
        :param pulumi.Input['CceAccessAccessConfigWindowsLogInfoArgs'] windows_log_info: Specifies the configuration of Windows event logs. Required when
               `path_type` is **container_file** or **container_stdout**.
               The windows_log_info structure is documented below.
        """
        pulumi.set(__self__, "path_type", path_type)
        if black_paths is not None:
            pulumi.set(__self__, "black_paths", black_paths)
        if container_name_regex is not None:
            pulumi.set(__self__, "container_name_regex", container_name_regex)
        if custom_key_value is not None:
            pulumi.set(__self__, "custom_key_value", custom_key_value)
        if exclude_envs is not None:
            pulumi.set(__self__, "exclude_envs", exclude_envs)
        if exclude_envs_logical is not None:
            pulumi.set(__self__, "exclude_envs_logical", exclude_envs_logical)
        if exclude_k8s_labels is not None:
            pulumi.set(__self__, "exclude_k8s_labels", exclude_k8s_labels)
        if exclude_k8s_labels_logical is not None:
            pulumi.set(__self__, "exclude_k8s_labels_logical", exclude_k8s_labels_logical)
        if exclude_labels is not None:
            pulumi.set(__self__, "exclude_labels", exclude_labels)
        if exclude_labels_logical is not None:
            pulumi.set(__self__, "exclude_labels_logical", exclude_labels_logical)
        if include_envs is not None:
            pulumi.set(__self__, "include_envs", include_envs)
        if include_envs_logical is not None:
            pulumi.set(__self__, "include_envs_logical", include_envs_logical)
        if include_k8s_labels is not None:
            pulumi.set(__self__, "include_k8s_labels", include_k8s_labels)
        if include_k8s_labels_logical is not None:
            pulumi.set(__self__, "include_k8s_labels_logical", include_k8s_labels_logical)
        if include_labels is not None:
            pulumi.set(__self__, "include_labels", include_labels)
        if include_labels_logical is not None:
            pulumi.set(__self__, "include_labels_logical", include_labels_logical)
        if log_envs is not None:
            pulumi.set(__self__, "log_envs", log_envs)
        if log_k8s is not None:
            pulumi.set(__self__, "log_k8s", log_k8s)
        if log_labels is not None:
            pulumi.set(__self__, "log_labels", log_labels)
        if multi_log_format is not None:
            pulumi.set(__self__, "multi_log_format", multi_log_format)
        if name_space_regex is not None:
            pulumi.set(__self__, "name_space_regex", name_space_regex)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if pod_name_regex is not None:
            pulumi.set(__self__, "pod_name_regex", pod_name_regex)
        if repeat_collect is not None:
            pulumi.set(__self__, "repeat_collect", repeat_collect)
        if single_log_format is not None:
            pulumi.set(__self__, "single_log_format", single_log_format)
        if stderr is not None:
            pulumi.set(__self__, "stderr", stderr)
        if stdout is not None:
            pulumi.set(__self__, "stdout", stdout)
        if system_fields is not None:
            pulumi.set(__self__, "system_fields", system_fields)
        if windows_log_info is not None:
            pulumi.set(__self__, "windows_log_info", windows_log_info)

    @_builtins.property
    @pulumi.getter(name="pathType")
    def path_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the CCE access. The options are as follows:
        + **container_stdout**
        + **container_file**
        + **host_file**
        """
        return pulumi.get(self, "path_type")

    @path_type.setter
    def path_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path_type", value)

    @_builtins.property
    @pulumi.getter(name="blackPaths")
    def black_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the collection path blacklist.
        """
        return pulumi.get(self, "black_paths")

    @black_paths.setter
    def black_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "black_paths", value)

    @_builtins.property
    @pulumi.getter(name="containerNameRegex")
    def container_name_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the regular expression matching of kubernetes container names.
        LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
        leave this field empty.
        """
        return pulumi.get(self, "container_name_regex")

    @container_name_regex.setter
    def container_name_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_name_regex", value)

    @_builtins.property
    @pulumi.getter(name="customKeyValue")
    def custom_key_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the custom key/value pairs of the CCE access.  
        Changing this creates a new resource.
        """
        return pulumi.get(self, "custom_key_value")

    @custom_key_value.setter
    def custom_key_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_key_value", value)

    @_builtins.property
    @pulumi.getter(name="excludeEnvs")
    def exclude_envs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the environment variable blacklist. A maximum of `30` tags can be
        created. The key names must be unique. LTS will exclude all containers with environment variables containing either
        an environment variable key with an empty corresponding environment variable value, or an environment variable key
        with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
        expression matching.
        """
        return pulumi.get(self, "exclude_envs")

    @exclude_envs.setter
    def exclude_envs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_envs", value)

    @_builtins.property
    @pulumi.getter(name="excludeEnvsLogical")
    def exclude_envs_logical(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the logical relationship between multiple environment variable
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_envs_logical")

    @exclude_envs_logical.setter
    def exclude_envs_logical(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_envs_logical", value)

    @_builtins.property
    @pulumi.getter(name="excludeK8sLabels")
    def exclude_k8s_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the kubernetes label blacklist. A maximum of `30` tags can be
        created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
        excluded. If labelValue is not empty, only containers whose K8s label contains `LabelKey=LabelValue` are excluded.
        LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
        OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
        """
        return pulumi.get(self, "exclude_k8s_labels")

    @exclude_k8s_labels.setter
    def exclude_k8s_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_k8s_labels", value)

    @_builtins.property
    @pulumi.getter(name="excludeK8sLabelsLogical")
    def exclude_k8s_labels_logical(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the logical relationship between multiple kubernetes label
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_k8s_labels_logical")

    @exclude_k8s_labels_logical.setter
    def exclude_k8s_labels_logical(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_k8s_labels_logical", value)

    @_builtins.property
    @pulumi.getter(name="excludeLabels")
    def exclude_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the container label blacklist. A maximum of `30` tags can be created.
        The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
        excluded. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
        excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
        are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
        """
        return pulumi.get(self, "exclude_labels")

    @exclude_labels.setter
    def exclude_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_labels", value)

    @_builtins.property
    @pulumi.getter(name="excludeLabelsLogical")
    def exclude_labels_logical(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the logical relationship between multiple container label
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_labels_logical")

    @exclude_labels_logical.setter
    def exclude_labels_logical(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_labels_logical", value)

    @_builtins.property
    @pulumi.getter(name="includeEnvs")
    def include_envs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the environment variable whitelist. A maximum of `30` tags can be
        created. The key names must be unique. LTS will match all containers with environment variables containing either
        an environment variable key with an empty corresponding environment variable value, or an environment variable key
        with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
        expression matching.
        """
        return pulumi.get(self, "include_envs")

    @include_envs.setter
    def include_envs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_envs", value)

    @_builtins.property
    @pulumi.getter(name="includeEnvsLogical")
    def include_envs_logical(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the logical relationship between multiple environment variable
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_envs_logical")

    @include_envs_logical.setter
    def include_envs_logical(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_envs_logical", value)

    @_builtins.property
    @pulumi.getter(name="includeK8sLabels")
    def include_k8s_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the kubernetes label whitelist. A maximum of `30` tags can be
        created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
        matched. If labelValue is not empty, only containers whose K8s Label contains `LabelKey=LabelValue` are matched.
        LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
        OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
        """
        return pulumi.get(self, "include_k8s_labels")

    @include_k8s_labels.setter
    def include_k8s_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_k8s_labels", value)

    @_builtins.property
    @pulumi.getter(name="includeK8sLabelsLogical")
    def include_k8s_labels_logical(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the logical relationship between multiple kubernetes label
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_k8s_labels_logical")

    @include_k8s_labels_logical.setter
    def include_k8s_labels_logical(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_k8s_labels_logical", value)

    @_builtins.property
    @pulumi.getter(name="includeLabels")
    def include_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the container label whitelist. A maximum of `30` tags can be created.
        The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
        matched. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
        matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
        are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
        """
        return pulumi.get(self, "include_labels")

    @include_labels.setter
    def include_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_labels", value)

    @_builtins.property
    @pulumi.getter(name="includeLabelsLogical")
    def include_labels_logical(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the logical relationship between multiple container label
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_labels_logical")

    @include_labels_logical.setter
    def include_labels_logical(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_labels_logical", value)

    @_builtins.property
    @pulumi.getter(name="logEnvs")
    def log_envs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the environment variable tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
        corresponding environment variable value. For example, if you enter `app` as the key and `app_alias` as the value,
        when the kubernetes environment variable contains `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        return pulumi.get(self, "log_envs")

    @log_envs.setter
    def log_envs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "log_envs", value)

    @_builtins.property
    @pulumi.getter(name="logK8s")
    def log_k8s(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the kubernetes label log tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
        value. For example, if you enter `app` as the key and `app_alias` as the value, when the K8s label contains
        `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        return pulumi.get(self, "log_k8s")

    @log_k8s.setter
    def log_k8s(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "log_k8s", value)

    @_builtins.property
    @pulumi.getter(name="logLabels")
    def log_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the container label log tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
        label value. For example, if you enter `app` as the key and `app_alias` as the value, when the Container label
        contains `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        return pulumi.get(self, "log_labels")

    @log_labels.setter
    def log_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "log_labels", value)

    @_builtins.property
    @pulumi.getter(name="multiLogFormat")
    def multi_log_format(self) -> Optional[pulumi.Input['CceAccessAccessConfigMultiLogFormatArgs']]:
        """
        Specifies the configuration multi-line logs. Multiple lines of exception log
        events can be displayed as a single log event. This is helpful when you check logs to locate problems.
        The multi_log_format structure is documented below.

        > `single_log_format` or `multi_log_format` must be specified.
        """
        return pulumi.get(self, "multi_log_format")

    @multi_log_format.setter
    def multi_log_format(self, value: Optional[pulumi.Input['CceAccessAccessConfigMultiLogFormatArgs']]):
        pulumi.set(self, "multi_log_format", value)

    @_builtins.property
    @pulumi.getter(name="nameSpaceRegex")
    def name_space_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the regular expression matching of kubernetes namespaces.
        LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
        leave this field empty.
        """
        return pulumi.get(self, "name_space_regex")

    @name_space_regex.setter
    def name_space_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name_space_regex", value)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the collection paths. Required when `path_type` is **container_file**
        or **host_file**.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "paths", value)

    @_builtins.property
    @pulumi.getter(name="podNameRegex")
    def pod_name_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the regular expression matching of kubernetes pods.
        LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
        leave this field empty.
        """
        return pulumi.get(self, "pod_name_regex")

    @pod_name_regex.setter
    def pod_name_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_name_regex", value)

    @_builtins.property
    @pulumi.getter(name="repeatCollect")
    def repeat_collect(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to allow repeated file collection.  
        Defaults to **false**.
        + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
        This function is available only to certain ICAgent versions, please refer to the documentation.
        + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.
        """
        return pulumi.get(self, "repeat_collect")

    @repeat_collect.setter
    def repeat_collect(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "repeat_collect", value)

    @_builtins.property
    @pulumi.getter(name="singleLogFormat")
    def single_log_format(self) -> Optional[pulumi.Input['CceAccessAccessConfigSingleLogFormatArgs']]:
        """
        Specifies the configuration single-line logs. Each log line is displayed
        as a single log event.
        The single_log_format structure is documented below.
        """
        return pulumi.get(self, "single_log_format")

    @single_log_format.setter
    def single_log_format(self, value: Optional[pulumi.Input['CceAccessAccessConfigSingleLogFormatArgs']]):
        pulumi.set(self, "single_log_format", value)

    @_builtins.property
    @pulumi.getter
    def stderr(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether error output is standard. Default is **false**.

        >  If the value of `path_type` is **container_stdout**, `stdout` or `stderr` must be **true**.
        """
        return pulumi.get(self, "stderr")

    @stderr.setter
    def stderr(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stderr", value)

    @_builtins.property
    @pulumi.getter
    def stdout(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether output is standard. Default is false.
        """
        return pulumi.get(self, "stdout")

    @stdout.setter
    def stdout(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdout", value)

    @_builtins.property
    @pulumi.getter(name="systemFields")
    def system_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of system built-in fields of the CCE access.  
        Changing this creates a new resource.
        If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
        the system as **pathfile**.
        If `system_fields` is specified, **pathFile** must be included.
        The valid values are as follows:
        + **pathFile**
        + **hostName**
        + **hostId**
        + **hostIP**
        + **hostIPv6**
        + **clusterId**
        + **podName**
        + **appName**
        + **containerName**
        + **nameSpace**
        + **category**
        + **serviceID**
        + **podIp**
        + **clusterName**
        + **workloadType**
        + **image_name**

        > These parameters include `name_space_regex`, `pod_name_regex`, `container_name_regex`, `log_labels`,
        `include_labels_logical`, `include_labels`, `exclude_labels_logical`, `exclude_labels`, `log_envs`,
        `include_envs_logical`, `include_envs`, `exclude_envs_logical`, `exclude_envs`, `log_k8s`,
        `include_k8s_labels_logical`, `include_k8s_labels`, `exclude_k8s_labels_logical` and
        `exclude_k8s_labels` are available, only `path_type` is not **host_file**.

        <a name="block_access_config_single_log_format"></a>
        The `single_log_format` block supports:
        """
        return pulumi.get(self, "system_fields")

    @system_fields.setter
    def system_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_fields", value)

    @_builtins.property
    @pulumi.getter(name="windowsLogInfo")
    def windows_log_info(self) -> Optional[pulumi.Input['CceAccessAccessConfigWindowsLogInfoArgs']]:
        """
        Specifies the configuration of Windows event logs. Required when
        `path_type` is **container_file** or **container_stdout**.
        The windows_log_info structure is documented below.
        """
        return pulumi.get(self, "windows_log_info")

    @windows_log_info.setter
    def windows_log_info(self, value: Optional[pulumi.Input['CceAccessAccessConfigWindowsLogInfoArgs']]):
        pulumi.set(self, "windows_log_info", value)


if not MYPY:
    class CceAccessAccessConfigMultiLogFormatArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies value of multi-line log format.
        + If mode is **regular**, the value is a regular expression.
        + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
        as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
        wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
        wildcard is **YY-M-D hh:mm:ss**.

        > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
        log line. If no match is found, the system time, which may be different from the time in the log event, is used.
        In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.

        <a name="block_access_config_windows_log_info"></a>
        The `windows_log_info` block supports:
        """
elif False:
    CceAccessAccessConfigMultiLogFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceAccessAccessConfigMultiLogFormatArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param pulumi.Input[_builtins.str] value: Specifies value of multi-line log format.
               + If mode is **regular**, the value is a regular expression.
               + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
               as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
               wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
               wildcard is **YY-M-D hh:mm:ss**.
               
               > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
               log line. If no match is found, the system time, which may be different from the time in the log event, is used.
               In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.
               
               <a name="block_access_config_windows_log_info"></a>
               The `windows_log_info` block supports:
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies value of multi-line log format.
        + If mode is **regular**, the value is a regular expression.
        + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
        as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
        wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
        wildcard is **YY-M-D hh:mm:ss**.

        > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
        log line. If no match is found, the system time, which may be different from the time in the log event, is used.
        In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.

        <a name="block_access_config_windows_log_info"></a>
        The `windows_log_info` block supports:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CceAccessAccessConfigSingleLogFormatArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies value of multi-line log format.
        + If mode is **regular**, the value is a regular expression.
        + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
        as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
        wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
        wildcard is **YY-M-D hh:mm:ss**.

        > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
        log line. If no match is found, the system time, which may be different from the time in the log event, is used.
        In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.

        <a name="block_access_config_windows_log_info"></a>
        The `windows_log_info` block supports:
        """
elif False:
    CceAccessAccessConfigSingleLogFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceAccessAccessConfigSingleLogFormatArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param pulumi.Input[_builtins.str] value: Specifies value of multi-line log format.
               + If mode is **regular**, the value is a regular expression.
               + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
               as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
               wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
               wildcard is **YY-M-D hh:mm:ss**.
               
               > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
               log line. If no match is found, the system time, which may be different from the time in the log event, is used.
               In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.
               
               <a name="block_access_config_windows_log_info"></a>
               The `windows_log_info` block supports:
        """
        pulumi.set(__self__, "mode", mode)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies value of multi-line log format.
        + If mode is **regular**, the value is a regular expression.
        + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
        as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
        wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
        wildcard is **YY-M-D hh:mm:ss**.

        > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
        log line. If no match is found, the system time, which may be different from the time in the log event, is used.
        In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.

        <a name="block_access_config_windows_log_info"></a>
        The `windows_log_info` block supports:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CceAccessAccessConfigWindowsLogInfoArgsDict(TypedDict):
        categorys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the types of Windows event logs to collect. The valid values are
        **Application**, **System**, **Security** and **Setup**.
        """
        event_levels: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the Windows event severity. The valid values are **information**,
        **warning**, **error**, **critical** and **verbose**. Only Windows Vista or later is supported.
        """
        time_offset: pulumi.Input[_builtins.int]
        """
        Specifies the collection time offset. This time takes effect only for the first
        time to ensure that the logs are not collected repeatedly.

        + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
        + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
        + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.

        <a name="cce_access_processors"></a>
        The `processors` block supports:
        """
        time_offset_unit: pulumi.Input[_builtins.str]
        """
        Specifies the collection time offset unit. The valid values are
        **day**, **hour** and **sec**.
        """
elif False:
    CceAccessAccessConfigWindowsLogInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceAccessAccessConfigWindowsLogInfoArgs:
    def __init__(__self__, *,
                 categorys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 event_levels: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 time_offset: pulumi.Input[_builtins.int],
                 time_offset_unit: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] categorys: Specifies the types of Windows event logs to collect. The valid values are
               **Application**, **System**, **Security** and **Setup**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] event_levels: Specifies the Windows event severity. The valid values are **information**,
               **warning**, **error**, **critical** and **verbose**. Only Windows Vista or later is supported.
        :param pulumi.Input[_builtins.int] time_offset: Specifies the collection time offset. This time takes effect only for the first
               time to ensure that the logs are not collected repeatedly.
               
               + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
               + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
               + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.
               
               <a name="cce_access_processors"></a>
               The `processors` block supports:
        :param pulumi.Input[_builtins.str] time_offset_unit: Specifies the collection time offset unit. The valid values are
               **day**, **hour** and **sec**.
        """
        pulumi.set(__self__, "categorys", categorys)
        pulumi.set(__self__, "event_levels", event_levels)
        pulumi.set(__self__, "time_offset", time_offset)
        pulumi.set(__self__, "time_offset_unit", time_offset_unit)

    @_builtins.property
    @pulumi.getter
    def categorys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the types of Windows event logs to collect. The valid values are
        **Application**, **System**, **Security** and **Setup**.
        """
        return pulumi.get(self, "categorys")

    @categorys.setter
    def categorys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "categorys", value)

    @_builtins.property
    @pulumi.getter(name="eventLevels")
    def event_levels(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the Windows event severity. The valid values are **information**,
        **warning**, **error**, **critical** and **verbose**. Only Windows Vista or later is supported.
        """
        return pulumi.get(self, "event_levels")

    @event_levels.setter
    def event_levels(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "event_levels", value)

    @_builtins.property
    @pulumi.getter(name="timeOffset")
    def time_offset(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the collection time offset. This time takes effect only for the first
        time to ensure that the logs are not collected repeatedly.

        + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
        + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
        + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.

        <a name="cce_access_processors"></a>
        The `processors` block supports:
        """
        return pulumi.get(self, "time_offset")

    @time_offset.setter
    def time_offset(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "time_offset", value)

    @_builtins.property
    @pulumi.getter(name="timeOffsetUnit")
    def time_offset_unit(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the collection time offset unit. The valid values are
        **day**, **hour** and **sec**.
        """
        return pulumi.get(self, "time_offset_unit")

    @time_offset_unit.setter
    def time_offset_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_offset_unit", value)


if not MYPY:
    class CceAccessDemoFieldArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the parsed field.
        """
        field_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value of the parsed field.
        """
elif False:
    CceAccessDemoFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceAccessDemoFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 field_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the name of the parsed field.
        :param pulumi.Input[_builtins.str] field_value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "field_name", field_name)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the parsed field.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "field_value")

    @field_value.setter
    def field_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_value", value)


if not MYPY:
    class CceAccessProcessorArgsDict(TypedDict):
        detail: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the configuration of the parser, in JSON format.  
        For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).

        <a name="cce_access_demoFields"></a>
        The `demo_fields` block supports:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of the parser.  
        The valid values are as follows:
        + **processor_regex**
        + **processor_split_string**
        + **processor_json**
        + **processor_gotime**
        + **processor_filter_regex**
        + **processor_drop**
        + **processor_rename**
        """
elif False:
    CceAccessProcessorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceAccessProcessorArgs:
    def __init__(__self__, *,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] detail: Specifies the configuration of the parser, in JSON format.  
               For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).
               
               <a name="cce_access_demoFields"></a>
               The `demo_fields` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the type of the parser.  
               The valid values are as follows:
               + **processor_regex**
               + **processor_split_string**
               + **processor_json**
               + **processor_gotime**
               + **processor_filter_regex**
               + **processor_drop**
               + **processor_rename**
        """
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the configuration of the parser, in JSON format.  
        For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).

        <a name="cce_access_demoFields"></a>
        The `demo_fields` block supports:
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the parser.  
        The valid values are as follows:
        + **processor_regex**
        + **processor_split_string**
        + **processor_json**
        + **processor_gotime**
        + **processor_filter_regex**
        + **processor_drop**
        + **processor_rename**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HostAccessAccessConfigArgsDict(TypedDict):
        paths: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the collection paths.

        + A path must start with `/` or `Letter:\\`.
        + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
        + A path cannot start with `/**` or `/*`.
        + Only one double asterisk (**) can be contained in a path.
        + Up to 10 paths can be specified.
        """
        black_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the collection path blacklist.

        + A path must start with `/` or `Letter:\\`.
        + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
        + A path cannot start with `/**` or `/*`.
        + Only one double asterisk (**) can be contained in a path.
        + Up to 10 paths can be specified.

        > If you blacklist a file or directory that has been set as a collection path, the blacklist settings
        will be used and the file or files in the directory will be filtered out.
        """
        custom_key_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the custom key/value pairs of the host access.  
        Changing this parameter will create a new resource.
        """
        multi_log_format: NotRequired[pulumi.Input['HostAccessAccessConfigMultiLogFormatArgsDict']]
        """
        Specifies the configuration multi-line logs. Multiple lines of exception log events
        can be displayed as a single log event. This is helpful when you check logs to locate problems.
        The multi_log_format structure is documented below.
        """
        repeat_collect: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to allow repeated flie collection.  
        Defaults to **false**.
        + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
        This function is available only to certain ICAgent versions, please refer to the documentation.
        + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.

        <a name="HostAccessConfigSingleLogFormat"></a>
        The `single_log_format` blocks supports:
        """
        single_log_format: NotRequired[pulumi.Input['HostAccessAccessConfigSingleLogFormatArgsDict']]
        """
        Specifies the configuration single-line logs. Each log line is displayed as a
        single log event. The single_log_format structure is documented below.
        """
        system_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of system built-in fields of the host access.  
        Changing this parameter will create a new resource.
        If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
        the system as **pathfile**.
        If `system_fields` is specified, **pathFile** must be included.
        The valid values are as follows:
        + **pathFile**
        + **hostName**
        + **hostId**
        + **hostIP**
        + **hostIPv6**
        """
        windows_log_info: NotRequired[pulumi.Input['HostAccessAccessConfigWindowsLogInfoArgsDict']]
        """
        Specifies the configuration of Windows event logs.
        The windows_log_info structure is documented below.
        """
elif False:
    HostAccessAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostAccessAccessConfigArgs:
    def __init__(__self__, *,
                 paths: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 black_paths: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_key_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 multi_log_format: Optional[pulumi.Input['HostAccessAccessConfigMultiLogFormatArgs']] = None,
                 repeat_collect: Optional[pulumi.Input[_builtins.bool]] = None,
                 single_log_format: Optional[pulumi.Input['HostAccessAccessConfigSingleLogFormatArgs']] = None,
                 system_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 windows_log_info: Optional[pulumi.Input['HostAccessAccessConfigWindowsLogInfoArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] paths: Specifies the collection paths.
               
               + A path must start with `/` or `Letter:\\`.
               + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
               + A path cannot start with `/**` or `/*`.
               + Only one double asterisk (**) can be contained in a path.
               + Up to 10 paths can be specified.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] black_paths: Specifies the collection path blacklist.
               
               + A path must start with `/` or `Letter:\\`.
               + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
               + A path cannot start with `/**` or `/*`.
               + Only one double asterisk (**) can be contained in a path.
               + Up to 10 paths can be specified.
               
               > If you blacklist a file or directory that has been set as a collection path, the blacklist settings
               will be used and the file or files in the directory will be filtered out.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_key_value: Specifies the custom key/value pairs of the host access.  
               Changing this parameter will create a new resource.
        :param pulumi.Input['HostAccessAccessConfigMultiLogFormatArgs'] multi_log_format: Specifies the configuration multi-line logs. Multiple lines of exception log events
               can be displayed as a single log event. This is helpful when you check logs to locate problems.
               The multi_log_format structure is documented below.
        :param pulumi.Input[_builtins.bool] repeat_collect: Specifies whether to allow repeated flie collection.  
               Defaults to **false**.
               + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
               This function is available only to certain ICAgent versions, please refer to the documentation.
               + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.
               
               <a name="HostAccessConfigSingleLogFormat"></a>
               The `single_log_format` blocks supports:
        :param pulumi.Input['HostAccessAccessConfigSingleLogFormatArgs'] single_log_format: Specifies the configuration single-line logs. Each log line is displayed as a
               single log event. The single_log_format structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] system_fields: Specifies the list of system built-in fields of the host access.  
               Changing this parameter will create a new resource.
               If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
               the system as **pathfile**.
               If `system_fields` is specified, **pathFile** must be included.
               The valid values are as follows:
               + **pathFile**
               + **hostName**
               + **hostId**
               + **hostIP**
               + **hostIPv6**
        :param pulumi.Input['HostAccessAccessConfigWindowsLogInfoArgs'] windows_log_info: Specifies the configuration of Windows event logs.
               The windows_log_info structure is documented below.
        """
        pulumi.set(__self__, "paths", paths)
        if black_paths is not None:
            pulumi.set(__self__, "black_paths", black_paths)
        if custom_key_value is not None:
            pulumi.set(__self__, "custom_key_value", custom_key_value)
        if multi_log_format is not None:
            pulumi.set(__self__, "multi_log_format", multi_log_format)
        if repeat_collect is not None:
            pulumi.set(__self__, "repeat_collect", repeat_collect)
        if single_log_format is not None:
            pulumi.set(__self__, "single_log_format", single_log_format)
        if system_fields is not None:
            pulumi.set(__self__, "system_fields", system_fields)
        if windows_log_info is not None:
            pulumi.set(__self__, "windows_log_info", windows_log_info)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the collection paths.

        + A path must start with `/` or `Letter:\\`.
        + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
        + A path cannot start with `/**` or `/*`.
        + Only one double asterisk (**) can be contained in a path.
        + Up to 10 paths can be specified.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "paths", value)

    @_builtins.property
    @pulumi.getter(name="blackPaths")
    def black_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the collection path blacklist.

        + A path must start with `/` or `Letter:\\`.
        + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
        + A path cannot start with `/**` or `/*`.
        + Only one double asterisk (**) can be contained in a path.
        + Up to 10 paths can be specified.

        > If you blacklist a file or directory that has been set as a collection path, the blacklist settings
        will be used and the file or files in the directory will be filtered out.
        """
        return pulumi.get(self, "black_paths")

    @black_paths.setter
    def black_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "black_paths", value)

    @_builtins.property
    @pulumi.getter(name="customKeyValue")
    def custom_key_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the custom key/value pairs of the host access.  
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "custom_key_value")

    @custom_key_value.setter
    def custom_key_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_key_value", value)

    @_builtins.property
    @pulumi.getter(name="multiLogFormat")
    def multi_log_format(self) -> Optional[pulumi.Input['HostAccessAccessConfigMultiLogFormatArgs']]:
        """
        Specifies the configuration multi-line logs. Multiple lines of exception log events
        can be displayed as a single log event. This is helpful when you check logs to locate problems.
        The multi_log_format structure is documented below.
        """
        return pulumi.get(self, "multi_log_format")

    @multi_log_format.setter
    def multi_log_format(self, value: Optional[pulumi.Input['HostAccessAccessConfigMultiLogFormatArgs']]):
        pulumi.set(self, "multi_log_format", value)

    @_builtins.property
    @pulumi.getter(name="repeatCollect")
    def repeat_collect(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to allow repeated flie collection.  
        Defaults to **false**.
        + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
        This function is available only to certain ICAgent versions, please refer to the documentation.
        + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.

        <a name="HostAccessConfigSingleLogFormat"></a>
        The `single_log_format` blocks supports:
        """
        return pulumi.get(self, "repeat_collect")

    @repeat_collect.setter
    def repeat_collect(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "repeat_collect", value)

    @_builtins.property
    @pulumi.getter(name="singleLogFormat")
    def single_log_format(self) -> Optional[pulumi.Input['HostAccessAccessConfigSingleLogFormatArgs']]:
        """
        Specifies the configuration single-line logs. Each log line is displayed as a
        single log event. The single_log_format structure is documented below.
        """
        return pulumi.get(self, "single_log_format")

    @single_log_format.setter
    def single_log_format(self, value: Optional[pulumi.Input['HostAccessAccessConfigSingleLogFormatArgs']]):
        pulumi.set(self, "single_log_format", value)

    @_builtins.property
    @pulumi.getter(name="systemFields")
    def system_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of system built-in fields of the host access.  
        Changing this parameter will create a new resource.
        If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
        the system as **pathfile**.
        If `system_fields` is specified, **pathFile** must be included.
        The valid values are as follows:
        + **pathFile**
        + **hostName**
        + **hostId**
        + **hostIP**
        + **hostIPv6**
        """
        return pulumi.get(self, "system_fields")

    @system_fields.setter
    def system_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "system_fields", value)

    @_builtins.property
    @pulumi.getter(name="windowsLogInfo")
    def windows_log_info(self) -> Optional[pulumi.Input['HostAccessAccessConfigWindowsLogInfoArgs']]:
        """
        Specifies the configuration of Windows event logs.
        The windows_log_info structure is documented below.
        """
        return pulumi.get(self, "windows_log_info")

    @windows_log_info.setter
    def windows_log_info(self, value: Optional[pulumi.Input['HostAccessAccessConfigWindowsLogInfoArgs']]):
        pulumi.set(self, "windows_log_info", value)


if not MYPY:
    class HostAccessAccessConfigMultiLogFormatArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value of the parsed field.
        """
elif False:
    HostAccessAccessConfigMultiLogFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostAccessAccessConfigMultiLogFormatArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HostAccessAccessConfigSingleLogFormatArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value of the parsed field.
        """
elif False:
    HostAccessAccessConfigSingleLogFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostAccessAccessConfigSingleLogFormatArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "mode", mode)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HostAccessAccessConfigWindowsLogInfoArgsDict(TypedDict):
        categorys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the types of Windows event logs to collect. The valid values are
        **Application**, **System**, **Security** and **Setup**.
        """
        event_levels: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the Windows event severity. The valid values are **information**, **warning**,
        **error**, **critical** and **verbose**.  Only Windows Vista or later is supported.
        """
        time_offset: pulumi.Input[_builtins.int]
        """
        Specifies the collection time offset. This time takes effect only for the first
        time to ensure that the logs are not collected repeatedly.

        + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
        + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
        + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.

        <a name="HostAccessProcessors"></a>
        The `processors` block supports:
        """
        time_offset_unit: pulumi.Input[_builtins.str]
        """
        Specifies the collection time offset unit. The valid values are
        **day**, **hour** and **sec**.
        """
elif False:
    HostAccessAccessConfigWindowsLogInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostAccessAccessConfigWindowsLogInfoArgs:
    def __init__(__self__, *,
                 categorys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 event_levels: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 time_offset: pulumi.Input[_builtins.int],
                 time_offset_unit: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] categorys: Specifies the types of Windows event logs to collect. The valid values are
               **Application**, **System**, **Security** and **Setup**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] event_levels: Specifies the Windows event severity. The valid values are **information**, **warning**,
               **error**, **critical** and **verbose**.  Only Windows Vista or later is supported.
        :param pulumi.Input[_builtins.int] time_offset: Specifies the collection time offset. This time takes effect only for the first
               time to ensure that the logs are not collected repeatedly.
               
               + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
               + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
               + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.
               
               <a name="HostAccessProcessors"></a>
               The `processors` block supports:
        :param pulumi.Input[_builtins.str] time_offset_unit: Specifies the collection time offset unit. The valid values are
               **day**, **hour** and **sec**.
        """
        pulumi.set(__self__, "categorys", categorys)
        pulumi.set(__self__, "event_levels", event_levels)
        pulumi.set(__self__, "time_offset", time_offset)
        pulumi.set(__self__, "time_offset_unit", time_offset_unit)

    @_builtins.property
    @pulumi.getter
    def categorys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the types of Windows event logs to collect. The valid values are
        **Application**, **System**, **Security** and **Setup**.
        """
        return pulumi.get(self, "categorys")

    @categorys.setter
    def categorys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "categorys", value)

    @_builtins.property
    @pulumi.getter(name="eventLevels")
    def event_levels(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the Windows event severity. The valid values are **information**, **warning**,
        **error**, **critical** and **verbose**.  Only Windows Vista or later is supported.
        """
        return pulumi.get(self, "event_levels")

    @event_levels.setter
    def event_levels(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "event_levels", value)

    @_builtins.property
    @pulumi.getter(name="timeOffset")
    def time_offset(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the collection time offset. This time takes effect only for the first
        time to ensure that the logs are not collected repeatedly.

        + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
        + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
        + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.

        <a name="HostAccessProcessors"></a>
        The `processors` block supports:
        """
        return pulumi.get(self, "time_offset")

    @time_offset.setter
    def time_offset(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "time_offset", value)

    @_builtins.property
    @pulumi.getter(name="timeOffsetUnit")
    def time_offset_unit(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the collection time offset unit. The valid values are
        **day**, **hour** and **sec**.
        """
        return pulumi.get(self, "time_offset_unit")

    @time_offset_unit.setter
    def time_offset_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_offset_unit", value)


if not MYPY:
    class HostAccessDemoFieldArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the parsed field.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value of the parsed field.
        """
elif False:
    HostAccessDemoFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostAccessDemoFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the parsed field.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the parsed field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HostAccessProcessorArgsDict(TypedDict):
        detail: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the configuration of the parser, in JSON format.  
        For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).

        <a name="HostAccessDemoFields"></a>
        The `demo_fields` block supports:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of the parser.  
        The valid values are as follows:
        + **processor_regex**
        + **processor_split_string**
        + **processor_json**
        + **processor_gotime**
        + **processor_filter_regex**
        + **processor_drop**
        + **processor_rename**
        """
elif False:
    HostAccessProcessorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostAccessProcessorArgs:
    def __init__(__self__, *,
                 detail: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] detail: Specifies the configuration of the parser, in JSON format.  
               For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).
               
               <a name="HostAccessDemoFields"></a>
               The `demo_fields` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the type of the parser.  
               The valid values are as follows:
               + **processor_regex**
               + **processor_split_string**
               + **processor_json**
               + **processor_gotime**
               + **processor_filter_regex**
               + **processor_drop**
               + **processor_rename**
        """
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the configuration of the parser, in JSON format.  
        For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).

        <a name="HostAccessDemoFields"></a>
        The `demo_fields` block supports:
        """
        return pulumi.get(self, "detail")

    @detail.setter
    def detail(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "detail", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the parser.  
        The valid values are as follows:
        + **processor_regex**
        + **processor_split_string**
        + **processor_json**
        + **processor_gotime**
        + **processor_filter_regex**
        + **processor_drop**
        + **processor_rename**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KeywordsAlarmRuleFrequencyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the frequency type.  
        The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        """
        cron_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cron expression.  
        This parameter is used when `type` is set to **CRON**.
        """
        day_of_week: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the day of week.  
        This parameter is used when `type` is set to **WEEKLY**.
        The value ranges from `1` to `7`. `1` means Sunday.
        """
        fixed_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the unit fixed rate.  
        This parameter is used when `type` is set to **FIXED_RATE**.
        + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`

        <a name="KeywordsAlarmRule_NotificationRule"></a>
        The `NotificationRule` block supports:
        """
        fixed_rate_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit of fixed rate.  
        The value can be: **minute** and **hour**.
        """
        hour_of_day: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the hour of day.  
        This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
        The value ranges from `0` to `23`.
        """
elif False:
    KeywordsAlarmRuleFrequencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeywordsAlarmRuleFrequencyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[_builtins.int]] = None,
                 fixed_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 fixed_rate_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 hour_of_day: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the frequency type.  
               The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        :param pulumi.Input[_builtins.str] cron_expression: Specifies the cron expression.  
               This parameter is used when `type` is set to **CRON**.
        :param pulumi.Input[_builtins.int] day_of_week: Specifies the day of week.  
               This parameter is used when `type` is set to **WEEKLY**.
               The value ranges from `1` to `7`. `1` means Sunday.
        :param pulumi.Input[_builtins.int] fixed_rate: Specifies the unit fixed rate.  
               This parameter is used when `type` is set to **FIXED_RATE**.
               + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
               + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`
               
               <a name="KeywordsAlarmRule_NotificationRule"></a>
               The `NotificationRule` block supports:
        :param pulumi.Input[_builtins.str] fixed_rate_unit: Specifies the unit of fixed rate.  
               The value can be: **minute** and **hour**.
        :param pulumi.Input[_builtins.int] hour_of_day: Specifies the hour of day.  
               This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
               The value ranges from `0` to `23`.
        """
        pulumi.set(__self__, "type", type)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if fixed_rate is not None:
            pulumi.set(__self__, "fixed_rate", fixed_rate)
        if fixed_rate_unit is not None:
            pulumi.set(__self__, "fixed_rate_unit", fixed_rate_unit)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the frequency type.  
        The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cron expression.  
        This parameter is used when `type` is set to **CRON**.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the day of week.  
        This parameter is used when `type` is set to **WEEKLY**.
        The value ranges from `1` to `7`. `1` means Sunday.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "day_of_week", value)

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the unit fixed rate.  
        This parameter is used when `type` is set to **FIXED_RATE**.
        + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`

        <a name="KeywordsAlarmRule_NotificationRule"></a>
        The `NotificationRule` block supports:
        """
        return pulumi.get(self, "fixed_rate")

    @fixed_rate.setter
    def fixed_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fixed_rate", value)

    @_builtins.property
    @pulumi.getter(name="fixedRateUnit")
    def fixed_rate_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit of fixed rate.  
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "fixed_rate_unit")

    @fixed_rate_unit.setter
    def fixed_rate_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fixed_rate_unit", value)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the hour of day.  
        This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
        The value ranges from `0` to `23`.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hour_of_day", value)


if not MYPY:
    class KeywordsAlarmRuleKeywordsRequestArgsDict(TypedDict):
        condition: pulumi.Input[_builtins.str]
        """
        Specifies the keywords request condition.  
        The value can be: **>=**, **<=**, **<** and **>**.
        """
        keywords: pulumi.Input[_builtins.str]
        """
        Specifies the keywords.
        """
        log_group_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the log group.
        """
        log_stream_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the log stream.
        """
        number: pulumi.Input[_builtins.int]
        """
        Specifies the line number.
        """
        search_time_range: pulumi.Input[_builtins.int]
        """
        Specifies the search time range.
        + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`.
        """
        search_time_range_unit: pulumi.Input[_builtins.str]
        """
        Specifies the unit of search time range.  
        The value can be: **minute** and **hour**.
        """
        log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the log group.
        """
        log_stream_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the log stream.

        <a name="KeywordsAlarmRule_Frequency"></a>
        The `Frequency` block supports:
        """
elif False:
    KeywordsAlarmRuleKeywordsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeywordsAlarmRuleKeywordsRequestArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str],
                 keywords: pulumi.Input[_builtins.str],
                 log_group_id: pulumi.Input[_builtins.str],
                 log_stream_id: pulumi.Input[_builtins.str],
                 number: pulumi.Input[_builtins.int],
                 search_time_range: pulumi.Input[_builtins.int],
                 search_time_range_unit: pulumi.Input[_builtins.str],
                 log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 log_stream_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition: Specifies the keywords request condition.  
               The value can be: **>=**, **<=**, **<** and **>**.
        :param pulumi.Input[_builtins.str] keywords: Specifies the keywords.
        :param pulumi.Input[_builtins.str] log_group_id: Specifies the ID of the log group.
        :param pulumi.Input[_builtins.str] log_stream_id: Specifies the ID of the log stream.
        :param pulumi.Input[_builtins.int] number: Specifies the line number.
        :param pulumi.Input[_builtins.int] search_time_range: Specifies the search time range.
               + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`.
               + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`.
        :param pulumi.Input[_builtins.str] search_time_range_unit: Specifies the unit of search time range.  
               The value can be: **minute** and **hour**.
        :param pulumi.Input[_builtins.str] log_group_name: Specifies the name of the log group.
        :param pulumi.Input[_builtins.str] log_stream_name: Specifies the name of the log stream.
               
               <a name="KeywordsAlarmRule_Frequency"></a>
               The `Frequency` block supports:
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "keywords", keywords)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "search_time_range", search_time_range)
        pulumi.set(__self__, "search_time_range_unit", search_time_range_unit)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the keywords request condition.  
        The value can be: **>=**, **<=**, **<** and **>**.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def keywords(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the keywords.
        """
        return pulumi.get(self, "keywords")

    @keywords.setter
    def keywords(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "keywords", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the log stream.
        """
        return pulumi.get(self, "log_stream_id")

    @log_stream_id.setter
    def log_stream_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_stream_id", value)

    @_builtins.property
    @pulumi.getter
    def number(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the line number.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter(name="searchTimeRange")
    def search_time_range(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the search time range.
        + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`.
        """
        return pulumi.get(self, "search_time_range")

    @search_time_range.setter
    def search_time_range(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "search_time_range", value)

    @_builtins.property
    @pulumi.getter(name="searchTimeRangeUnit")
    def search_time_range_unit(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the unit of search time range.  
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "search_time_range_unit")

    @search_time_range_unit.setter
    def search_time_range_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "search_time_range_unit", value)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the log group.
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the log stream.

        <a name="KeywordsAlarmRule_Frequency"></a>
        The `Frequency` block supports:
        """
        return pulumi.get(self, "log_stream_name")

    @log_stream_name.setter
    def log_stream_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_stream_name", value)


if not MYPY:
    class KeywordsAlarmRuleNotificationRuleArgsDict(TypedDict):
        template_name: pulumi.Input[_builtins.str]
        """
        Specifies the notification template name.
        """
        topics: pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationRuleTopicArgsDict']]]
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        Specifies the user name.
        """
        language: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the notification language.  
        The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.

        <a name="KeywordsAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the timezone.
        """
elif False:
    KeywordsAlarmRuleNotificationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeywordsAlarmRuleNotificationRuleArgs:
    def __init__(__self__, *,
                 template_name: pulumi.Input[_builtins.str],
                 topics: pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationRuleTopicArgs']]],
                 user_name: pulumi.Input[_builtins.str],
                 language: Optional[pulumi.Input[_builtins.str]] = None,
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] template_name: Specifies the notification template name.
        :param pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationRuleTopicArgs']]] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param pulumi.Input[_builtins.str] user_name: Specifies the user name.
        :param pulumi.Input[_builtins.str] language: Specifies the notification language.  
               The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.
               
               <a name="KeywordsAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        :param pulumi.Input[_builtins.str] timezone: Specifies the timezone.
        """
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_name", value)

    @_builtins.property
    @pulumi.getter
    def topics(self) -> pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationRuleTopicArgs']]]:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationRuleTopicArgs']]]):
        pulumi.set(self, "topics", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the notification language.  
        The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.

        <a name="KeywordsAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the timezone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class KeywordsAlarmRuleNotificationRuleTopicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the topic name.
        """
        topic_urn: pulumi.Input[_builtins.str]
        """
        Specifies the topic URN.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        push_policy: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the push policy.
        """
elif False:
    KeywordsAlarmRuleNotificationRuleTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeywordsAlarmRuleNotificationRuleTopicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 topic_urn: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 push_policy: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the topic name.
        :param pulumi.Input[_builtins.str] topic_urn: Specifies the topic URN.
        :param pulumi.Input[_builtins.str] display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param pulumi.Input[_builtins.int] push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_urn", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")

    @push_policy.setter
    def push_policy(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "push_policy", value)


if not MYPY:
    class KeywordsAlarmRuleNotificationSaveRuleArgsDict(TypedDict):
        template_name: pulumi.Input[_builtins.str]
        """
        Specifies the notification template name.
        """
        topics: pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationSaveRuleTopicArgsDict']]]
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        Specifies the user name.
        """
        language: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the notification language.  
        The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.

        <a name="KeywordsAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the timezone.
        """
elif False:
    KeywordsAlarmRuleNotificationSaveRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeywordsAlarmRuleNotificationSaveRuleArgs:
    def __init__(__self__, *,
                 template_name: pulumi.Input[_builtins.str],
                 topics: pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationSaveRuleTopicArgs']]],
                 user_name: pulumi.Input[_builtins.str],
                 language: Optional[pulumi.Input[_builtins.str]] = None,
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] template_name: Specifies the notification template name.
        :param pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationSaveRuleTopicArgs']]] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param pulumi.Input[_builtins.str] user_name: Specifies the user name.
        :param pulumi.Input[_builtins.str] language: Specifies the notification language.  
               The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.
               
               <a name="KeywordsAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        :param pulumi.Input[_builtins.str] timezone: Specifies the timezone.
        """
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_name", value)

    @_builtins.property
    @pulumi.getter
    def topics(self) -> pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationSaveRuleTopicArgs']]]:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: pulumi.Input[Sequence[pulumi.Input['KeywordsAlarmRuleNotificationSaveRuleTopicArgs']]]):
        pulumi.set(self, "topics", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the notification language.  
        The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.

        <a name="KeywordsAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the timezone.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class KeywordsAlarmRuleNotificationSaveRuleTopicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the topic name.
        """
        topic_urn: pulumi.Input[_builtins.str]
        """
        Specifies the topic URN.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        push_policy: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the push policy.
        """
elif False:
    KeywordsAlarmRuleNotificationSaveRuleTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeywordsAlarmRuleNotificationSaveRuleTopicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 topic_urn: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 push_policy: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the topic name.
        :param pulumi.Input[_builtins.str] topic_urn: Specifies the topic URN.
        :param pulumi.Input[_builtins.str] display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param pulumi.Input[_builtins.int] push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_urn", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")

    @push_policy.setter
    def push_policy(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "push_policy", value)


if not MYPY:
    class LogConvergeLogMappingConfigArgsDict(TypedDict):
        source_log_group_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the log group for source side.
        """
        target_log_group_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the log group for target side.
        """
        log_stream_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogConvergeLogMappingConfigLogStreamConfigArgsDict']]]]
        """
        Specifies the log streams converged under the current log group.  
        The log_stream_config structure is documented below.

        <a name="converge_log_streams_config"></a>
        The `log_stream_config` block supports:
        """
        target_log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the log group for target side.

        > If you want to use an existing log group, this parameter (`target_log_group_id`) is required.
        """
elif False:
    LogConvergeLogMappingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogConvergeLogMappingConfigArgs:
    def __init__(__self__, *,
                 source_log_group_id: pulumi.Input[_builtins.str],
                 target_log_group_name: pulumi.Input[_builtins.str],
                 log_stream_configs: Optional[pulumi.Input[Sequence[pulumi.Input['LogConvergeLogMappingConfigLogStreamConfigArgs']]]] = None,
                 target_log_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_log_group_id: Specifies the ID of the log group for source side.
        :param pulumi.Input[_builtins.str] target_log_group_name: Specifies the name of the log group for target side.
        :param pulumi.Input[Sequence[pulumi.Input['LogConvergeLogMappingConfigLogStreamConfigArgs']]] log_stream_configs: Specifies the log streams converged under the current log group.  
               The log_stream_config structure is documented below.
               
               <a name="converge_log_streams_config"></a>
               The `log_stream_config` block supports:
        :param pulumi.Input[_builtins.str] target_log_group_id: Specifies the ID of the log group for target side.
               
               > If you want to use an existing log group, this parameter (`target_log_group_id`) is required.
        """
        pulumi.set(__self__, "source_log_group_id", source_log_group_id)
        pulumi.set(__self__, "target_log_group_name", target_log_group_name)
        if log_stream_configs is not None:
            pulumi.set(__self__, "log_stream_configs", log_stream_configs)
        if target_log_group_id is not None:
            pulumi.set(__self__, "target_log_group_id", target_log_group_id)

    @_builtins.property
    @pulumi.getter(name="sourceLogGroupId")
    def source_log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the log group for source side.
        """
        return pulumi.get(self, "source_log_group_id")

    @source_log_group_id.setter
    def source_log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="targetLogGroupName")
    def target_log_group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the log group for target side.
        """
        return pulumi.get(self, "target_log_group_name")

    @target_log_group_name.setter
    def target_log_group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="logStreamConfigs")
    def log_stream_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogConvergeLogMappingConfigLogStreamConfigArgs']]]]:
        """
        Specifies the log streams converged under the current log group.  
        The log_stream_config structure is documented below.

        <a name="converge_log_streams_config"></a>
        The `log_stream_config` block supports:
        """
        return pulumi.get(self, "log_stream_configs")

    @log_stream_configs.setter
    def log_stream_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogConvergeLogMappingConfigLogStreamConfigArgs']]]]):
        pulumi.set(self, "log_stream_configs", value)

    @_builtins.property
    @pulumi.getter(name="targetLogGroupId")
    def target_log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the log group for target side.

        > If you want to use an existing log group, this parameter (`target_log_group_id`) is required.
        """
        return pulumi.get(self, "target_log_group_id")

    @target_log_group_id.setter
    def target_log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_log_group_id", value)


if not MYPY:
    class LogConvergeLogMappingConfigLogStreamConfigArgsDict(TypedDict):
        source_log_stream_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the log stream for source side.
        """
        target_log_stream_name: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the log stream for source side.
        """
        target_log_stream_ttl: pulumi.Input[_builtins.int]
        """
        Specifies the ID of the log stream for source side.
        """
        target_log_stream_eps_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The enterprise project ID of the log stream for target side.
        """
        target_log_stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the log stream for source side.

        > If you want to use an existing log stream, this parameter (`target_log_stream_id`) is required.
        """
elif False:
    LogConvergeLogMappingConfigLogStreamConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogConvergeLogMappingConfigLogStreamConfigArgs:
    def __init__(__self__, *,
                 source_log_stream_id: pulumi.Input[_builtins.str],
                 target_log_stream_name: pulumi.Input[_builtins.str],
                 target_log_stream_ttl: pulumi.Input[_builtins.int],
                 target_log_stream_eps_id: Optional[pulumi.Input[_builtins.str]] = None,
                 target_log_stream_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source_log_stream_id: Specifies the ID of the log stream for source side.
        :param pulumi.Input[_builtins.str] target_log_stream_name: Specifies the ID of the log stream for source side.
        :param pulumi.Input[_builtins.int] target_log_stream_ttl: Specifies the ID of the log stream for source side.
        :param pulumi.Input[_builtins.str] target_log_stream_eps_id: The enterprise project ID of the log stream for target side.
        :param pulumi.Input[_builtins.str] target_log_stream_id: Specifies the ID of the log stream for source side.
               
               > If you want to use an existing log stream, this parameter (`target_log_stream_id`) is required.
        """
        pulumi.set(__self__, "source_log_stream_id", source_log_stream_id)
        pulumi.set(__self__, "target_log_stream_name", target_log_stream_name)
        pulumi.set(__self__, "target_log_stream_ttl", target_log_stream_ttl)
        if target_log_stream_eps_id is not None:
            pulumi.set(__self__, "target_log_stream_eps_id", target_log_stream_eps_id)
        if target_log_stream_id is not None:
            pulumi.set(__self__, "target_log_stream_id", target_log_stream_id)

    @_builtins.property
    @pulumi.getter(name="sourceLogStreamId")
    def source_log_stream_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the log stream for source side.
        """
        return pulumi.get(self, "source_log_stream_id")

    @source_log_stream_id.setter
    def source_log_stream_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_log_stream_id", value)

    @_builtins.property
    @pulumi.getter(name="targetLogStreamName")
    def target_log_stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the log stream for source side.
        """
        return pulumi.get(self, "target_log_stream_name")

    @target_log_stream_name.setter
    def target_log_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_log_stream_name", value)

    @_builtins.property
    @pulumi.getter(name="targetLogStreamTtl")
    def target_log_stream_ttl(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the ID of the log stream for source side.
        """
        return pulumi.get(self, "target_log_stream_ttl")

    @target_log_stream_ttl.setter
    def target_log_stream_ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_log_stream_ttl", value)

    @_builtins.property
    @pulumi.getter(name="targetLogStreamEpsId")
    def target_log_stream_eps_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The enterprise project ID of the log stream for target side.
        """
        return pulumi.get(self, "target_log_stream_eps_id")

    @target_log_stream_eps_id.setter
    def target_log_stream_eps_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_log_stream_eps_id", value)

    @_builtins.property
    @pulumi.getter(name="targetLogStreamId")
    def target_log_stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the log stream for source side.

        > If you want to use an existing log stream, this parameter (`target_log_stream_id`) is required.
        """
        return pulumi.get(self, "target_log_stream_id")

    @target_log_stream_id.setter
    def target_log_stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_log_stream_id", value)


if not MYPY:
    class MetricRuleAggregatorArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        Specifies the field of the log statistics.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        group_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of the group fields of the log statistics.
        """
        keyword: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the keyword of the log statistics. The keyword is case sensitive.  
        This parameter is required and available only when the `aggregator.type` parameter is set to **countKeyword**.

        <a name="metric_rule_filter"></a>
        The `filter` block supports:
        """
elif False:
    MetricRuleAggregatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricRuleAggregatorArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 keyword: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] field: Specifies the field of the log statistics.
        :param pulumi.Input[_builtins.str] type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_bies: Specifies the list of the group fields of the log statistics.
        :param pulumi.Input[_builtins.str] keyword: Specifies the keyword of the log statistics. The keyword is case sensitive.  
               This parameter is required and available only when the `aggregator.type` parameter is set to **countKeyword**.
               
               <a name="metric_rule_filter"></a>
               The `filter` block supports:
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field of the log statistics.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of the group fields of the log statistics.
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_bies", value)

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the keyword of the log statistics. The keyword is case sensitive.  
        This parameter is required and available only when the `aggregator.type` parameter is set to **countKeyword**.

        <a name="metric_rule_filter"></a>
        The `filter` block supports:
        """
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyword", value)


if not MYPY:
    class MetricRuleFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterArgsDict']]]]
        """
        Specifies the list of the log filter rule associations.
        The filters structure is documented below.

        <a name="metric_rule_associated_filters"></a>
        The `filters` block supports:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
elif False:
    MetricRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricRuleFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterArgs']]] filters: Specifies the list of the log filter rule associations.
               The filters structure is documented below.
               
               <a name="metric_rule_associated_filters"></a>
               The `filters` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterArgs']]]]:
        """
        Specifies the list of the log filter rule associations.
        The filters structure is documented below.

        <a name="metric_rule_associated_filters"></a>
        The `filters` block supports:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MetricRuleFilterFilterArgsDict(TypedDict):
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterFilterArgsDict']]]]
        """
        Specifies the list of the log filter rule associations.
        The filters structure is documented below.

        <a name="metric_rule_associated_filters"></a>
        The `filters` block supports:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
elif False:
    MetricRuleFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricRuleFilterFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterFilterArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterFilterArgs']]] filters: Specifies the list of the log filter rule associations.
               The filters structure is documented below.
               
               <a name="metric_rule_associated_filters"></a>
               The `filters` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterFilterArgs']]]]:
        """
        Specifies the list of the log filter rule associations.
        The filters structure is documented below.

        <a name="metric_rule_associated_filters"></a>
        The `filters` block supports:
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRuleFilterFilterFilterArgs']]]]):
        pulumi.set(self, "filters", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MetricRuleFilterFilterFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the filter field of the log.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        lower: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the minimum value corresponding to the log filter field.  
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
        or **outRange**.
        """
        upper: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the maximum value corresponding to the log filter field.  
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
        or **outRange**.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value corresponding to the log filter field.
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **contains**,
        **notContains**, **equal**, **notEqual**, **gt**, **gte**, **lt** or **lte**.
        """
elif False:
    MetricRuleFilterFilterFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricRuleFilterFilterFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 lower: Optional[pulumi.Input[_builtins.str]] = None,
                 upper: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the filter field of the log.
        :param pulumi.Input[_builtins.str] type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        :param pulumi.Input[_builtins.str] lower: Specifies the minimum value corresponding to the log filter field.  
               This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
               or **outRange**.
        :param pulumi.Input[_builtins.str] upper: Specifies the maximum value corresponding to the log filter field.  
               This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
               or **outRange**.
        :param pulumi.Input[_builtins.str] value: Specifies the value corresponding to the log filter field.
               This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **contains**,
               **notContains**, **equal**, **notEqual**, **gt**, **gte**, **lt** or **lte**.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the filter field of the log.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def lower(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the minimum value corresponding to the log filter field.  
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
        or **outRange**.
        """
        return pulumi.get(self, "lower")

    @lower.setter
    def lower(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lower", value)

    @_builtins.property
    @pulumi.getter
    def upper(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the maximum value corresponding to the log filter field.  
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
        or **outRange**.
        """
        return pulumi.get(self, "upper")

    @upper.setter
    def upper(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upper", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value corresponding to the log filter field.
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **contains**,
        **notContains**, **equal**, **notEqual**, **gt**, **gte**, **lt** or **lte**.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MetricRuleSamplerArgsDict(TypedDict):
        ratio: pulumi.Input[_builtins.str]
        """
        Specifies the sampling rate of the log.
        + If `sampler.type` is set to **random**, the valid value ranges from `0.1` to `1`.
        + If `sampler.type` is set to **none**, the value is set to `1`.

        <a name="metric_rule_sinks"></a>
        The `sinks` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
elif False:
    MetricRuleSamplerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricRuleSamplerArgs:
    def __init__(__self__, *,
                 ratio: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ratio: Specifies the sampling rate of the log.
               + If `sampler.type` is set to **random**, the valid value ranges from `0.1` to `1`.
               + If `sampler.type` is set to **none**, the value is set to `1`.
               
               <a name="metric_rule_sinks"></a>
               The `sinks` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        """
        pulumi.set(__self__, "ratio", ratio)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def ratio(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the sampling rate of the log.
        + If `sampler.type` is set to **random**, the valid value ranges from `0.1` to `1`.
        + If `sampler.type` is set to **none**, the value is set to `1`.

        <a name="metric_rule_sinks"></a>
        The `sinks` block supports:
        """
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ratio", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MetricRuleSinkArgsDict(TypedDict):
        metric_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the generated log metric. The name must be unique.
        The name only English letters, digits, hyphens (-) and colon(:) are allowed, and must start with an English letter.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the AOM Prometheus common instance.  
        This parameter is required and available only when the `sinks.type` parameter is set to **aom**.

        <a name="metric_rule_aggregator"></a>
        The `aggregator` block supports:
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the AOM Prometheus common instance.  
        This parameter is required and available only when the `sinks.type` parameter is set to **aom**.
        """
elif False:
    MetricRuleSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricRuleSinkArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metric_name: Specifies the name of the generated log metric. The name must be unique.
               The name only English letters, digits, hyphens (-) and colon(:) are allowed, and must start with an English letter.
        :param pulumi.Input[_builtins.str] type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        :param pulumi.Input[_builtins.str] instance_id: Specifies the ID of the AOM Prometheus common instance.  
               This parameter is required and available only when the `sinks.type` parameter is set to **aom**.
               
               <a name="metric_rule_aggregator"></a>
               The `aggregator` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the name of the AOM Prometheus common instance.  
               This parameter is required and available only when the `sinks.type` parameter is set to **aom**.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "type", type)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the generated log metric. The name must be unique.
        The name only English letters, digits, hyphens (-) and colon(:) are allowed, and must start with an English letter.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the AOM Prometheus common instance.  
        This parameter is required and available only when the `sinks.type` parameter is set to **aom**.

        <a name="metric_rule_aggregator"></a>
        The `aggregator` block supports:
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the AOM Prometheus common instance.  
        This parameter is required and available only when the `sinks.type` parameter is set to **aom**.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NotificationTemplateTemplateArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        The content of the sub-template..  
        In the sub-template body, only the following variables are supported for the variables following the **$** symbol.
        The supported variables vary according to the alarm type (keyword alarm and SQL alarm).

        + Common variables:
        * Alarm severity: **${event_severity}**.
        * Occurrence time: **${starts_at}**.
        * Alarm source: **$event.metadata.resource_provider**.
        * Resource type: **$event.metadata.resource_type**.
        * Resource ID: **${resources}**.
        * Expression: **$event.annotations.condition_expression**.
        * current value: **$event.annotations.current_value**.
        * Statistical period: **$event.annotations.frequency**.

        + Keywords alarm specific variable:
        * query time: **$event.annotations.results[0].time**.
        * Run the **$event.annotations.results[0].raw_results** command to query LTSs.

        + SQL alarm specific variable:
        * LTS group/stream name: **$event.annotations.results[0].resource_id**.
        * Query statement: **$event.annotations.results[0].sql**.
        * Query time: **$event.annotations.results[0].time**.
        * Query URL: **$event.annotations.results[0].url**.
        * Run the **$event.annotations.results[0].raw_results** command to query LTSs.

        > semicolon(;) after variable is an English symbol and must be added. Otherwise, the template will fail to be replaced.
        """
        sub_type: pulumi.Input[_builtins.str]
        """
        The type of the sub-template.  
        Only the following five types are supported: **sms**, **dingding**, **wechat**, **webhook**, **email**.
        """
elif False:
    NotificationTemplateTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationTemplateTemplateArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 sub_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] content: The content of the sub-template..  
               In the sub-template body, only the following variables are supported for the variables following the **$** symbol.
               The supported variables vary according to the alarm type (keyword alarm and SQL alarm).
               
               + Common variables:
               * Alarm severity: **${event_severity}**.
               * Occurrence time: **${starts_at}**.
               * Alarm source: **$event.metadata.resource_provider**.
               * Resource type: **$event.metadata.resource_type**.
               * Resource ID: **${resources}**.
               * Expression: **$event.annotations.condition_expression**.
               * current value: **$event.annotations.current_value**.
               * Statistical period: **$event.annotations.frequency**.
               
               + Keywords alarm specific variable:
               * query time: **$event.annotations.results[0].time**.
               * Run the **$event.annotations.results[0].raw_results** command to query LTSs.
               
               + SQL alarm specific variable:
               * LTS group/stream name: **$event.annotations.results[0].resource_id**.
               * Query statement: **$event.annotations.results[0].sql**.
               * Query time: **$event.annotations.results[0].time**.
               * Query URL: **$event.annotations.results[0].url**.
               * Run the **$event.annotations.results[0].raw_results** command to query LTSs.
               
               > semicolon(;) after variable is an English symbol and must be added. Otherwise, the template will fail to be replaced.
        :param pulumi.Input[_builtins.str] sub_type: The type of the sub-template.  
               Only the following five types are supported: **sms**, **dingding**, **wechat**, **webhook**, **email**.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "sub_type", sub_type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        The content of the sub-template..  
        In the sub-template body, only the following variables are supported for the variables following the **$** symbol.
        The supported variables vary according to the alarm type (keyword alarm and SQL alarm).

        + Common variables:
        * Alarm severity: **${event_severity}**.
        * Occurrence time: **${starts_at}**.
        * Alarm source: **$event.metadata.resource_provider**.
        * Resource type: **$event.metadata.resource_type**.
        * Resource ID: **${resources}**.
        * Expression: **$event.annotations.condition_expression**.
        * current value: **$event.annotations.current_value**.
        * Statistical period: **$event.annotations.frequency**.

        + Keywords alarm specific variable:
        * query time: **$event.annotations.results[0].time**.
        * Run the **$event.annotations.results[0].raw_results** command to query LTSs.

        + SQL alarm specific variable:
        * LTS group/stream name: **$event.annotations.results[0].resource_id**.
        * Query statement: **$event.annotations.results[0].sql**.
        * Query time: **$event.annotations.results[0].time**.
        * Query URL: **$event.annotations.results[0].url**.
        * Run the **$event.annotations.results[0].raw_results** command to query LTSs.

        > semicolon(;) after variable is an English symbol and must be added. Otherwise, the template will fail to be replaced.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the sub-template.  
        Only the following five types are supported: **sms**, **dingding**, **wechat**, **webhook**, **email**.
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sub_type", value)


if not MYPY:
    class RegisterKafkaInstanceConnectInfoArgsDict(TypedDict):
        encrypted_pwd: NotRequired[pulumi.Input[_builtins.str]]
        """
        The encrypted password of the SASL_SSL user of the Kafka instance.
        """
        pwd: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the password of the SASL_SSL user of the Kafka instance.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the SASL_SSL user of the Kafka instance.
        """
elif False:
    RegisterKafkaInstanceConnectInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegisterKafkaInstanceConnectInfoArgs:
    def __init__(__self__, *,
                 encrypted_pwd: Optional[pulumi.Input[_builtins.str]] = None,
                 pwd: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] encrypted_pwd: The encrypted password of the SASL_SSL user of the Kafka instance.
        :param pulumi.Input[_builtins.str] pwd: Specifies the password of the SASL_SSL user of the Kafka instance.
        :param pulumi.Input[_builtins.str] user_name: Specifies the name of the SASL_SSL user of the Kafka instance.
        """
        if encrypted_pwd is not None:
            pulumi.set(__self__, "encrypted_pwd", encrypted_pwd)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="encryptedPwd")
    def encrypted_pwd(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The encrypted password of the SASL_SSL user of the Kafka instance.
        """
        return pulumi.get(self, "encrypted_pwd")

    @encrypted_pwd.setter
    def encrypted_pwd(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encrypted_pwd", value)

    @_builtins.property
    @pulumi.getter
    def pwd(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the password of the SASL_SSL user of the Kafka instance.
        """
        return pulumi.get(self, "pwd")

    @pwd.setter
    def pwd(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pwd", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the SASL_SSL user of the Kafka instance.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class SqlAlarmRuleFrequencyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the frequency type.
        The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        """
        cron_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cron expression.
        This parameter is used when `type` is set to **CRON**.
        """
        day_of_week: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the day of week.
        This parameter is used when `type` is set to **WEEKLY**.
        The value ranges from `1` to `7`. `1` means Sunday.
        """
        fixed_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the unit fixed rate.
        This parameter is used when `type` is set to **FIXED_RATE**.
        + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`.

        <a name="SQLAlarmRule_NotificationRule"></a>
        The `NotificationRule` block supports:
        """
        fixed_rate_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit of fixed rate.
        The value can be: **minute** and **hour**.
        """
        hour_of_day: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the hour of day.
        This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
        The value ranges from `0` to `23`.
        """
elif False:
    SqlAlarmRuleFrequencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAlarmRuleFrequencyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[_builtins.int]] = None,
                 fixed_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 fixed_rate_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 hour_of_day: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the frequency type.
               The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        :param pulumi.Input[_builtins.str] cron_expression: Specifies the cron expression.
               This parameter is used when `type` is set to **CRON**.
        :param pulumi.Input[_builtins.int] day_of_week: Specifies the day of week.
               This parameter is used when `type` is set to **WEEKLY**.
               The value ranges from `1` to `7`. `1` means Sunday.
        :param pulumi.Input[_builtins.int] fixed_rate: Specifies the unit fixed rate.
               This parameter is used when `type` is set to **FIXED_RATE**.
               + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
               + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`.
               
               <a name="SQLAlarmRule_NotificationRule"></a>
               The `NotificationRule` block supports:
        :param pulumi.Input[_builtins.str] fixed_rate_unit: Specifies the unit of fixed rate.
               The value can be: **minute** and **hour**.
        :param pulumi.Input[_builtins.int] hour_of_day: Specifies the hour of day.
               This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
               The value ranges from `0` to `23`.
        """
        pulumi.set(__self__, "type", type)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if fixed_rate is not None:
            pulumi.set(__self__, "fixed_rate", fixed_rate)
        if fixed_rate_unit is not None:
            pulumi.set(__self__, "fixed_rate_unit", fixed_rate_unit)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the frequency type.
        The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cron expression.
        This parameter is used when `type` is set to **CRON**.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the day of week.
        This parameter is used when `type` is set to **WEEKLY**.
        The value ranges from `1` to `7`. `1` means Sunday.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "day_of_week", value)

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the unit fixed rate.
        This parameter is used when `type` is set to **FIXED_RATE**.
        + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`.

        <a name="SQLAlarmRule_NotificationRule"></a>
        The `NotificationRule` block supports:
        """
        return pulumi.get(self, "fixed_rate")

    @fixed_rate.setter
    def fixed_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fixed_rate", value)

    @_builtins.property
    @pulumi.getter(name="fixedRateUnit")
    def fixed_rate_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit of fixed rate.
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "fixed_rate_unit")

    @fixed_rate_unit.setter
    def fixed_rate_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fixed_rate_unit", value)

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the hour of day.
        This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
        The value ranges from `0` to `23`.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hour_of_day", value)


if not MYPY:
    class SqlAlarmRuleNotificationRuleArgsDict(TypedDict):
        language: pulumi.Input[_builtins.str]
        """
        Specifies the notification language.
        The value can be **zh-cn** and **en-us**.
        """
        template_name: pulumi.Input[_builtins.str]
        """
        Specifies the notification template name.
        """
        topics: pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationRuleTopicArgsDict']]]
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        Specifies the user name.
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the timezone.

        <a name="SQLAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
elif False:
    SqlAlarmRuleNotificationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAlarmRuleNotificationRuleArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[_builtins.str],
                 template_name: pulumi.Input[_builtins.str],
                 topics: pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationRuleTopicArgs']]],
                 user_name: pulumi.Input[_builtins.str],
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] language: Specifies the notification language.
               The value can be **zh-cn** and **en-us**.
        :param pulumi.Input[_builtins.str] template_name: Specifies the notification template name.
        :param pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationRuleTopicArgs']]] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param pulumi.Input[_builtins.str] user_name: Specifies the user name.
        :param pulumi.Input[_builtins.str] timezone: Specifies the timezone.
               
               <a name="SQLAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        """
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def language(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification language.
        The value can be **zh-cn** and **en-us**.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language", value)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_name", value)

    @_builtins.property
    @pulumi.getter
    def topics(self) -> pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationRuleTopicArgs']]]:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationRuleTopicArgs']]]):
        pulumi.set(self, "topics", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the timezone.

        <a name="SQLAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class SqlAlarmRuleNotificationRuleTopicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the topic name.
        """
        topic_urn: pulumi.Input[_builtins.str]
        """
        Specifies the topic URN.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        push_policy: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the push policy.
        """
elif False:
    SqlAlarmRuleNotificationRuleTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAlarmRuleNotificationRuleTopicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 topic_urn: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 push_policy: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the topic name.
        :param pulumi.Input[_builtins.str] topic_urn: Specifies the topic URN.
        :param pulumi.Input[_builtins.str] display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param pulumi.Input[_builtins.int] push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_urn", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")

    @push_policy.setter
    def push_policy(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "push_policy", value)


if not MYPY:
    class SqlAlarmRuleNotificationSaveRuleArgsDict(TypedDict):
        language: pulumi.Input[_builtins.str]
        """
        Specifies the notification language.
        The value can be **zh-cn** and **en-us**.
        """
        template_name: pulumi.Input[_builtins.str]
        """
        Specifies the notification template name.
        """
        topics: pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationSaveRuleTopicArgsDict']]]
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        user_name: pulumi.Input[_builtins.str]
        """
        Specifies the user name.
        """
        timezone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the timezone.

        <a name="SQLAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
elif False:
    SqlAlarmRuleNotificationSaveRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAlarmRuleNotificationSaveRuleArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[_builtins.str],
                 template_name: pulumi.Input[_builtins.str],
                 topics: pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationSaveRuleTopicArgs']]],
                 user_name: pulumi.Input[_builtins.str],
                 timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] language: Specifies the notification language.
               The value can be **zh-cn** and **en-us**.
        :param pulumi.Input[_builtins.str] template_name: Specifies the notification template name.
        :param pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationSaveRuleTopicArgs']]] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param pulumi.Input[_builtins.str] user_name: Specifies the user name.
        :param pulumi.Input[_builtins.str] timezone: Specifies the timezone.
               
               <a name="SQLAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        """
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def language(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification language.
        The value can be **zh-cn** and **en-us**.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language", value)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_name", value)

    @_builtins.property
    @pulumi.getter
    def topics(self) -> pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationSaveRuleTopicArgs']]]:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: pulumi.Input[Sequence[pulumi.Input['SqlAlarmRuleNotificationSaveRuleTopicArgs']]]):
        pulumi.set(self, "topics", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the timezone.

        <a name="SQLAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class SqlAlarmRuleNotificationSaveRuleTopicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the topic name.
        """
        topic_urn: pulumi.Input[_builtins.str]
        """
        Specifies the topic URN.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        push_policy: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the push policy.
        """
elif False:
    SqlAlarmRuleNotificationSaveRuleTopicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAlarmRuleNotificationSaveRuleTopicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 topic_urn: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 push_policy: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the topic name.
        :param pulumi.Input[_builtins.str] topic_urn: Specifies the topic URN.
        :param pulumi.Input[_builtins.str] display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param pulumi.Input[_builtins.int] push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_urn", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")

    @push_policy.setter
    def push_policy(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "push_policy", value)


if not MYPY:
    class SqlAlarmRuleSqlRequestArgsDict(TypedDict):
        log_group_id: pulumi.Input[_builtins.str]
        """
        Specifies the log group id.
        """
        log_stream_id: pulumi.Input[_builtins.str]
        """
        Specifies the log stream id.
        """
        search_time_range: pulumi.Input[_builtins.int]
        """
        Specifies the search time range.
        + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`;
        + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`;
        """
        search_time_range_unit: pulumi.Input[_builtins.str]
        """
        Specifies the unit of search time range.
        The value can be: **minute** and **hour**.
        """
        sql: pulumi.Input[_builtins.str]
        """
        Specifies the SQL.
        """
        title: pulumi.Input[_builtins.str]
        """
        Specifies the SQL request title.
        """
        is_time_range_relative: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the SQL request is relative to time range.  
        Defaults to **false**.
        """
        log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the log group.
        """
        log_stream_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the log stream.

        <a name="SQLAlarmRule_Frequency"></a>
        The `Frequency` block supports:
        """
elif False:
    SqlAlarmRuleSqlRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAlarmRuleSqlRequestArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[_builtins.str],
                 log_stream_id: pulumi.Input[_builtins.str],
                 search_time_range: pulumi.Input[_builtins.int],
                 search_time_range_unit: pulumi.Input[_builtins.str],
                 sql: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 is_time_range_relative: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 log_stream_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_group_id: Specifies the log group id.
        :param pulumi.Input[_builtins.str] log_stream_id: Specifies the log stream id.
        :param pulumi.Input[_builtins.int] search_time_range: Specifies the search time range.
               + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`;
               + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`;
        :param pulumi.Input[_builtins.str] search_time_range_unit: Specifies the unit of search time range.
               The value can be: **minute** and **hour**.
        :param pulumi.Input[_builtins.str] sql: Specifies the SQL.
        :param pulumi.Input[_builtins.str] title: Specifies the SQL request title.
        :param pulumi.Input[_builtins.bool] is_time_range_relative: Specifies the SQL request is relative to time range.  
               Defaults to **false**.
        :param pulumi.Input[_builtins.str] log_group_name: Specifies the name of the log group.
        :param pulumi.Input[_builtins.str] log_stream_name: Specifies the name of the log stream.
               
               <a name="SQLAlarmRule_Frequency"></a>
               The `Frequency` block supports:
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "search_time_range", search_time_range)
        pulumi.set(__self__, "search_time_range_unit", search_time_range_unit)
        pulumi.set(__self__, "sql", sql)
        pulumi.set(__self__, "title", title)
        if is_time_range_relative is not None:
            pulumi.set(__self__, "is_time_range_relative", is_time_range_relative)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log group id.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log stream id.
        """
        return pulumi.get(self, "log_stream_id")

    @log_stream_id.setter
    def log_stream_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_stream_id", value)

    @_builtins.property
    @pulumi.getter(name="searchTimeRange")
    def search_time_range(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the search time range.
        + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`;
        + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`;
        """
        return pulumi.get(self, "search_time_range")

    @search_time_range.setter
    def search_time_range(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "search_time_range", value)

    @_builtins.property
    @pulumi.getter(name="searchTimeRangeUnit")
    def search_time_range_unit(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the unit of search time range.
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "search_time_range_unit")

    @search_time_range_unit.setter
    def search_time_range_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "search_time_range_unit", value)

    @_builtins.property
    @pulumi.getter
    def sql(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the SQL.
        """
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sql", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the SQL request title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="isTimeRangeRelative")
    def is_time_range_relative(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the SQL request is relative to time range.  
        Defaults to **false**.
        """
        return pulumi.get(self, "is_time_range_relative")

    @is_time_range_relative.setter
    def is_time_range_relative(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_time_range_relative", value)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the log group.
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the log stream.

        <a name="SQLAlarmRule_Frequency"></a>
        The `Frequency` block supports:
        """
        return pulumi.get(self, "log_stream_name")

    @log_stream_name.setter
    def log_stream_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_stream_name", value)


if not MYPY:
    class StreamIndexConfigurationFieldArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the field.  
        The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
        The name cannot start with a dot and end with a double underscores (__) or a dot.
        """
        field_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the field.  
        The valid values are as follows:
        + **string**
        + **long**
        + **float**
        """
        asciis: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of the ASCII delimiters.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        """
        case_sensitive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether letters are case sensitive.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        field_analysis_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alias name of the field.  
        Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        """
        include_chinese: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to include Chinese.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        lts_sub_fields_info_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamIndexConfigurationFieldLtsSubFieldsInfoListArgsDict']]]]
        """
        Specifies the list of of the JSON fields.  
        The lts_sub_fields_info_list structure is documented below.
        The parameter is available only when the `fields.field_type` parameter set to **json**.

        <a name="stream_index_config_fields_lts_sub_fields_info_list"></a>
        The `lts_sub_fields_info_list` block supports:
        """
        quick_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable quick analysis.  
        Defaults to **false**.
        """
        tokenizer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the custom delimiter.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
elif False:
    StreamIndexConfigurationFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamIndexConfigurationFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 field_type: pulumi.Input[_builtins.str],
                 asciis: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 case_sensitive: Optional[pulumi.Input[_builtins.bool]] = None,
                 field_analysis_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 include_chinese: Optional[pulumi.Input[_builtins.bool]] = None,
                 lts_sub_fields_info_lists: Optional[pulumi.Input[Sequence[pulumi.Input['StreamIndexConfigurationFieldLtsSubFieldsInfoListArgs']]]] = None,
                 quick_analysis: Optional[pulumi.Input[_builtins.bool]] = None,
                 tokenizer: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the name of the field.  
               The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
               The name cannot start with a dot and end with a double underscores (__) or a dot.
        :param pulumi.Input[_builtins.str] field_type: Specifies the type of the field.  
               The valid values are as follows:
               + **string**
               + **long**
               + **float**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] asciis: Specifies the list of the ASCII delimiters.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
               For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        :param pulumi.Input[_builtins.bool] case_sensitive: Specifies whether letters are case sensitive.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param pulumi.Input[_builtins.str] field_analysis_alias: Specifies the alias name of the field.  
               Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        :param pulumi.Input[_builtins.bool] include_chinese: Specifies whether to include Chinese.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param pulumi.Input[Sequence[pulumi.Input['StreamIndexConfigurationFieldLtsSubFieldsInfoListArgs']]] lts_sub_fields_info_lists: Specifies the list of of the JSON fields.  
               The lts_sub_fields_info_list structure is documented below.
               The parameter is available only when the `fields.field_type` parameter set to **json**.
               
               <a name="stream_index_config_fields_lts_sub_fields_info_list"></a>
               The `lts_sub_fields_info_list` block supports:
        :param pulumi.Input[_builtins.bool] quick_analysis: Specifies whether to enable quick analysis.  
               Defaults to **false**.
        :param pulumi.Input[_builtins.str] tokenizer: Specifies the custom delimiter.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        if asciis is not None:
            pulumi.set(__self__, "asciis", asciis)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if field_analysis_alias is not None:
            pulumi.set(__self__, "field_analysis_alias", field_analysis_alias)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if lts_sub_fields_info_lists is not None:
            pulumi.set(__self__, "lts_sub_fields_info_lists", lts_sub_fields_info_lists)
        if quick_analysis is not None:
            pulumi.set(__self__, "quick_analysis", quick_analysis)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the field.  
        The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
        The name cannot start with a dot and end with a double underscores (__) or a dot.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the field.  
        The valid values are as follows:
        + **string**
        + **long**
        + **float**
        """
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_type", value)

    @_builtins.property
    @pulumi.getter
    def asciis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of the ASCII delimiters.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        """
        return pulumi.get(self, "asciis")

    @asciis.setter
    def asciis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "asciis", value)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether letters are case sensitive.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter(name="fieldAnalysisAlias")
    def field_analysis_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alias name of the field.  
        Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        """
        return pulumi.get(self, "field_analysis_alias")

    @field_analysis_alias.setter
    def field_analysis_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_analysis_alias", value)

    @_builtins.property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to include Chinese.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "include_chinese")

    @include_chinese.setter
    def include_chinese(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_chinese", value)

    @_builtins.property
    @pulumi.getter(name="ltsSubFieldsInfoLists")
    def lts_sub_fields_info_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamIndexConfigurationFieldLtsSubFieldsInfoListArgs']]]]:
        """
        Specifies the list of of the JSON fields.  
        The lts_sub_fields_info_list structure is documented below.
        The parameter is available only when the `fields.field_type` parameter set to **json**.

        <a name="stream_index_config_fields_lts_sub_fields_info_list"></a>
        The `lts_sub_fields_info_list` block supports:
        """
        return pulumi.get(self, "lts_sub_fields_info_lists")

    @lts_sub_fields_info_lists.setter
    def lts_sub_fields_info_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamIndexConfigurationFieldLtsSubFieldsInfoListArgs']]]]):
        pulumi.set(self, "lts_sub_fields_info_lists", value)

    @_builtins.property
    @pulumi.getter(name="quickAnalysis")
    def quick_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable quick analysis.  
        Defaults to **false**.
        """
        return pulumi.get(self, "quick_analysis")

    @quick_analysis.setter
    def quick_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "quick_analysis", value)

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the custom delimiter.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "tokenizer")

    @tokenizer.setter
    def tokenizer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tokenizer", value)


if not MYPY:
    class StreamIndexConfigurationFieldLtsSubFieldsInfoListArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the field.  
        The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
        The name cannot start with a dot and end with a double underscores (__) or a dot.
        """
        field_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the field.  
        The valid values are as follows:
        + **string**
        + **long**
        + **float**
        """
        field_analysis_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the alias name of the field.  
        Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        """
        quick_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable quick analysis.  
        Defaults to **false**.
        """
elif False:
    StreamIndexConfigurationFieldLtsSubFieldsInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamIndexConfigurationFieldLtsSubFieldsInfoListArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 field_type: pulumi.Input[_builtins.str],
                 field_analysis_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 quick_analysis: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the name of the field.  
               The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
               The name cannot start with a dot and end with a double underscores (__) or a dot.
        :param pulumi.Input[_builtins.str] field_type: Specifies the type of the field.  
               The valid values are as follows:
               + **string**
               + **long**
               + **float**
        :param pulumi.Input[_builtins.str] field_analysis_alias: Specifies the alias name of the field.  
               Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        :param pulumi.Input[_builtins.bool] quick_analysis: Specifies whether to enable quick analysis.  
               Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        if field_analysis_alias is not None:
            pulumi.set(__self__, "field_analysis_alias", field_analysis_alias)
        if quick_analysis is not None:
            pulumi.set(__self__, "quick_analysis", quick_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the field.  
        The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
        The name cannot start with a dot and end with a double underscores (__) or a dot.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the field.  
        The valid values are as follows:
        + **string**
        + **long**
        + **float**
        """
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_type", value)

    @_builtins.property
    @pulumi.getter(name="fieldAnalysisAlias")
    def field_analysis_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the alias name of the field.  
        Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        """
        return pulumi.get(self, "field_analysis_alias")

    @field_analysis_alias.setter
    def field_analysis_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_analysis_alias", value)

    @_builtins.property
    @pulumi.getter(name="quickAnalysis")
    def quick_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable quick analysis.  
        Defaults to **false**.
        """
        return pulumi.get(self, "quick_analysis")

    @quick_analysis.setter
    def quick_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "quick_analysis", value)


if not MYPY:
    class StreamIndexConfigurationFullTextIndexArgsDict(TypedDict):
        asciis: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of the ASCII delimiters.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        """
        case_sensitive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether letters are case sensitive.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the full-text index.  
        Defaults to **true**.
        """
        include_chinese: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to include Chinese.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        tokenizer: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the custom delimiter.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
elif False:
    StreamIndexConfigurationFullTextIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamIndexConfigurationFullTextIndexArgs:
    def __init__(__self__, *,
                 asciis: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 case_sensitive: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 include_chinese: Optional[pulumi.Input[_builtins.bool]] = None,
                 tokenizer: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] asciis: Specifies the list of the ASCII delimiters.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
               For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        :param pulumi.Input[_builtins.bool] case_sensitive: Specifies whether letters are case sensitive.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param pulumi.Input[_builtins.bool] enable: Specifies whether to enable the full-text index.  
               Defaults to **true**.
        :param pulumi.Input[_builtins.bool] include_chinese: Specifies whether to include Chinese.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param pulumi.Input[_builtins.str] tokenizer: Specifies the custom delimiter.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        if asciis is not None:
            pulumi.set(__self__, "asciis", asciis)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter
    def asciis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of the ASCII delimiters.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        """
        return pulumi.get(self, "asciis")

    @asciis.setter
    def asciis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "asciis", value)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether letters are case sensitive.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "case_sensitive", value)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the full-text index.  
        Defaults to **true**.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to include Chinese.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "include_chinese")

    @include_chinese.setter
    def include_chinese(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_chinese", value)

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the custom delimiter.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "tokenizer")

    @tokenizer.setter
    def tokenizer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tokenizer", value)


if not MYPY:
    class StructTemplateDemoFieldArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        index: NotRequired[pulumi.Input[_builtins.int]]
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        user_defined_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    StructTemplateDemoFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructTemplateDemoFieldArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 index: Optional[pulumi.Input[_builtins.int]] = None,
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 user_defined_name: Optional[pulumi.Input[_builtins.str]] = None):
        if content is not None:
            pulumi.set(__self__, "content", content)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_defined_name is not None:
            pulumi.set(__self__, "user_defined_name", user_defined_name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="userDefinedName")
    def user_defined_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "user_defined_name")

    @user_defined_name.setter
    def user_defined_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_defined_name", value)


if not MYPY:
    class StructTemplateTagFieldArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    StructTemplateTagFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructTemplateTagFieldArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if content is not None:
            pulumi.set(__self__, "content", content)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StructingTemplateDemoFieldArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the field name. The valid length is limited from `1` to `64`.
        """
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
elif False:
    StructingTemplateDemoFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructingTemplateDemoFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the field name. The valid length is limited from `1` to `64`.
        :param pulumi.Input[_builtins.bool] is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field name. The valid length is limited from `1` to `64`.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)


if not MYPY:
    class StructingTemplateTagFieldArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the field name. The valid length is limited from `1` to `64`.
        """
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
elif False:
    StructingTemplateTagFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructingTemplateTagFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the field name. The valid length is limited from `1` to `64`.
        :param pulumi.Input[_builtins.bool] is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field name. The valid length is limited from `1` to `64`.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)


if not MYPY:
    class StructuringConfigurationDemoFieldArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the field name.
        """
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether quick analysis is enabled.
        """
elif False:
    StructuringConfigurationDemoFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructuringConfigurationDemoFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the field name.
        :param pulumi.Input[_builtins.bool] is_analysis: Specifies whether quick analysis is enabled.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field name.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether quick analysis is enabled.
        """
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)


if not MYPY:
    class StructuringConfigurationTagFieldArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the field name.
        """
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether quick analysis is enabled.
        """
elif False:
    StructuringConfigurationTagFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructuringConfigurationTagFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the field name.
        :param pulumi.Input[_builtins.bool] is_analysis: Specifies whether quick analysis is enabled.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field name.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether quick analysis is enabled.
        """
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)


if not MYPY:
    class StructuringCustomConfigurationDemoFieldArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the field content.
        """
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the field name. The value ranges from `1` to `50`.
        """
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
elif False:
    StructuringCustomConfigurationDemoFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructuringCustomConfigurationDemoFieldArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: Specifies the field content.
        :param pulumi.Input[_builtins.str] field_name: Specifies the field name. The value ranges from `1` to `50`.
        :param pulumi.Input[_builtins.bool] is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        :param pulumi.Input[_builtins.str] type: Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the field content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the field name. The value ranges from `1` to `50`.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class StructuringCustomConfigurationTagFieldArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        Specifies the field name. The value ranges from `1` to `50`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the field content.
        """
        is_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
elif False:
    StructuringCustomConfigurationTagFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StructuringCustomConfigurationTagFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 is_analysis: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] field_name: Specifies the field name. The value ranges from `1` to `50`.
        :param pulumi.Input[_builtins.str] type: Specifies the field data type. Valid values are **string**, **long** and **float**.
        :param pulumi.Input[_builtins.str] content: Specifies the field content.
        :param pulumi.Input[_builtins.bool] is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "type", type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field name. The value ranges from `1` to `50`.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the field content.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")

    @is_analysis.setter
    def is_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_analysis", value)


if not MYPY:
    class TransferLogStreamArgsDict(TypedDict):
        log_stream_id: pulumi.Input[_builtins.str]
        """
        Log stream ID.

        Changing this parameter will create a new resource.
        """
        log_stream_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log stream name.

        Changing this parameter will create a new resource.

        <a name="LtsTransfer_LogTransferInfo"></a>
        The `log_transfer_info` block supports:
        """
elif False:
    TransferLogStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferLogStreamArgs:
    def __init__(__self__, *,
                 log_stream_id: pulumi.Input[_builtins.str],
                 log_stream_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_stream_id: Log stream ID.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] log_stream_name: Log stream name.
               
               Changing this parameter will create a new resource.
               
               <a name="LtsTransfer_LogTransferInfo"></a>
               The `log_transfer_info` block supports:
        """
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> pulumi.Input[_builtins.str]:
        """
        Log stream ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_stream_id")

    @log_stream_id.setter
    def log_stream_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_stream_id", value)

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log stream name.

        Changing this parameter will create a new resource.

        <a name="LtsTransfer_LogTransferInfo"></a>
        The `log_transfer_info` block supports:
        """
        return pulumi.get(self, "log_stream_name")

    @log_stream_name.setter
    def log_stream_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_stream_name", value)


if not MYPY:
    class TransferLogTransferInfoArgsDict(TypedDict):
        log_storage_format: pulumi.Input[_builtins.str]
        """
        Log transfer format.  
        Value options are as follows:
        + **JSON**: JSON format, which is available to OBS and DIS transfer tasks.
        + **RAW**: Raw log format, which is available to OBS, DIS and DMS transfer tasks.
        """
        log_transfer_detail: pulumi.Input['TransferLogTransferInfoLogTransferDetailArgsDict']
        """
        Log transfer details.  
        The log_transfer_detail structure is documented below.

        <a name="LtsTransfer_LogAgency"></a>
        The `log_agency_transfer` block supports:
        """
        log_transfer_mode: pulumi.Input[_builtins.str]
        """
        Log transfer mode.  
        Value options are as follows:
        + **cycle**: Periodical transfer, which is available to OBS transfer tasks.
        + **realTime**: Real-time transfer, which is available to DIS and DMS transfer tasks.

        Changing this parameter will create a new resource.
        """
        log_transfer_status: pulumi.Input[_builtins.str]
        """
        Log transfer status.  
        Value options are as follows:
        + **ENABLE**: Log transfer is enabled.
        + **DISABLE**: Log transfer is disabled
        """
        log_transfer_type: pulumi.Input[_builtins.str]
        """
        Log transfer type.  
        The valid values are **OBS**, **DIS**, and **DMS**.

        Changing this parameter will create a new resource.
        """
        log_agency_transfer: NotRequired[pulumi.Input['TransferLogTransferInfoLogAgencyTransferArgsDict']]
        """
        Information about agency which lets an account delegate resource management
        to other accounts.
        This parameter is mandatory if you transfer logs for another account.
        The log_agency_transfer structure is documented below.

        Changing this parameter will create a new resource.
        """
elif False:
    TransferLogTransferInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferLogTransferInfoArgs:
    def __init__(__self__, *,
                 log_storage_format: pulumi.Input[_builtins.str],
                 log_transfer_detail: pulumi.Input['TransferLogTransferInfoLogTransferDetailArgs'],
                 log_transfer_mode: pulumi.Input[_builtins.str],
                 log_transfer_status: pulumi.Input[_builtins.str],
                 log_transfer_type: pulumi.Input[_builtins.str],
                 log_agency_transfer: Optional[pulumi.Input['TransferLogTransferInfoLogAgencyTransferArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] log_storage_format: Log transfer format.  
               Value options are as follows:
               + **JSON**: JSON format, which is available to OBS and DIS transfer tasks.
               + **RAW**: Raw log format, which is available to OBS, DIS and DMS transfer tasks.
        :param pulumi.Input['TransferLogTransferInfoLogTransferDetailArgs'] log_transfer_detail: Log transfer details.  
               The log_transfer_detail structure is documented below.
               
               <a name="LtsTransfer_LogAgency"></a>
               The `log_agency_transfer` block supports:
        :param pulumi.Input[_builtins.str] log_transfer_mode: Log transfer mode.  
               Value options are as follows:
               + **cycle**: Periodical transfer, which is available to OBS transfer tasks.
               + **realTime**: Real-time transfer, which is available to DIS and DMS transfer tasks.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] log_transfer_status: Log transfer status.  
               Value options are as follows:
               + **ENABLE**: Log transfer is enabled.
               + **DISABLE**: Log transfer is disabled
        :param pulumi.Input[_builtins.str] log_transfer_type: Log transfer type.  
               The valid values are **OBS**, **DIS**, and **DMS**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input['TransferLogTransferInfoLogAgencyTransferArgs'] log_agency_transfer: Information about agency which lets an account delegate resource management
               to other accounts.
               This parameter is mandatory if you transfer logs for another account.
               The log_agency_transfer structure is documented below.
               
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "log_storage_format", log_storage_format)
        pulumi.set(__self__, "log_transfer_detail", log_transfer_detail)
        pulumi.set(__self__, "log_transfer_mode", log_transfer_mode)
        pulumi.set(__self__, "log_transfer_status", log_transfer_status)
        pulumi.set(__self__, "log_transfer_type", log_transfer_type)
        if log_agency_transfer is not None:
            pulumi.set(__self__, "log_agency_transfer", log_agency_transfer)

    @_builtins.property
    @pulumi.getter(name="logStorageFormat")
    def log_storage_format(self) -> pulumi.Input[_builtins.str]:
        """
        Log transfer format.  
        Value options are as follows:
        + **JSON**: JSON format, which is available to OBS and DIS transfer tasks.
        + **RAW**: Raw log format, which is available to OBS, DIS and DMS transfer tasks.
        """
        return pulumi.get(self, "log_storage_format")

    @log_storage_format.setter
    def log_storage_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_storage_format", value)

    @_builtins.property
    @pulumi.getter(name="logTransferDetail")
    def log_transfer_detail(self) -> pulumi.Input['TransferLogTransferInfoLogTransferDetailArgs']:
        """
        Log transfer details.  
        The log_transfer_detail structure is documented below.

        <a name="LtsTransfer_LogAgency"></a>
        The `log_agency_transfer` block supports:
        """
        return pulumi.get(self, "log_transfer_detail")

    @log_transfer_detail.setter
    def log_transfer_detail(self, value: pulumi.Input['TransferLogTransferInfoLogTransferDetailArgs']):
        pulumi.set(self, "log_transfer_detail", value)

    @_builtins.property
    @pulumi.getter(name="logTransferMode")
    def log_transfer_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Log transfer mode.  
        Value options are as follows:
        + **cycle**: Periodical transfer, which is available to OBS transfer tasks.
        + **realTime**: Real-time transfer, which is available to DIS and DMS transfer tasks.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_transfer_mode")

    @log_transfer_mode.setter
    def log_transfer_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_transfer_mode", value)

    @_builtins.property
    @pulumi.getter(name="logTransferStatus")
    def log_transfer_status(self) -> pulumi.Input[_builtins.str]:
        """
        Log transfer status.  
        Value options are as follows:
        + **ENABLE**: Log transfer is enabled.
        + **DISABLE**: Log transfer is disabled
        """
        return pulumi.get(self, "log_transfer_status")

    @log_transfer_status.setter
    def log_transfer_status(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_transfer_status", value)

    @_builtins.property
    @pulumi.getter(name="logTransferType")
    def log_transfer_type(self) -> pulumi.Input[_builtins.str]:
        """
        Log transfer type.  
        The valid values are **OBS**, **DIS**, and **DMS**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_transfer_type")

    @log_transfer_type.setter
    def log_transfer_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_transfer_type", value)

    @_builtins.property
    @pulumi.getter(name="logAgencyTransfer")
    def log_agency_transfer(self) -> Optional[pulumi.Input['TransferLogTransferInfoLogAgencyTransferArgs']]:
        """
        Information about agency which lets an account delegate resource management
        to other accounts.
        This parameter is mandatory if you transfer logs for another account.
        The log_agency_transfer structure is documented below.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_agency_transfer")

    @log_agency_transfer.setter
    def log_agency_transfer(self, value: Optional[pulumi.Input['TransferLogTransferInfoLogAgencyTransferArgs']]):
        pulumi.set(self, "log_agency_transfer", value)


if not MYPY:
    class TransferLogTransferInfoLogAgencyTransferArgsDict(TypedDict):
        agency_domain_id: pulumi.Input[_builtins.str]
        """
        Delegator account ID.

        Changing this parameter will create a new resource.
        """
        agency_domain_name: pulumi.Input[_builtins.str]
        """
        Delegator account name.

        Changing this parameter will create a new resource.
        """
        agency_name: pulumi.Input[_builtins.str]
        """
        The agency name created by the delegator.

        Changing this parameter will create a new resource.
        """
        agency_project_id: pulumi.Input[_builtins.str]
        """
        Project ID of the delegator.

        Changing this parameter will create a new resource.

        <a name="LtsTransfer_LogTransferDetail"></a>
        The `log_transfer_detail` block supports:
        """
elif False:
    TransferLogTransferInfoLogAgencyTransferArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferLogTransferInfoLogAgencyTransferArgs:
    def __init__(__self__, *,
                 agency_domain_id: pulumi.Input[_builtins.str],
                 agency_domain_name: pulumi.Input[_builtins.str],
                 agency_name: pulumi.Input[_builtins.str],
                 agency_project_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agency_domain_id: Delegator account ID.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] agency_domain_name: Delegator account name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] agency_name: The agency name created by the delegator.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] agency_project_id: Project ID of the delegator.
               
               Changing this parameter will create a new resource.
               
               <a name="LtsTransfer_LogTransferDetail"></a>
               The `log_transfer_detail` block supports:
        """
        pulumi.set(__self__, "agency_domain_id", agency_domain_id)
        pulumi.set(__self__, "agency_domain_name", agency_domain_name)
        pulumi.set(__self__, "agency_name", agency_name)
        pulumi.set(__self__, "agency_project_id", agency_project_id)

    @_builtins.property
    @pulumi.getter(name="agencyDomainId")
    def agency_domain_id(self) -> pulumi.Input[_builtins.str]:
        """
        Delegator account ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "agency_domain_id")

    @agency_domain_id.setter
    def agency_domain_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agency_domain_id", value)

    @_builtins.property
    @pulumi.getter(name="agencyDomainName")
    def agency_domain_name(self) -> pulumi.Input[_builtins.str]:
        """
        Delegator account name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "agency_domain_name")

    @agency_domain_name.setter
    def agency_domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agency_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> pulumi.Input[_builtins.str]:
        """
        The agency name created by the delegator.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agency_name", value)

    @_builtins.property
    @pulumi.getter(name="agencyProjectId")
    def agency_project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Project ID of the delegator.

        Changing this parameter will create a new resource.

        <a name="LtsTransfer_LogTransferDetail"></a>
        The `log_transfer_detail` block supports:
        """
        return pulumi.get(self, "agency_project_id")

    @agency_project_id.setter
    def agency_project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agency_project_id", value)


if not MYPY:
    class TransferLogTransferInfoLogTransferDetailArgsDict(TypedDict):
        cloud_project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud project ID.
        """
        delivery_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of tag fields will be delivered when transferring.  
        This field must contain the following host information: **hostIP**, **hostId**, **hostName**, **pathFile**, and **collectTime**.
        The common fields include **logStreamName**, **regionName**, **logGroupName**, and **projectId**, which are optional.
        The transfer tag: **streamTag**, which is optional.
        This parameter is valid only for OBS or DIS transfer in JSON format.
        """
        dis_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        DIS stream ID.  
        This parameter is mandatory when you create a DIS transfer task.
        """
        dis_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        DIS stream name.  
        This parameter is mandatory when you create a DIS transfer task.
        """
        invalid_field_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value of the invalid field fill.
        """
        kafka_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kafka ID.  
        This parameter is mandatory when you create a DMS transfer task.
        """
        kafka_topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kafka topic.  
        This parameter is mandatory when you create a DMS transfer task.

        > Before creating a DMS transfer task, register your Kafka instance with Kafka ID and Kafka topic first.
        """
        lts_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of built-in fields and custom tags to be transferred.  
        If you want to transfer all built-in and specified fields in the log, you need to set it to **all**.
        """
        obs_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        OBS bucket name.  
        This parameter is mandatory when you create an OBS transfer task.
        """
        obs_dir_prefix_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom transfer path of an OBS transfer task.
        """
        obs_encrypted_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether OBS bucket encryption is enabled.
        """
        obs_encrypted_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ID for an OBS transfer task.  
        This parameter is mandatory if encryption is enabled for the target OBS bucket.
        """
        obs_eps_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enterprise project ID of an OBS transfer task.
        """
        obs_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Length of the transfer interval for an OBS transfer task.  
        This parameter is mandatory when you create an OBS transfer task.
        The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
        and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
        Value options are as follows:
        + **2**: 2 minutes, the **obs_period_unit** must be **min**.
        + **5**: 5 minutes, the **obs_period_unit** must be **min**.
        + **30**: 30 minutes, the **obs_period_unit** must be **min**.
        + **1**: 1 hour, the **obs_period_unit** must be **hour**.
        + **3**: 3 hours, the **obs_period_unit** must be **hour**.
        + **6**: 6 hours, the **obs_period_unit** must be **hour**.
        + **12**: 12 hours, the **obs_period_unit** must be **hour**.
        """
        obs_period_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unit of the transfer interval for an OBS transfer task.  
        This parameter is mandatory when you create an OBS transfer task.
        The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
        and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
        Value options are as follows:
        + **min**: minute.
        + **hour**: hour.
        """
        obs_prefix_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Transfer file prefix of an OBS transfer task.
        """
        obs_time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time zone for an OBS transfer task.  
        For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
        If this parameter is specified, **obs_time_zone_id** must also be specified.
        """
        obs_time_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the time zone for an OBS transfer task.  
        For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
        If this parameter is specified, **obs_time_zone** must also be specified.
        """
        obs_transfer_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        OBS bucket path, which is the log transfer destination.
        """
        stream_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of stream tag fields to be transferred.  
        If you want to transfer all stream tag fields in the log, you need to set it to **all**.
        """
        struct_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of structured fields to be transferred.  
        If you want to transfer all fields in a log in the log, you need to set it to **all**.

        > 1. The `lts_tags`, `stream_tags` and `struct_fields` parameters are valid only for DMS transfer in JSON format.
        At least one of them must be set.
        """
elif False:
    TransferLogTransferInfoLogTransferDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferLogTransferInfoLogTransferDetailArgs:
    def __init__(__self__, *,
                 cloud_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 delivery_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dis_id: Optional[pulumi.Input[_builtins.str]] = None,
                 dis_name: Optional[pulumi.Input[_builtins.str]] = None,
                 invalid_field_value: Optional[pulumi.Input[_builtins.str]] = None,
                 kafka_id: Optional[pulumi.Input[_builtins.str]] = None,
                 kafka_topic: Optional[pulumi.Input[_builtins.str]] = None,
                 lts_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 obs_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_dir_prefix_name: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_encrypted_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 obs_encrypted_id: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_eps_id: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_period: Optional[pulumi.Input[_builtins.int]] = None,
                 obs_period_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_prefix_name: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_time_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_time_zone_id: Optional[pulumi.Input[_builtins.str]] = None,
                 obs_transfer_path: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 struct_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_project_id: The cloud project ID.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] delivery_tags: The list of tag fields will be delivered when transferring.  
               This field must contain the following host information: **hostIP**, **hostId**, **hostName**, **pathFile**, and **collectTime**.
               The common fields include **logStreamName**, **regionName**, **logGroupName**, and **projectId**, which are optional.
               The transfer tag: **streamTag**, which is optional.
               This parameter is valid only for OBS or DIS transfer in JSON format.
        :param pulumi.Input[_builtins.str] dis_id: DIS stream ID.  
               This parameter is mandatory when you create a DIS transfer task.
        :param pulumi.Input[_builtins.str] dis_name: DIS stream name.  
               This parameter is mandatory when you create a DIS transfer task.
        :param pulumi.Input[_builtins.str] invalid_field_value: Specifies the value of the invalid field fill.
        :param pulumi.Input[_builtins.str] kafka_id: Kafka ID.  
               This parameter is mandatory when you create a DMS transfer task.
        :param pulumi.Input[_builtins.str] kafka_topic: Kafka topic.  
               This parameter is mandatory when you create a DMS transfer task.
               
               > Before creating a DMS transfer task, register your Kafka instance with Kafka ID and Kafka topic first.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] lts_tags: Specifies the list of built-in fields and custom tags to be transferred.  
               If you want to transfer all built-in and specified fields in the log, you need to set it to **all**.
        :param pulumi.Input[_builtins.str] obs_bucket_name: OBS bucket name.  
               This parameter is mandatory when you create an OBS transfer task.
        :param pulumi.Input[_builtins.str] obs_dir_prefix_name: Custom transfer path of an OBS transfer task.
        :param pulumi.Input[_builtins.bool] obs_encrypted_enable: Whether OBS bucket encryption is enabled.
        :param pulumi.Input[_builtins.str] obs_encrypted_id: KMS key ID for an OBS transfer task.  
               This parameter is mandatory if encryption is enabled for the target OBS bucket.
        :param pulumi.Input[_builtins.str] obs_eps_id: Enterprise project ID of an OBS transfer task.
        :param pulumi.Input[_builtins.int] obs_period: Length of the transfer interval for an OBS transfer task.  
               This parameter is mandatory when you create an OBS transfer task.
               The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
               and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
               Value options are as follows:
               + **2**: 2 minutes, the **obs_period_unit** must be **min**.
               + **5**: 5 minutes, the **obs_period_unit** must be **min**.
               + **30**: 30 minutes, the **obs_period_unit** must be **min**.
               + **1**: 1 hour, the **obs_period_unit** must be **hour**.
               + **3**: 3 hours, the **obs_period_unit** must be **hour**.
               + **6**: 6 hours, the **obs_period_unit** must be **hour**.
               + **12**: 12 hours, the **obs_period_unit** must be **hour**.
        :param pulumi.Input[_builtins.str] obs_period_unit: Unit of the transfer interval for an OBS transfer task.  
               This parameter is mandatory when you create an OBS transfer task.
               The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
               and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
               Value options are as follows:
               + **min**: minute.
               + **hour**: hour.
        :param pulumi.Input[_builtins.str] obs_prefix_name: Transfer file prefix of an OBS transfer task.
        :param pulumi.Input[_builtins.str] obs_time_zone: Time zone for an OBS transfer task.  
               For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
               If this parameter is specified, **obs_time_zone_id** must also be specified.
        :param pulumi.Input[_builtins.str] obs_time_zone_id: ID of the time zone for an OBS transfer task.  
               For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
               If this parameter is specified, **obs_time_zone** must also be specified.
        :param pulumi.Input[_builtins.str] obs_transfer_path: OBS bucket path, which is the log transfer destination.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stream_tags: Specifies the list of stream tag fields to be transferred.  
               If you want to transfer all stream tag fields in the log, you need to set it to **all**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] struct_fields: Specifies the list of structured fields to be transferred.  
               If you want to transfer all fields in a log in the log, you need to set it to **all**.
               
               > 1. The `lts_tags`, `stream_tags` and `struct_fields` parameters are valid only for DMS transfer in JSON format.
               At least one of them must be set.
        """
        if cloud_project_id is not None:
            pulumi.set(__self__, "cloud_project_id", cloud_project_id)
        if delivery_tags is not None:
            pulumi.set(__self__, "delivery_tags", delivery_tags)
        if dis_id is not None:
            pulumi.set(__self__, "dis_id", dis_id)
        if dis_name is not None:
            pulumi.set(__self__, "dis_name", dis_name)
        if invalid_field_value is not None:
            pulumi.set(__self__, "invalid_field_value", invalid_field_value)
        if kafka_id is not None:
            pulumi.set(__self__, "kafka_id", kafka_id)
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)
        if lts_tags is not None:
            pulumi.set(__self__, "lts_tags", lts_tags)
        if obs_bucket_name is not None:
            pulumi.set(__self__, "obs_bucket_name", obs_bucket_name)
        if obs_dir_prefix_name is not None:
            pulumi.set(__self__, "obs_dir_prefix_name", obs_dir_prefix_name)
        if obs_encrypted_enable is not None:
            pulumi.set(__self__, "obs_encrypted_enable", obs_encrypted_enable)
        if obs_encrypted_id is not None:
            pulumi.set(__self__, "obs_encrypted_id", obs_encrypted_id)
        if obs_eps_id is not None:
            pulumi.set(__self__, "obs_eps_id", obs_eps_id)
        if obs_period is not None:
            pulumi.set(__self__, "obs_period", obs_period)
        if obs_period_unit is not None:
            pulumi.set(__self__, "obs_period_unit", obs_period_unit)
        if obs_prefix_name is not None:
            pulumi.set(__self__, "obs_prefix_name", obs_prefix_name)
        if obs_time_zone is not None:
            pulumi.set(__self__, "obs_time_zone", obs_time_zone)
        if obs_time_zone_id is not None:
            pulumi.set(__self__, "obs_time_zone_id", obs_time_zone_id)
        if obs_transfer_path is not None:
            pulumi.set(__self__, "obs_transfer_path", obs_transfer_path)
        if stream_tags is not None:
            pulumi.set(__self__, "stream_tags", stream_tags)
        if struct_fields is not None:
            pulumi.set(__self__, "struct_fields", struct_fields)

    @_builtins.property
    @pulumi.getter(name="cloudProjectId")
    def cloud_project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud project ID.
        """
        return pulumi.get(self, "cloud_project_id")

    @cloud_project_id.setter
    def cloud_project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_project_id", value)

    @_builtins.property
    @pulumi.getter(name="deliveryTags")
    def delivery_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of tag fields will be delivered when transferring.  
        This field must contain the following host information: **hostIP**, **hostId**, **hostName**, **pathFile**, and **collectTime**.
        The common fields include **logStreamName**, **regionName**, **logGroupName**, and **projectId**, which are optional.
        The transfer tag: **streamTag**, which is optional.
        This parameter is valid only for OBS or DIS transfer in JSON format.
        """
        return pulumi.get(self, "delivery_tags")

    @delivery_tags.setter
    def delivery_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "delivery_tags", value)

    @_builtins.property
    @pulumi.getter(name="disId")
    def dis_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DIS stream ID.  
        This parameter is mandatory when you create a DIS transfer task.
        """
        return pulumi.get(self, "dis_id")

    @dis_id.setter
    def dis_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dis_id", value)

    @_builtins.property
    @pulumi.getter(name="disName")
    def dis_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DIS stream name.  
        This parameter is mandatory when you create a DIS transfer task.
        """
        return pulumi.get(self, "dis_name")

    @dis_name.setter
    def dis_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dis_name", value)

    @_builtins.property
    @pulumi.getter(name="invalidFieldValue")
    def invalid_field_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value of the invalid field fill.
        """
        return pulumi.get(self, "invalid_field_value")

    @invalid_field_value.setter
    def invalid_field_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invalid_field_value", value)

    @_builtins.property
    @pulumi.getter(name="kafkaId")
    def kafka_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kafka ID.  
        This parameter is mandatory when you create a DMS transfer task.
        """
        return pulumi.get(self, "kafka_id")

    @kafka_id.setter
    def kafka_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kafka_id", value)

    @_builtins.property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kafka topic.  
        This parameter is mandatory when you create a DMS transfer task.

        > Before creating a DMS transfer task, register your Kafka instance with Kafka ID and Kafka topic first.
        """
        return pulumi.get(self, "kafka_topic")

    @kafka_topic.setter
    def kafka_topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kafka_topic", value)

    @_builtins.property
    @pulumi.getter(name="ltsTags")
    def lts_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of built-in fields and custom tags to be transferred.  
        If you want to transfer all built-in and specified fields in the log, you need to set it to **all**.
        """
        return pulumi.get(self, "lts_tags")

    @lts_tags.setter
    def lts_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "lts_tags", value)

    @_builtins.property
    @pulumi.getter(name="obsBucketName")
    def obs_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OBS bucket name.  
        This parameter is mandatory when you create an OBS transfer task.
        """
        return pulumi.get(self, "obs_bucket_name")

    @obs_bucket_name.setter
    def obs_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="obsDirPrefixName")
    def obs_dir_prefix_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom transfer path of an OBS transfer task.
        """
        return pulumi.get(self, "obs_dir_prefix_name")

    @obs_dir_prefix_name.setter
    def obs_dir_prefix_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_dir_prefix_name", value)

    @_builtins.property
    @pulumi.getter(name="obsEncryptedEnable")
    def obs_encrypted_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether OBS bucket encryption is enabled.
        """
        return pulumi.get(self, "obs_encrypted_enable")

    @obs_encrypted_enable.setter
    def obs_encrypted_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "obs_encrypted_enable", value)

    @_builtins.property
    @pulumi.getter(name="obsEncryptedId")
    def obs_encrypted_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ID for an OBS transfer task.  
        This parameter is mandatory if encryption is enabled for the target OBS bucket.
        """
        return pulumi.get(self, "obs_encrypted_id")

    @obs_encrypted_id.setter
    def obs_encrypted_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_encrypted_id", value)

    @_builtins.property
    @pulumi.getter(name="obsEpsId")
    def obs_eps_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enterprise project ID of an OBS transfer task.
        """
        return pulumi.get(self, "obs_eps_id")

    @obs_eps_id.setter
    def obs_eps_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_eps_id", value)

    @_builtins.property
    @pulumi.getter(name="obsPeriod")
    def obs_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Length of the transfer interval for an OBS transfer task.  
        This parameter is mandatory when you create an OBS transfer task.
        The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
        and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
        Value options are as follows:
        + **2**: 2 minutes, the **obs_period_unit** must be **min**.
        + **5**: 5 minutes, the **obs_period_unit** must be **min**.
        + **30**: 30 minutes, the **obs_period_unit** must be **min**.
        + **1**: 1 hour, the **obs_period_unit** must be **hour**.
        + **3**: 3 hours, the **obs_period_unit** must be **hour**.
        + **6**: 6 hours, the **obs_period_unit** must be **hour**.
        + **12**: 12 hours, the **obs_period_unit** must be **hour**.
        """
        return pulumi.get(self, "obs_period")

    @obs_period.setter
    def obs_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "obs_period", value)

    @_builtins.property
    @pulumi.getter(name="obsPeriodUnit")
    def obs_period_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unit of the transfer interval for an OBS transfer task.  
        This parameter is mandatory when you create an OBS transfer task.
        The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
        and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
        Value options are as follows:
        + **min**: minute.
        + **hour**: hour.
        """
        return pulumi.get(self, "obs_period_unit")

    @obs_period_unit.setter
    def obs_period_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_period_unit", value)

    @_builtins.property
    @pulumi.getter(name="obsPrefixName")
    def obs_prefix_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Transfer file prefix of an OBS transfer task.
        """
        return pulumi.get(self, "obs_prefix_name")

    @obs_prefix_name.setter
    def obs_prefix_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_prefix_name", value)

    @_builtins.property
    @pulumi.getter(name="obsTimeZone")
    def obs_time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time zone for an OBS transfer task.  
        For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
        If this parameter is specified, **obs_time_zone_id** must also be specified.
        """
        return pulumi.get(self, "obs_time_zone")

    @obs_time_zone.setter
    def obs_time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_time_zone", value)

    @_builtins.property
    @pulumi.getter(name="obsTimeZoneId")
    def obs_time_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the time zone for an OBS transfer task.  
        For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
        If this parameter is specified, **obs_time_zone** must also be specified.
        """
        return pulumi.get(self, "obs_time_zone_id")

    @obs_time_zone_id.setter
    def obs_time_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_time_zone_id", value)

    @_builtins.property
    @pulumi.getter(name="obsTransferPath")
    def obs_transfer_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OBS bucket path, which is the log transfer destination.
        """
        return pulumi.get(self, "obs_transfer_path")

    @obs_transfer_path.setter
    def obs_transfer_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "obs_transfer_path", value)

    @_builtins.property
    @pulumi.getter(name="streamTags")
    def stream_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of stream tag fields to be transferred.  
        If you want to transfer all stream tag fields in the log, you need to set it to **all**.
        """
        return pulumi.get(self, "stream_tags")

    @stream_tags.setter
    def stream_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stream_tags", value)

    @_builtins.property
    @pulumi.getter(name="structFields")
    def struct_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of structured fields to be transferred.  
        If you want to transfer all fields in a log in the log, you need to set it to **all**.

        > 1. The `lts_tags`, `stream_tags` and `struct_fields` parameters are valid only for DMS transfer in JSON format.
        At least one of them must be set.
        """
        return pulumi.get(self, "struct_fields")

    @struct_fields.setter
    def struct_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "struct_fields", value)


if not MYPY:
    class GetAlarmsSortArgsDict(TypedDict):
        order: _builtins.str
        """
        Specifies the sort mode of the alarm.  
        The valid values are as follows:
        + **asc**
        + **desc**
        """
        order_bies: Sequence[_builtins.str]
        """
        Specifies the fields to be sorted.
        """
elif False:
    GetAlarmsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlarmsSortArgs:
    def __init__(__self__, *,
                 order: _builtins.str,
                 order_bies: Sequence[_builtins.str]):
        """
        :param _builtins.str order: Specifies the sort mode of the alarm.  
               The valid values are as follows:
               + **asc**
               + **desc**
        :param Sequence[_builtins.str] order_bies: Specifies the fields to be sorted.
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "order_bies", order_bies)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.str:
        """
        Specifies the sort mode of the alarm.  
        The valid values are as follows:
        + **asc**
        + **desc**
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: _builtins.str):
        pulumi.set(self, "order", value)

    @_builtins.property
    @pulumi.getter(name="orderBies")
    def order_bies(self) -> Sequence[_builtins.str]:
        """
        Specifies the fields to be sorted.
        """
        return pulumi.get(self, "order_bies")

    @order_bies.setter
    def order_bies(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "order_bies", value)


if not MYPY:
    class GetHostsFilterArgsDict(TypedDict):
        host_ip_lists: NotRequired[Sequence[_builtins.str]]
        """
        Specifies the list of the host IPs.
        """
        host_name_lists: NotRequired[Sequence[_builtins.str]]
        """
        Specifies the list of the host names.
        """
        host_status: NotRequired[_builtins.str]
        """
        Specifies the status of the host.  
        The valid values are as follows:
        + **uninstall**
        + **running**
        + **offline**
        + **error**
        + **plugin error**
        + **install-fail**
        + **upgrade failed**
        + **upgrade-fail**
        + **authentication error**
        """
        host_version: NotRequired[_builtins.str]
        """
        Specifies the version of the host.
        """
elif False:
    GetHostsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostsFilterArgs:
    def __init__(__self__, *,
                 host_ip_lists: Optional[Sequence[_builtins.str]] = None,
                 host_name_lists: Optional[Sequence[_builtins.str]] = None,
                 host_status: Optional[_builtins.str] = None,
                 host_version: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] host_ip_lists: Specifies the list of the host IPs.
        :param Sequence[_builtins.str] host_name_lists: Specifies the list of the host names.
        :param _builtins.str host_status: Specifies the status of the host.  
               The valid values are as follows:
               + **uninstall**
               + **running**
               + **offline**
               + **error**
               + **plugin error**
               + **install-fail**
               + **upgrade failed**
               + **upgrade-fail**
               + **authentication error**
        :param _builtins.str host_version: Specifies the version of the host.
        """
        if host_ip_lists is not None:
            pulumi.set(__self__, "host_ip_lists", host_ip_lists)
        if host_name_lists is not None:
            pulumi.set(__self__, "host_name_lists", host_name_lists)
        if host_status is not None:
            pulumi.set(__self__, "host_status", host_status)
        if host_version is not None:
            pulumi.set(__self__, "host_version", host_version)

    @_builtins.property
    @pulumi.getter(name="hostIpLists")
    def host_ip_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of the host IPs.
        """
        return pulumi.get(self, "host_ip_lists")

    @host_ip_lists.setter
    def host_ip_lists(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "host_ip_lists", value)

    @_builtins.property
    @pulumi.getter(name="hostNameLists")
    def host_name_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of the host names.
        """
        return pulumi.get(self, "host_name_lists")

    @host_name_lists.setter
    def host_name_lists(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "host_name_lists", value)

    @_builtins.property
    @pulumi.getter(name="hostStatus")
    def host_status(self) -> Optional[_builtins.str]:
        """
        Specifies the status of the host.  
        The valid values are as follows:
        + **uninstall**
        + **running**
        + **offline**
        + **error**
        + **plugin error**
        + **install-fail**
        + **upgrade failed**
        + **upgrade-fail**
        + **authentication error**
        """
        return pulumi.get(self, "host_status")

    @host_status.setter
    def host_status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "host_status", value)

    @_builtins.property
    @pulumi.getter(name="hostVersion")
    def host_version(self) -> Optional[_builtins.str]:
        """
        Specifies the version of the host.
        """
        return pulumi.get(self, "host_version")

    @host_version.setter
    def host_version(self, value: Optional[_builtins.str]):
        pulumi.set(self, "host_version", value)


