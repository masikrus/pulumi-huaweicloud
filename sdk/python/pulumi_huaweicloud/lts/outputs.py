# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AccessRuleFile',
    'AccessRuleFileLogStreamInfo',
    'AomAccessAccessRule',
    'CceAccessAccessConfig',
    'CceAccessAccessConfigMultiLogFormat',
    'CceAccessAccessConfigSingleLogFormat',
    'CceAccessAccessConfigWindowsLogInfo',
    'CceAccessDemoField',
    'CceAccessProcessor',
    'HostAccessAccessConfig',
    'HostAccessAccessConfigMultiLogFormat',
    'HostAccessAccessConfigSingleLogFormat',
    'HostAccessAccessConfigWindowsLogInfo',
    'HostAccessDemoField',
    'HostAccessProcessor',
    'KeywordsAlarmRuleFrequency',
    'KeywordsAlarmRuleKeywordsRequest',
    'KeywordsAlarmRuleNotificationRule',
    'KeywordsAlarmRuleNotificationRuleTopic',
    'KeywordsAlarmRuleNotificationSaveRule',
    'KeywordsAlarmRuleNotificationSaveRuleTopic',
    'LogConvergeLogMappingConfig',
    'LogConvergeLogMappingConfigLogStreamConfig',
    'MetricRuleAggregator',
    'MetricRuleFilter',
    'MetricRuleFilterFilter',
    'MetricRuleFilterFilterFilter',
    'MetricRuleSampler',
    'MetricRuleSink',
    'NotificationTemplateTemplate',
    'RegisterKafkaInstanceConnectInfo',
    'SqlAlarmRuleFrequency',
    'SqlAlarmRuleNotificationRule',
    'SqlAlarmRuleNotificationRuleTopic',
    'SqlAlarmRuleNotificationSaveRule',
    'SqlAlarmRuleNotificationSaveRuleTopic',
    'SqlAlarmRuleSqlRequest',
    'StreamIndexConfigurationField',
    'StreamIndexConfigurationFieldLtsSubFieldsInfoList',
    'StreamIndexConfigurationFullTextIndex',
    'StructTemplateDemoField',
    'StructTemplateTagField',
    'StructingTemplateDemoField',
    'StructingTemplateTagField',
    'StructuringConfigurationDemoField',
    'StructuringConfigurationTagField',
    'StructuringCustomConfigurationDemoField',
    'StructuringCustomConfigurationTagField',
    'TransferLogStream',
    'TransferLogTransferInfo',
    'TransferLogTransferInfoLogAgencyTransfer',
    'TransferLogTransferInfoLogTransferDetail',
    'GetAlarmsAlarmResult',
    'GetAlarmsAlarmAnnotationResult',
    'GetAlarmsAlarmMetadataResult',
    'GetAlarmsSortResult',
    'GetAomAccessesAccessResult',
    'GetAomAccessesAccessAccessRuleResult',
    'GetCceAccessesAccessResult',
    'GetCceAccessesAccessAccessConfigResult',
    'GetCceAccessesAccessAccessConfigMultiLogFormatResult',
    'GetCceAccessesAccessAccessConfigSingleLogFormatResult',
    'GetCceAccessesAccessAccessConfigWindowsLogInfoResult',
    'GetCceAccessesAccessDemoFieldResult',
    'GetCceAccessesAccessProcessorResult',
    'GetGroupsGroupResult',
    'GetHostAccessesAccessResult',
    'GetHostAccessesAccessAccessConfigResult',
    'GetHostAccessesAccessAccessConfigMultiLogFormatResult',
    'GetHostAccessesAccessAccessConfigSingleLogFormatResult',
    'GetHostAccessesAccessAccessConfigWindowsLogInfoResult',
    'GetHostAccessesAccessDemoFieldResult',
    'GetHostAccessesAccessProcessorResult',
    'GetHostGroupsGroupResult',
    'GetHostsFilterResult',
    'GetHostsHostResult',
    'GetKeywordAlarmRulesKeywordAlarmRuleResult',
    'GetKeywordAlarmRulesKeywordAlarmRuleFrequencyResult',
    'GetKeywordAlarmRulesKeywordAlarmRuleKeywordsRequestResult',
    'GetKeywordAlarmRulesKeywordAlarmRuleTopicResult',
    'GetNotificationTemplatesTemplateResult',
    'GetNotificationTemplatesTemplateTemplateResult',
    'GetSearchCriteriaSearchCriteriaResult',
    'GetSearchCriteriaSearchCriteriaCriteriaResult',
    'GetSqlAlarmRulesSqlAlarmRuleResult',
    'GetSqlAlarmRulesSqlAlarmRuleFrequencyResult',
    'GetSqlAlarmRulesSqlAlarmRuleSqlRequestResult',
    'GetSqlAlarmRulesSqlAlarmRuleTopicResult',
    'GetStreamsStreamResult',
    'GetStructuringCustomTemplatesTemplateResult',
    'GetTransfersTransferResult',
    'GetTransfersTransferLogStreamResult',
    'GetTransfersTransferLogTransferInfoResult',
    'GetTransfersTransferLogTransferInfoLogAgencyTransferResult',
    'GetTransfersTransferLogTransferInfoLogTransferDetailResult',
]

@pulumi.output_type
class AccessRuleFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"
        elif key == "logStreamInfos":
            suggest = "log_stream_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessRuleFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessRuleFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessRuleFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_name: _builtins.str,
                 log_stream_infos: Sequence['outputs.AccessRuleFileLogStreamInfo']):
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "log_stream_infos", log_stream_infos)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter(name="logStreamInfos")
    def log_stream_infos(self) -> Sequence['outputs.AccessRuleFileLogStreamInfo']:
        return pulumi.get(self, "log_stream_infos")


@pulumi.output_type
class AccessRuleFileLogStreamInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetLogGroupId":
            suggest = "target_log_group_id"
        elif key == "targetLogGroupName":
            suggest = "target_log_group_name"
        elif key == "targetLogStreamId":
            suggest = "target_log_stream_id"
        elif key == "targetLogStreamName":
            suggest = "target_log_stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessRuleFileLogStreamInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessRuleFileLogStreamInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessRuleFileLogStreamInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_log_group_id: _builtins.str,
                 target_log_group_name: _builtins.str,
                 target_log_stream_id: _builtins.str,
                 target_log_stream_name: _builtins.str):
        pulumi.set(__self__, "target_log_group_id", target_log_group_id)
        pulumi.set(__self__, "target_log_group_name", target_log_group_name)
        pulumi.set(__self__, "target_log_stream_id", target_log_stream_id)
        pulumi.set(__self__, "target_log_stream_name", target_log_stream_name)

    @_builtins.property
    @pulumi.getter(name="targetLogGroupId")
    def target_log_group_id(self) -> _builtins.str:
        return pulumi.get(self, "target_log_group_id")

    @_builtins.property
    @pulumi.getter(name="targetLogGroupName")
    def target_log_group_name(self) -> _builtins.str:
        return pulumi.get(self, "target_log_group_name")

    @_builtins.property
    @pulumi.getter(name="targetLogStreamId")
    def target_log_stream_id(self) -> _builtins.str:
        return pulumi.get(self, "target_log_stream_id")

    @_builtins.property
    @pulumi.getter(name="targetLogStreamName")
    def target_log_stream_name(self) -> _builtins.str:
        return pulumi.get(self, "target_log_stream_name")


@pulumi.output_type
class AomAccessAccessRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"
        elif key == "logGroupId":
            suggest = "log_group_id"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "logStreamId":
            suggest = "log_stream_id"
        elif key == "logStreamName":
            suggest = "log_stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AomAccessAccessRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AomAccessAccessRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AomAccessAccessRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_name: _builtins.str,
                 log_group_id: _builtins.str,
                 log_group_name: _builtins.str,
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str):
        """
        :param _builtins.str file_name: Specifies the path name.
               + When collecting access all logs, set this field to `__ALL_FILES__`.
               + When collecting specify log paths, the matching rule should be `^\\/[A-Za-z0-9.*_\\/-]+|stdout\\.log|`, such as
               `/test/*` or `/test/demo.log`. Up to two asterisks (*) are allowed.
        :param _builtins.str log_group_id: Specifies the log group ID.
        :param _builtins.str log_group_name: Specifies the log group name.
        :param _builtins.str log_stream_id: Specifies the log stream ID.
        :param _builtins.str log_stream_name: Specifies the log stream name.
        """
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        """
        Specifies the path name.
        + When collecting access all logs, set this field to `__ALL_FILES__`.
        + When collecting specify log paths, the matching rule should be `^\\/[A-Za-z0-9.*_\\/-]+|stdout\\.log|`, such as
        `/test/*` or `/test/demo.log`. Up to two asterisks (*) are allowed.
        """
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Specifies the log group ID.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        Specifies the log group name.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        Specifies the log stream ID.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        Specifies the log stream name.
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class CceAccessAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathType":
            suggest = "path_type"
        elif key == "blackPaths":
            suggest = "black_paths"
        elif key == "containerNameRegex":
            suggest = "container_name_regex"
        elif key == "customKeyValue":
            suggest = "custom_key_value"
        elif key == "excludeEnvs":
            suggest = "exclude_envs"
        elif key == "excludeEnvsLogical":
            suggest = "exclude_envs_logical"
        elif key == "excludeK8sLabels":
            suggest = "exclude_k8s_labels"
        elif key == "excludeK8sLabelsLogical":
            suggest = "exclude_k8s_labels_logical"
        elif key == "excludeLabels":
            suggest = "exclude_labels"
        elif key == "excludeLabelsLogical":
            suggest = "exclude_labels_logical"
        elif key == "includeEnvs":
            suggest = "include_envs"
        elif key == "includeEnvsLogical":
            suggest = "include_envs_logical"
        elif key == "includeK8sLabels":
            suggest = "include_k8s_labels"
        elif key == "includeK8sLabelsLogical":
            suggest = "include_k8s_labels_logical"
        elif key == "includeLabels":
            suggest = "include_labels"
        elif key == "includeLabelsLogical":
            suggest = "include_labels_logical"
        elif key == "logEnvs":
            suggest = "log_envs"
        elif key == "logK8s":
            suggest = "log_k8s"
        elif key == "logLabels":
            suggest = "log_labels"
        elif key == "multiLogFormat":
            suggest = "multi_log_format"
        elif key == "nameSpaceRegex":
            suggest = "name_space_regex"
        elif key == "podNameRegex":
            suggest = "pod_name_regex"
        elif key == "repeatCollect":
            suggest = "repeat_collect"
        elif key == "singleLogFormat":
            suggest = "single_log_format"
        elif key == "systemFields":
            suggest = "system_fields"
        elif key == "windowsLogInfo":
            suggest = "windows_log_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CceAccessAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CceAccessAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CceAccessAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path_type: _builtins.str,
                 black_paths: Optional[Sequence[_builtins.str]] = None,
                 container_name_regex: Optional[_builtins.str] = None,
                 custom_key_value: Optional[Mapping[str, _builtins.str]] = None,
                 exclude_envs: Optional[Mapping[str, _builtins.str]] = None,
                 exclude_envs_logical: Optional[_builtins.str] = None,
                 exclude_k8s_labels: Optional[Mapping[str, _builtins.str]] = None,
                 exclude_k8s_labels_logical: Optional[_builtins.str] = None,
                 exclude_labels: Optional[Mapping[str, _builtins.str]] = None,
                 exclude_labels_logical: Optional[_builtins.str] = None,
                 include_envs: Optional[Mapping[str, _builtins.str]] = None,
                 include_envs_logical: Optional[_builtins.str] = None,
                 include_k8s_labels: Optional[Mapping[str, _builtins.str]] = None,
                 include_k8s_labels_logical: Optional[_builtins.str] = None,
                 include_labels: Optional[Mapping[str, _builtins.str]] = None,
                 include_labels_logical: Optional[_builtins.str] = None,
                 log_envs: Optional[Mapping[str, _builtins.str]] = None,
                 log_k8s: Optional[Mapping[str, _builtins.str]] = None,
                 log_labels: Optional[Mapping[str, _builtins.str]] = None,
                 multi_log_format: Optional['outputs.CceAccessAccessConfigMultiLogFormat'] = None,
                 name_space_regex: Optional[_builtins.str] = None,
                 paths: Optional[Sequence[_builtins.str]] = None,
                 pod_name_regex: Optional[_builtins.str] = None,
                 repeat_collect: Optional[_builtins.bool] = None,
                 single_log_format: Optional['outputs.CceAccessAccessConfigSingleLogFormat'] = None,
                 stderr: Optional[_builtins.bool] = None,
                 stdout: Optional[_builtins.bool] = None,
                 system_fields: Optional[Sequence[_builtins.str]] = None,
                 windows_log_info: Optional['outputs.CceAccessAccessConfigWindowsLogInfo'] = None):
        """
        :param _builtins.str path_type: Specifies the type of the CCE access. The options are as follows:
               + **container_stdout**
               + **container_file**
               + **host_file**
        :param Sequence[_builtins.str] black_paths: Specifies the collection path blacklist.
        :param _builtins.str container_name_regex: Specifies the regular expression matching of kubernetes container names.
               LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
               leave this field empty.
        :param Mapping[str, _builtins.str] custom_key_value: Specifies the custom key/value pairs of the CCE access.  
               Changing this creates a new resource.
        :param Mapping[str, _builtins.str] exclude_envs: Specifies the environment variable blacklist. A maximum of `30` tags can be
               created. The key names must be unique. LTS will exclude all containers with environment variables containing either
               an environment variable key with an empty corresponding environment variable value, or an environment variable key
               with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
               expression matching.
        :param _builtins.str exclude_envs_logical: Specifies the logical relationship between multiple environment variable
               blacklists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] exclude_k8s_labels: Specifies the kubernetes label blacklist. A maximum of `30` tags can be
               created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
               excluded. If labelValue is not empty, only containers whose K8s label contains `LabelKey=LabelValue` are excluded.
               LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
               OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
        :param _builtins.str exclude_k8s_labels_logical: Specifies the logical relationship between multiple kubernetes label
               blacklists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] exclude_labels: Specifies the container label blacklist. A maximum of `30` tags can be created.
               The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
               excluded. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
               excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
               are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
        :param _builtins.str exclude_labels_logical: Specifies the logical relationship between multiple container label
               blacklists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] include_envs: Specifies the environment variable whitelist. A maximum of `30` tags can be
               created. The key names must be unique. LTS will match all containers with environment variables containing either
               an environment variable key with an empty corresponding environment variable value, or an environment variable key
               with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
               expression matching.
        :param _builtins.str include_envs_logical: Specifies the logical relationship between multiple environment variable
               whitelists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] include_k8s_labels: Specifies the kubernetes label whitelist. A maximum of `30` tags can be
               created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
               matched. If labelValue is not empty, only containers whose K8s Label contains `LabelKey=LabelValue` are matched.
               LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
               OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
        :param _builtins.str include_k8s_labels_logical: Specifies the logical relationship between multiple kubernetes label
               whitelists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] include_labels: Specifies the container label whitelist. A maximum of `30` tags can be created.
               The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
               matched. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
               matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
               are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
        :param _builtins.str include_labels_logical: Specifies the logical relationship between multiple container label
               whitelists.
               Defaults to **or**.
               The valid values are as follows:
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] log_envs: Specifies the environment variable tag. A maximum of `30` tags can be created.
               The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
               corresponding environment variable value. For example, if you enter `app` as the key and `app_alias` as the value,
               when the kubernetes environment variable contains `app=lts`, `{app_alias: lts}` will be added to the log.
        :param Mapping[str, _builtins.str] log_k8s: Specifies the kubernetes label log tag. A maximum of `30` tags can be created.
               The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
               value. For example, if you enter `app` as the key and `app_alias` as the value, when the K8s label contains
               `app=lts`, `{app_alias: lts}` will be added to the log.
        :param Mapping[str, _builtins.str] log_labels: Specifies the container label log tag. A maximum of `30` tags can be created.
               The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
               label value. For example, if you enter `app` as the key and `app_alias` as the value, when the Container label
               contains `app=lts`, `{app_alias: lts}` will be added to the log.
        :param 'CceAccessAccessConfigMultiLogFormatArgs' multi_log_format: Specifies the configuration multi-line logs. Multiple lines of exception log
               events can be displayed as a single log event. This is helpful when you check logs to locate problems.
               The multi_log_format structure is documented below.
               
               > `single_log_format` or `multi_log_format` must be specified.
        :param _builtins.str name_space_regex: Specifies the regular expression matching of kubernetes namespaces.
               LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
               leave this field empty.
        :param Sequence[_builtins.str] paths: Specifies the collection paths. Required when `path_type` is **container_file**
               or **host_file**.
        :param _builtins.str pod_name_regex: Specifies the regular expression matching of kubernetes pods.
               LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
               leave this field empty.
        :param _builtins.bool repeat_collect: Specifies whether to allow repeated file collection.  
               Defaults to **false**.
               + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
               This function is available only to certain ICAgent versions, please refer to the documentation.
               + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.
        :param 'CceAccessAccessConfigSingleLogFormatArgs' single_log_format: Specifies the configuration single-line logs. Each log line is displayed
               as a single log event.
               The single_log_format structure is documented below.
        :param _builtins.bool stderr: Specifies whether error output is standard. Default is **false**.
               
               >  If the value of `path_type` is **container_stdout**, `stdout` or `stderr` must be **true**.
        :param _builtins.bool stdout: Specifies whether output is standard. Default is false.
        :param Sequence[_builtins.str] system_fields: Specifies the list of system built-in fields of the CCE access.  
               Changing this creates a new resource.
               If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
               the system as **pathfile**.
               If `system_fields` is specified, **pathFile** must be included.
               The valid values are as follows:
               + **pathFile**
               + **hostName**
               + **hostId**
               + **hostIP**
               + **hostIPv6**
               + **clusterId**
               + **podName**
               + **appName**
               + **containerName**
               + **nameSpace**
               + **category**
               + **serviceID**
               + **podIp**
               + **clusterName**
               + **workloadType**
               + **image_name**
               
               > These parameters include `name_space_regex`, `pod_name_regex`, `container_name_regex`, `log_labels`,
               `include_labels_logical`, `include_labels`, `exclude_labels_logical`, `exclude_labels`, `log_envs`,
               `include_envs_logical`, `include_envs`, `exclude_envs_logical`, `exclude_envs`, `log_k8s`,
               `include_k8s_labels_logical`, `include_k8s_labels`, `exclude_k8s_labels_logical` and
               `exclude_k8s_labels` are available, only `path_type` is not **host_file**.
               
               <a name="block_access_config_single_log_format"></a>
               The `single_log_format` block supports:
        :param 'CceAccessAccessConfigWindowsLogInfoArgs' windows_log_info: Specifies the configuration of Windows event logs. Required when
               `path_type` is **container_file** or **container_stdout**.
               The windows_log_info structure is documented below.
        """
        pulumi.set(__self__, "path_type", path_type)
        if black_paths is not None:
            pulumi.set(__self__, "black_paths", black_paths)
        if container_name_regex is not None:
            pulumi.set(__self__, "container_name_regex", container_name_regex)
        if custom_key_value is not None:
            pulumi.set(__self__, "custom_key_value", custom_key_value)
        if exclude_envs is not None:
            pulumi.set(__self__, "exclude_envs", exclude_envs)
        if exclude_envs_logical is not None:
            pulumi.set(__self__, "exclude_envs_logical", exclude_envs_logical)
        if exclude_k8s_labels is not None:
            pulumi.set(__self__, "exclude_k8s_labels", exclude_k8s_labels)
        if exclude_k8s_labels_logical is not None:
            pulumi.set(__self__, "exclude_k8s_labels_logical", exclude_k8s_labels_logical)
        if exclude_labels is not None:
            pulumi.set(__self__, "exclude_labels", exclude_labels)
        if exclude_labels_logical is not None:
            pulumi.set(__self__, "exclude_labels_logical", exclude_labels_logical)
        if include_envs is not None:
            pulumi.set(__self__, "include_envs", include_envs)
        if include_envs_logical is not None:
            pulumi.set(__self__, "include_envs_logical", include_envs_logical)
        if include_k8s_labels is not None:
            pulumi.set(__self__, "include_k8s_labels", include_k8s_labels)
        if include_k8s_labels_logical is not None:
            pulumi.set(__self__, "include_k8s_labels_logical", include_k8s_labels_logical)
        if include_labels is not None:
            pulumi.set(__self__, "include_labels", include_labels)
        if include_labels_logical is not None:
            pulumi.set(__self__, "include_labels_logical", include_labels_logical)
        if log_envs is not None:
            pulumi.set(__self__, "log_envs", log_envs)
        if log_k8s is not None:
            pulumi.set(__self__, "log_k8s", log_k8s)
        if log_labels is not None:
            pulumi.set(__self__, "log_labels", log_labels)
        if multi_log_format is not None:
            pulumi.set(__self__, "multi_log_format", multi_log_format)
        if name_space_regex is not None:
            pulumi.set(__self__, "name_space_regex", name_space_regex)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if pod_name_regex is not None:
            pulumi.set(__self__, "pod_name_regex", pod_name_regex)
        if repeat_collect is not None:
            pulumi.set(__self__, "repeat_collect", repeat_collect)
        if single_log_format is not None:
            pulumi.set(__self__, "single_log_format", single_log_format)
        if stderr is not None:
            pulumi.set(__self__, "stderr", stderr)
        if stdout is not None:
            pulumi.set(__self__, "stdout", stdout)
        if system_fields is not None:
            pulumi.set(__self__, "system_fields", system_fields)
        if windows_log_info is not None:
            pulumi.set(__self__, "windows_log_info", windows_log_info)

    @_builtins.property
    @pulumi.getter(name="pathType")
    def path_type(self) -> _builtins.str:
        """
        Specifies the type of the CCE access. The options are as follows:
        + **container_stdout**
        + **container_file**
        + **host_file**
        """
        return pulumi.get(self, "path_type")

    @_builtins.property
    @pulumi.getter(name="blackPaths")
    def black_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the collection path blacklist.
        """
        return pulumi.get(self, "black_paths")

    @_builtins.property
    @pulumi.getter(name="containerNameRegex")
    def container_name_regex(self) -> Optional[_builtins.str]:
        """
        Specifies the regular expression matching of kubernetes container names.
        LTS will collect logs of the containers with names matching this expression. To collect logs of all containers,
        leave this field empty.
        """
        return pulumi.get(self, "container_name_regex")

    @_builtins.property
    @pulumi.getter(name="customKeyValue")
    def custom_key_value(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the custom key/value pairs of the CCE access.  
        Changing this creates a new resource.
        """
        return pulumi.get(self, "custom_key_value")

    @_builtins.property
    @pulumi.getter(name="excludeEnvs")
    def exclude_envs(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the environment variable blacklist. A maximum of `30` tags can be
        created. The key names must be unique. LTS will exclude all containers with environment variables containing either
        an environment variable key with an empty corresponding environment variable value, or an environment variable key
        with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
        expression matching.
        """
        return pulumi.get(self, "exclude_envs")

    @_builtins.property
    @pulumi.getter(name="excludeEnvsLogical")
    def exclude_envs_logical(self) -> Optional[_builtins.str]:
        """
        Specifies the logical relationship between multiple environment variable
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_envs_logical")

    @_builtins.property
    @pulumi.getter(name="excludeK8sLabels")
    def exclude_k8s_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the kubernetes label blacklist. A maximum of `30` tags can be
        created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
        excluded. If labelValue is not empty, only containers whose K8s label contains `LabelKey=LabelValue` are excluded.
        LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists are in the
        OR relationship. That is, a K8s Label can be excluded as long as it meets any of the blacklists.
        """
        return pulumi.get(self, "exclude_k8s_labels")

    @_builtins.property
    @pulumi.getter(name="excludeK8sLabelsLogical")
    def exclude_k8s_labels_logical(self) -> Optional[_builtins.str]:
        """
        Specifies the logical relationship between multiple kubernetes label
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_k8s_labels_logical")

    @_builtins.property
    @pulumi.getter(name="excludeLabels")
    def exclude_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the container label blacklist. A maximum of `30` tags can be created.
        The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
        excluded. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
        excluded. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple blacklists
        are in the OR relationship. That is, a container label can be excluded as long as it meets any of the blacklists.
        """
        return pulumi.get(self, "exclude_labels")

    @_builtins.property
    @pulumi.getter(name="excludeLabelsLogical")
    def exclude_labels_logical(self) -> Optional[_builtins.str]:
        """
        Specifies the logical relationship between multiple container label
        blacklists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_labels_logical")

    @_builtins.property
    @pulumi.getter(name="includeEnvs")
    def include_envs(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the environment variable whitelist. A maximum of `30` tags can be
        created. The key names must be unique. LTS will match all containers with environment variables containing either
        an environment variable key with an empty corresponding environment variable value, or an environment variable key
        with its corresponding environment variable value. LabelKey must be fully matched, and labelValue supports regular
        expression matching.
        """
        return pulumi.get(self, "include_envs")

    @_builtins.property
    @pulumi.getter(name="includeEnvsLogical")
    def include_envs_logical(self) -> Optional[_builtins.str]:
        """
        Specifies the logical relationship between multiple environment variable
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_envs_logical")

    @_builtins.property
    @pulumi.getter(name="includeK8sLabels")
    def include_k8s_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the kubernetes label whitelist. A maximum of `30` tags can be
        created. The key names must be unique. If labelValue is empty, all containers whose K8s label contains labelKey are
        matched. If labelValue is not empty, only containers whose K8s Label contains `LabelKey=LabelValue` are matched.
        LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists are in the
        OR relationship. That is, a K8s label can be matched as long as it meets any of the whitelists.
        """
        return pulumi.get(self, "include_k8s_labels")

    @_builtins.property
    @pulumi.getter(name="includeK8sLabelsLogical")
    def include_k8s_labels_logical(self) -> Optional[_builtins.str]:
        """
        Specifies the logical relationship between multiple kubernetes label
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_k8s_labels_logical")

    @_builtins.property
    @pulumi.getter(name="includeLabels")
    def include_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the container label whitelist. A maximum of `30` tags can be created.
        The key names must be unique. If labelValue is empty, all containers whose container label contains labelKey are
        matched. If labelValue is not empty, only containers whose container label contains `LabelKey=LabelValue` are
        matched. LabelKey must be fully matched, and labelValue supports regular expression matching. Multiple whitelists
        are in the OR relationship. That is, a container label can be matched as long as it meets any of the whitelists.
        """
        return pulumi.get(self, "include_labels")

    @_builtins.property
    @pulumi.getter(name="includeLabelsLogical")
    def include_labels_logical(self) -> Optional[_builtins.str]:
        """
        Specifies the logical relationship between multiple container label
        whitelists.
        Defaults to **or**.
        The valid values are as follows:
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_labels_logical")

    @_builtins.property
    @pulumi.getter(name="logEnvs")
    def log_envs(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the environment variable tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each environment variable key has a
        corresponding environment variable value. For example, if you enter `app` as the key and `app_alias` as the value,
        when the kubernetes environment variable contains `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        return pulumi.get(self, "log_envs")

    @_builtins.property
    @pulumi.getter(name="logK8s")
    def log_k8s(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the kubernetes label log tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding label
        value. For example, if you enter `app` as the key and `app_alias` as the value, when the K8s label contains
        `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        return pulumi.get(self, "log_k8s")

    @_builtins.property
    @pulumi.getter(name="logLabels")
    def log_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the container label log tag. A maximum of `30` tags can be created.
        The key names must be unique. LTS adds the specified fields to the log when each label key has a corresponding
        label value. For example, if you enter `app` as the key and `app_alias` as the value, when the Container label
        contains `app=lts`, `{app_alias: lts}` will be added to the log.
        """
        return pulumi.get(self, "log_labels")

    @_builtins.property
    @pulumi.getter(name="multiLogFormat")
    def multi_log_format(self) -> Optional['outputs.CceAccessAccessConfigMultiLogFormat']:
        """
        Specifies the configuration multi-line logs. Multiple lines of exception log
        events can be displayed as a single log event. This is helpful when you check logs to locate problems.
        The multi_log_format structure is documented below.

        > `single_log_format` or `multi_log_format` must be specified.
        """
        return pulumi.get(self, "multi_log_format")

    @_builtins.property
    @pulumi.getter(name="nameSpaceRegex")
    def name_space_regex(self) -> Optional[_builtins.str]:
        """
        Specifies the regular expression matching of kubernetes namespaces.
        LTS will collect logs of the namespaces with names matching this expression. To collect logs of all namespaces,
        leave this field empty.
        """
        return pulumi.get(self, "name_space_regex")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the collection paths. Required when `path_type` is **container_file**
        or **host_file**.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="podNameRegex")
    def pod_name_regex(self) -> Optional[_builtins.str]:
        """
        Specifies the regular expression matching of kubernetes pods.
        LTS will collect logs of the Pods with names matching this expression. To collect logs of all Pods,
        leave this field empty.
        """
        return pulumi.get(self, "pod_name_regex")

    @_builtins.property
    @pulumi.getter(name="repeatCollect")
    def repeat_collect(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to allow repeated file collection.  
        Defaults to **false**.
        + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
        This function is available only to certain ICAgent versions, please refer to the documentation.
        + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.
        """
        return pulumi.get(self, "repeat_collect")

    @_builtins.property
    @pulumi.getter(name="singleLogFormat")
    def single_log_format(self) -> Optional['outputs.CceAccessAccessConfigSingleLogFormat']:
        """
        Specifies the configuration single-line logs. Each log line is displayed
        as a single log event.
        The single_log_format structure is documented below.
        """
        return pulumi.get(self, "single_log_format")

    @_builtins.property
    @pulumi.getter
    def stderr(self) -> Optional[_builtins.bool]:
        """
        Specifies whether error output is standard. Default is **false**.

        >  If the value of `path_type` is **container_stdout**, `stdout` or `stderr` must be **true**.
        """
        return pulumi.get(self, "stderr")

    @_builtins.property
    @pulumi.getter
    def stdout(self) -> Optional[_builtins.bool]:
        """
        Specifies whether output is standard. Default is false.
        """
        return pulumi.get(self, "stdout")

    @_builtins.property
    @pulumi.getter(name="systemFields")
    def system_fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of system built-in fields of the CCE access.  
        Changing this creates a new resource.
        If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
        the system as **pathfile**.
        If `system_fields` is specified, **pathFile** must be included.
        The valid values are as follows:
        + **pathFile**
        + **hostName**
        + **hostId**
        + **hostIP**
        + **hostIPv6**
        + **clusterId**
        + **podName**
        + **appName**
        + **containerName**
        + **nameSpace**
        + **category**
        + **serviceID**
        + **podIp**
        + **clusterName**
        + **workloadType**
        + **image_name**

        > These parameters include `name_space_regex`, `pod_name_regex`, `container_name_regex`, `log_labels`,
        `include_labels_logical`, `include_labels`, `exclude_labels_logical`, `exclude_labels`, `log_envs`,
        `include_envs_logical`, `include_envs`, `exclude_envs_logical`, `exclude_envs`, `log_k8s`,
        `include_k8s_labels_logical`, `include_k8s_labels`, `exclude_k8s_labels_logical` and
        `exclude_k8s_labels` are available, only `path_type` is not **host_file**.

        <a name="block_access_config_single_log_format"></a>
        The `single_log_format` block supports:
        """
        return pulumi.get(self, "system_fields")

    @_builtins.property
    @pulumi.getter(name="windowsLogInfo")
    def windows_log_info(self) -> Optional['outputs.CceAccessAccessConfigWindowsLogInfo']:
        """
        Specifies the configuration of Windows event logs. Required when
        `path_type` is **container_file** or **container_stdout**.
        The windows_log_info structure is documented below.
        """
        return pulumi.get(self, "windows_log_info")


@pulumi.output_type
class CceAccessAccessConfigMultiLogFormat(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: Specifies value of multi-line log format.
               + If mode is **regular**, the value is a regular expression.
               + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
               as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
               wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
               wildcard is **YY-M-D hh:mm:ss**.
               
               > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
               log line. If no match is found, the system time, which may be different from the time in the log event, is used.
               In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.
               
               <a name="block_access_config_windows_log_info"></a>
               The `windows_log_info` block supports:
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies value of multi-line log format.
        + If mode is **regular**, the value is a regular expression.
        + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
        as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
        wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
        wildcard is **YY-M-D hh:mm:ss**.

        > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
        log line. If no match is found, the system time, which may be different from the time in the log event, is used.
        In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.

        <a name="block_access_config_windows_log_info"></a>
        The `windows_log_info` block supports:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CceAccessAccessConfigSingleLogFormat(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: Specifies value of multi-line log format.
               + If mode is **regular**, the value is a regular expression.
               + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
               as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
               wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
               wildcard is **YY-M-D hh:mm:ss**.
               
               > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
               log line. If no match is found, the system time, which may be different from the time in the log event, is used.
               In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.
               
               <a name="block_access_config_windows_log_info"></a>
               The `windows_log_info` block supports:
        """
        pulumi.set(__self__, "mode", mode)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies value of multi-line log format.
        + If mode is **regular**, the value is a regular expression.
        + If mode is **time**, the value is a time wildcard, which is used to look for the log printing time
        as the beginning of a log event. If the time format in a log event is `2019-01-01 23:59:59`, the time
        wildcard is **YYYY-MM-DD hh:mm:ss**. If the time format in a log event is `19-1-1 23:59:59`, the time
        wildcard is **YY-M-D hh:mm:ss**.

        > The time wildcard and regular expression will look for the specified pattern right from the beginning of each
        log line. If no match is found, the system time, which may be different from the time in the log event, is used.
        In general cases, you are advised to select **Single-line** for Log Format and **system** time for Log Time.

        <a name="block_access_config_windows_log_info"></a>
        The `windows_log_info` block supports:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CceAccessAccessConfigWindowsLogInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventLevels":
            suggest = "event_levels"
        elif key == "timeOffset":
            suggest = "time_offset"
        elif key == "timeOffsetUnit":
            suggest = "time_offset_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CceAccessAccessConfigWindowsLogInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CceAccessAccessConfigWindowsLogInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CceAccessAccessConfigWindowsLogInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categorys: Sequence[_builtins.str],
                 event_levels: Sequence[_builtins.str],
                 time_offset: _builtins.int,
                 time_offset_unit: _builtins.str):
        """
        :param Sequence[_builtins.str] categorys: Specifies the types of Windows event logs to collect. The valid values are
               **Application**, **System**, **Security** and **Setup**.
        :param Sequence[_builtins.str] event_levels: Specifies the Windows event severity. The valid values are **information**,
               **warning**, **error**, **critical** and **verbose**. Only Windows Vista or later is supported.
        :param _builtins.int time_offset: Specifies the collection time offset. This time takes effect only for the first
               time to ensure that the logs are not collected repeatedly.
               
               + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
               + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
               + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.
               
               <a name="cce_access_processors"></a>
               The `processors` block supports:
        :param _builtins.str time_offset_unit: Specifies the collection time offset unit. The valid values are
               **day**, **hour** and **sec**.
        """
        pulumi.set(__self__, "categorys", categorys)
        pulumi.set(__self__, "event_levels", event_levels)
        pulumi.set(__self__, "time_offset", time_offset)
        pulumi.set(__self__, "time_offset_unit", time_offset_unit)

    @_builtins.property
    @pulumi.getter
    def categorys(self) -> Sequence[_builtins.str]:
        """
        Specifies the types of Windows event logs to collect. The valid values are
        **Application**, **System**, **Security** and **Setup**.
        """
        return pulumi.get(self, "categorys")

    @_builtins.property
    @pulumi.getter(name="eventLevels")
    def event_levels(self) -> Sequence[_builtins.str]:
        """
        Specifies the Windows event severity. The valid values are **information**,
        **warning**, **error**, **critical** and **verbose**. Only Windows Vista or later is supported.
        """
        return pulumi.get(self, "event_levels")

    @_builtins.property
    @pulumi.getter(name="timeOffset")
    def time_offset(self) -> _builtins.int:
        """
        Specifies the collection time offset. This time takes effect only for the first
        time to ensure that the logs are not collected repeatedly.

        + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
        + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
        + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.

        <a name="cce_access_processors"></a>
        The `processors` block supports:
        """
        return pulumi.get(self, "time_offset")

    @_builtins.property
    @pulumi.getter(name="timeOffsetUnit")
    def time_offset_unit(self) -> _builtins.str:
        """
        Specifies the collection time offset unit. The valid values are
        **day**, **hour** and **sec**.
        """
        return pulumi.get(self, "time_offset_unit")


@pulumi.output_type
class CceAccessDemoField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldValue":
            suggest = "field_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CceAccessDemoField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CceAccessDemoField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CceAccessDemoField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str field_name: Specifies the name of the parsed field.
        :param _builtins.str field_value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "field_name", field_name)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the name of the parsed field.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[_builtins.str]:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "field_value")


@pulumi.output_type
class CceAccessProcessor(dict):
    def __init__(__self__, *,
                 detail: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str detail: Specifies the configuration of the parser, in JSON format.  
               For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).
               
               <a name="cce_access_demoFields"></a>
               The `demo_fields` block supports:
        :param _builtins.str type: Specifies the type of the parser.  
               The valid values are as follows:
               + **processor_regex**
               + **processor_split_string**
               + **processor_json**
               + **processor_gotime**
               + **processor_filter_regex**
               + **processor_drop**
               + **processor_rename**
        """
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[_builtins.str]:
        """
        Specifies the configuration of the parser, in JSON format.  
        For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).

        <a name="cce_access_demoFields"></a>
        The `demo_fields` block supports:
        """
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the type of the parser.  
        The valid values are as follows:
        + **processor_regex**
        + **processor_split_string**
        + **processor_json**
        + **processor_gotime**
        + **processor_filter_regex**
        + **processor_drop**
        + **processor_rename**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class HostAccessAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackPaths":
            suggest = "black_paths"
        elif key == "customKeyValue":
            suggest = "custom_key_value"
        elif key == "multiLogFormat":
            suggest = "multi_log_format"
        elif key == "repeatCollect":
            suggest = "repeat_collect"
        elif key == "singleLogFormat":
            suggest = "single_log_format"
        elif key == "systemFields":
            suggest = "system_fields"
        elif key == "windowsLogInfo":
            suggest = "windows_log_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAccessAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAccessAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAccessAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paths: Sequence[_builtins.str],
                 black_paths: Optional[Sequence[_builtins.str]] = None,
                 custom_key_value: Optional[Mapping[str, _builtins.str]] = None,
                 multi_log_format: Optional['outputs.HostAccessAccessConfigMultiLogFormat'] = None,
                 repeat_collect: Optional[_builtins.bool] = None,
                 single_log_format: Optional['outputs.HostAccessAccessConfigSingleLogFormat'] = None,
                 system_fields: Optional[Sequence[_builtins.str]] = None,
                 windows_log_info: Optional['outputs.HostAccessAccessConfigWindowsLogInfo'] = None):
        """
        :param Sequence[_builtins.str] paths: Specifies the collection paths.
               
               + A path must start with `/` or `Letter:\\`.
               + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
               + A path cannot start with `/**` or `/*`.
               + Only one double asterisk (**) can be contained in a path.
               + Up to 10 paths can be specified.
        :param Sequence[_builtins.str] black_paths: Specifies the collection path blacklist.
               
               + A path must start with `/` or `Letter:\\`.
               + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
               + A path cannot start with `/**` or `/*`.
               + Only one double asterisk (**) can be contained in a path.
               + Up to 10 paths can be specified.
               
               > If you blacklist a file or directory that has been set as a collection path, the blacklist settings
               will be used and the file or files in the directory will be filtered out.
        :param Mapping[str, _builtins.str] custom_key_value: Specifies the custom key/value pairs of the host access.  
               Changing this parameter will create a new resource.
        :param 'HostAccessAccessConfigMultiLogFormatArgs' multi_log_format: Specifies the configuration multi-line logs. Multiple lines of exception log events
               can be displayed as a single log event. This is helpful when you check logs to locate problems.
               The multi_log_format structure is documented below.
        :param _builtins.bool repeat_collect: Specifies whether to allow repeated flie collection.  
               Defaults to **false**.
               + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
               This function is available only to certain ICAgent versions, please refer to the documentation.
               + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.
               
               <a name="HostAccessConfigSingleLogFormat"></a>
               The `single_log_format` blocks supports:
        :param 'HostAccessAccessConfigSingleLogFormatArgs' single_log_format: Specifies the configuration single-line logs. Each log line is displayed as a
               single log event. The single_log_format structure is documented below.
        :param Sequence[_builtins.str] system_fields: Specifies the list of system built-in fields of the host access.  
               Changing this parameter will create a new resource.
               If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
               the system as **pathfile**.
               If `system_fields` is specified, **pathFile** must be included.
               The valid values are as follows:
               + **pathFile**
               + **hostName**
               + **hostId**
               + **hostIP**
               + **hostIPv6**
        :param 'HostAccessAccessConfigWindowsLogInfoArgs' windows_log_info: Specifies the configuration of Windows event logs.
               The windows_log_info structure is documented below.
        """
        pulumi.set(__self__, "paths", paths)
        if black_paths is not None:
            pulumi.set(__self__, "black_paths", black_paths)
        if custom_key_value is not None:
            pulumi.set(__self__, "custom_key_value", custom_key_value)
        if multi_log_format is not None:
            pulumi.set(__self__, "multi_log_format", multi_log_format)
        if repeat_collect is not None:
            pulumi.set(__self__, "repeat_collect", repeat_collect)
        if single_log_format is not None:
            pulumi.set(__self__, "single_log_format", single_log_format)
        if system_fields is not None:
            pulumi.set(__self__, "system_fields", system_fields)
        if windows_log_info is not None:
            pulumi.set(__self__, "windows_log_info", windows_log_info)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence[_builtins.str]:
        """
        Specifies the collection paths.

        + A path must start with `/` or `Letter:\\`.
        + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
        + A path cannot start with `/**` or `/*`.
        + Only one double asterisk (**) can be contained in a path.
        + Up to 10 paths can be specified.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="blackPaths")
    def black_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the collection path blacklist.

        + A path must start with `/` or `Letter:\\`.
        + A path cannot contain only slashes (/). The following special characters are not allowed: <>'|"
        + A path cannot start with `/**` or `/*`.
        + Only one double asterisk (**) can be contained in a path.
        + Up to 10 paths can be specified.

        > If you blacklist a file or directory that has been set as a collection path, the blacklist settings
        will be used and the file or files in the directory will be filtered out.
        """
        return pulumi.get(self, "black_paths")

    @_builtins.property
    @pulumi.getter(name="customKeyValue")
    def custom_key_value(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the custom key/value pairs of the host access.  
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "custom_key_value")

    @_builtins.property
    @pulumi.getter(name="multiLogFormat")
    def multi_log_format(self) -> Optional['outputs.HostAccessAccessConfigMultiLogFormat']:
        """
        Specifies the configuration multi-line logs. Multiple lines of exception log events
        can be displayed as a single log event. This is helpful when you check logs to locate problems.
        The multi_log_format structure is documented below.
        """
        return pulumi.get(self, "multi_log_format")

    @_builtins.property
    @pulumi.getter(name="repeatCollect")
    def repeat_collect(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to allow repeated flie collection.  
        Defaults to **false**.
        + If this parameter is set to **true**, one host log file can be collected to multiple log streams.
        This function is available only to certain ICAgent versions, please refer to the documentation.
        + If this parameter is set to **false**, the same log file in the same host cannot be collected to different log streams.

        <a name="HostAccessConfigSingleLogFormat"></a>
        The `single_log_format` blocks supports:
        """
        return pulumi.get(self, "repeat_collect")

    @_builtins.property
    @pulumi.getter(name="singleLogFormat")
    def single_log_format(self) -> Optional['outputs.HostAccessAccessConfigSingleLogFormat']:
        """
        Specifies the configuration single-line logs. Each log line is displayed as a
        single log event. The single_log_format structure is documented below.
        """
        return pulumi.get(self, "single_log_format")

    @_builtins.property
    @pulumi.getter(name="systemFields")
    def system_fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of system built-in fields of the host access.  
        Changing this parameter will create a new resource.
        If `custom_key_value` is specified, the value of `system_fields` will be automatically assigned by
        the system as **pathfile**.
        If `system_fields` is specified, **pathFile** must be included.
        The valid values are as follows:
        + **pathFile**
        + **hostName**
        + **hostId**
        + **hostIP**
        + **hostIPv6**
        """
        return pulumi.get(self, "system_fields")

    @_builtins.property
    @pulumi.getter(name="windowsLogInfo")
    def windows_log_info(self) -> Optional['outputs.HostAccessAccessConfigWindowsLogInfo']:
        """
        Specifies the configuration of Windows event logs.
        The windows_log_info structure is documented below.
        """
        return pulumi.get(self, "windows_log_info")


@pulumi.output_type
class HostAccessAccessConfigMultiLogFormat(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostAccessAccessConfigSingleLogFormat(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Specifies mode of multi-line log format. The options are as follows:
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "mode", mode)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Specifies mode of multi-line log format. The options are as follows:
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostAccessAccessConfigWindowsLogInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventLevels":
            suggest = "event_levels"
        elif key == "timeOffset":
            suggest = "time_offset"
        elif key == "timeOffsetUnit":
            suggest = "time_offset_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostAccessAccessConfigWindowsLogInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostAccessAccessConfigWindowsLogInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostAccessAccessConfigWindowsLogInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categorys: Sequence[_builtins.str],
                 event_levels: Sequence[_builtins.str],
                 time_offset: _builtins.int,
                 time_offset_unit: _builtins.str):
        """
        :param Sequence[_builtins.str] categorys: Specifies the types of Windows event logs to collect. The valid values are
               **Application**, **System**, **Security** and **Setup**.
        :param Sequence[_builtins.str] event_levels: Specifies the Windows event severity. The valid values are **information**, **warning**,
               **error**, **critical** and **verbose**.  Only Windows Vista or later is supported.
        :param _builtins.int time_offset: Specifies the collection time offset. This time takes effect only for the first
               time to ensure that the logs are not collected repeatedly.
               
               + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
               + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
               + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.
               
               <a name="HostAccessProcessors"></a>
               The `processors` block supports:
        :param _builtins.str time_offset_unit: Specifies the collection time offset unit. The valid values are
               **day**, **hour** and **sec**.
        """
        pulumi.set(__self__, "categorys", categorys)
        pulumi.set(__self__, "event_levels", event_levels)
        pulumi.set(__self__, "time_offset", time_offset)
        pulumi.set(__self__, "time_offset_unit", time_offset_unit)

    @_builtins.property
    @pulumi.getter
    def categorys(self) -> Sequence[_builtins.str]:
        """
        Specifies the types of Windows event logs to collect. The valid values are
        **Application**, **System**, **Security** and **Setup**.
        """
        return pulumi.get(self, "categorys")

    @_builtins.property
    @pulumi.getter(name="eventLevels")
    def event_levels(self) -> Sequence[_builtins.str]:
        """
        Specifies the Windows event severity. The valid values are **information**, **warning**,
        **error**, **critical** and **verbose**.  Only Windows Vista or later is supported.
        """
        return pulumi.get(self, "event_levels")

    @_builtins.property
    @pulumi.getter(name="timeOffset")
    def time_offset(self) -> _builtins.int:
        """
        Specifies the collection time offset. This time takes effect only for the first
        time to ensure that the logs are not collected repeatedly.

        + When `time_offset_unit` is set to **day**, the value ranges from `1` to `7` days.
        + When `time_offset_unit` is set to **hour**, the value ranges from `1` to `168` hours.
        + When `time_offset_unit` is set to **sec**, the value ranges from `1` to `604,800` seconds.

        <a name="HostAccessProcessors"></a>
        The `processors` block supports:
        """
        return pulumi.get(self, "time_offset")

    @_builtins.property
    @pulumi.getter(name="timeOffsetUnit")
    def time_offset_unit(self) -> _builtins.str:
        """
        Specifies the collection time offset unit. The valid values are
        **day**, **hour** and **sec**.
        """
        return pulumi.get(self, "time_offset_unit")


@pulumi.output_type
class HostAccessDemoField(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name of the parsed field.
        :param _builtins.str value: Specifies the value of the parsed field.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the parsed field.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the value of the parsed field.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostAccessProcessor(dict):
    def __init__(__self__, *,
                 detail: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str detail: Specifies the configuration of the parser, in JSON format.  
               For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).
               
               <a name="HostAccessDemoFields"></a>
               The `demo_fields` block supports:
        :param _builtins.str type: Specifies the type of the parser.  
               The valid values are as follows:
               + **processor_regex**
               + **processor_split_string**
               + **processor_json**
               + **processor_gotime**
               + **processor_filter_regex**
               + **processor_drop**
               + **processor_rename**
        """
        if detail is not None:
            pulumi.set(__self__, "detail", detail)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> Optional[_builtins.str]:
        """
        Specifies the configuration of the parser, in JSON format.  
        For the keys, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/api-lts/CreateAccessConfig.html#CreateAccessConfig__request_Detail).

        <a name="HostAccessDemoFields"></a>
        The `demo_fields` block supports:
        """
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the type of the parser.  
        The valid values are as follows:
        + **processor_regex**
        + **processor_split_string**
        + **processor_json**
        + **processor_gotime**
        + **processor_filter_regex**
        + **processor_drop**
        + **processor_rename**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KeywordsAlarmRuleFrequency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "fixedRate":
            suggest = "fixed_rate"
        elif key == "fixedRateUnit":
            suggest = "fixed_rate_unit"
        elif key == "hourOfDay":
            suggest = "hour_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeywordsAlarmRuleFrequency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeywordsAlarmRuleFrequency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeywordsAlarmRuleFrequency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 cron_expression: Optional[_builtins.str] = None,
                 day_of_week: Optional[_builtins.int] = None,
                 fixed_rate: Optional[_builtins.int] = None,
                 fixed_rate_unit: Optional[_builtins.str] = None,
                 hour_of_day: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Specifies the frequency type.  
               The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        :param _builtins.str cron_expression: Specifies the cron expression.  
               This parameter is used when `type` is set to **CRON**.
        :param _builtins.int day_of_week: Specifies the day of week.  
               This parameter is used when `type` is set to **WEEKLY**.
               The value ranges from `1` to `7`. `1` means Sunday.
        :param _builtins.int fixed_rate: Specifies the unit fixed rate.  
               This parameter is used when `type` is set to **FIXED_RATE**.
               + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
               + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`
               
               <a name="KeywordsAlarmRule_NotificationRule"></a>
               The `NotificationRule` block supports:
        :param _builtins.str fixed_rate_unit: Specifies the unit of fixed rate.  
               The value can be: **minute** and **hour**.
        :param _builtins.int hour_of_day: Specifies the hour of day.  
               This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
               The value ranges from `0` to `23`.
        """
        pulumi.set(__self__, "type", type)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if fixed_rate is not None:
            pulumi.set(__self__, "fixed_rate", fixed_rate)
        if fixed_rate_unit is not None:
            pulumi.set(__self__, "fixed_rate_unit", fixed_rate_unit)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the frequency type.  
        The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[_builtins.str]:
        """
        Specifies the cron expression.  
        This parameter is used when `type` is set to **CRON**.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.int]:
        """
        Specifies the day of week.  
        This parameter is used when `type` is set to **WEEKLY**.
        The value ranges from `1` to `7`. `1` means Sunday.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> Optional[_builtins.int]:
        """
        Specifies the unit fixed rate.  
        This parameter is used when `type` is set to **FIXED_RATE**.
        + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`

        <a name="KeywordsAlarmRule_NotificationRule"></a>
        The `NotificationRule` block supports:
        """
        return pulumi.get(self, "fixed_rate")

    @_builtins.property
    @pulumi.getter(name="fixedRateUnit")
    def fixed_rate_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit of fixed rate.  
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "fixed_rate_unit")

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[_builtins.int]:
        """
        Specifies the hour of day.  
        This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
        The value ranges from `0` to `23`.
        """
        return pulumi.get(self, "hour_of_day")


@pulumi.output_type
class KeywordsAlarmRuleKeywordsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupId":
            suggest = "log_group_id"
        elif key == "logStreamId":
            suggest = "log_stream_id"
        elif key == "searchTimeRange":
            suggest = "search_time_range"
        elif key == "searchTimeRangeUnit":
            suggest = "search_time_range_unit"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "logStreamName":
            suggest = "log_stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeywordsAlarmRuleKeywordsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeywordsAlarmRuleKeywordsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeywordsAlarmRuleKeywordsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: _builtins.str,
                 keywords: _builtins.str,
                 log_group_id: _builtins.str,
                 log_stream_id: _builtins.str,
                 number: _builtins.int,
                 search_time_range: _builtins.int,
                 search_time_range_unit: _builtins.str,
                 log_group_name: Optional[_builtins.str] = None,
                 log_stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str condition: Specifies the keywords request condition.  
               The value can be: **>=**, **<=**, **<** and **>**.
        :param _builtins.str keywords: Specifies the keywords.
        :param _builtins.str log_group_id: Specifies the ID of the log group.
        :param _builtins.str log_stream_id: Specifies the ID of the log stream.
        :param _builtins.int number: Specifies the line number.
        :param _builtins.int search_time_range: Specifies the search time range.
               + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`.
               + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`.
        :param _builtins.str search_time_range_unit: Specifies the unit of search time range.  
               The value can be: **minute** and **hour**.
        :param _builtins.str log_group_name: Specifies the name of the log group.
        :param _builtins.str log_stream_name: Specifies the name of the log stream.
               
               <a name="KeywordsAlarmRule_Frequency"></a>
               The `Frequency` block supports:
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "keywords", keywords)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "search_time_range", search_time_range)
        pulumi.set(__self__, "search_time_range_unit", search_time_range_unit)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        Specifies the keywords request condition.  
        The value can be: **>=**, **<=**, **<** and **>**.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def keywords(self) -> _builtins.str:
        """
        Specifies the keywords.
        """
        return pulumi.get(self, "keywords")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Specifies the ID of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        Specifies the ID of the log stream.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        Specifies the line number.
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="searchTimeRange")
    def search_time_range(self) -> _builtins.int:
        """
        Specifies the search time range.
        + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`.
        """
        return pulumi.get(self, "search_time_range")

    @_builtins.property
    @pulumi.getter(name="searchTimeRangeUnit")
    def search_time_range_unit(self) -> _builtins.str:
        """
        Specifies the unit of search time range.  
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "search_time_range_unit")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the log group.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the log stream.

        <a name="KeywordsAlarmRule_Frequency"></a>
        The `Frequency` block supports:
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class KeywordsAlarmRuleNotificationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeywordsAlarmRuleNotificationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeywordsAlarmRuleNotificationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeywordsAlarmRuleNotificationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_name: _builtins.str,
                 topics: Sequence['outputs.KeywordsAlarmRuleNotificationRuleTopic'],
                 user_name: _builtins.str,
                 language: Optional[_builtins.str] = None,
                 timezone: Optional[_builtins.str] = None):
        """
        :param _builtins.str template_name: Specifies the notification template name.
        :param Sequence['KeywordsAlarmRuleNotificationRuleTopicArgs'] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param _builtins.str user_name: Specifies the user name.
        :param _builtins.str language: Specifies the notification language.  
               The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.
               
               <a name="KeywordsAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        :param _builtins.str timezone: Specifies the timezone.
        """
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence['outputs.KeywordsAlarmRuleNotificationRuleTopic']:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[_builtins.str]:
        """
        Specifies the notification language.  
        The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.

        <a name="KeywordsAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Specifies the timezone.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class KeywordsAlarmRuleNotificationRuleTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicUrn":
            suggest = "topic_urn"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "pushPolicy":
            suggest = "push_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeywordsAlarmRuleNotificationRuleTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeywordsAlarmRuleNotificationRuleTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeywordsAlarmRuleNotificationRuleTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 topic_urn: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 push_policy: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Specifies the topic name.
        :param _builtins.str topic_urn: Specifies the topic URN.
        :param _builtins.str display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param _builtins.int push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[_builtins.int]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")


@pulumi.output_type
class KeywordsAlarmRuleNotificationSaveRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeywordsAlarmRuleNotificationSaveRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeywordsAlarmRuleNotificationSaveRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeywordsAlarmRuleNotificationSaveRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_name: _builtins.str,
                 topics: Sequence['outputs.KeywordsAlarmRuleNotificationSaveRuleTopic'],
                 user_name: _builtins.str,
                 language: Optional[_builtins.str] = None,
                 timezone: Optional[_builtins.str] = None):
        """
        :param _builtins.str template_name: Specifies the notification template name.
        :param Sequence['KeywordsAlarmRuleNotificationSaveRuleTopicArgs'] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param _builtins.str user_name: Specifies the user name.
        :param _builtins.str language: Specifies the notification language.  
               The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.
               
               <a name="KeywordsAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        :param _builtins.str timezone: Specifies the timezone.
        """
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence['outputs.KeywordsAlarmRuleNotificationSaveRuleTopic']:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[_builtins.str]:
        """
        Specifies the notification language.  
        The value can be **zh-cn** and **en-us**, defaults to **zh-cn**.

        <a name="KeywordsAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Specifies the timezone.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class KeywordsAlarmRuleNotificationSaveRuleTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicUrn":
            suggest = "topic_urn"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "pushPolicy":
            suggest = "push_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeywordsAlarmRuleNotificationSaveRuleTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeywordsAlarmRuleNotificationSaveRuleTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeywordsAlarmRuleNotificationSaveRuleTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 topic_urn: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 push_policy: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Specifies the topic name.
        :param _builtins.str topic_urn: Specifies the topic URN.
        :param _builtins.str display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param _builtins.int push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[_builtins.int]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")


@pulumi.output_type
class LogConvergeLogMappingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceLogGroupId":
            suggest = "source_log_group_id"
        elif key == "targetLogGroupName":
            suggest = "target_log_group_name"
        elif key == "logStreamConfigs":
            suggest = "log_stream_configs"
        elif key == "targetLogGroupId":
            suggest = "target_log_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogConvergeLogMappingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogConvergeLogMappingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogConvergeLogMappingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_log_group_id: _builtins.str,
                 target_log_group_name: _builtins.str,
                 log_stream_configs: Optional[Sequence['outputs.LogConvergeLogMappingConfigLogStreamConfig']] = None,
                 target_log_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str source_log_group_id: Specifies the ID of the log group for source side.
        :param _builtins.str target_log_group_name: Specifies the name of the log group for target side.
        :param Sequence['LogConvergeLogMappingConfigLogStreamConfigArgs'] log_stream_configs: Specifies the log streams converged under the current log group.  
               The log_stream_config structure is documented below.
               
               <a name="converge_log_streams_config"></a>
               The `log_stream_config` block supports:
        :param _builtins.str target_log_group_id: Specifies the ID of the log group for target side.
               
               > If you want to use an existing log group, this parameter (`target_log_group_id`) is required.
        """
        pulumi.set(__self__, "source_log_group_id", source_log_group_id)
        pulumi.set(__self__, "target_log_group_name", target_log_group_name)
        if log_stream_configs is not None:
            pulumi.set(__self__, "log_stream_configs", log_stream_configs)
        if target_log_group_id is not None:
            pulumi.set(__self__, "target_log_group_id", target_log_group_id)

    @_builtins.property
    @pulumi.getter(name="sourceLogGroupId")
    def source_log_group_id(self) -> _builtins.str:
        """
        Specifies the ID of the log group for source side.
        """
        return pulumi.get(self, "source_log_group_id")

    @_builtins.property
    @pulumi.getter(name="targetLogGroupName")
    def target_log_group_name(self) -> _builtins.str:
        """
        Specifies the name of the log group for target side.
        """
        return pulumi.get(self, "target_log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamConfigs")
    def log_stream_configs(self) -> Optional[Sequence['outputs.LogConvergeLogMappingConfigLogStreamConfig']]:
        """
        Specifies the log streams converged under the current log group.  
        The log_stream_config structure is documented below.

        <a name="converge_log_streams_config"></a>
        The `log_stream_config` block supports:
        """
        return pulumi.get(self, "log_stream_configs")

    @_builtins.property
    @pulumi.getter(name="targetLogGroupId")
    def target_log_group_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the log group for target side.

        > If you want to use an existing log group, this parameter (`target_log_group_id`) is required.
        """
        return pulumi.get(self, "target_log_group_id")


@pulumi.output_type
class LogConvergeLogMappingConfigLogStreamConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceLogStreamId":
            suggest = "source_log_stream_id"
        elif key == "targetLogStreamName":
            suggest = "target_log_stream_name"
        elif key == "targetLogStreamTtl":
            suggest = "target_log_stream_ttl"
        elif key == "targetLogStreamEpsId":
            suggest = "target_log_stream_eps_id"
        elif key == "targetLogStreamId":
            suggest = "target_log_stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogConvergeLogMappingConfigLogStreamConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogConvergeLogMappingConfigLogStreamConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogConvergeLogMappingConfigLogStreamConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_log_stream_id: _builtins.str,
                 target_log_stream_name: _builtins.str,
                 target_log_stream_ttl: _builtins.int,
                 target_log_stream_eps_id: Optional[_builtins.str] = None,
                 target_log_stream_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str source_log_stream_id: Specifies the ID of the log stream for source side.
        :param _builtins.str target_log_stream_name: Specifies the ID of the log stream for source side.
        :param _builtins.int target_log_stream_ttl: Specifies the ID of the log stream for source side.
        :param _builtins.str target_log_stream_eps_id: The enterprise project ID of the log stream for target side.
        :param _builtins.str target_log_stream_id: Specifies the ID of the log stream for source side.
               
               > If you want to use an existing log stream, this parameter (`target_log_stream_id`) is required.
        """
        pulumi.set(__self__, "source_log_stream_id", source_log_stream_id)
        pulumi.set(__self__, "target_log_stream_name", target_log_stream_name)
        pulumi.set(__self__, "target_log_stream_ttl", target_log_stream_ttl)
        if target_log_stream_eps_id is not None:
            pulumi.set(__self__, "target_log_stream_eps_id", target_log_stream_eps_id)
        if target_log_stream_id is not None:
            pulumi.set(__self__, "target_log_stream_id", target_log_stream_id)

    @_builtins.property
    @pulumi.getter(name="sourceLogStreamId")
    def source_log_stream_id(self) -> _builtins.str:
        """
        Specifies the ID of the log stream for source side.
        """
        return pulumi.get(self, "source_log_stream_id")

    @_builtins.property
    @pulumi.getter(name="targetLogStreamName")
    def target_log_stream_name(self) -> _builtins.str:
        """
        Specifies the ID of the log stream for source side.
        """
        return pulumi.get(self, "target_log_stream_name")

    @_builtins.property
    @pulumi.getter(name="targetLogStreamTtl")
    def target_log_stream_ttl(self) -> _builtins.int:
        """
        Specifies the ID of the log stream for source side.
        """
        return pulumi.get(self, "target_log_stream_ttl")

    @_builtins.property
    @pulumi.getter(name="targetLogStreamEpsId")
    def target_log_stream_eps_id(self) -> Optional[_builtins.str]:
        """
        The enterprise project ID of the log stream for target side.
        """
        return pulumi.get(self, "target_log_stream_eps_id")

    @_builtins.property
    @pulumi.getter(name="targetLogStreamId")
    def target_log_stream_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the log stream for source side.

        > If you want to use an existing log stream, this parameter (`target_log_stream_id`) is required.
        """
        return pulumi.get(self, "target_log_stream_id")


@pulumi.output_type
class MetricRuleAggregator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleAggregator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleAggregator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleAggregator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: _builtins.str,
                 type: _builtins.str,
                 group_bies: Optional[Sequence[_builtins.str]] = None,
                 keyword: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Specifies the field of the log statistics.
        :param _builtins.str type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        :param Sequence[_builtins.str] group_bies: Specifies the list of the group fields of the log statistics.
        :param _builtins.str keyword: Specifies the keyword of the log statistics. The keyword is case sensitive.  
               This parameter is required and available only when the `aggregator.type` parameter is set to **countKeyword**.
               
               <a name="metric_rule_filter"></a>
               The `filter` block supports:
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Specifies the field of the log statistics.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of the group fields of the log statistics.
        """
        return pulumi.get(self, "group_bies")

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> Optional[_builtins.str]:
        """
        Specifies the keyword of the log statistics. The keyword is case sensitive.  
        This parameter is required and available only when the `aggregator.type` parameter is set to **countKeyword**.

        <a name="metric_rule_filter"></a>
        The `filter` block supports:
        """
        return pulumi.get(self, "keyword")


@pulumi.output_type
class MetricRuleFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.MetricRuleFilterFilter']] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence['MetricRuleFilterFilterArgs'] filters: Specifies the list of the log filter rule associations.
               The filters structure is documented below.
               
               <a name="metric_rule_associated_filters"></a>
               The `filters` block supports:
        :param _builtins.str type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.MetricRuleFilterFilter']]:
        """
        Specifies the list of the log filter rule associations.
        The filters structure is documented below.

        <a name="metric_rule_associated_filters"></a>
        The `filters` block supports:
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetricRuleFilterFilter(dict):
    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.MetricRuleFilterFilterFilter']] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence['MetricRuleFilterFilterFilterArgs'] filters: Specifies the list of the log filter rule associations.
               The filters structure is documented below.
               
               <a name="metric_rule_associated_filters"></a>
               The `filters` block supports:
        :param _builtins.str type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.MetricRuleFilterFilterFilter']]:
        """
        Specifies the list of the log filter rule associations.
        The filters structure is documented below.

        <a name="metric_rule_associated_filters"></a>
        The `filters` block supports:
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetricRuleFilterFilterFilter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 type: _builtins.str,
                 lower: Optional[_builtins.str] = None,
                 upper: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Specifies the filter field of the log.
        :param _builtins.str type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        :param _builtins.str lower: Specifies the minimum value corresponding to the log filter field.  
               This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
               or **outRange**.
        :param _builtins.str upper: Specifies the maximum value corresponding to the log filter field.  
               This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
               or **outRange**.
        :param _builtins.str value: Specifies the value corresponding to the log filter field.
               This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **contains**,
               **notContains**, **equal**, **notEqual**, **gt**, **gte**, **lt** or **lte**.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        if lower is not None:
            pulumi.set(__self__, "lower", lower)
        if upper is not None:
            pulumi.set(__self__, "upper", upper)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the filter field of the log.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def lower(self) -> Optional[_builtins.str]:
        """
        Specifies the minimum value corresponding to the log filter field.  
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
        or **outRange**.
        """
        return pulumi.get(self, "lower")

    @_builtins.property
    @pulumi.getter
    def upper(self) -> Optional[_builtins.str]:
        """
        Specifies the maximum value corresponding to the log filter field.  
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **range**
        or **outRange**.
        """
        return pulumi.get(self, "upper")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the value corresponding to the log filter field.
        This parameter is required and available only when the `filters.filters.filters.type` parameter is set to **contains**,
        **notContains**, **equal**, **notEqual**, **gt**, **gte**, **lt** or **lte**.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MetricRuleSampler(dict):
    def __init__(__self__, *,
                 ratio: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str ratio: Specifies the sampling rate of the log.
               + If `sampler.type` is set to **random**, the valid value ranges from `0.1` to `1`.
               + If `sampler.type` is set to **none**, the value is set to `1`.
               
               <a name="metric_rule_sinks"></a>
               The `sinks` block supports:
        :param _builtins.str type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        """
        pulumi.set(__self__, "ratio", ratio)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def ratio(self) -> _builtins.str:
        """
        Specifies the sampling rate of the log.
        + If `sampler.type` is set to **random**, the valid value ranges from `0.1` to `1`.
        + If `sampler.type` is set to **none**, the value is set to `1`.

        <a name="metric_rule_sinks"></a>
        The `sinks` block supports:
        """
        return pulumi.get(self, "ratio")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetricRuleSink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRuleSink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRuleSink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRuleSink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 type: _builtins.str,
                 instance_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_name: Specifies the name of the generated log metric. The name must be unique.
               The name only English letters, digits, hyphens (-) and colon(:) are allowed, and must start with an English letter.
        :param _builtins.str type: Specifies the filter conditions of the log.  
               The valid values are as follows:
               + **contains**: Applicable to `string` data type.
               + **notContains**: Applicable to `string` data type.
               + **fieldExist**: Applicable to `string` data type.
               + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
               + **equal**: Applicable to `string`, `float` and `long` data types.
               + **notEqual**: Applicable to `string`, `float` and `long` data types.
               + **gt**: Applicable to `float` and `long` data types.
               + **gte**: Applicable to `float` and `long` data types.
               + **lt**: Applicable to `float` and `long` data types.
               + **lte**: Applicable to `float` and `long` data types.
               + **range**: Applicable to `float` and `long` data types.
               + **outRange**: Applicable to `float` and `long` data types.
        :param _builtins.str instance_id: Specifies the ID of the AOM Prometheus common instance.  
               This parameter is required and available only when the `sinks.type` parameter is set to **aom**.
               
               <a name="metric_rule_aggregator"></a>
               The `aggregator` block supports:
        :param _builtins.str name: Specifies the name of the AOM Prometheus common instance.  
               This parameter is required and available only when the `sinks.type` parameter is set to **aom**.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "type", type)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Specifies the name of the generated log metric. The name must be unique.
        The name only English letters, digits, hyphens (-) and colon(:) are allowed, and must start with an English letter.
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the filter conditions of the log.  
        The valid values are as follows:
        + **contains**: Applicable to `string` data type.
        + **notContains**: Applicable to `string` data type.
        + **fieldExist**: Applicable to `string` data type.
        + **fieldNotExist**: Applicable to `string`, `float` and `long` data types.
        + **equal**: Applicable to `string`, `float` and `long` data types.
        + **notEqual**: Applicable to `string`, `float` and `long` data types.
        + **gt**: Applicable to `float` and `long` data types.
        + **gte**: Applicable to `float` and `long` data types.
        + **lt**: Applicable to `float` and `long` data types.
        + **lte**: Applicable to `float` and `long` data types.
        + **range**: Applicable to `float` and `long` data types.
        + **outRange**: Applicable to `float` and `long` data types.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the AOM Prometheus common instance.  
        This parameter is required and available only when the `sinks.type` parameter is set to **aom**.

        <a name="metric_rule_aggregator"></a>
        The `aggregator` block supports:
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the AOM Prometheus common instance.  
        This parameter is required and available only when the `sinks.type` parameter is set to **aom**.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NotificationTemplateTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subType":
            suggest = "sub_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationTemplateTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationTemplateTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationTemplateTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: _builtins.str,
                 sub_type: _builtins.str):
        """
        :param _builtins.str content: The content of the sub-template..  
               In the sub-template body, only the following variables are supported for the variables following the **$** symbol.
               The supported variables vary according to the alarm type (keyword alarm and SQL alarm).
               
               + Common variables:
               * Alarm severity: **${event_severity}**.
               * Occurrence time: **${starts_at}**.
               * Alarm source: **$event.metadata.resource_provider**.
               * Resource type: **$event.metadata.resource_type**.
               * Resource ID: **${resources}**.
               * Expression: **$event.annotations.condition_expression**.
               * current value: **$event.annotations.current_value**.
               * Statistical period: **$event.annotations.frequency**.
               
               + Keywords alarm specific variable:
               * query time: **$event.annotations.results[0].time**.
               * Run the **$event.annotations.results[0].raw_results** command to query LTSs.
               
               + SQL alarm specific variable:
               * LTS group/stream name: **$event.annotations.results[0].resource_id**.
               * Query statement: **$event.annotations.results[0].sql**.
               * Query time: **$event.annotations.results[0].time**.
               * Query URL: **$event.annotations.results[0].url**.
               * Run the **$event.annotations.results[0].raw_results** command to query LTSs.
               
               > semicolon(;) after variable is an English symbol and must be added. Otherwise, the template will fail to be replaced.
        :param _builtins.str sub_type: The type of the sub-template.  
               Only the following five types are supported: **sms**, **dingding**, **wechat**, **webhook**, **email**.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "sub_type", sub_type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The content of the sub-template..  
        In the sub-template body, only the following variables are supported for the variables following the **$** symbol.
        The supported variables vary according to the alarm type (keyword alarm and SQL alarm).

        + Common variables:
        * Alarm severity: **${event_severity}**.
        * Occurrence time: **${starts_at}**.
        * Alarm source: **$event.metadata.resource_provider**.
        * Resource type: **$event.metadata.resource_type**.
        * Resource ID: **${resources}**.
        * Expression: **$event.annotations.condition_expression**.
        * current value: **$event.annotations.current_value**.
        * Statistical period: **$event.annotations.frequency**.

        + Keywords alarm specific variable:
        * query time: **$event.annotations.results[0].time**.
        * Run the **$event.annotations.results[0].raw_results** command to query LTSs.

        + SQL alarm specific variable:
        * LTS group/stream name: **$event.annotations.results[0].resource_id**.
        * Query statement: **$event.annotations.results[0].sql**.
        * Query time: **$event.annotations.results[0].time**.
        * Query URL: **$event.annotations.results[0].url**.
        * Run the **$event.annotations.results[0].raw_results** command to query LTSs.

        > semicolon(;) after variable is an English symbol and must be added. Otherwise, the template will fail to be replaced.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> _builtins.str:
        """
        The type of the sub-template.  
        Only the following five types are supported: **sms**, **dingding**, **wechat**, **webhook**, **email**.
        """
        return pulumi.get(self, "sub_type")


@pulumi.output_type
class RegisterKafkaInstanceConnectInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedPwd":
            suggest = "encrypted_pwd"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegisterKafkaInstanceConnectInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegisterKafkaInstanceConnectInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegisterKafkaInstanceConnectInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted_pwd: Optional[_builtins.str] = None,
                 pwd: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str encrypted_pwd: The encrypted password of the SASL_SSL user of the Kafka instance.
        :param _builtins.str pwd: Specifies the password of the SASL_SSL user of the Kafka instance.
        :param _builtins.str user_name: Specifies the name of the SASL_SSL user of the Kafka instance.
        """
        if encrypted_pwd is not None:
            pulumi.set(__self__, "encrypted_pwd", encrypted_pwd)
        if pwd is not None:
            pulumi.set(__self__, "pwd", pwd)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="encryptedPwd")
    def encrypted_pwd(self) -> Optional[_builtins.str]:
        """
        The encrypted password of the SASL_SSL user of the Kafka instance.
        """
        return pulumi.get(self, "encrypted_pwd")

    @_builtins.property
    @pulumi.getter
    def pwd(self) -> Optional[_builtins.str]:
        """
        Specifies the password of the SASL_SSL user of the Kafka instance.
        """
        return pulumi.get(self, "pwd")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the SASL_SSL user of the Kafka instance.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class SqlAlarmRuleFrequency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "fixedRate":
            suggest = "fixed_rate"
        elif key == "fixedRateUnit":
            suggest = "fixed_rate_unit"
        elif key == "hourOfDay":
            suggest = "hour_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAlarmRuleFrequency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAlarmRuleFrequency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAlarmRuleFrequency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 cron_expression: Optional[_builtins.str] = None,
                 day_of_week: Optional[_builtins.int] = None,
                 fixed_rate: Optional[_builtins.int] = None,
                 fixed_rate_unit: Optional[_builtins.str] = None,
                 hour_of_day: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Specifies the frequency type.
               The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        :param _builtins.str cron_expression: Specifies the cron expression.
               This parameter is used when `type` is set to **CRON**.
        :param _builtins.int day_of_week: Specifies the day of week.
               This parameter is used when `type` is set to **WEEKLY**.
               The value ranges from `1` to `7`. `1` means Sunday.
        :param _builtins.int fixed_rate: Specifies the unit fixed rate.
               This parameter is used when `type` is set to **FIXED_RATE**.
               + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
               + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`.
               
               <a name="SQLAlarmRule_NotificationRule"></a>
               The `NotificationRule` block supports:
        :param _builtins.str fixed_rate_unit: Specifies the unit of fixed rate.
               The value can be: **minute** and **hour**.
        :param _builtins.int hour_of_day: Specifies the hour of day.
               This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
               The value ranges from `0` to `23`.
        """
        pulumi.set(__self__, "type", type)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if fixed_rate is not None:
            pulumi.set(__self__, "fixed_rate", fixed_rate)
        if fixed_rate_unit is not None:
            pulumi.set(__self__, "fixed_rate_unit", fixed_rate_unit)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the frequency type.
        The value can be: **CRON**, **HOURLY**, **DAILY**, **WEEKLY** and **FIXED_RATE**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[_builtins.str]:
        """
        Specifies the cron expression.
        This parameter is used when `type` is set to **CRON**.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.int]:
        """
        Specifies the day of week.
        This parameter is used when `type` is set to **WEEKLY**.
        The value ranges from `1` to `7`. `1` means Sunday.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> Optional[_builtins.int]:
        """
        Specifies the unit fixed rate.
        This parameter is used when `type` is set to **FIXED_RATE**.
        + When the `fixed_rate_unit` is **minute**, the value ranges from `1` to `60`.
        + When the `fixed_rate_unit` is **hour**, the value ranges from `1` to `24`.

        <a name="SQLAlarmRule_NotificationRule"></a>
        The `NotificationRule` block supports:
        """
        return pulumi.get(self, "fixed_rate")

    @_builtins.property
    @pulumi.getter(name="fixedRateUnit")
    def fixed_rate_unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit of fixed rate.
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "fixed_rate_unit")

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[_builtins.int]:
        """
        Specifies the hour of day.
        This parameter is used when `type` is set to **DAILY** or **WEEKLY**.
        The value ranges from `0` to `23`.
        """
        return pulumi.get(self, "hour_of_day")


@pulumi.output_type
class SqlAlarmRuleNotificationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAlarmRuleNotificationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAlarmRuleNotificationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAlarmRuleNotificationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language: _builtins.str,
                 template_name: _builtins.str,
                 topics: Sequence['outputs.SqlAlarmRuleNotificationRuleTopic'],
                 user_name: _builtins.str,
                 timezone: Optional[_builtins.str] = None):
        """
        :param _builtins.str language: Specifies the notification language.
               The value can be **zh-cn** and **en-us**.
        :param _builtins.str template_name: Specifies the notification template name.
        :param Sequence['SqlAlarmRuleNotificationRuleTopicArgs'] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param _builtins.str user_name: Specifies the user name.
        :param _builtins.str timezone: Specifies the timezone.
               
               <a name="SQLAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        """
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def language(self) -> _builtins.str:
        """
        Specifies the notification language.
        The value can be **zh-cn** and **en-us**.
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence['outputs.SqlAlarmRuleNotificationRuleTopic']:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Specifies the timezone.

        <a name="SQLAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class SqlAlarmRuleNotificationRuleTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicUrn":
            suggest = "topic_urn"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "pushPolicy":
            suggest = "push_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAlarmRuleNotificationRuleTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAlarmRuleNotificationRuleTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAlarmRuleNotificationRuleTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 topic_urn: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 push_policy: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Specifies the topic name.
        :param _builtins.str topic_urn: Specifies the topic URN.
        :param _builtins.str display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param _builtins.int push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[_builtins.int]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")


@pulumi.output_type
class SqlAlarmRuleNotificationSaveRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAlarmRuleNotificationSaveRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAlarmRuleNotificationSaveRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAlarmRuleNotificationSaveRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language: _builtins.str,
                 template_name: _builtins.str,
                 topics: Sequence['outputs.SqlAlarmRuleNotificationSaveRuleTopic'],
                 user_name: _builtins.str,
                 timezone: Optional[_builtins.str] = None):
        """
        :param _builtins.str language: Specifies the notification language.
               The value can be **zh-cn** and **en-us**.
        :param _builtins.str template_name: Specifies the notification template name.
        :param Sequence['SqlAlarmRuleNotificationSaveRuleTopicArgs'] topics: Specifies the SMN topics.
               The Topic structure is documented below.
        :param _builtins.str user_name: Specifies the user name.
        :param _builtins.str timezone: Specifies the timezone.
               
               <a name="SQLAlarmRule_Topic"></a>
               The `NotificationRuleTopic` block supports:
        """
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "user_name", user_name)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def language(self) -> _builtins.str:
        """
        Specifies the notification language.
        The value can be **zh-cn** and **en-us**.
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        Specifies the notification template name.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence['outputs.SqlAlarmRuleNotificationSaveRuleTopic']:
        """
        Specifies the SMN topics.
        The Topic structure is documented below.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Specifies the user name.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Specifies the timezone.

        <a name="SQLAlarmRule_Topic"></a>
        The `NotificationRuleTopic` block supports:
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class SqlAlarmRuleNotificationSaveRuleTopic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicUrn":
            suggest = "topic_urn"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "pushPolicy":
            suggest = "push_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAlarmRuleNotificationSaveRuleTopic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAlarmRuleNotificationSaveRuleTopic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAlarmRuleNotificationSaveRuleTopic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 topic_urn: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 push_policy: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Specifies the topic name.
        :param _builtins.str topic_urn: Specifies the topic URN.
        :param _builtins.str display_name: Specifies the display name.
               This will be shown as the sender of the message.
        :param _builtins.int push_policy: Specifies the push policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if push_policy is not None:
            pulumi.set(__self__, "push_policy", push_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the topic name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        Specifies the display name.
        This will be shown as the sender of the message.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> Optional[_builtins.int]:
        """
        Specifies the push policy.
        """
        return pulumi.get(self, "push_policy")


@pulumi.output_type
class SqlAlarmRuleSqlRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupId":
            suggest = "log_group_id"
        elif key == "logStreamId":
            suggest = "log_stream_id"
        elif key == "searchTimeRange":
            suggest = "search_time_range"
        elif key == "searchTimeRangeUnit":
            suggest = "search_time_range_unit"
        elif key == "isTimeRangeRelative":
            suggest = "is_time_range_relative"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "logStreamName":
            suggest = "log_stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAlarmRuleSqlRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAlarmRuleSqlRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAlarmRuleSqlRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_id: _builtins.str,
                 log_stream_id: _builtins.str,
                 search_time_range: _builtins.int,
                 search_time_range_unit: _builtins.str,
                 sql: _builtins.str,
                 title: _builtins.str,
                 is_time_range_relative: Optional[_builtins.bool] = None,
                 log_group_name: Optional[_builtins.str] = None,
                 log_stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str log_group_id: Specifies the log group id.
        :param _builtins.str log_stream_id: Specifies the log stream id.
        :param _builtins.int search_time_range: Specifies the search time range.
               + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`;
               + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`;
        :param _builtins.str search_time_range_unit: Specifies the unit of search time range.
               The value can be: **minute** and **hour**.
        :param _builtins.str sql: Specifies the SQL.
        :param _builtins.str title: Specifies the SQL request title.
        :param _builtins.bool is_time_range_relative: Specifies the SQL request is relative to time range.  
               Defaults to **false**.
        :param _builtins.str log_group_name: Specifies the name of the log group.
        :param _builtins.str log_stream_name: Specifies the name of the log stream.
               
               <a name="SQLAlarmRule_Frequency"></a>
               The `Frequency` block supports:
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "search_time_range", search_time_range)
        pulumi.set(__self__, "search_time_range_unit", search_time_range_unit)
        pulumi.set(__self__, "sql", sql)
        pulumi.set(__self__, "title", title)
        if is_time_range_relative is not None:
            pulumi.set(__self__, "is_time_range_relative", is_time_range_relative)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        Specifies the log group id.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        Specifies the log stream id.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="searchTimeRange")
    def search_time_range(self) -> _builtins.int:
        """
        Specifies the search time range.
        + When the `search_time_range_unit` is **minute**, the value ranges from `1` to `60`;
        + When the `search_time_range_unit` is **hour**, the value ranges from `1` to `24`;
        """
        return pulumi.get(self, "search_time_range")

    @_builtins.property
    @pulumi.getter(name="searchTimeRangeUnit")
    def search_time_range_unit(self) -> _builtins.str:
        """
        Specifies the unit of search time range.
        The value can be: **minute** and **hour**.
        """
        return pulumi.get(self, "search_time_range_unit")

    @_builtins.property
    @pulumi.getter
    def sql(self) -> _builtins.str:
        """
        Specifies the SQL.
        """
        return pulumi.get(self, "sql")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        Specifies the SQL request title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="isTimeRangeRelative")
    def is_time_range_relative(self) -> Optional[_builtins.bool]:
        """
        Specifies the SQL request is relative to time range.  
        Defaults to **false**.
        """
        return pulumi.get(self, "is_time_range_relative")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the log group.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the log stream.

        <a name="SQLAlarmRule_Frequency"></a>
        The `Frequency` block supports:
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class StreamIndexConfigurationField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"
        elif key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "fieldAnalysisAlias":
            suggest = "field_analysis_alias"
        elif key == "includeChinese":
            suggest = "include_chinese"
        elif key == "ltsSubFieldsInfoLists":
            suggest = "lts_sub_fields_info_lists"
        elif key == "quickAnalysis":
            suggest = "quick_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamIndexConfigurationField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamIndexConfigurationField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamIndexConfigurationField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_type: _builtins.str,
                 asciis: Optional[Sequence[_builtins.str]] = None,
                 case_sensitive: Optional[_builtins.bool] = None,
                 field_analysis_alias: Optional[_builtins.str] = None,
                 include_chinese: Optional[_builtins.bool] = None,
                 lts_sub_fields_info_lists: Optional[Sequence['outputs.StreamIndexConfigurationFieldLtsSubFieldsInfoList']] = None,
                 quick_analysis: Optional[_builtins.bool] = None,
                 tokenizer: Optional[_builtins.str] = None):
        """
        :param _builtins.str field_name: Specifies the name of the field.  
               The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
               The name cannot start with a dot and end with a double underscores (__) or a dot.
        :param _builtins.str field_type: Specifies the type of the field.  
               The valid values are as follows:
               + **string**
               + **long**
               + **float**
        :param Sequence[_builtins.str] asciis: Specifies the list of the ASCII delimiters.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
               For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        :param _builtins.bool case_sensitive: Specifies whether letters are case sensitive.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param _builtins.str field_analysis_alias: Specifies the alias name of the field.  
               Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        :param _builtins.bool include_chinese: Specifies whether to include Chinese.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param Sequence['StreamIndexConfigurationFieldLtsSubFieldsInfoListArgs'] lts_sub_fields_info_lists: Specifies the list of of the JSON fields.  
               The lts_sub_fields_info_list structure is documented below.
               The parameter is available only when the `fields.field_type` parameter set to **json**.
               
               <a name="stream_index_config_fields_lts_sub_fields_info_list"></a>
               The `lts_sub_fields_info_list` block supports:
        :param _builtins.bool quick_analysis: Specifies whether to enable quick analysis.  
               Defaults to **false**.
        :param _builtins.str tokenizer: Specifies the custom delimiter.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        if asciis is not None:
            pulumi.set(__self__, "asciis", asciis)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if field_analysis_alias is not None:
            pulumi.set(__self__, "field_analysis_alias", field_analysis_alias)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if lts_sub_fields_info_lists is not None:
            pulumi.set(__self__, "lts_sub_fields_info_lists", lts_sub_fields_info_lists)
        if quick_analysis is not None:
            pulumi.set(__self__, "quick_analysis", quick_analysis)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the name of the field.  
        The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
        The name cannot start with a dot and end with a double underscores (__) or a dot.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> _builtins.str:
        """
        Specifies the type of the field.  
        The valid values are as follows:
        + **string**
        + **long**
        + **float**
        """
        return pulumi.get(self, "field_type")

    @_builtins.property
    @pulumi.getter
    def asciis(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of the ASCII delimiters.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        """
        return pulumi.get(self, "asciis")

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Specifies whether letters are case sensitive.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter(name="fieldAnalysisAlias")
    def field_analysis_alias(self) -> Optional[_builtins.str]:
        """
        Specifies the alias name of the field.  
        Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        """
        return pulumi.get(self, "field_analysis_alias")

    @_builtins.property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to include Chinese.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "include_chinese")

    @_builtins.property
    @pulumi.getter(name="ltsSubFieldsInfoLists")
    def lts_sub_fields_info_lists(self) -> Optional[Sequence['outputs.StreamIndexConfigurationFieldLtsSubFieldsInfoList']]:
        """
        Specifies the list of of the JSON fields.  
        The lts_sub_fields_info_list structure is documented below.
        The parameter is available only when the `fields.field_type` parameter set to **json**.

        <a name="stream_index_config_fields_lts_sub_fields_info_list"></a>
        The `lts_sub_fields_info_list` block supports:
        """
        return pulumi.get(self, "lts_sub_fields_info_lists")

    @_builtins.property
    @pulumi.getter(name="quickAnalysis")
    def quick_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable quick analysis.  
        Defaults to **false**.
        """
        return pulumi.get(self, "quick_analysis")

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[_builtins.str]:
        """
        Specifies the custom delimiter.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "tokenizer")


@pulumi.output_type
class StreamIndexConfigurationFieldLtsSubFieldsInfoList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"
        elif key == "fieldAnalysisAlias":
            suggest = "field_analysis_alias"
        elif key == "quickAnalysis":
            suggest = "quick_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamIndexConfigurationFieldLtsSubFieldsInfoList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamIndexConfigurationFieldLtsSubFieldsInfoList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamIndexConfigurationFieldLtsSubFieldsInfoList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_type: _builtins.str,
                 field_analysis_alias: Optional[_builtins.str] = None,
                 quick_analysis: Optional[_builtins.bool] = None):
        """
        :param _builtins.str field_name: Specifies the name of the field.  
               The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
               The name cannot start with a dot and end with a double underscores (__) or a dot.
        :param _builtins.str field_type: Specifies the type of the field.  
               The valid values are as follows:
               + **string**
               + **long**
               + **float**
        :param _builtins.str field_analysis_alias: Specifies the alias name of the field.  
               Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        :param _builtins.bool quick_analysis: Specifies whether to enable quick analysis.  
               Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        if field_analysis_alias is not None:
            pulumi.set(__self__, "field_analysis_alias", field_analysis_alias)
        if quick_analysis is not None:
            pulumi.set(__self__, "quick_analysis", quick_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the name of the field.  
        The field name only letters, digits, hyphens (-), underscores (_) and dots (.) are allowed.
        The name cannot start with a dot and end with a double underscores (__) or a dot.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> _builtins.str:
        """
        Specifies the type of the field.  
        The valid values are as follows:
        + **string**
        + **long**
        + **float**
        """
        return pulumi.get(self, "field_type")

    @_builtins.property
    @pulumi.getter(name="fieldAnalysisAlias")
    def field_analysis_alias(self) -> Optional[_builtins.str]:
        """
        Specifies the alias name of the field.  
        Currently, only available in `cn-north-9`, `ap-southeast-1`, `ap-southeast-3` and `cn-east-3` regions.
        """
        return pulumi.get(self, "field_analysis_alias")

    @_builtins.property
    @pulumi.getter(name="quickAnalysis")
    def quick_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable quick analysis.  
        Defaults to **false**.
        """
        return pulumi.get(self, "quick_analysis")


@pulumi.output_type
class StreamIndexConfigurationFullTextIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "includeChinese":
            suggest = "include_chinese"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamIndexConfigurationFullTextIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamIndexConfigurationFullTextIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamIndexConfigurationFullTextIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asciis: Optional[Sequence[_builtins.str]] = None,
                 case_sensitive: Optional[_builtins.bool] = None,
                 enable: Optional[_builtins.bool] = None,
                 include_chinese: Optional[_builtins.bool] = None,
                 tokenizer: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] asciis: Specifies the list of the ASCII delimiters.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
               For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        :param _builtins.bool case_sensitive: Specifies whether letters are case sensitive.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param _builtins.bool enable: Specifies whether to enable the full-text index.  
               Defaults to **true**.
        :param _builtins.bool include_chinese: Specifies whether to include Chinese.  
               Defaults to **false**.
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        :param _builtins.str tokenizer: Specifies the custom delimiter.  
               The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        if asciis is not None:
            pulumi.set(__self__, "asciis", asciis)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if tokenizer is not None:
            pulumi.set(__self__, "tokenizer", tokenizer)

    @_builtins.property
    @pulumi.getter
    def asciis(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of the ASCII delimiters.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        For more ASCII delimiters, please refer to the [document](https://support.huaweicloud.com/intl/en-us/usermanual-lts/lts_05_0008.html#lts_05_0008__section15661144724914).
        """
        return pulumi.get(self, "asciis")

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        Specifies whether letters are case sensitive.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable the full-text index.  
        Defaults to **true**.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to include Chinese.  
        Defaults to **false**.
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "include_chinese")

    @_builtins.property
    @pulumi.getter
    def tokenizer(self) -> Optional[_builtins.str]:
        """
        Specifies the custom delimiter.  
        The parameter is available only when the `fields.field_type` parameter set to **string** or **json**.
        """
        return pulumi.get(self, "tokenizer")


@pulumi.output_type
class StructTemplateDemoField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"
        elif key == "userDefinedName":
            suggest = "user_defined_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructTemplateDemoField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructTemplateDemoField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructTemplateDemoField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None,
                 field_name: Optional[_builtins.str] = None,
                 index: Optional[_builtins.int] = None,
                 is_analysis: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None,
                 user_defined_name: Optional[_builtins.str] = None):
        if content is not None:
            pulumi.set(__self__, "content", content)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_defined_name is not None:
            pulumi.set(__self__, "user_defined_name", user_defined_name)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter
    def index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_analysis")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userDefinedName")
    def user_defined_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_defined_name")


@pulumi.output_type
class StructTemplateTagField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructTemplateTagField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructTemplateTagField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructTemplateTagField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None,
                 field_name: Optional[_builtins.str] = None,
                 is_analysis: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        if content is not None:
            pulumi.set(__self__, "content", content)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_analysis")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class StructingTemplateDemoField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructingTemplateDemoField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructingTemplateDemoField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructingTemplateDemoField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 is_analysis: Optional[_builtins.bool] = None):
        """
        :param _builtins.str field_name: Specifies the field name. The valid length is limited from `1` to `64`.
        :param _builtins.bool is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the field name. The valid length is limited from `1` to `64`.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")


@pulumi.output_type
class StructingTemplateTagField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructingTemplateTagField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructingTemplateTagField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructingTemplateTagField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 is_analysis: Optional[_builtins.bool] = None):
        """
        :param _builtins.str field_name: Specifies the field name. The valid length is limited from `1` to `64`.
        :param _builtins.bool is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the field name. The valid length is limited from `1` to `64`.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")


@pulumi.output_type
class StructuringConfigurationDemoField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructuringConfigurationDemoField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructuringConfigurationDemoField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructuringConfigurationDemoField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 is_analysis: Optional[_builtins.bool] = None):
        """
        :param _builtins.str field_name: Specifies the field name.
        :param _builtins.bool is_analysis: Specifies whether quick analysis is enabled.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the field name.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether quick analysis is enabled.
        """
        return pulumi.get(self, "is_analysis")


@pulumi.output_type
class StructuringConfigurationTagField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructuringConfigurationTagField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructuringConfigurationTagField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructuringConfigurationTagField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 is_analysis: Optional[_builtins.bool] = None):
        """
        :param _builtins.str field_name: Specifies the field name.
        :param _builtins.bool is_analysis: Specifies whether quick analysis is enabled.
        """
        pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the field name.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether quick analysis is enabled.
        """
        return pulumi.get(self, "is_analysis")


@pulumi.output_type
class StructuringCustomConfigurationDemoField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructuringCustomConfigurationDemoField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructuringCustomConfigurationDemoField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructuringCustomConfigurationDemoField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None,
                 field_name: Optional[_builtins.str] = None,
                 is_analysis: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: Specifies the field content.
        :param _builtins.str field_name: Specifies the field name. The value ranges from `1` to `50`.
        :param _builtins.bool is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        :param _builtins.str type: Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Specifies the field content.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[_builtins.str]:
        """
        Specifies the field name. The value ranges from `1` to `50`.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StructuringCustomConfigurationTagField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "isAnalysis":
            suggest = "is_analysis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StructuringCustomConfigurationTagField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StructuringCustomConfigurationTagField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StructuringCustomConfigurationTagField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 type: _builtins.str,
                 content: Optional[_builtins.str] = None,
                 is_analysis: Optional[_builtins.bool] = None):
        """
        :param _builtins.str field_name: Specifies the field name. The value ranges from `1` to `50`.
        :param _builtins.str type: Specifies the field data type. Valid values are **string**, **long** and **float**.
        :param _builtins.str content: Specifies the field content.
        :param _builtins.bool is_analysis: Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "type", type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if is_analysis is not None:
            pulumi.set(__self__, "is_analysis", is_analysis)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Specifies the field name. The value ranges from `1` to `50`.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the field data type. Valid values are **string**, **long** and **float**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Specifies the field content.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="isAnalysis")
    def is_analysis(self) -> Optional[_builtins.bool]:
        """
        Specifies whether quick analysis is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "is_analysis")


@pulumi.output_type
class TransferLogStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logStreamId":
            suggest = "log_stream_id"
        elif key == "logStreamName":
            suggest = "log_stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransferLogStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransferLogStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransferLogStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_stream_id: _builtins.str,
                 log_stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str log_stream_id: Log stream ID.
               
               Changing this parameter will create a new resource.
        :param _builtins.str log_stream_name: Log stream name.
               
               Changing this parameter will create a new resource.
               
               <a name="LtsTransfer_LogTransferInfo"></a>
               The `log_transfer_info` block supports:
        """
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        if log_stream_name is not None:
            pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        Log stream ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> Optional[_builtins.str]:
        """
        Log stream name.

        Changing this parameter will create a new resource.

        <a name="LtsTransfer_LogTransferInfo"></a>
        The `log_transfer_info` block supports:
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class TransferLogTransferInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logStorageFormat":
            suggest = "log_storage_format"
        elif key == "logTransferDetail":
            suggest = "log_transfer_detail"
        elif key == "logTransferMode":
            suggest = "log_transfer_mode"
        elif key == "logTransferStatus":
            suggest = "log_transfer_status"
        elif key == "logTransferType":
            suggest = "log_transfer_type"
        elif key == "logAgencyTransfer":
            suggest = "log_agency_transfer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransferLogTransferInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransferLogTransferInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransferLogTransferInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_storage_format: _builtins.str,
                 log_transfer_detail: 'outputs.TransferLogTransferInfoLogTransferDetail',
                 log_transfer_mode: _builtins.str,
                 log_transfer_status: _builtins.str,
                 log_transfer_type: _builtins.str,
                 log_agency_transfer: Optional['outputs.TransferLogTransferInfoLogAgencyTransfer'] = None):
        """
        :param _builtins.str log_storage_format: Log transfer format.  
               Value options are as follows:
               + **JSON**: JSON format, which is available to OBS and DIS transfer tasks.
               + **RAW**: Raw log format, which is available to OBS, DIS and DMS transfer tasks.
        :param 'TransferLogTransferInfoLogTransferDetailArgs' log_transfer_detail: Log transfer details.  
               The log_transfer_detail structure is documented below.
               
               <a name="LtsTransfer_LogAgency"></a>
               The `log_agency_transfer` block supports:
        :param _builtins.str log_transfer_mode: Log transfer mode.  
               Value options are as follows:
               + **cycle**: Periodical transfer, which is available to OBS transfer tasks.
               + **realTime**: Real-time transfer, which is available to DIS and DMS transfer tasks.
               
               Changing this parameter will create a new resource.
        :param _builtins.str log_transfer_status: Log transfer status.  
               Value options are as follows:
               + **ENABLE**: Log transfer is enabled.
               + **DISABLE**: Log transfer is disabled
        :param _builtins.str log_transfer_type: Log transfer type.  
               The valid values are **OBS**, **DIS**, and **DMS**.
               
               Changing this parameter will create a new resource.
        :param 'TransferLogTransferInfoLogAgencyTransferArgs' log_agency_transfer: Information about agency which lets an account delegate resource management
               to other accounts.
               This parameter is mandatory if you transfer logs for another account.
               The log_agency_transfer structure is documented below.
               
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "log_storage_format", log_storage_format)
        pulumi.set(__self__, "log_transfer_detail", log_transfer_detail)
        pulumi.set(__self__, "log_transfer_mode", log_transfer_mode)
        pulumi.set(__self__, "log_transfer_status", log_transfer_status)
        pulumi.set(__self__, "log_transfer_type", log_transfer_type)
        if log_agency_transfer is not None:
            pulumi.set(__self__, "log_agency_transfer", log_agency_transfer)

    @_builtins.property
    @pulumi.getter(name="logStorageFormat")
    def log_storage_format(self) -> _builtins.str:
        """
        Log transfer format.  
        Value options are as follows:
        + **JSON**: JSON format, which is available to OBS and DIS transfer tasks.
        + **RAW**: Raw log format, which is available to OBS, DIS and DMS transfer tasks.
        """
        return pulumi.get(self, "log_storage_format")

    @_builtins.property
    @pulumi.getter(name="logTransferDetail")
    def log_transfer_detail(self) -> 'outputs.TransferLogTransferInfoLogTransferDetail':
        """
        Log transfer details.  
        The log_transfer_detail structure is documented below.

        <a name="LtsTransfer_LogAgency"></a>
        The `log_agency_transfer` block supports:
        """
        return pulumi.get(self, "log_transfer_detail")

    @_builtins.property
    @pulumi.getter(name="logTransferMode")
    def log_transfer_mode(self) -> _builtins.str:
        """
        Log transfer mode.  
        Value options are as follows:
        + **cycle**: Periodical transfer, which is available to OBS transfer tasks.
        + **realTime**: Real-time transfer, which is available to DIS and DMS transfer tasks.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_transfer_mode")

    @_builtins.property
    @pulumi.getter(name="logTransferStatus")
    def log_transfer_status(self) -> _builtins.str:
        """
        Log transfer status.  
        Value options are as follows:
        + **ENABLE**: Log transfer is enabled.
        + **DISABLE**: Log transfer is disabled
        """
        return pulumi.get(self, "log_transfer_status")

    @_builtins.property
    @pulumi.getter(name="logTransferType")
    def log_transfer_type(self) -> _builtins.str:
        """
        Log transfer type.  
        The valid values are **OBS**, **DIS**, and **DMS**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_transfer_type")

    @_builtins.property
    @pulumi.getter(name="logAgencyTransfer")
    def log_agency_transfer(self) -> Optional['outputs.TransferLogTransferInfoLogAgencyTransfer']:
        """
        Information about agency which lets an account delegate resource management
        to other accounts.
        This parameter is mandatory if you transfer logs for another account.
        The log_agency_transfer structure is documented below.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "log_agency_transfer")


@pulumi.output_type
class TransferLogTransferInfoLogAgencyTransfer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agencyDomainId":
            suggest = "agency_domain_id"
        elif key == "agencyDomainName":
            suggest = "agency_domain_name"
        elif key == "agencyName":
            suggest = "agency_name"
        elif key == "agencyProjectId":
            suggest = "agency_project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransferLogTransferInfoLogAgencyTransfer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransferLogTransferInfoLogAgencyTransfer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransferLogTransferInfoLogAgencyTransfer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agency_domain_id: _builtins.str,
                 agency_domain_name: _builtins.str,
                 agency_name: _builtins.str,
                 agency_project_id: _builtins.str):
        """
        :param _builtins.str agency_domain_id: Delegator account ID.
               
               Changing this parameter will create a new resource.
        :param _builtins.str agency_domain_name: Delegator account name.
               
               Changing this parameter will create a new resource.
        :param _builtins.str agency_name: The agency name created by the delegator.
               
               Changing this parameter will create a new resource.
        :param _builtins.str agency_project_id: Project ID of the delegator.
               
               Changing this parameter will create a new resource.
               
               <a name="LtsTransfer_LogTransferDetail"></a>
               The `log_transfer_detail` block supports:
        """
        pulumi.set(__self__, "agency_domain_id", agency_domain_id)
        pulumi.set(__self__, "agency_domain_name", agency_domain_name)
        pulumi.set(__self__, "agency_name", agency_name)
        pulumi.set(__self__, "agency_project_id", agency_project_id)

    @_builtins.property
    @pulumi.getter(name="agencyDomainId")
    def agency_domain_id(self) -> _builtins.str:
        """
        Delegator account ID.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "agency_domain_id")

    @_builtins.property
    @pulumi.getter(name="agencyDomainName")
    def agency_domain_name(self) -> _builtins.str:
        """
        Delegator account name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "agency_domain_name")

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> _builtins.str:
        """
        The agency name created by the delegator.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "agency_name")

    @_builtins.property
    @pulumi.getter(name="agencyProjectId")
    def agency_project_id(self) -> _builtins.str:
        """
        Project ID of the delegator.

        Changing this parameter will create a new resource.

        <a name="LtsTransfer_LogTransferDetail"></a>
        The `log_transfer_detail` block supports:
        """
        return pulumi.get(self, "agency_project_id")


@pulumi.output_type
class TransferLogTransferInfoLogTransferDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProjectId":
            suggest = "cloud_project_id"
        elif key == "deliveryTags":
            suggest = "delivery_tags"
        elif key == "disId":
            suggest = "dis_id"
        elif key == "disName":
            suggest = "dis_name"
        elif key == "invalidFieldValue":
            suggest = "invalid_field_value"
        elif key == "kafkaId":
            suggest = "kafka_id"
        elif key == "kafkaTopic":
            suggest = "kafka_topic"
        elif key == "ltsTags":
            suggest = "lts_tags"
        elif key == "obsBucketName":
            suggest = "obs_bucket_name"
        elif key == "obsDirPrefixName":
            suggest = "obs_dir_prefix_name"
        elif key == "obsEncryptedEnable":
            suggest = "obs_encrypted_enable"
        elif key == "obsEncryptedId":
            suggest = "obs_encrypted_id"
        elif key == "obsEpsId":
            suggest = "obs_eps_id"
        elif key == "obsPeriod":
            suggest = "obs_period"
        elif key == "obsPeriodUnit":
            suggest = "obs_period_unit"
        elif key == "obsPrefixName":
            suggest = "obs_prefix_name"
        elif key == "obsTimeZone":
            suggest = "obs_time_zone"
        elif key == "obsTimeZoneId":
            suggest = "obs_time_zone_id"
        elif key == "obsTransferPath":
            suggest = "obs_transfer_path"
        elif key == "streamTags":
            suggest = "stream_tags"
        elif key == "structFields":
            suggest = "struct_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransferLogTransferInfoLogTransferDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransferLogTransferInfoLogTransferDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransferLogTransferInfoLogTransferDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_project_id: Optional[_builtins.str] = None,
                 delivery_tags: Optional[Sequence[_builtins.str]] = None,
                 dis_id: Optional[_builtins.str] = None,
                 dis_name: Optional[_builtins.str] = None,
                 invalid_field_value: Optional[_builtins.str] = None,
                 kafka_id: Optional[_builtins.str] = None,
                 kafka_topic: Optional[_builtins.str] = None,
                 lts_tags: Optional[Sequence[_builtins.str]] = None,
                 obs_bucket_name: Optional[_builtins.str] = None,
                 obs_dir_prefix_name: Optional[_builtins.str] = None,
                 obs_encrypted_enable: Optional[_builtins.bool] = None,
                 obs_encrypted_id: Optional[_builtins.str] = None,
                 obs_eps_id: Optional[_builtins.str] = None,
                 obs_period: Optional[_builtins.int] = None,
                 obs_period_unit: Optional[_builtins.str] = None,
                 obs_prefix_name: Optional[_builtins.str] = None,
                 obs_time_zone: Optional[_builtins.str] = None,
                 obs_time_zone_id: Optional[_builtins.str] = None,
                 obs_transfer_path: Optional[_builtins.str] = None,
                 stream_tags: Optional[Sequence[_builtins.str]] = None,
                 struct_fields: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str cloud_project_id: The cloud project ID.
        :param Sequence[_builtins.str] delivery_tags: The list of tag fields will be delivered when transferring.  
               This field must contain the following host information: **hostIP**, **hostId**, **hostName**, **pathFile**, and **collectTime**.
               The common fields include **logStreamName**, **regionName**, **logGroupName**, and **projectId**, which are optional.
               The transfer tag: **streamTag**, which is optional.
               This parameter is valid only for OBS or DIS transfer in JSON format.
        :param _builtins.str dis_id: DIS stream ID.  
               This parameter is mandatory when you create a DIS transfer task.
        :param _builtins.str dis_name: DIS stream name.  
               This parameter is mandatory when you create a DIS transfer task.
        :param _builtins.str invalid_field_value: Specifies the value of the invalid field fill.
        :param _builtins.str kafka_id: Kafka ID.  
               This parameter is mandatory when you create a DMS transfer task.
        :param _builtins.str kafka_topic: Kafka topic.  
               This parameter is mandatory when you create a DMS transfer task.
               
               > Before creating a DMS transfer task, register your Kafka instance with Kafka ID and Kafka topic first.
        :param Sequence[_builtins.str] lts_tags: Specifies the list of built-in fields and custom tags to be transferred.  
               If you want to transfer all built-in and specified fields in the log, you need to set it to **all**.
        :param _builtins.str obs_bucket_name: OBS bucket name.  
               This parameter is mandatory when you create an OBS transfer task.
        :param _builtins.str obs_dir_prefix_name: Custom transfer path of an OBS transfer task.
        :param _builtins.bool obs_encrypted_enable: Whether OBS bucket encryption is enabled.
        :param _builtins.str obs_encrypted_id: KMS key ID for an OBS transfer task.  
               This parameter is mandatory if encryption is enabled for the target OBS bucket.
        :param _builtins.str obs_eps_id: Enterprise project ID of an OBS transfer task.
        :param _builtins.int obs_period: Length of the transfer interval for an OBS transfer task.  
               This parameter is mandatory when you create an OBS transfer task.
               The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
               and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
               Value options are as follows:
               + **2**: 2 minutes, the **obs_period_unit** must be **min**.
               + **5**: 5 minutes, the **obs_period_unit** must be **min**.
               + **30**: 30 minutes, the **obs_period_unit** must be **min**.
               + **1**: 1 hour, the **obs_period_unit** must be **hour**.
               + **3**: 3 hours, the **obs_period_unit** must be **hour**.
               + **6**: 6 hours, the **obs_period_unit** must be **hour**.
               + **12**: 12 hours, the **obs_period_unit** must be **hour**.
        :param _builtins.str obs_period_unit: Unit of the transfer interval for an OBS transfer task.  
               This parameter is mandatory when you create an OBS transfer task.
               The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
               and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
               Value options are as follows:
               + **min**: minute.
               + **hour**: hour.
        :param _builtins.str obs_prefix_name: Transfer file prefix of an OBS transfer task.
        :param _builtins.str obs_time_zone: Time zone for an OBS transfer task.  
               For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
               If this parameter is specified, **obs_time_zone_id** must also be specified.
        :param _builtins.str obs_time_zone_id: ID of the time zone for an OBS transfer task.  
               For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
               If this parameter is specified, **obs_time_zone** must also be specified.
        :param _builtins.str obs_transfer_path: OBS bucket path, which is the log transfer destination.
        :param Sequence[_builtins.str] stream_tags: Specifies the list of stream tag fields to be transferred.  
               If you want to transfer all stream tag fields in the log, you need to set it to **all**.
        :param Sequence[_builtins.str] struct_fields: Specifies the list of structured fields to be transferred.  
               If you want to transfer all fields in a log in the log, you need to set it to **all**.
               
               > 1. The `lts_tags`, `stream_tags` and `struct_fields` parameters are valid only for DMS transfer in JSON format.
               At least one of them must be set.
        """
        if cloud_project_id is not None:
            pulumi.set(__self__, "cloud_project_id", cloud_project_id)
        if delivery_tags is not None:
            pulumi.set(__self__, "delivery_tags", delivery_tags)
        if dis_id is not None:
            pulumi.set(__self__, "dis_id", dis_id)
        if dis_name is not None:
            pulumi.set(__self__, "dis_name", dis_name)
        if invalid_field_value is not None:
            pulumi.set(__self__, "invalid_field_value", invalid_field_value)
        if kafka_id is not None:
            pulumi.set(__self__, "kafka_id", kafka_id)
        if kafka_topic is not None:
            pulumi.set(__self__, "kafka_topic", kafka_topic)
        if lts_tags is not None:
            pulumi.set(__self__, "lts_tags", lts_tags)
        if obs_bucket_name is not None:
            pulumi.set(__self__, "obs_bucket_name", obs_bucket_name)
        if obs_dir_prefix_name is not None:
            pulumi.set(__self__, "obs_dir_prefix_name", obs_dir_prefix_name)
        if obs_encrypted_enable is not None:
            pulumi.set(__self__, "obs_encrypted_enable", obs_encrypted_enable)
        if obs_encrypted_id is not None:
            pulumi.set(__self__, "obs_encrypted_id", obs_encrypted_id)
        if obs_eps_id is not None:
            pulumi.set(__self__, "obs_eps_id", obs_eps_id)
        if obs_period is not None:
            pulumi.set(__self__, "obs_period", obs_period)
        if obs_period_unit is not None:
            pulumi.set(__self__, "obs_period_unit", obs_period_unit)
        if obs_prefix_name is not None:
            pulumi.set(__self__, "obs_prefix_name", obs_prefix_name)
        if obs_time_zone is not None:
            pulumi.set(__self__, "obs_time_zone", obs_time_zone)
        if obs_time_zone_id is not None:
            pulumi.set(__self__, "obs_time_zone_id", obs_time_zone_id)
        if obs_transfer_path is not None:
            pulumi.set(__self__, "obs_transfer_path", obs_transfer_path)
        if stream_tags is not None:
            pulumi.set(__self__, "stream_tags", stream_tags)
        if struct_fields is not None:
            pulumi.set(__self__, "struct_fields", struct_fields)

    @_builtins.property
    @pulumi.getter(name="cloudProjectId")
    def cloud_project_id(self) -> Optional[_builtins.str]:
        """
        The cloud project ID.
        """
        return pulumi.get(self, "cloud_project_id")

    @_builtins.property
    @pulumi.getter(name="deliveryTags")
    def delivery_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of tag fields will be delivered when transferring.  
        This field must contain the following host information: **hostIP**, **hostId**, **hostName**, **pathFile**, and **collectTime**.
        The common fields include **logStreamName**, **regionName**, **logGroupName**, and **projectId**, which are optional.
        The transfer tag: **streamTag**, which is optional.
        This parameter is valid only for OBS or DIS transfer in JSON format.
        """
        return pulumi.get(self, "delivery_tags")

    @_builtins.property
    @pulumi.getter(name="disId")
    def dis_id(self) -> Optional[_builtins.str]:
        """
        DIS stream ID.  
        This parameter is mandatory when you create a DIS transfer task.
        """
        return pulumi.get(self, "dis_id")

    @_builtins.property
    @pulumi.getter(name="disName")
    def dis_name(self) -> Optional[_builtins.str]:
        """
        DIS stream name.  
        This parameter is mandatory when you create a DIS transfer task.
        """
        return pulumi.get(self, "dis_name")

    @_builtins.property
    @pulumi.getter(name="invalidFieldValue")
    def invalid_field_value(self) -> Optional[_builtins.str]:
        """
        Specifies the value of the invalid field fill.
        """
        return pulumi.get(self, "invalid_field_value")

    @_builtins.property
    @pulumi.getter(name="kafkaId")
    def kafka_id(self) -> Optional[_builtins.str]:
        """
        Kafka ID.  
        This parameter is mandatory when you create a DMS transfer task.
        """
        return pulumi.get(self, "kafka_id")

    @_builtins.property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> Optional[_builtins.str]:
        """
        Kafka topic.  
        This parameter is mandatory when you create a DMS transfer task.

        > Before creating a DMS transfer task, register your Kafka instance with Kafka ID and Kafka topic first.
        """
        return pulumi.get(self, "kafka_topic")

    @_builtins.property
    @pulumi.getter(name="ltsTags")
    def lts_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of built-in fields and custom tags to be transferred.  
        If you want to transfer all built-in and specified fields in the log, you need to set it to **all**.
        """
        return pulumi.get(self, "lts_tags")

    @_builtins.property
    @pulumi.getter(name="obsBucketName")
    def obs_bucket_name(self) -> Optional[_builtins.str]:
        """
        OBS bucket name.  
        This parameter is mandatory when you create an OBS transfer task.
        """
        return pulumi.get(self, "obs_bucket_name")

    @_builtins.property
    @pulumi.getter(name="obsDirPrefixName")
    def obs_dir_prefix_name(self) -> Optional[_builtins.str]:
        """
        Custom transfer path of an OBS transfer task.
        """
        return pulumi.get(self, "obs_dir_prefix_name")

    @_builtins.property
    @pulumi.getter(name="obsEncryptedEnable")
    def obs_encrypted_enable(self) -> Optional[_builtins.bool]:
        """
        Whether OBS bucket encryption is enabled.
        """
        return pulumi.get(self, "obs_encrypted_enable")

    @_builtins.property
    @pulumi.getter(name="obsEncryptedId")
    def obs_encrypted_id(self) -> Optional[_builtins.str]:
        """
        KMS key ID for an OBS transfer task.  
        This parameter is mandatory if encryption is enabled for the target OBS bucket.
        """
        return pulumi.get(self, "obs_encrypted_id")

    @_builtins.property
    @pulumi.getter(name="obsEpsId")
    def obs_eps_id(self) -> Optional[_builtins.str]:
        """
        Enterprise project ID of an OBS transfer task.
        """
        return pulumi.get(self, "obs_eps_id")

    @_builtins.property
    @pulumi.getter(name="obsPeriod")
    def obs_period(self) -> Optional[_builtins.int]:
        """
        Length of the transfer interval for an OBS transfer task.  
        This parameter is mandatory when you create an OBS transfer task.
        The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
        and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
        Value options are as follows:
        + **2**: 2 minutes, the **obs_period_unit** must be **min**.
        + **5**: 5 minutes, the **obs_period_unit** must be **min**.
        + **30**: 30 minutes, the **obs_period_unit** must be **min**.
        + **1**: 1 hour, the **obs_period_unit** must be **hour**.
        + **3**: 3 hours, the **obs_period_unit** must be **hour**.
        + **6**: 6 hours, the **obs_period_unit** must be **hour**.
        + **12**: 12 hours, the **obs_period_unit** must be **hour**.
        """
        return pulumi.get(self, "obs_period")

    @_builtins.property
    @pulumi.getter(name="obsPeriodUnit")
    def obs_period_unit(self) -> Optional[_builtins.str]:
        """
        Unit of the transfer interval for an OBS transfer task.  
        This parameter is mandatory when you create an OBS transfer task.
        The log transfer interval is specified by the combination of the values of **obs_period** and **obs_period_unit**,
        and must be set to one of the following: 2 min, 5 min, 30 min, 1 hour, 3 hours, 6 hours, and 12 hours.
        Value options are as follows:
        + **min**: minute.
        + **hour**: hour.
        """
        return pulumi.get(self, "obs_period_unit")

    @_builtins.property
    @pulumi.getter(name="obsPrefixName")
    def obs_prefix_name(self) -> Optional[_builtins.str]:
        """
        Transfer file prefix of an OBS transfer task.
        """
        return pulumi.get(self, "obs_prefix_name")

    @_builtins.property
    @pulumi.getter(name="obsTimeZone")
    def obs_time_zone(self) -> Optional[_builtins.str]:
        """
        Time zone for an OBS transfer task.  
        For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
        If this parameter is specified, **obs_time_zone_id** must also be specified.
        """
        return pulumi.get(self, "obs_time_zone")

    @_builtins.property
    @pulumi.getter(name="obsTimeZoneId")
    def obs_time_zone_id(self) -> Optional[_builtins.str]:
        """
        ID of the time zone for an OBS transfer task.  
        For details, see [Time Zone List for OBS Transfer](https://support.huaweicloud.com/intl/en-us/api-lts/lts_api_0111.html).
        If this parameter is specified, **obs_time_zone** must also be specified.
        """
        return pulumi.get(self, "obs_time_zone_id")

    @_builtins.property
    @pulumi.getter(name="obsTransferPath")
    def obs_transfer_path(self) -> Optional[_builtins.str]:
        """
        OBS bucket path, which is the log transfer destination.
        """
        return pulumi.get(self, "obs_transfer_path")

    @_builtins.property
    @pulumi.getter(name="streamTags")
    def stream_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of stream tag fields to be transferred.  
        If you want to transfer all stream tag fields in the log, you need to set it to **all**.
        """
        return pulumi.get(self, "stream_tags")

    @_builtins.property
    @pulumi.getter(name="structFields")
    def struct_fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of structured fields to be transferred.  
        If you want to transfer all fields in a log in the log, you need to set it to **all**.

        > 1. The `lts_tags`, `stream_tags` and `struct_fields` parameters are valid only for DMS transfer in JSON format.
        At least one of them must be set.
        """
        return pulumi.get(self, "struct_fields")


@pulumi.output_type
class GetAlarmsAlarmResult(dict):
    def __init__(__self__, *,
                 annotations: Sequence['outputs.GetAlarmsAlarmAnnotationResult'],
                 arrives_at: _builtins.int,
                 ends_at: _builtins.int,
                 id: _builtins.str,
                 metadatas: Sequence['outputs.GetAlarmsAlarmMetadataResult'],
                 starts_at: _builtins.int,
                 timeout: _builtins.int,
                 type: _builtins.str):
        """
        :param Sequence['GetAlarmsAlarmAnnotationArgs'] annotations: The details of the alarm.  
               The annotations structure is documented below.
        :param _builtins.int arrives_at: The time when the alarm arrives, in milliseconds.
        :param _builtins.int ends_at: The time when the alarm is cleared, in milliseconds.
        :param _builtins.str id: The ID of the alarm.
        :param Sequence['GetAlarmsAlarmMetadataArgs'] metadatas: The metadata of the alarm.  
               The metadata structure is documented below.
        :param _builtins.int starts_at: The time when the alarm is generated, in milliseconds.
        :param _builtins.int timeout: The time when the alarm is automatically cleared, in milliseconds.
        :param _builtins.str type: Specifies the type of the alarm to be queried.  
               The valid values are as follows:
               + **active_alert**: Query active alarms.
               + **history_alert**: Query historical alarms.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "arrives_at", arrives_at)
        pulumi.set(__self__, "ends_at", ends_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "starts_at", starts_at)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Sequence['outputs.GetAlarmsAlarmAnnotationResult']:
        """
        The details of the alarm.  
        The annotations structure is documented below.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="arrivesAt")
    def arrives_at(self) -> _builtins.int:
        """
        The time when the alarm arrives, in milliseconds.
        """
        return pulumi.get(self, "arrives_at")

    @_builtins.property
    @pulumi.getter(name="endsAt")
    def ends_at(self) -> _builtins.int:
        """
        The time when the alarm is cleared, in milliseconds.
        """
        return pulumi.get(self, "ends_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the alarm.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetAlarmsAlarmMetadataResult']:
        """
        The metadata of the alarm.  
        The metadata structure is documented below.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter(name="startsAt")
    def starts_at(self) -> _builtins.int:
        """
        The time when the alarm is generated, in milliseconds.
        """
        return pulumi.get(self, "starts_at")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        The time when the alarm is automatically cleared, in milliseconds.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the alarm to be queried.  
        The valid values are as follows:
        + **active_alert**: Query active alarms.
        + **history_alert**: Query historical alarms.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAlarmsAlarmAnnotationResult(dict):
    def __init__(__self__, *,
                 alarm_action_rule_name: _builtins.str,
                 alarm_rule_alias: _builtins.str,
                 alarm_rule_url: _builtins.str,
                 alarm_status: _builtins.str,
                 condition_expression: _builtins.str,
                 condition_expression_with_value: _builtins.str,
                 current_value: _builtins.str,
                 frequency: _builtins.str,
                 log_info: _builtins.str,
                 message: _builtins.str,
                 notification_frequency: _builtins.str,
                 old_annotations: _builtins.str,
                 recovery_policy: _builtins.bool,
                 type: _builtins.str):
        """
        :param _builtins.str alarm_action_rule_name: The name of the alarm action rule.
        :param _builtins.str alarm_rule_alias: The alias of the alarm rule.
        :param _builtins.str alarm_rule_url: The URL of the alarm rule.
        :param _builtins.str alarm_status: The status of the alarm trigger.
        :param _builtins.str condition_expression: The condition expression of the alarm trigger.
        :param _builtins.str condition_expression_with_value: The condition of the alarm trigger.
        :param _builtins.str current_value: The current value of the alarm.
        :param _builtins.str frequency: The frequency of the alarm.
        :param _builtins.str log_info: The log information of the alarm.
        :param _builtins.str message: The detail information of the alarm.
        :param _builtins.str notification_frequency: The notification frequency of the alarm.
        :param _builtins.str old_annotations: The raw data of the alarm detail.
        :param _builtins.bool recovery_policy: Whether the alarm is recovered.
        :param _builtins.str type: Specifies the type of the alarm to be queried.  
               The valid values are as follows:
               + **active_alert**: Query active alarms.
               + **history_alert**: Query historical alarms.
        """
        pulumi.set(__self__, "alarm_action_rule_name", alarm_action_rule_name)
        pulumi.set(__self__, "alarm_rule_alias", alarm_rule_alias)
        pulumi.set(__self__, "alarm_rule_url", alarm_rule_url)
        pulumi.set(__self__, "alarm_status", alarm_status)
        pulumi.set(__self__, "condition_expression", condition_expression)
        pulumi.set(__self__, "condition_expression_with_value", condition_expression_with_value)
        pulumi.set(__self__, "current_value", current_value)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "log_info", log_info)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "notification_frequency", notification_frequency)
        pulumi.set(__self__, "old_annotations", old_annotations)
        pulumi.set(__self__, "recovery_policy", recovery_policy)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="alarmActionRuleName")
    def alarm_action_rule_name(self) -> _builtins.str:
        """
        The name of the alarm action rule.
        """
        return pulumi.get(self, "alarm_action_rule_name")

    @_builtins.property
    @pulumi.getter(name="alarmRuleAlias")
    def alarm_rule_alias(self) -> _builtins.str:
        """
        The alias of the alarm rule.
        """
        return pulumi.get(self, "alarm_rule_alias")

    @_builtins.property
    @pulumi.getter(name="alarmRuleUrl")
    def alarm_rule_url(self) -> _builtins.str:
        """
        The URL of the alarm rule.
        """
        return pulumi.get(self, "alarm_rule_url")

    @_builtins.property
    @pulumi.getter(name="alarmStatus")
    def alarm_status(self) -> _builtins.str:
        """
        The status of the alarm trigger.
        """
        return pulumi.get(self, "alarm_status")

    @_builtins.property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> _builtins.str:
        """
        The condition expression of the alarm trigger.
        """
        return pulumi.get(self, "condition_expression")

    @_builtins.property
    @pulumi.getter(name="conditionExpressionWithValue")
    def condition_expression_with_value(self) -> _builtins.str:
        """
        The condition of the alarm trigger.
        """
        return pulumi.get(self, "condition_expression_with_value")

    @_builtins.property
    @pulumi.getter(name="currentValue")
    def current_value(self) -> _builtins.str:
        """
        The current value of the alarm.
        """
        return pulumi.get(self, "current_value")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        The frequency of the alarm.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="logInfo")
    def log_info(self) -> _builtins.str:
        """
        The log information of the alarm.
        """
        return pulumi.get(self, "log_info")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The detail information of the alarm.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="notificationFrequency")
    def notification_frequency(self) -> _builtins.str:
        """
        The notification frequency of the alarm.
        """
        return pulumi.get(self, "notification_frequency")

    @_builtins.property
    @pulumi.getter(name="oldAnnotations")
    def old_annotations(self) -> _builtins.str:
        """
        The raw data of the alarm detail.
        """
        return pulumi.get(self, "old_annotations")

    @_builtins.property
    @pulumi.getter(name="recoveryPolicy")
    def recovery_policy(self) -> _builtins.bool:
        """
        Whether the alarm is recovered.
        """
        return pulumi.get(self, "recovery_policy")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the alarm to be queried.  
        The valid values are as follows:
        + **active_alert**: Query active alarms.
        + **history_alert**: Query historical alarms.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAlarmsAlarmMetadataResult(dict):
    def __init__(__self__, *,
                 event_id: _builtins.str,
                 event_name: _builtins.str,
                 event_severity: _builtins.str,
                 event_subtype: _builtins.str,
                 event_type: _builtins.str,
                 log_group_name: _builtins.str,
                 log_stream_name: _builtins.str,
                 lts_alarm_type: _builtins.str,
                 resource_id: _builtins.str,
                 resource_provider: _builtins.str,
                 resource_type: _builtins.str):
        """
        :param _builtins.str event_id: The ID of the alarm rule.
        :param _builtins.str event_name: The name of the alarm rule.
        :param _builtins.str event_severity: The level of the alarm.
        :param _builtins.str event_subtype: The type of the alarm.
        :param _builtins.str event_type: The mode of the alarm.
        :param _builtins.str log_group_name: The original name of the log group.
        :param _builtins.str log_stream_name: The original name of the log stream.
        :param _builtins.str lts_alarm_type: The type of the alarm rule.
        :param _builtins.str resource_id: The ID of the resource.
        :param _builtins.str resource_provider: The source of the alarm.
        :param _builtins.str resource_type: The type of the resource.
        """
        pulumi.set(__self__, "event_id", event_id)
        pulumi.set(__self__, "event_name", event_name)
        pulumi.set(__self__, "event_severity", event_severity)
        pulumi.set(__self__, "event_subtype", event_subtype)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_stream_name", log_stream_name)
        pulumi.set(__self__, "lts_alarm_type", lts_alarm_type)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_provider", resource_provider)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="eventId")
    def event_id(self) -> _builtins.str:
        """
        The ID of the alarm rule.
        """
        return pulumi.get(self, "event_id")

    @_builtins.property
    @pulumi.getter(name="eventName")
    def event_name(self) -> _builtins.str:
        """
        The name of the alarm rule.
        """
        return pulumi.get(self, "event_name")

    @_builtins.property
    @pulumi.getter(name="eventSeverity")
    def event_severity(self) -> _builtins.str:
        """
        The level of the alarm.
        """
        return pulumi.get(self, "event_severity")

    @_builtins.property
    @pulumi.getter(name="eventSubtype")
    def event_subtype(self) -> _builtins.str:
        """
        The type of the alarm.
        """
        return pulumi.get(self, "event_subtype")

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        """
        The mode of the alarm.
        """
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        The original name of the log group.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        The original name of the log stream.
        """
        return pulumi.get(self, "log_stream_name")

    @_builtins.property
    @pulumi.getter(name="ltsAlarmType")
    def lts_alarm_type(self) -> _builtins.str:
        """
        The type of the alarm rule.
        """
        return pulumi.get(self, "lts_alarm_type")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The ID of the resource.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> _builtins.str:
        """
        The source of the alarm.
        """
        return pulumi.get(self, "resource_provider")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The type of the resource.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetAlarmsSortResult(dict):
    def __init__(__self__, *,
                 order: _builtins.str,
                 order_bies: Sequence[_builtins.str]):
        """
        :param _builtins.str order: Specifies the sort mode of the alarm.  
               The valid values are as follows:
               + **asc**
               + **desc**
        :param Sequence[_builtins.str] order_bies: Specifies the fields to be sorted.
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "order_bies", order_bies)

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.str:
        """
        Specifies the sort mode of the alarm.  
        The valid values are as follows:
        + **asc**
        + **desc**
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="orderBies")
    def order_bies(self) -> Sequence[_builtins.str]:
        """
        Specifies the fields to be sorted.
        """
        return pulumi.get(self, "order_bies")


@pulumi.output_type
class GetAomAccessesAccessResult(dict):
    def __init__(__self__, *,
                 access_rules: Sequence['outputs.GetAomAccessesAccessAccessRuleResult'],
                 cluster_id: _builtins.str,
                 cluster_name: _builtins.str,
                 container_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 namespace: _builtins.str,
                 workloads: Sequence[_builtins.str]):
        """
        :param Sequence['GetAomAccessesAccessAccessRuleArgs'] access_rules: The AOM access log details.
               The access_rules structure is documented below.
        :param _builtins.str cluster_id: The cluster ID corresponding to the AOM access rule.
        :param _builtins.str cluster_name: The cluster name corresponding to the AOM access rule.
        :param _builtins.str container_name: The name of the container corresponding to AOM access rule.
        :param _builtins.str id: The ID of the AOM access rule.
        :param _builtins.str name: The name of the AOM access rule.
        :param _builtins.str namespace: The namespace corresponding to the AOM access rule.
        :param Sequence[_builtins.str] workloads: The list of the workloads corresponding to AOM access rule.
        """
        pulumi.set(__self__, "access_rules", access_rules)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "workloads", workloads)

    @_builtins.property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Sequence['outputs.GetAomAccessesAccessAccessRuleResult']:
        """
        The AOM access log details.
        The access_rules structure is documented below.
        """
        return pulumi.get(self, "access_rules")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The cluster ID corresponding to the AOM access rule.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The cluster name corresponding to the AOM access rule.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> _builtins.str:
        """
        The name of the container corresponding to AOM access rule.
        """
        return pulumi.get(self, "container_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the AOM access rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the AOM access rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> _builtins.str:
        """
        The namespace corresponding to the AOM access rule.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def workloads(self) -> Sequence[_builtins.str]:
        """
        The list of the workloads corresponding to AOM access rule.
        """
        return pulumi.get(self, "workloads")


@pulumi.output_type
class GetAomAccessesAccessAccessRuleResult(dict):
    def __init__(__self__, *,
                 file_name: _builtins.str,
                 log_group_id: _builtins.str,
                 log_group_name: _builtins.str,
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str):
        """
        :param _builtins.str file_name: The name of the log path.
        :param _builtins.str log_group_id: The ID of the log group.
        :param _builtins.str log_group_name: Specifies the ID of the log group name to be queried.
        :param _builtins.str log_stream_id: The ID of the log stream.
        :param _builtins.str log_stream_name: Specifies the log stream name to be queried.
        """
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        """
        The name of the log path.
        """
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        The ID of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        Specifies the ID of the log group name to be queried.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The ID of the log stream.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        Specifies the log stream name to be queried.
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class GetCceAccessesAccessResult(dict):
    def __init__(__self__, *,
                 access_configs: Sequence['outputs.GetCceAccessesAccessAccessConfigResult'],
                 access_type: _builtins.str,
                 binary_collect: _builtins.bool,
                 cluster_id: _builtins.str,
                 created_at: _builtins.str,
                 demo_fields: Sequence['outputs.GetCceAccessesAccessDemoFieldResult'],
                 demo_log: _builtins.str,
                 encoding_format: _builtins.str,
                 host_group_ids: Sequence[_builtins.str],
                 id: _builtins.str,
                 incremental_collect: _builtins.bool,
                 log_group_id: _builtins.str,
                 log_group_name: _builtins.str,
                 log_split: _builtins.bool,
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str,
                 name: _builtins.str,
                 processor_type: _builtins.str,
                 processors: Sequence['outputs.GetCceAccessesAccessProcessorResult'],
                 tags: Mapping[str, _builtins.str]):
        """
        :param Sequence['GetCceAccessesAccessAccessConfigArgs'] access_configs: The configuration detail of the CCE access.  
               The access_config structure is documented below.
        :param _builtins.str access_type: The type of the log access.
        :param _builtins.bool binary_collect: Whether collect in binary format.
        :param _builtins.str cluster_id: The ID of the cluster corresponding to CCE access.
        :param _builtins.str created_at: The creation time of the CCE access, in RFC3339 format.
        :param Sequence['GetCceAccessesAccessDemoFieldArgs'] demo_fields: The list of the parsed fields of the example log.  
               The demo_fields structure is documented below.
        :param _builtins.str demo_log: The example log of the ICAgent structuring parsing.  
               This parameter is available when the `processor_type` parameter is specified.
        :param _builtins.str encoding_format: The encoding format log file.
               + **UTF-8**
               + **GBK**
        :param Sequence[_builtins.str] host_group_ids: The ID list of the log access host groups.
        :param _builtins.str id: The ID of the CCE access.
        :param _builtins.bool incremental_collect: Whether to collect incrementally.
        :param _builtins.str log_group_id: The ID of the log group.
        :param _builtins.str log_group_name: Specifies the name of the log group to which the access configurations and log
               streams belong.
        :param _builtins.bool log_split: Whether to split log.
        :param _builtins.str log_stream_id: The ID of the log stream.
        :param _builtins.str log_stream_name: Specifies the name of the log stream to which the access configurations belong.
        :param _builtins.str name: Specifies the name of the CCE access to be queried.
        :param _builtins.str processor_type: The type of the ICAgent structuring parsing.
               + **SINGLE_LINE**
               + **MULTI_LINE**
               + **REGEX**
               + **MULTI_REGEX**
               + **SPLIT**
               + **JSON**
               + **NGINX**
               + **COMPOSE**
        :param Sequence['GetCceAccessesAccessProcessorArgs'] processors: The list of the ICAgent structuring parsing rules.  
               The processors structure is documented below.
        :param Mapping[str, _builtins.str] tags: Specifies the key/value pairs to associate with the CCE access.
        """
        pulumi.set(__self__, "access_configs", access_configs)
        pulumi.set(__self__, "access_type", access_type)
        pulumi.set(__self__, "binary_collect", binary_collect)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "demo_fields", demo_fields)
        pulumi.set(__self__, "demo_log", demo_log)
        pulumi.set(__self__, "encoding_format", encoding_format)
        pulumi.set(__self__, "host_group_ids", host_group_ids)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "incremental_collect", incremental_collect)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_split", log_split)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "processor_type", processor_type)
        pulumi.set(__self__, "processors", processors)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Sequence['outputs.GetCceAccessesAccessAccessConfigResult']:
        """
        The configuration detail of the CCE access.  
        The access_config structure is documented below.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> _builtins.str:
        """
        The type of the log access.
        """
        return pulumi.get(self, "access_type")

    @_builtins.property
    @pulumi.getter(name="binaryCollect")
    def binary_collect(self) -> _builtins.bool:
        """
        Whether collect in binary format.
        """
        return pulumi.get(self, "binary_collect")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The ID of the cluster corresponding to CCE access.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the CCE access, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="demoFields")
    def demo_fields(self) -> Sequence['outputs.GetCceAccessesAccessDemoFieldResult']:
        """
        The list of the parsed fields of the example log.  
        The demo_fields structure is documented below.
        """
        return pulumi.get(self, "demo_fields")

    @_builtins.property
    @pulumi.getter(name="demoLog")
    def demo_log(self) -> _builtins.str:
        """
        The example log of the ICAgent structuring parsing.  
        This parameter is available when the `processor_type` parameter is specified.
        """
        return pulumi.get(self, "demo_log")

    @_builtins.property
    @pulumi.getter(name="encodingFormat")
    def encoding_format(self) -> _builtins.str:
        """
        The encoding format log file.
        + **UTF-8**
        + **GBK**
        """
        return pulumi.get(self, "encoding_format")

    @_builtins.property
    @pulumi.getter(name="hostGroupIds")
    def host_group_ids(self) -> Sequence[_builtins.str]:
        """
        The ID list of the log access host groups.
        """
        return pulumi.get(self, "host_group_ids")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the CCE access.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="incrementalCollect")
    def incremental_collect(self) -> _builtins.bool:
        """
        Whether to collect incrementally.
        """
        return pulumi.get(self, "incremental_collect")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        The ID of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        Specifies the name of the log group to which the access configurations and log
        streams belong.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logSplit")
    def log_split(self) -> _builtins.bool:
        """
        Whether to split log.
        """
        return pulumi.get(self, "log_split")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The ID of the log stream.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        Specifies the name of the log stream to which the access configurations belong.
        """
        return pulumi.get(self, "log_stream_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the CCE access to be queried.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="processorType")
    def processor_type(self) -> _builtins.str:
        """
        The type of the ICAgent structuring parsing.
        + **SINGLE_LINE**
        + **MULTI_LINE**
        + **REGEX**
        + **MULTI_REGEX**
        + **SPLIT**
        + **JSON**
        + **NGINX**
        + **COMPOSE**
        """
        return pulumi.get(self, "processor_type")

    @_builtins.property
    @pulumi.getter
    def processors(self) -> Sequence['outputs.GetCceAccessesAccessProcessorResult']:
        """
        The list of the ICAgent structuring parsing rules.  
        The processors structure is documented below.
        """
        return pulumi.get(self, "processors")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Specifies the key/value pairs to associate with the CCE access.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCceAccessesAccessAccessConfigResult(dict):
    def __init__(__self__, *,
                 black_paths: Sequence[_builtins.str],
                 container_name_regex: _builtins.str,
                 custom_key_value: Mapping[str, _builtins.str],
                 exclude_envs: Mapping[str, _builtins.str],
                 exclude_envs_logical: _builtins.str,
                 exclude_k8s_labels: Mapping[str, _builtins.str],
                 exclude_k8s_labels_logical: _builtins.str,
                 exclude_labels: Mapping[str, _builtins.str],
                 exclude_labels_logical: _builtins.str,
                 include_envs: Mapping[str, _builtins.str],
                 include_envs_logical: _builtins.str,
                 include_k8s_labels: Mapping[str, _builtins.str],
                 include_k8s_labels_logical: _builtins.str,
                 include_labels: Mapping[str, _builtins.str],
                 include_labels_logical: _builtins.str,
                 log_envs: Mapping[str, _builtins.str],
                 log_k8s: Mapping[str, _builtins.str],
                 log_labels: Mapping[str, _builtins.str],
                 multi_log_formats: Sequence['outputs.GetCceAccessesAccessAccessConfigMultiLogFormatResult'],
                 name_space_regex: _builtins.str,
                 path_type: _builtins.str,
                 paths: Sequence[_builtins.str],
                 pod_name_regex: _builtins.str,
                 repeat_collect: _builtins.bool,
                 single_log_formats: Sequence['outputs.GetCceAccessesAccessAccessConfigSingleLogFormatResult'],
                 stderr: _builtins.bool,
                 stdout: _builtins.bool,
                 system_fields: Sequence[_builtins.str],
                 windows_log_infos: Sequence['outputs.GetCceAccessesAccessAccessConfigWindowsLogInfoResult']):
        """
        :param Sequence[_builtins.str] black_paths: The collection path blacklist.
        :param _builtins.str container_name_regex: The regular expression matching of kubernetes container names.
        :param Mapping[str, _builtins.str] custom_key_value: The custom key/value pairs of the CCE access.
        :param Mapping[str, _builtins.str] exclude_envs: The environment variable blacklist.
        :param _builtins.str exclude_envs_logical: The logical relationship between multiple environment variable blacklist.
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] exclude_k8s_labels: The kubernetes label blacklist.
        :param _builtins.str exclude_k8s_labels_logical: The logical relationship between multiple kubernetes label blacklist.
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] exclude_labels: The container label blacklist.
        :param _builtins.str exclude_labels_logical: The logical relationship between multiple container label blacklists.
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] include_envs: The environment variable whitelist.
        :param _builtins.str include_envs_logical: The logical relationship between multiple environment variable whitelists.
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] include_k8s_labels: The kubernetes label whitelist.
        :param _builtins.str include_k8s_labels_logical: The logical relationship between multiple kubernetes label whitelists.
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] include_labels: The container label whitelist.
        :param _builtins.str include_labels_logical: The logical relationship between multiple container label whitelists.
               + **and**
               + **or**
        :param Mapping[str, _builtins.str] log_envs: The environment variable tag.
        :param Mapping[str, _builtins.str] log_k8s: The kubernetes label log tag.
        :param Mapping[str, _builtins.str] log_labels: The container label log tag.
        :param Sequence['GetCceAccessesAccessAccessConfigMultiLogFormatArgs'] multi_log_formats: The configuration multi-line logs.  
               The multi_log_format structure is documented below.
        :param _builtins.str name_space_regex: The regular expression matching of kubernetes namespaces.
        :param _builtins.str path_type: The type of the CCE access.
               + **container_stdout**
               + **container_file**
               + **host_file**
        :param Sequence[_builtins.str] paths: The collection paths.
        :param _builtins.str pod_name_regex: The regular expression matching of kubernetes pods.
        :param _builtins.bool repeat_collect: Whether to allow repeated file collection.
        :param Sequence['GetCceAccessesAccessAccessConfigSingleLogFormatArgs'] single_log_formats: The configuration single-line logs.  
               The single_log_format structure is documented below.
        :param _builtins.bool stderr: Whether error output is standard.
        :param _builtins.bool stdout: Whether output is standard.
        :param Sequence[_builtins.str] system_fields: The list of system built-in fields of the CCE access.
        :param Sequence['GetCceAccessesAccessAccessConfigWindowsLogInfoArgs'] windows_log_infos: The configuration of Windows event logs.  
               The windows_log_info structure is documented below.
        """
        pulumi.set(__self__, "black_paths", black_paths)
        pulumi.set(__self__, "container_name_regex", container_name_regex)
        pulumi.set(__self__, "custom_key_value", custom_key_value)
        pulumi.set(__self__, "exclude_envs", exclude_envs)
        pulumi.set(__self__, "exclude_envs_logical", exclude_envs_logical)
        pulumi.set(__self__, "exclude_k8s_labels", exclude_k8s_labels)
        pulumi.set(__self__, "exclude_k8s_labels_logical", exclude_k8s_labels_logical)
        pulumi.set(__self__, "exclude_labels", exclude_labels)
        pulumi.set(__self__, "exclude_labels_logical", exclude_labels_logical)
        pulumi.set(__self__, "include_envs", include_envs)
        pulumi.set(__self__, "include_envs_logical", include_envs_logical)
        pulumi.set(__self__, "include_k8s_labels", include_k8s_labels)
        pulumi.set(__self__, "include_k8s_labels_logical", include_k8s_labels_logical)
        pulumi.set(__self__, "include_labels", include_labels)
        pulumi.set(__self__, "include_labels_logical", include_labels_logical)
        pulumi.set(__self__, "log_envs", log_envs)
        pulumi.set(__self__, "log_k8s", log_k8s)
        pulumi.set(__self__, "log_labels", log_labels)
        pulumi.set(__self__, "multi_log_formats", multi_log_formats)
        pulumi.set(__self__, "name_space_regex", name_space_regex)
        pulumi.set(__self__, "path_type", path_type)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "pod_name_regex", pod_name_regex)
        pulumi.set(__self__, "repeat_collect", repeat_collect)
        pulumi.set(__self__, "single_log_formats", single_log_formats)
        pulumi.set(__self__, "stderr", stderr)
        pulumi.set(__self__, "stdout", stdout)
        pulumi.set(__self__, "system_fields", system_fields)
        pulumi.set(__self__, "windows_log_infos", windows_log_infos)

    @_builtins.property
    @pulumi.getter(name="blackPaths")
    def black_paths(self) -> Sequence[_builtins.str]:
        """
        The collection path blacklist.
        """
        return pulumi.get(self, "black_paths")

    @_builtins.property
    @pulumi.getter(name="containerNameRegex")
    def container_name_regex(self) -> _builtins.str:
        """
        The regular expression matching of kubernetes container names.
        """
        return pulumi.get(self, "container_name_regex")

    @_builtins.property
    @pulumi.getter(name="customKeyValue")
    def custom_key_value(self) -> Mapping[str, _builtins.str]:
        """
        The custom key/value pairs of the CCE access.
        """
        return pulumi.get(self, "custom_key_value")

    @_builtins.property
    @pulumi.getter(name="excludeEnvs")
    def exclude_envs(self) -> Mapping[str, _builtins.str]:
        """
        The environment variable blacklist.
        """
        return pulumi.get(self, "exclude_envs")

    @_builtins.property
    @pulumi.getter(name="excludeEnvsLogical")
    def exclude_envs_logical(self) -> _builtins.str:
        """
        The logical relationship between multiple environment variable blacklist.
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_envs_logical")

    @_builtins.property
    @pulumi.getter(name="excludeK8sLabels")
    def exclude_k8s_labels(self) -> Mapping[str, _builtins.str]:
        """
        The kubernetes label blacklist.
        """
        return pulumi.get(self, "exclude_k8s_labels")

    @_builtins.property
    @pulumi.getter(name="excludeK8sLabelsLogical")
    def exclude_k8s_labels_logical(self) -> _builtins.str:
        """
        The logical relationship between multiple kubernetes label blacklist.
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_k8s_labels_logical")

    @_builtins.property
    @pulumi.getter(name="excludeLabels")
    def exclude_labels(self) -> Mapping[str, _builtins.str]:
        """
        The container label blacklist.
        """
        return pulumi.get(self, "exclude_labels")

    @_builtins.property
    @pulumi.getter(name="excludeLabelsLogical")
    def exclude_labels_logical(self) -> _builtins.str:
        """
        The logical relationship between multiple container label blacklists.
        + **and**
        + **or**
        """
        return pulumi.get(self, "exclude_labels_logical")

    @_builtins.property
    @pulumi.getter(name="includeEnvs")
    def include_envs(self) -> Mapping[str, _builtins.str]:
        """
        The environment variable whitelist.
        """
        return pulumi.get(self, "include_envs")

    @_builtins.property
    @pulumi.getter(name="includeEnvsLogical")
    def include_envs_logical(self) -> _builtins.str:
        """
        The logical relationship between multiple environment variable whitelists.
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_envs_logical")

    @_builtins.property
    @pulumi.getter(name="includeK8sLabels")
    def include_k8s_labels(self) -> Mapping[str, _builtins.str]:
        """
        The kubernetes label whitelist.
        """
        return pulumi.get(self, "include_k8s_labels")

    @_builtins.property
    @pulumi.getter(name="includeK8sLabelsLogical")
    def include_k8s_labels_logical(self) -> _builtins.str:
        """
        The logical relationship between multiple kubernetes label whitelists.
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_k8s_labels_logical")

    @_builtins.property
    @pulumi.getter(name="includeLabels")
    def include_labels(self) -> Mapping[str, _builtins.str]:
        """
        The container label whitelist.
        """
        return pulumi.get(self, "include_labels")

    @_builtins.property
    @pulumi.getter(name="includeLabelsLogical")
    def include_labels_logical(self) -> _builtins.str:
        """
        The logical relationship between multiple container label whitelists.
        + **and**
        + **or**
        """
        return pulumi.get(self, "include_labels_logical")

    @_builtins.property
    @pulumi.getter(name="logEnvs")
    def log_envs(self) -> Mapping[str, _builtins.str]:
        """
        The environment variable tag.
        """
        return pulumi.get(self, "log_envs")

    @_builtins.property
    @pulumi.getter(name="logK8s")
    def log_k8s(self) -> Mapping[str, _builtins.str]:
        """
        The kubernetes label log tag.
        """
        return pulumi.get(self, "log_k8s")

    @_builtins.property
    @pulumi.getter(name="logLabels")
    def log_labels(self) -> Mapping[str, _builtins.str]:
        """
        The container label log tag.
        """
        return pulumi.get(self, "log_labels")

    @_builtins.property
    @pulumi.getter(name="multiLogFormats")
    def multi_log_formats(self) -> Sequence['outputs.GetCceAccessesAccessAccessConfigMultiLogFormatResult']:
        """
        The configuration multi-line logs.  
        The multi_log_format structure is documented below.
        """
        return pulumi.get(self, "multi_log_formats")

    @_builtins.property
    @pulumi.getter(name="nameSpaceRegex")
    def name_space_regex(self) -> _builtins.str:
        """
        The regular expression matching of kubernetes namespaces.
        """
        return pulumi.get(self, "name_space_regex")

    @_builtins.property
    @pulumi.getter(name="pathType")
    def path_type(self) -> _builtins.str:
        """
        The type of the CCE access.
        + **container_stdout**
        + **container_file**
        + **host_file**
        """
        return pulumi.get(self, "path_type")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence[_builtins.str]:
        """
        The collection paths.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="podNameRegex")
    def pod_name_regex(self) -> _builtins.str:
        """
        The regular expression matching of kubernetes pods.
        """
        return pulumi.get(self, "pod_name_regex")

    @_builtins.property
    @pulumi.getter(name="repeatCollect")
    def repeat_collect(self) -> _builtins.bool:
        """
        Whether to allow repeated file collection.
        """
        return pulumi.get(self, "repeat_collect")

    @_builtins.property
    @pulumi.getter(name="singleLogFormats")
    def single_log_formats(self) -> Sequence['outputs.GetCceAccessesAccessAccessConfigSingleLogFormatResult']:
        """
        The configuration single-line logs.  
        The single_log_format structure is documented below.
        """
        return pulumi.get(self, "single_log_formats")

    @_builtins.property
    @pulumi.getter
    def stderr(self) -> _builtins.bool:
        """
        Whether error output is standard.
        """
        return pulumi.get(self, "stderr")

    @_builtins.property
    @pulumi.getter
    def stdout(self) -> _builtins.bool:
        """
        Whether output is standard.
        """
        return pulumi.get(self, "stdout")

    @_builtins.property
    @pulumi.getter(name="systemFields")
    def system_fields(self) -> Sequence[_builtins.str]:
        """
        The list of system built-in fields of the CCE access.
        """
        return pulumi.get(self, "system_fields")

    @_builtins.property
    @pulumi.getter(name="windowsLogInfos")
    def windows_log_infos(self) -> Sequence['outputs.GetCceAccessesAccessAccessConfigWindowsLogInfoResult']:
        """
        The configuration of Windows event logs.  
        The windows_log_info structure is documented below.
        """
        return pulumi.get(self, "windows_log_infos")


@pulumi.output_type
class GetCceAccessesAccessAccessConfigMultiLogFormatResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str mode: The mode of multi-line log format.
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: The value of multi-line log format.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode of multi-line log format.
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of multi-line log format.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCceAccessesAccessAccessConfigSingleLogFormatResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str mode: The mode of multi-line log format.
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: The value of multi-line log format.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode of multi-line log format.
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of multi-line log format.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCceAccessesAccessAccessConfigWindowsLogInfoResult(dict):
    def __init__(__self__, *,
                 categorys: Sequence[_builtins.str],
                 event_levels: Sequence[_builtins.str],
                 time_offset: _builtins.int,
                 time_offset_unit: _builtins.str):
        """
        :param Sequence[_builtins.str] categorys: The types of Windows event logs to be collected.
               + **Application**
               + **System**
               + **Security**
               + **Setup**
        :param Sequence[_builtins.str] event_levels: The list of Windows event levels.  
               The element includes:
               + **information**
               + **warning**
               + **error**
               + **critical**
               + **verbose**
        :param _builtins.int time_offset: The collection time offset.
        :param _builtins.str time_offset_unit: The collection time offset unit.
               + **day**
               + **hour**
               + **sec**
        """
        pulumi.set(__self__, "categorys", categorys)
        pulumi.set(__self__, "event_levels", event_levels)
        pulumi.set(__self__, "time_offset", time_offset)
        pulumi.set(__self__, "time_offset_unit", time_offset_unit)

    @_builtins.property
    @pulumi.getter
    def categorys(self) -> Sequence[_builtins.str]:
        """
        The types of Windows event logs to be collected.
        + **Application**
        + **System**
        + **Security**
        + **Setup**
        """
        return pulumi.get(self, "categorys")

    @_builtins.property
    @pulumi.getter(name="eventLevels")
    def event_levels(self) -> Sequence[_builtins.str]:
        """
        The list of Windows event levels.  
        The element includes:
        + **information**
        + **warning**
        + **error**
        + **critical**
        + **verbose**
        """
        return pulumi.get(self, "event_levels")

    @_builtins.property
    @pulumi.getter(name="timeOffset")
    def time_offset(self) -> _builtins.int:
        """
        The collection time offset.
        """
        return pulumi.get(self, "time_offset")

    @_builtins.property
    @pulumi.getter(name="timeOffsetUnit")
    def time_offset_unit(self) -> _builtins.str:
        """
        The collection time offset unit.
        + **day**
        + **hour**
        + **sec**
        """
        return pulumi.get(self, "time_offset_unit")


@pulumi.output_type
class GetCceAccessesAccessDemoFieldResult(dict):
    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_value: _builtins.str):
        """
        :param _builtins.str field_name: The name of the parsed field.
        :param _builtins.str field_value: The value of the parsed field.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_value", field_value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        The name of the parsed field.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> _builtins.str:
        """
        The value of the parsed field.
        """
        return pulumi.get(self, "field_value")


@pulumi.output_type
class GetCceAccessesAccessProcessorResult(dict):
    def __init__(__self__, *,
                 detail: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str detail: The configuration of the parser, in JSON format.
        :param _builtins.str type: The type of the parser.
               + **processor_regex**
               + **processor_split_string**
               + **processor_json**
               + **processor_gotime**
               + **processor_filter_regex**
               + **processor_drop**
               + **processor_rename**
        """
        pulumi.set(__self__, "detail", detail)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> _builtins.str:
        """
        The configuration of the parser, in JSON format.
        """
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the parser.
        + **processor_regex**
        + **processor_split_string**
        + **processor_json**
        + **processor_gotime**
        + **processor_filter_regex**
        + **processor_drop**
        + **processor_rename**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGroupsGroupResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 ttl_in_days: _builtins.int):
        """
        :param _builtins.str created_at: The creation time of the log group, in RFC3339 format.
        :param _builtins.str enterprise_project_id: The enterprise project ID to which the log group belongs.
        :param _builtins.str id: The log group ID.
        :param _builtins.str name: The log group name.
        :param Mapping[str, _builtins.str] tags: The key/value pairs to associate with the log group.
        :param _builtins.int ttl_in_days: The log expiration time(days).
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "ttl_in_days", ttl_in_days)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the log group, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        The enterprise project ID to which the log group belongs.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The log group ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The log group name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to associate with the log group.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="ttlInDays")
    def ttl_in_days(self) -> _builtins.int:
        """
        The log expiration time(days).
        """
        return pulumi.get(self, "ttl_in_days")


@pulumi.output_type
class GetHostAccessesAccessResult(dict):
    def __init__(__self__, *,
                 access_configs: Sequence['outputs.GetHostAccessesAccessAccessConfigResult'],
                 access_type: _builtins.str,
                 binary_collect: _builtins.bool,
                 created_at: _builtins.str,
                 demo_fields: Sequence['outputs.GetHostAccessesAccessDemoFieldResult'],
                 demo_log: _builtins.str,
                 encoding_format: _builtins.str,
                 host_group_ids: Sequence[_builtins.str],
                 id: _builtins.str,
                 incremental_collect: _builtins.bool,
                 log_group_id: _builtins.str,
                 log_group_name: _builtins.str,
                 log_split: _builtins.bool,
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str,
                 name: _builtins.str,
                 processor_type: _builtins.str,
                 processors: Sequence['outputs.GetHostAccessesAccessProcessorResult'],
                 tags: Mapping[str, _builtins.str]):
        """
        :param Sequence['GetHostAccessesAccessAccessConfigArgs'] access_configs: The configuration detail of the host access.
        :param _builtins.str access_type: The type of the log access.
               + **AGENT**: ECS access.
        :param _builtins.bool binary_collect: Whether to allow collection of binary log files.
        :param _builtins.str created_at: The creation time of the host access, in RFC3339 format.
        :param Sequence['GetHostAccessesAccessDemoFieldArgs'] demo_fields: The list of the parsed fields of the example log.
        :param _builtins.str demo_log: The example log of the ICAgent structuring parsing.
        :param _builtins.str encoding_format: The encoding format log file.
               + **UTF-8**
               + **GBK**
        :param Sequence[_builtins.str] host_group_ids: The ID list of the log access host groups.
        :param _builtins.str id: The ID of the host access.
        :param _builtins.bool incremental_collect: Whether to collect logs incrementally.
        :param _builtins.str log_group_id: The ID of the log group to which the host access belongs.
        :param _builtins.str log_group_name: The name of the log group to which the host access belongs.
        :param _builtins.bool log_split: Whether log splitting is enabled.
        :param _builtins.str log_stream_id: The ID of the log stream to which the host access belongs.
        :param _builtins.str log_stream_name: The name of the log stream to which the host access belongs.
        :param _builtins.str name: The name of the parsed field.
        :param _builtins.str processor_type: The type of the ICAgent structuring parsing.
               + **SINGLE_LINE**
               + **MULTI_LINE**
               + **REGEX**
               + **MULTI_REGEX**
               + **SPLIT**
               + **JSON**
               + **NGINX**
               + **COMPOSE**
        :param Sequence['GetHostAccessesAccessProcessorArgs'] processors: The list of the ICAgent structuring parsing rules.
        :param Mapping[str, _builtins.str] tags: Specifies the key/value pairs to associate with the host access.
        """
        pulumi.set(__self__, "access_configs", access_configs)
        pulumi.set(__self__, "access_type", access_type)
        pulumi.set(__self__, "binary_collect", binary_collect)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "demo_fields", demo_fields)
        pulumi.set(__self__, "demo_log", demo_log)
        pulumi.set(__self__, "encoding_format", encoding_format)
        pulumi.set(__self__, "host_group_ids", host_group_ids)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "incremental_collect", incremental_collect)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_split", log_split)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "processor_type", processor_type)
        pulumi.set(__self__, "processors", processors)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="accessConfigs")
    def access_configs(self) -> Sequence['outputs.GetHostAccessesAccessAccessConfigResult']:
        """
        The configuration detail of the host access.
        """
        return pulumi.get(self, "access_configs")

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> _builtins.str:
        """
        The type of the log access.
        + **AGENT**: ECS access.
        """
        return pulumi.get(self, "access_type")

    @_builtins.property
    @pulumi.getter(name="binaryCollect")
    def binary_collect(self) -> _builtins.bool:
        """
        Whether to allow collection of binary log files.
        """
        return pulumi.get(self, "binary_collect")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the host access, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="demoFields")
    def demo_fields(self) -> Sequence['outputs.GetHostAccessesAccessDemoFieldResult']:
        """
        The list of the parsed fields of the example log.
        """
        return pulumi.get(self, "demo_fields")

    @_builtins.property
    @pulumi.getter(name="demoLog")
    def demo_log(self) -> _builtins.str:
        """
        The example log of the ICAgent structuring parsing.
        """
        return pulumi.get(self, "demo_log")

    @_builtins.property
    @pulumi.getter(name="encodingFormat")
    def encoding_format(self) -> _builtins.str:
        """
        The encoding format log file.
        + **UTF-8**
        + **GBK**
        """
        return pulumi.get(self, "encoding_format")

    @_builtins.property
    @pulumi.getter(name="hostGroupIds")
    def host_group_ids(self) -> Sequence[_builtins.str]:
        """
        The ID list of the log access host groups.
        """
        return pulumi.get(self, "host_group_ids")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the host access.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="incrementalCollect")
    def incremental_collect(self) -> _builtins.bool:
        """
        Whether to collect logs incrementally.
        """
        return pulumi.get(self, "incremental_collect")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        The ID of the log group to which the host access belongs.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        The name of the log group to which the host access belongs.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logSplit")
    def log_split(self) -> _builtins.bool:
        """
        Whether log splitting is enabled.
        """
        return pulumi.get(self, "log_split")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The ID of the log stream to which the host access belongs.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        The name of the log stream to which the host access belongs.
        """
        return pulumi.get(self, "log_stream_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the parsed field.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="processorType")
    def processor_type(self) -> _builtins.str:
        """
        The type of the ICAgent structuring parsing.
        + **SINGLE_LINE**
        + **MULTI_LINE**
        + **REGEX**
        + **MULTI_REGEX**
        + **SPLIT**
        + **JSON**
        + **NGINX**
        + **COMPOSE**
        """
        return pulumi.get(self, "processor_type")

    @_builtins.property
    @pulumi.getter
    def processors(self) -> Sequence['outputs.GetHostAccessesAccessProcessorResult']:
        """
        The list of the ICAgent structuring parsing rules.
        """
        return pulumi.get(self, "processors")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Specifies the key/value pairs to associate with the host access.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetHostAccessesAccessAccessConfigResult(dict):
    def __init__(__self__, *,
                 black_paths: Sequence[_builtins.str],
                 custom_key_value: Mapping[str, _builtins.str],
                 multi_log_formats: Sequence['outputs.GetHostAccessesAccessAccessConfigMultiLogFormatResult'],
                 paths: Sequence[_builtins.str],
                 repeat_collect: _builtins.bool,
                 single_log_formats: Sequence['outputs.GetHostAccessesAccessAccessConfigSingleLogFormatResult'],
                 system_fields: Sequence[_builtins.str],
                 windows_log_infos: Sequence['outputs.GetHostAccessesAccessAccessConfigWindowsLogInfoResult']):
        """
        :param Sequence[_builtins.str] black_paths: The collection path blacklist.
        :param Mapping[str, _builtins.str] custom_key_value: The custom key/value pairs of the host access.
        :param Sequence['GetHostAccessesAccessAccessConfigMultiLogFormatArgs'] multi_log_formats: The configuration multi-line logs.
        :param Sequence[_builtins.str] paths: The list of paths where collected logs are located.
        :param _builtins.bool repeat_collect: Whether the file is allowed to be collected repeatedly.
        :param Sequence['GetHostAccessesAccessAccessConfigSingleLogFormatArgs'] single_log_formats: The configuration single-line logs.
        :param Sequence[_builtins.str] system_fields: The list of system built-in fields of the host access.
        :param Sequence['GetHostAccessesAccessAccessConfigWindowsLogInfoArgs'] windows_log_infos: The configuration of Windows event logs.
        """
        pulumi.set(__self__, "black_paths", black_paths)
        pulumi.set(__self__, "custom_key_value", custom_key_value)
        pulumi.set(__self__, "multi_log_formats", multi_log_formats)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "repeat_collect", repeat_collect)
        pulumi.set(__self__, "single_log_formats", single_log_formats)
        pulumi.set(__self__, "system_fields", system_fields)
        pulumi.set(__self__, "windows_log_infos", windows_log_infos)

    @_builtins.property
    @pulumi.getter(name="blackPaths")
    def black_paths(self) -> Sequence[_builtins.str]:
        """
        The collection path blacklist.
        """
        return pulumi.get(self, "black_paths")

    @_builtins.property
    @pulumi.getter(name="customKeyValue")
    def custom_key_value(self) -> Mapping[str, _builtins.str]:
        """
        The custom key/value pairs of the host access.
        """
        return pulumi.get(self, "custom_key_value")

    @_builtins.property
    @pulumi.getter(name="multiLogFormats")
    def multi_log_formats(self) -> Sequence['outputs.GetHostAccessesAccessAccessConfigMultiLogFormatResult']:
        """
        The configuration multi-line logs.
        """
        return pulumi.get(self, "multi_log_formats")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Sequence[_builtins.str]:
        """
        The list of paths where collected logs are located.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter(name="repeatCollect")
    def repeat_collect(self) -> _builtins.bool:
        """
        Whether the file is allowed to be collected repeatedly.
        """
        return pulumi.get(self, "repeat_collect")

    @_builtins.property
    @pulumi.getter(name="singleLogFormats")
    def single_log_formats(self) -> Sequence['outputs.GetHostAccessesAccessAccessConfigSingleLogFormatResult']:
        """
        The configuration single-line logs.
        """
        return pulumi.get(self, "single_log_formats")

    @_builtins.property
    @pulumi.getter(name="systemFields")
    def system_fields(self) -> Sequence[_builtins.str]:
        """
        The list of system built-in fields of the host access.
        """
        return pulumi.get(self, "system_fields")

    @_builtins.property
    @pulumi.getter(name="windowsLogInfos")
    def windows_log_infos(self) -> Sequence['outputs.GetHostAccessesAccessAccessConfigWindowsLogInfoResult']:
        """
        The configuration of Windows event logs.
        """
        return pulumi.get(self, "windows_log_infos")


@pulumi.output_type
class GetHostAccessesAccessAccessConfigMultiLogFormatResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str mode: The mode of multi-line log format.
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: The value of the parsed field.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode of multi-line log format.
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the parsed field.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHostAccessesAccessAccessConfigSingleLogFormatResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str mode: The mode of multi-line log format.
               + **time**: the time wildcard.
               + **regular**: the regular expression.
        :param _builtins.str value: The value of the parsed field.
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The mode of multi-line log format.
        + **time**: the time wildcard.
        + **regular**: the regular expression.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the parsed field.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHostAccessesAccessAccessConfigWindowsLogInfoResult(dict):
    def __init__(__self__, *,
                 categorys: Sequence[_builtins.str],
                 event_levels: Sequence[_builtins.str],
                 time_offset: _builtins.int,
                 time_offset_unit: _builtins.str):
        """
        :param Sequence[_builtins.str] categorys: The types of Windows event logs to be collected.
               + **Application**
               + **System**
               + **Security**
               + **Setup**
        :param Sequence[_builtins.str] event_levels: The list of Windows event levels.
               + **information**
               + **warning**
               + **error**
               + **critical**
               + **verbose**
        :param _builtins.int time_offset: The collection time offset.
        :param _builtins.str time_offset_unit: The collection time offset unit.
               + **day**
               + **hour**
               + **sec**
        """
        pulumi.set(__self__, "categorys", categorys)
        pulumi.set(__self__, "event_levels", event_levels)
        pulumi.set(__self__, "time_offset", time_offset)
        pulumi.set(__self__, "time_offset_unit", time_offset_unit)

    @_builtins.property
    @pulumi.getter
    def categorys(self) -> Sequence[_builtins.str]:
        """
        The types of Windows event logs to be collected.
        + **Application**
        + **System**
        + **Security**
        + **Setup**
        """
        return pulumi.get(self, "categorys")

    @_builtins.property
    @pulumi.getter(name="eventLevels")
    def event_levels(self) -> Sequence[_builtins.str]:
        """
        The list of Windows event levels.
        + **information**
        + **warning**
        + **error**
        + **critical**
        + **verbose**
        """
        return pulumi.get(self, "event_levels")

    @_builtins.property
    @pulumi.getter(name="timeOffset")
    def time_offset(self) -> _builtins.int:
        """
        The collection time offset.
        """
        return pulumi.get(self, "time_offset")

    @_builtins.property
    @pulumi.getter(name="timeOffsetUnit")
    def time_offset_unit(self) -> _builtins.str:
        """
        The collection time offset unit.
        + **day**
        + **hour**
        + **sec**
        """
        return pulumi.get(self, "time_offset_unit")


@pulumi.output_type
class GetHostAccessesAccessDemoFieldResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the parsed field.
        :param _builtins.str value: The value of the parsed field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the parsed field.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the parsed field.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetHostAccessesAccessProcessorResult(dict):
    def __init__(__self__, *,
                 detail: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str detail: The configuration of the parser, in JSON format.
        :param _builtins.str type: The type of the parser.
        """
        pulumi.set(__self__, "detail", detail)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def detail(self) -> _builtins.str:
        """
        The configuration of the parser, in JSON format.
        """
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the parser.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetHostGroupsGroupResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 host_ids: Sequence[_builtins.str],
                 id: _builtins.str,
                 name: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the host group, in RFC3339 format.
        :param Sequence[_builtins.str] host_ids: The ID list of hosts to associate with the host group.
        :param _builtins.str id: The ID of the host group.
        :param _builtins.str name: Speicifies the name of the host group.
        :param Mapping[str, _builtins.str] tags: Specifies the key/value pairs to associate with the host group.
        :param _builtins.str type: Speicifies the type of the host group.  
               The valid values are as follows:
               + **windows**
               + **linux**
        :param _builtins.str updated_at: The latest update time of the host group, in RFC3339 format.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "host_ids", host_ids)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the host group, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="hostIds")
    def host_ids(self) -> Sequence[_builtins.str]:
        """
        The ID list of hosts to associate with the host group.
        """
        return pulumi.get(self, "host_ids")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the host group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Speicifies the name of the host group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Specifies the key/value pairs to associate with the host group.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Speicifies the type of the host group.  
        The valid values are as follows:
        + **windows**
        + **linux**
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest update time of the host group, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetHostsFilterResult(dict):
    def __init__(__self__, *,
                 host_ip_lists: Optional[Sequence[_builtins.str]] = None,
                 host_name_lists: Optional[Sequence[_builtins.str]] = None,
                 host_status: Optional[_builtins.str] = None,
                 host_version: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] host_ip_lists: Specifies the list of the host IPs.
        :param Sequence[_builtins.str] host_name_lists: Specifies the list of the host names.
        :param _builtins.str host_status: Specifies the status of the host.  
               The valid values are as follows:
               + **uninstall**
               + **running**
               + **offline**
               + **error**
               + **plugin error**
               + **install-fail**
               + **upgrade failed**
               + **upgrade-fail**
               + **authentication error**
        :param _builtins.str host_version: Specifies the version of the host.
        """
        if host_ip_lists is not None:
            pulumi.set(__self__, "host_ip_lists", host_ip_lists)
        if host_name_lists is not None:
            pulumi.set(__self__, "host_name_lists", host_name_lists)
        if host_status is not None:
            pulumi.set(__self__, "host_status", host_status)
        if host_version is not None:
            pulumi.set(__self__, "host_version", host_version)

    @_builtins.property
    @pulumi.getter(name="hostIpLists")
    def host_ip_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of the host IPs.
        """
        return pulumi.get(self, "host_ip_lists")

    @_builtins.property
    @pulumi.getter(name="hostNameLists")
    def host_name_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of the host names.
        """
        return pulumi.get(self, "host_name_lists")

    @_builtins.property
    @pulumi.getter(name="hostStatus")
    def host_status(self) -> Optional[_builtins.str]:
        """
        Specifies the status of the host.  
        The valid values are as follows:
        + **uninstall**
        + **running**
        + **offline**
        + **error**
        + **plugin error**
        + **install-fail**
        + **upgrade failed**
        + **upgrade-fail**
        + **authentication error**
        """
        return pulumi.get(self, "host_status")

    @_builtins.property
    @pulumi.getter(name="hostVersion")
    def host_version(self) -> Optional[_builtins.str]:
        """
        Specifies the version of the host.
        """
        return pulumi.get(self, "host_version")


@pulumi.output_type
class GetHostsHostResult(dict):
    def __init__(__self__, *,
                 host_id: _builtins.str,
                 host_ip: _builtins.str,
                 host_name: _builtins.str,
                 host_status: _builtins.str,
                 host_type: _builtins.str,
                 host_version: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str host_id: The ID of the host.
        :param _builtins.str host_ip: The IP of the host.
        :param _builtins.str host_name: The name of the host.
        :param _builtins.str host_status: Specifies the status of the host.  
               The valid values are as follows:
               + **uninstall**
               + **running**
               + **offline**
               + **error**
               + **plugin error**
               + **install-fail**
               + **upgrade failed**
               + **upgrade-fail**
               + **authentication error**
        :param _builtins.str host_type: The type of the host.
               + **linux**
               + **windows**
        :param _builtins.str host_version: Specifies the version of the host.
        :param _builtins.str updated_at: The latest update time of the host, in RFC3339 format.
        """
        pulumi.set(__self__, "host_id", host_id)
        pulumi.set(__self__, "host_ip", host_ip)
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "host_status", host_status)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_version", host_version)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> _builtins.str:
        """
        The ID of the host.
        """
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostIp")
    def host_ip(self) -> _builtins.str:
        """
        The IP of the host.
        """
        return pulumi.get(self, "host_ip")

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> _builtins.str:
        """
        The name of the host.
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter(name="hostStatus")
    def host_status(self) -> _builtins.str:
        """
        Specifies the status of the host.  
        The valid values are as follows:
        + **uninstall**
        + **running**
        + **offline**
        + **error**
        + **plugin error**
        + **install-fail**
        + **upgrade failed**
        + **upgrade-fail**
        + **authentication error**
        """
        return pulumi.get(self, "host_status")

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> _builtins.str:
        """
        The type of the host.
        + **linux**
        + **windows**
        """
        return pulumi.get(self, "host_type")

    @_builtins.property
    @pulumi.getter(name="hostVersion")
    def host_version(self) -> _builtins.str:
        """
        Specifies the version of the host.
        """
        return pulumi.get(self, "host_version")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest update time of the host, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetKeywordAlarmRulesKeywordAlarmRuleResult(dict):
    def __init__(__self__, *,
                 alarm_action_rule_name: _builtins.str,
                 alarm_level: _builtins.str,
                 condition_expression: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 domain_id: _builtins.str,
                 frequencies: Sequence['outputs.GetKeywordAlarmRulesKeywordAlarmRuleFrequencyResult'],
                 id: _builtins.str,
                 keywords_requests: Sequence['outputs.GetKeywordAlarmRulesKeywordAlarmRuleKeywordsRequestResult'],
                 name: _builtins.str,
                 notification_frequency: _builtins.int,
                 recovery_frequency: _builtins.int,
                 send_notifications: _builtins.bool,
                 send_recovery_notifications: _builtins.bool,
                 status: _builtins.str,
                 template_name: _builtins.str,
                 topics: Sequence['outputs.GetKeywordAlarmRulesKeywordAlarmRuleTopicResult'],
                 trigger_condition_count: _builtins.int,
                 trigger_condition_frequency: _builtins.int,
                 updated_at: _builtins.str):
        """
        :param _builtins.str alarm_action_rule_name: The name of the alarm action rule associated with the keyword alarm rule.
        :param _builtins.str alarm_level: The level of the alarm.
               + **Info**
               + **Minor**
               + **Major**
               + **Critical**
        :param _builtins.str condition_expression: The condition expression of the keyword alarm rule.
        :param _builtins.str created_at: The creation time of the keyword alarm rule, in RFC3339 format.
        :param _builtins.str description: The description of the keyword alarm rule.
        :param _builtins.str domain_id: The ID of the domain to which the keyword alarm rule belongs.
        :param Sequence['GetKeywordAlarmRulesKeywordAlarmRuleFrequencyArgs'] frequencies: The configuration of the alarm query frequency.
        :param _builtins.str id: The ID of the keyword alarm rule.
        :param Sequence['GetKeywordAlarmRulesKeywordAlarmRuleKeywordsRequestArgs'] keywords_requests: The detail of the keyword alarm rule.
        :param _builtins.str name: The name of the topic.
        :param _builtins.int notification_frequency: The notification frequency of the alarm, in minutes.
               + **0**
               + **5**
               + **10**
               + **15**
               + **30**
               + **60**
               + **180**
               + **360**
        :param _builtins.int recovery_frequency: The frequency of recovery the alarm notification.
        :param _builtins.bool send_notifications: Whether to send notification.
        :param _builtins.bool send_recovery_notifications: Whether recovery notification is enabled.
        :param _builtins.str status: The status of the keyword alarm rule.
               + **RUNNING**
               + **STOPPING**: Stopped.
        :param _builtins.str template_name: The message templete name of the alarm action rule associated with the keyword alarm rule.
        :param Sequence['GetKeywordAlarmRulesKeywordAlarmRuleTopicArgs'] topics: The list of the SMN topics associated with the keyword alarm rule.
        :param _builtins.int trigger_condition_count: The count to trigger the alarm.
        :param _builtins.int trigger_condition_frequency: The frequency of trigger the alarm.
        :param _builtins.str updated_at: The update latest of the keyword alarm rule, in RFC3339 format.
        """
        pulumi.set(__self__, "alarm_action_rule_name", alarm_action_rule_name)
        pulumi.set(__self__, "alarm_level", alarm_level)
        pulumi.set(__self__, "condition_expression", condition_expression)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "frequencies", frequencies)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "keywords_requests", keywords_requests)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_frequency", notification_frequency)
        pulumi.set(__self__, "recovery_frequency", recovery_frequency)
        pulumi.set(__self__, "send_notifications", send_notifications)
        pulumi.set(__self__, "send_recovery_notifications", send_recovery_notifications)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "trigger_condition_count", trigger_condition_count)
        pulumi.set(__self__, "trigger_condition_frequency", trigger_condition_frequency)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="alarmActionRuleName")
    def alarm_action_rule_name(self) -> _builtins.str:
        """
        The name of the alarm action rule associated with the keyword alarm rule.
        """
        return pulumi.get(self, "alarm_action_rule_name")

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> _builtins.str:
        """
        The level of the alarm.
        + **Info**
        + **Minor**
        + **Major**
        + **Critical**
        """
        return pulumi.get(self, "alarm_level")

    @_builtins.property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> _builtins.str:
        """
        The condition expression of the keyword alarm rule.
        """
        return pulumi.get(self, "condition_expression")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the keyword alarm rule, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the keyword alarm rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        """
        The ID of the domain to which the keyword alarm rule belongs.
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter
    def frequencies(self) -> Sequence['outputs.GetKeywordAlarmRulesKeywordAlarmRuleFrequencyResult']:
        """
        The configuration of the alarm query frequency.
        """
        return pulumi.get(self, "frequencies")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the keyword alarm rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keywordsRequests")
    def keywords_requests(self) -> Sequence['outputs.GetKeywordAlarmRulesKeywordAlarmRuleKeywordsRequestResult']:
        """
        The detail of the keyword alarm rule.
        """
        return pulumi.get(self, "keywords_requests")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notificationFrequency")
    def notification_frequency(self) -> _builtins.int:
        """
        The notification frequency of the alarm, in minutes.
        + **0**
        + **5**
        + **10**
        + **15**
        + **30**
        + **60**
        + **180**
        + **360**
        """
        return pulumi.get(self, "notification_frequency")

    @_builtins.property
    @pulumi.getter(name="recoveryFrequency")
    def recovery_frequency(self) -> _builtins.int:
        """
        The frequency of recovery the alarm notification.
        """
        return pulumi.get(self, "recovery_frequency")

    @_builtins.property
    @pulumi.getter(name="sendNotifications")
    def send_notifications(self) -> _builtins.bool:
        """
        Whether to send notification.
        """
        return pulumi.get(self, "send_notifications")

    @_builtins.property
    @pulumi.getter(name="sendRecoveryNotifications")
    def send_recovery_notifications(self) -> _builtins.bool:
        """
        Whether recovery notification is enabled.
        """
        return pulumi.get(self, "send_recovery_notifications")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the keyword alarm rule.
        + **RUNNING**
        + **STOPPING**: Stopped.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        The message templete name of the alarm action rule associated with the keyword alarm rule.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence['outputs.GetKeywordAlarmRulesKeywordAlarmRuleTopicResult']:
        """
        The list of the SMN topics associated with the keyword alarm rule.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="triggerConditionCount")
    def trigger_condition_count(self) -> _builtins.int:
        """
        The count to trigger the alarm.
        """
        return pulumi.get(self, "trigger_condition_count")

    @_builtins.property
    @pulumi.getter(name="triggerConditionFrequency")
    def trigger_condition_frequency(self) -> _builtins.int:
        """
        The frequency of trigger the alarm.
        """
        return pulumi.get(self, "trigger_condition_frequency")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The update latest of the keyword alarm rule, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetKeywordAlarmRulesKeywordAlarmRuleFrequencyResult(dict):
    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 day_of_week: _builtins.int,
                 fixed_rate: _builtins.int,
                 fixed_rate_unit: _builtins.str,
                 hour_of_day: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str cron_expression: The cron expression.
        :param _builtins.int day_of_week: The day of week.
        :param _builtins.int fixed_rate: The times of custom interval for querying alarm.
        :param _builtins.str fixed_rate_unit: The unit of custom interval for querying alarm.
               + **minute**
               + **hour**
        :param _builtins.int hour_of_day: The hour of day.
        :param _builtins.str type: The frequency type of statistical alarm.
               + **CRON**
               + **HOURLY**
               + **DAILY**
               + **WEEKLY**
               + **FIXED_RATE**
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "fixed_rate", fixed_rate)
        pulumi.set(__self__, "fixed_rate_unit", fixed_rate_unit)
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        The cron expression.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.int:
        """
        The day of week.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> _builtins.int:
        """
        The times of custom interval for querying alarm.
        """
        return pulumi.get(self, "fixed_rate")

    @_builtins.property
    @pulumi.getter(name="fixedRateUnit")
    def fixed_rate_unit(self) -> _builtins.str:
        """
        The unit of custom interval for querying alarm.
        + **minute**
        + **hour**
        """
        return pulumi.get(self, "fixed_rate_unit")

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> _builtins.int:
        """
        The hour of day.
        """
        return pulumi.get(self, "hour_of_day")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The frequency type of statistical alarm.
        + **CRON**
        + **HOURLY**
        + **DAILY**
        + **WEEKLY**
        + **FIXED_RATE**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetKeywordAlarmRulesKeywordAlarmRuleKeywordsRequestResult(dict):
    def __init__(__self__, *,
                 condition: _builtins.str,
                 keywords: _builtins.str,
                 log_group_id: _builtins.str,
                 log_group_name: _builtins.str,
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str,
                 number: _builtins.int,
                 search_time_range: _builtins.int,
                 search_time_range_unit: _builtins.str):
        """
        :param _builtins.str condition: The condition for triggering the alarm.
               + **>**
               + **<**
               + **>=**
               + **<=**
        :param _builtins.str keywords: The keyword in the queried logs.
        :param _builtins.str log_group_id: The ID of the log group to which the queried logs belong.
        :param _builtins.str log_group_name: The name of the log stream to which the queried logs belong.
        :param _builtins.str log_stream_id: The ID of the log stream to which the queried logs belong.
        :param _builtins.str log_stream_name: The name of the log stream to which the queried logs belong.
        :param _builtins.int number: The maximum number of logs containing the keyword that trigger the alarm.
        :param _builtins.int search_time_range: The search time range for querying the logs.
               + **minute**
               + **hour**
        :param _builtins.str search_time_range_unit: The unit of search time range for querying the logs.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "keywords", keywords)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "search_time_range", search_time_range)
        pulumi.set(__self__, "search_time_range_unit", search_time_range_unit)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        The condition for triggering the alarm.
        + **>**
        + **<**
        + **>=**
        + **<=**
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def keywords(self) -> _builtins.str:
        """
        The keyword in the queried logs.
        """
        return pulumi.get(self, "keywords")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        The ID of the log group to which the queried logs belong.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        The name of the log stream to which the queried logs belong.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The ID of the log stream to which the queried logs belong.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        The name of the log stream to which the queried logs belong.
        """
        return pulumi.get(self, "log_stream_name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        The maximum number of logs containing the keyword that trigger the alarm.
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="searchTimeRange")
    def search_time_range(self) -> _builtins.int:
        """
        The search time range for querying the logs.
        + **minute**
        + **hour**
        """
        return pulumi.get(self, "search_time_range")

    @_builtins.property
    @pulumi.getter(name="searchTimeRangeUnit")
    def search_time_range_unit(self) -> _builtins.str:
        """
        The unit of search time range for querying the logs.
        """
        return pulumi.get(self, "search_time_range_unit")


@pulumi.output_type
class GetKeywordAlarmRulesKeywordAlarmRuleTopicResult(dict):
    def __init__(__self__, *,
                 display_name: _builtins.str,
                 name: _builtins.str,
                 push_policy: _builtins.int,
                 topic_urn: _builtins.str):
        """
        :param _builtins.str display_name: The display name of the topic.
        :param _builtins.str name: The name of the topic.
        :param _builtins.int push_policy: The push policy of the topic.
        :param _builtins.str topic_urn: The URN of the topic.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "push_policy", push_policy)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name of the topic.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> _builtins.int:
        """
        The push policy of the topic.
        """
        return pulumi.get(self, "push_policy")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        The URN of the topic.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetNotificationTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 locale: _builtins.str,
                 name: _builtins.str,
                 source: _builtins.str,
                 templates: Sequence['outputs.GetNotificationTemplatesTemplateTemplateResult'],
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the log group, in RFC3339 format.
        :param _builtins.str description: The description of the notification template.
        :param _builtins.str locale: The language of the notification template.
        :param _builtins.str name: The name of the notification template.
        :param _builtins.str source: The source of the notification template.
        :param Sequence['GetNotificationTemplatesTemplateTemplateArgs'] templates: The list of notification template bodies.
        :param _builtins.str updated_at: The latest update time of the log group, in RFC3339 format.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "templates", templates)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the log group, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the notification template.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> _builtins.str:
        """
        The language of the notification template.
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the notification template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the notification template.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Sequence['outputs.GetNotificationTemplatesTemplateTemplateResult']:
        """
        The list of notification template bodies.
        """
        return pulumi.get(self, "templates")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest update time of the log group, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetNotificationTemplatesTemplateTemplateResult(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 sub_type: _builtins.str):
        """
        :param _builtins.str content: The content of the template body.
        :param _builtins.str sub_type: The type of the template body.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "sub_type", sub_type)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The content of the template body.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> _builtins.str:
        """
        The type of the template body.
        """
        return pulumi.get(self, "sub_type")


@pulumi.output_type
class GetSearchCriteriaSearchCriteriaResult(dict):
    def __init__(__self__, *,
                 criterias: Sequence['outputs.GetSearchCriteriaSearchCriteriaCriteriaResult'],
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str):
        """
        :param Sequence['GetSearchCriteriaSearchCriteriaCriteriaArgs'] criterias: The content of search criterion.
        :param _builtins.str log_stream_id: The ID of the log stream.
        :param _builtins.str log_stream_name: The name of the log stream.
        """
        pulumi.set(__self__, "criterias", criterias)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Sequence['outputs.GetSearchCriteriaSearchCriteriaCriteriaResult']:
        """
        The content of search criterion.
        """
        return pulumi.get(self, "criterias")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The ID of the log stream.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        The name of the log stream.
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class GetSearchCriteriaSearchCriteriaCriteriaResult(dict):
    def __init__(__self__, *,
                 criteria: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str criteria: The content of search criterion.
        :param _builtins.str id: The ID of the search criterion.
        :param _builtins.str name: The name of the search criterion.
        :param _builtins.str type: The name of the search criterion.
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> _builtins.str:
        """
        The content of search criterion.
        """
        return pulumi.get(self, "criteria")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the search criterion.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the search criterion.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The name of the search criterion.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSqlAlarmRulesSqlAlarmRuleResult(dict):
    def __init__(__self__, *,
                 alarm_action_rule_name: _builtins.str,
                 alarm_level: _builtins.str,
                 condition_expression: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 domain_id: _builtins.str,
                 frequencies: Sequence['outputs.GetSqlAlarmRulesSqlAlarmRuleFrequencyResult'],
                 id: _builtins.str,
                 name: _builtins.str,
                 notification_frequency: _builtins.int,
                 recovery_frequency: _builtins.int,
                 send_notifications: _builtins.bool,
                 send_recovery_notifications: _builtins.bool,
                 sql_requests: Sequence['outputs.GetSqlAlarmRulesSqlAlarmRuleSqlRequestResult'],
                 status: _builtins.str,
                 template_name: _builtins.str,
                 topics: Sequence['outputs.GetSqlAlarmRulesSqlAlarmRuleTopicResult'],
                 trigger_condition_count: _builtins.int,
                 trigger_condition_frequency: _builtins.int,
                 updated_at: _builtins.str):
        """
        :param _builtins.str alarm_action_rule_name: The name of the alarm action rule associated with the SQL alarm rule.
        :param _builtins.str alarm_level: The level of the alarm.
               + **Info**
               + **Minor**
               + **Major**
               + **Critical**
        :param _builtins.str condition_expression: The condition expression.
        :param _builtins.str created_at: The creation time of the SQL alarm rule, in RFC3339 format.
        :param _builtins.str description: The description of the SQL alarm rule.
        :param _builtins.str domain_id: The ID of the domain to which the SQL alarm rule belongs.
        :param Sequence['GetSqlAlarmRulesSqlAlarmRuleFrequencyArgs'] frequencies: The alarm frequency configuration list.
        :param _builtins.str id: The ID of the SQL alarm rule.
        :param _builtins.str name: The name of the topic.
        :param _builtins.int notification_frequency: The notification frequency of the alarm, in minutes.
               + **0**
               + **5**
               + **10**
               + **15**
               + **30**
               + **60**
               + **180**
               + **360**
        :param _builtins.int recovery_frequency: The frequency of recovery the alarm notification.
        :param _builtins.bool send_notifications: Whether to send notification.
        :param _builtins.bool send_recovery_notifications: Whether to send recovery notification.
        :param Sequence['GetSqlAlarmRulesSqlAlarmRuleSqlRequestArgs'] sql_requests: The request list of the SQL alarm rule.
        :param _builtins.str status: The status of the SQL alarm rule.
               + **RUNNING**
               + **STOPPING**: Stopped.
        :param _builtins.str template_name: The message template name of the alarm action rule associated with the SQL alarm rule.
        :param Sequence['GetSqlAlarmRulesSqlAlarmRuleTopicArgs'] topics: The list of the SMN topics associated with the SQL alarm rule.
        :param _builtins.int trigger_condition_count: The count to trigger the alarm.
        :param _builtins.int trigger_condition_frequency: The frequency to trigger the alarm.
        :param _builtins.str updated_at: The latest update of the SQL alarm rule, in RFC3339 format.
        """
        pulumi.set(__self__, "alarm_action_rule_name", alarm_action_rule_name)
        pulumi.set(__self__, "alarm_level", alarm_level)
        pulumi.set(__self__, "condition_expression", condition_expression)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "frequencies", frequencies)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_frequency", notification_frequency)
        pulumi.set(__self__, "recovery_frequency", recovery_frequency)
        pulumi.set(__self__, "send_notifications", send_notifications)
        pulumi.set(__self__, "send_recovery_notifications", send_recovery_notifications)
        pulumi.set(__self__, "sql_requests", sql_requests)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "topics", topics)
        pulumi.set(__self__, "trigger_condition_count", trigger_condition_count)
        pulumi.set(__self__, "trigger_condition_frequency", trigger_condition_frequency)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="alarmActionRuleName")
    def alarm_action_rule_name(self) -> _builtins.str:
        """
        The name of the alarm action rule associated with the SQL alarm rule.
        """
        return pulumi.get(self, "alarm_action_rule_name")

    @_builtins.property
    @pulumi.getter(name="alarmLevel")
    def alarm_level(self) -> _builtins.str:
        """
        The level of the alarm.
        + **Info**
        + **Minor**
        + **Major**
        + **Critical**
        """
        return pulumi.get(self, "alarm_level")

    @_builtins.property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> _builtins.str:
        """
        The condition expression.
        """
        return pulumi.get(self, "condition_expression")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the SQL alarm rule, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the SQL alarm rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        """
        The ID of the domain to which the SQL alarm rule belongs.
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter
    def frequencies(self) -> Sequence['outputs.GetSqlAlarmRulesSqlAlarmRuleFrequencyResult']:
        """
        The alarm frequency configuration list.
        """
        return pulumi.get(self, "frequencies")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the SQL alarm rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notificationFrequency")
    def notification_frequency(self) -> _builtins.int:
        """
        The notification frequency of the alarm, in minutes.
        + **0**
        + **5**
        + **10**
        + **15**
        + **30**
        + **60**
        + **180**
        + **360**
        """
        return pulumi.get(self, "notification_frequency")

    @_builtins.property
    @pulumi.getter(name="recoveryFrequency")
    def recovery_frequency(self) -> _builtins.int:
        """
        The frequency of recovery the alarm notification.
        """
        return pulumi.get(self, "recovery_frequency")

    @_builtins.property
    @pulumi.getter(name="sendNotifications")
    def send_notifications(self) -> _builtins.bool:
        """
        Whether to send notification.
        """
        return pulumi.get(self, "send_notifications")

    @_builtins.property
    @pulumi.getter(name="sendRecoveryNotifications")
    def send_recovery_notifications(self) -> _builtins.bool:
        """
        Whether to send recovery notification.
        """
        return pulumi.get(self, "send_recovery_notifications")

    @_builtins.property
    @pulumi.getter(name="sqlRequests")
    def sql_requests(self) -> Sequence['outputs.GetSqlAlarmRulesSqlAlarmRuleSqlRequestResult']:
        """
        The request list of the SQL alarm rule.
        """
        return pulumi.get(self, "sql_requests")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the SQL alarm rule.
        + **RUNNING**
        + **STOPPING**: Stopped.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        The message template name of the alarm action rule associated with the SQL alarm rule.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def topics(self) -> Sequence['outputs.GetSqlAlarmRulesSqlAlarmRuleTopicResult']:
        """
        The list of the SMN topics associated with the SQL alarm rule.
        """
        return pulumi.get(self, "topics")

    @_builtins.property
    @pulumi.getter(name="triggerConditionCount")
    def trigger_condition_count(self) -> _builtins.int:
        """
        The count to trigger the alarm.
        """
        return pulumi.get(self, "trigger_condition_count")

    @_builtins.property
    @pulumi.getter(name="triggerConditionFrequency")
    def trigger_condition_frequency(self) -> _builtins.int:
        """
        The frequency to trigger the alarm.
        """
        return pulumi.get(self, "trigger_condition_frequency")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest update of the SQL alarm rule, in RFC3339 format.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetSqlAlarmRulesSqlAlarmRuleFrequencyResult(dict):
    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 day_of_week: _builtins.int,
                 fixed_rate: _builtins.int,
                 fixed_rate_unit: _builtins.str,
                 hour_of_day: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str cron_expression: The cron expression.
        :param _builtins.int day_of_week: The day of week.
        :param _builtins.int fixed_rate: The times of custom interval for querying alarm.
        :param _builtins.str fixed_rate_unit: The unit of custom interval for querying alarm.
               + **minute**
               + **hour**
        :param _builtins.int hour_of_day: The hour of day.
        :param _builtins.str type: The type of the frequency.
               + **CRON**
               + **HOURLY**
               + **DAILY**
               + **WEEKLY**
               + **FIXED_RATE**
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "fixed_rate", fixed_rate)
        pulumi.set(__self__, "fixed_rate_unit", fixed_rate_unit)
        pulumi.set(__self__, "hour_of_day", hour_of_day)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        The cron expression.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.int:
        """
        The day of week.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> _builtins.int:
        """
        The times of custom interval for querying alarm.
        """
        return pulumi.get(self, "fixed_rate")

    @_builtins.property
    @pulumi.getter(name="fixedRateUnit")
    def fixed_rate_unit(self) -> _builtins.str:
        """
        The unit of custom interval for querying alarm.
        + **minute**
        + **hour**
        """
        return pulumi.get(self, "fixed_rate_unit")

    @_builtins.property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> _builtins.int:
        """
        The hour of day.
        """
        return pulumi.get(self, "hour_of_day")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the frequency.
        + **CRON**
        + **HOURLY**
        + **DAILY**
        + **WEEKLY**
        + **FIXED_RATE**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSqlAlarmRulesSqlAlarmRuleSqlRequestResult(dict):
    def __init__(__self__, *,
                 is_time_range_relative: _builtins.bool,
                 log_group_id: _builtins.str,
                 log_group_name: _builtins.str,
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str,
                 search_time_range: _builtins.int,
                 search_time_range_unit: _builtins.str,
                 sql: _builtins.str,
                 title: _builtins.str):
        """
        :param _builtins.bool is_time_range_relative: The SQL request is relative to time range.
        :param _builtins.str log_group_id: The ID of the log group.
        :param _builtins.str log_group_name: The name of the log group.
        :param _builtins.str log_stream_id: The ID of the log stream.
        :param _builtins.str log_stream_name: The name of the log stream.
        :param _builtins.int search_time_range: The search time range.
        :param _builtins.str search_time_range_unit: The unit of search time range.
               + **minute**
               + **hour**
        :param _builtins.str sql: The SQL statement.
        :param _builtins.str title: The title of the SQL request.
        """
        pulumi.set(__self__, "is_time_range_relative", is_time_range_relative)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)
        pulumi.set(__self__, "search_time_range", search_time_range)
        pulumi.set(__self__, "search_time_range_unit", search_time_range_unit)
        pulumi.set(__self__, "sql", sql)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="isTimeRangeRelative")
    def is_time_range_relative(self) -> _builtins.bool:
        """
        The SQL request is relative to time range.
        """
        return pulumi.get(self, "is_time_range_relative")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        The ID of the log group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        The name of the log group.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The ID of the log stream.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        The name of the log stream.
        """
        return pulumi.get(self, "log_stream_name")

    @_builtins.property
    @pulumi.getter(name="searchTimeRange")
    def search_time_range(self) -> _builtins.int:
        """
        The search time range.
        """
        return pulumi.get(self, "search_time_range")

    @_builtins.property
    @pulumi.getter(name="searchTimeRangeUnit")
    def search_time_range_unit(self) -> _builtins.str:
        """
        The unit of search time range.
        + **minute**
        + **hour**
        """
        return pulumi.get(self, "search_time_range_unit")

    @_builtins.property
    @pulumi.getter
    def sql(self) -> _builtins.str:
        """
        The SQL statement.
        """
        return pulumi.get(self, "sql")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the SQL request.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSqlAlarmRulesSqlAlarmRuleTopicResult(dict):
    def __init__(__self__, *,
                 display_name: _builtins.str,
                 name: _builtins.str,
                 push_policy: _builtins.int,
                 topic_urn: _builtins.str):
        """
        :param _builtins.str display_name: The display name of the topic.
        :param _builtins.str name: The name of the topic.
        :param _builtins.int push_policy: The push policy of the topic.
        :param _builtins.str topic_urn: The URN of the topic.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "push_policy", push_policy)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name of the topic.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> _builtins.int:
        """
        The push policy of the topic.
        """
        return pulumi.get(self, "push_policy")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        The URN of the topic.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetStreamsStreamResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 ttl_in_days: _builtins.int):
        """
        :param _builtins.str created_at: The creation time of the log stream, in RFC3339 format.
        :param _builtins.str id: The ID of the log stream.
        :param _builtins.str name: Specifies the name of the log stream.
        :param Mapping[str, _builtins.str] tags: The key/value pairs to associate with the log stream.
        :param _builtins.int ttl_in_days: The log expiration time (days).
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "ttl_in_days", ttl_in_days)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the log stream, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the log stream.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the log stream.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to associate with the log stream.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="ttlInDays")
    def ttl_in_days(self) -> _builtins.int:
        """
        The log expiration time (days).
        """
        return pulumi.get(self, "ttl_in_days")


@pulumi.output_type
class GetStructuringCustomTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 demo_log: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str demo_log: The sample log event.
        :param _builtins.str id: The structuring custom template ID.
        :param _builtins.str name: Specifies the custom template name to be queried.
        :param _builtins.str type: Specifies the custom template type to be queried. Valid values are: **regex**, **json**,
               **split** and **nginx**.
        """
        pulumi.set(__self__, "demo_log", demo_log)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="demoLog")
    def demo_log(self) -> _builtins.str:
        """
        The sample log event.
        """
        return pulumi.get(self, "demo_log")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The structuring custom template ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the custom template name to be queried.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the custom template type to be queried. Valid values are: **regex**, **json**,
        **split** and **nginx**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTransfersTransferResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 log_group_id: _builtins.str,
                 log_group_name: _builtins.str,
                 log_streams: Sequence['outputs.GetTransfersTransferLogStreamResult'],
                 log_transfer_infos: Sequence['outputs.GetTransfersTransferLogTransferInfoResult']):
        """
        :param _builtins.str id: The ID of the transfer.
        :param _builtins.str log_group_id: The ID of the log group to which the log transfer belongs.
        :param _builtins.str log_group_name: Specifies the name of the log group to which the log transfers and log streams
               belong.
        :param Sequence['GetTransfersTransferLogStreamArgs'] log_streams: The configuration of the log streams that to be transferred.  
               The log_streams structure is documented below.
        :param Sequence['GetTransfersTransferLogTransferInfoArgs'] log_transfer_infos: The configuration of the log transfer.  
               The log_transfer_info structure is documented below.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "log_streams", log_streams)
        pulumi.set(__self__, "log_transfer_infos", log_transfer_infos)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the transfer.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        The ID of the log group to which the log transfer belongs.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> _builtins.str:
        """
        Specifies the name of the log group to which the log transfers and log streams
        belong.
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreams")
    def log_streams(self) -> Sequence['outputs.GetTransfersTransferLogStreamResult']:
        """
        The configuration of the log streams that to be transferred.  
        The log_streams structure is documented below.
        """
        return pulumi.get(self, "log_streams")

    @_builtins.property
    @pulumi.getter(name="logTransferInfos")
    def log_transfer_infos(self) -> Sequence['outputs.GetTransfersTransferLogTransferInfoResult']:
        """
        The configuration of the log transfer.  
        The log_transfer_info structure is documented below.
        """
        return pulumi.get(self, "log_transfer_infos")


@pulumi.output_type
class GetTransfersTransferLogStreamResult(dict):
    def __init__(__self__, *,
                 log_stream_id: _builtins.str,
                 log_stream_name: _builtins.str):
        """
        :param _builtins.str log_stream_id: The ID of the log stream.
        :param _builtins.str log_stream_name: Specifies the name of the log stream to be transferred in the log transfer.
        """
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "log_stream_name", log_stream_name)

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The ID of the log stream.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="logStreamName")
    def log_stream_name(self) -> _builtins.str:
        """
        Specifies the name of the log stream to be transferred in the log transfer.
        """
        return pulumi.get(self, "log_stream_name")


@pulumi.output_type
class GetTransfersTransferLogTransferInfoResult(dict):
    def __init__(__self__, *,
                 log_agency_transfers: Sequence['outputs.GetTransfersTransferLogTransferInfoLogAgencyTransferResult'],
                 log_storage_format: _builtins.str,
                 log_transfer_details: Sequence['outputs.GetTransfersTransferLogTransferInfoLogTransferDetailResult'],
                 log_transfer_mode: _builtins.str,
                 log_transfer_status: _builtins.str,
                 log_transfer_type: _builtins.str):
        """
        :param Sequence['GetTransfersTransferLogTransferInfoLogAgencyTransferArgs'] log_agency_transfers: The configuration of the agency transfer.  
               The log_agency_transfer structure is documented below.
        :param _builtins.str log_storage_format: The format of the log transfer.
        :param Sequence['GetTransfersTransferLogTransferInfoLogTransferDetailArgs'] log_transfer_details: The detail of the log transfer configuration.  
               The log_transfer_detail structure is documented below.
        :param _builtins.str log_transfer_mode: The mode of the log transfer.
        :param _builtins.str log_transfer_status: The status of the log transfer.
        :param _builtins.str log_transfer_type: The type of the log transfer.
        """
        pulumi.set(__self__, "log_agency_transfers", log_agency_transfers)
        pulumi.set(__self__, "log_storage_format", log_storage_format)
        pulumi.set(__self__, "log_transfer_details", log_transfer_details)
        pulumi.set(__self__, "log_transfer_mode", log_transfer_mode)
        pulumi.set(__self__, "log_transfer_status", log_transfer_status)
        pulumi.set(__self__, "log_transfer_type", log_transfer_type)

    @_builtins.property
    @pulumi.getter(name="logAgencyTransfers")
    def log_agency_transfers(self) -> Sequence['outputs.GetTransfersTransferLogTransferInfoLogAgencyTransferResult']:
        """
        The configuration of the agency transfer.  
        The log_agency_transfer structure is documented below.
        """
        return pulumi.get(self, "log_agency_transfers")

    @_builtins.property
    @pulumi.getter(name="logStorageFormat")
    def log_storage_format(self) -> _builtins.str:
        """
        The format of the log transfer.
        """
        return pulumi.get(self, "log_storage_format")

    @_builtins.property
    @pulumi.getter(name="logTransferDetails")
    def log_transfer_details(self) -> Sequence['outputs.GetTransfersTransferLogTransferInfoLogTransferDetailResult']:
        """
        The detail of the log transfer configuration.  
        The log_transfer_detail structure is documented below.
        """
        return pulumi.get(self, "log_transfer_details")

    @_builtins.property
    @pulumi.getter(name="logTransferMode")
    def log_transfer_mode(self) -> _builtins.str:
        """
        The mode of the log transfer.
        """
        return pulumi.get(self, "log_transfer_mode")

    @_builtins.property
    @pulumi.getter(name="logTransferStatus")
    def log_transfer_status(self) -> _builtins.str:
        """
        The status of the log transfer.
        """
        return pulumi.get(self, "log_transfer_status")

    @_builtins.property
    @pulumi.getter(name="logTransferType")
    def log_transfer_type(self) -> _builtins.str:
        """
        The type of the log transfer.
        """
        return pulumi.get(self, "log_transfer_type")


@pulumi.output_type
class GetTransfersTransferLogTransferInfoLogAgencyTransferResult(dict):
    def __init__(__self__, *,
                 agency_domain_id: _builtins.str,
                 agency_domain_name: _builtins.str,
                 agency_name: _builtins.str,
                 agency_project_id: _builtins.str):
        """
        :param _builtins.str agency_domain_id: The ID of the delegator account.
        :param _builtins.str agency_domain_name: The name of the delegator account.
        :param _builtins.str agency_name: The agency name created by the delegator account.
        :param _builtins.str agency_project_id: The project ID of the delegator account.
        """
        pulumi.set(__self__, "agency_domain_id", agency_domain_id)
        pulumi.set(__self__, "agency_domain_name", agency_domain_name)
        pulumi.set(__self__, "agency_name", agency_name)
        pulumi.set(__self__, "agency_project_id", agency_project_id)

    @_builtins.property
    @pulumi.getter(name="agencyDomainId")
    def agency_domain_id(self) -> _builtins.str:
        """
        The ID of the delegator account.
        """
        return pulumi.get(self, "agency_domain_id")

    @_builtins.property
    @pulumi.getter(name="agencyDomainName")
    def agency_domain_name(self) -> _builtins.str:
        """
        The name of the delegator account.
        """
        return pulumi.get(self, "agency_domain_name")

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> _builtins.str:
        """
        The agency name created by the delegator account.
        """
        return pulumi.get(self, "agency_name")

    @_builtins.property
    @pulumi.getter(name="agencyProjectId")
    def agency_project_id(self) -> _builtins.str:
        """
        The project ID of the delegator account.
        """
        return pulumi.get(self, "agency_project_id")


@pulumi.output_type
class GetTransfersTransferLogTransferInfoLogTransferDetailResult(dict):
    def __init__(__self__, *,
                 delivery_tags: Sequence[_builtins.str],
                 dis_id: _builtins.str,
                 dis_name: _builtins.str,
                 kafka_id: _builtins.str,
                 kafka_topic: _builtins.str,
                 obs_bucket_name: _builtins.str,
                 obs_dir_prefix_name: _builtins.str,
                 obs_encrypted_enable: _builtins.bool,
                 obs_encrypted_id: _builtins.str,
                 obs_eps_id: _builtins.str,
                 obs_period: _builtins.int,
                 obs_period_unit: _builtins.str,
                 obs_prefix_name: _builtins.str,
                 obs_time_zone: _builtins.str,
                 obs_time_zone_id: _builtins.str,
                 obs_transfer_path: _builtins.str):
        """
        :param Sequence[_builtins.str] delivery_tags: The list of tag fields will be delivered when transferring.
        :param _builtins.str dis_id: The ID of the DIS stream.
        :param _builtins.str dis_name: The name of the DIS stream.
        :param _builtins.str kafka_id: The ID of the kafka instance.
        :param _builtins.str kafka_topic: The kafka topic.
        :param _builtins.str obs_bucket_name: The name of the OBS bucket, which is the log transfer destination object.
        :param _builtins.str obs_dir_prefix_name: The custom prefix of the transfer path.
        :param _builtins.bool obs_encrypted_enable: Whether OBS bucket encryption is enabled.
        :param _builtins.str obs_encrypted_id: The KMS key ID for an OBS transfer task.
        :param _builtins.str obs_eps_id: The enterprise project ID of an OBS transfer task.
        :param _builtins.int obs_period: The length of the transfer interval for an OBS transfer task.
        :param _builtins.str obs_period_unit: The unit of the transfer interval for an OBS transfer task.
        :param _builtins.str obs_prefix_name: The transfer file prefix of an OBS transfer task.
        :param _builtins.str obs_time_zone: The time zone for an OBS transfer task.
        :param _builtins.str obs_time_zone_id: ID of the time zone for an OBS transfer task.
        :param _builtins.str obs_transfer_path: The storage path of the OBS bucket, which is the log transfer destination.
        """
        pulumi.set(__self__, "delivery_tags", delivery_tags)
        pulumi.set(__self__, "dis_id", dis_id)
        pulumi.set(__self__, "dis_name", dis_name)
        pulumi.set(__self__, "kafka_id", kafka_id)
        pulumi.set(__self__, "kafka_topic", kafka_topic)
        pulumi.set(__self__, "obs_bucket_name", obs_bucket_name)
        pulumi.set(__self__, "obs_dir_prefix_name", obs_dir_prefix_name)
        pulumi.set(__self__, "obs_encrypted_enable", obs_encrypted_enable)
        pulumi.set(__self__, "obs_encrypted_id", obs_encrypted_id)
        pulumi.set(__self__, "obs_eps_id", obs_eps_id)
        pulumi.set(__self__, "obs_period", obs_period)
        pulumi.set(__self__, "obs_period_unit", obs_period_unit)
        pulumi.set(__self__, "obs_prefix_name", obs_prefix_name)
        pulumi.set(__self__, "obs_time_zone", obs_time_zone)
        pulumi.set(__self__, "obs_time_zone_id", obs_time_zone_id)
        pulumi.set(__self__, "obs_transfer_path", obs_transfer_path)

    @_builtins.property
    @pulumi.getter(name="deliveryTags")
    def delivery_tags(self) -> Sequence[_builtins.str]:
        """
        The list of tag fields will be delivered when transferring.
        """
        return pulumi.get(self, "delivery_tags")

    @_builtins.property
    @pulumi.getter(name="disId")
    def dis_id(self) -> _builtins.str:
        """
        The ID of the DIS stream.
        """
        return pulumi.get(self, "dis_id")

    @_builtins.property
    @pulumi.getter(name="disName")
    def dis_name(self) -> _builtins.str:
        """
        The name of the DIS stream.
        """
        return pulumi.get(self, "dis_name")

    @_builtins.property
    @pulumi.getter(name="kafkaId")
    def kafka_id(self) -> _builtins.str:
        """
        The ID of the kafka instance.
        """
        return pulumi.get(self, "kafka_id")

    @_builtins.property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> _builtins.str:
        """
        The kafka topic.
        """
        return pulumi.get(self, "kafka_topic")

    @_builtins.property
    @pulumi.getter(name="obsBucketName")
    def obs_bucket_name(self) -> _builtins.str:
        """
        The name of the OBS bucket, which is the log transfer destination object.
        """
        return pulumi.get(self, "obs_bucket_name")

    @_builtins.property
    @pulumi.getter(name="obsDirPrefixName")
    def obs_dir_prefix_name(self) -> _builtins.str:
        """
        The custom prefix of the transfer path.
        """
        return pulumi.get(self, "obs_dir_prefix_name")

    @_builtins.property
    @pulumi.getter(name="obsEncryptedEnable")
    def obs_encrypted_enable(self) -> _builtins.bool:
        """
        Whether OBS bucket encryption is enabled.
        """
        return pulumi.get(self, "obs_encrypted_enable")

    @_builtins.property
    @pulumi.getter(name="obsEncryptedId")
    def obs_encrypted_id(self) -> _builtins.str:
        """
        The KMS key ID for an OBS transfer task.
        """
        return pulumi.get(self, "obs_encrypted_id")

    @_builtins.property
    @pulumi.getter(name="obsEpsId")
    def obs_eps_id(self) -> _builtins.str:
        """
        The enterprise project ID of an OBS transfer task.
        """
        return pulumi.get(self, "obs_eps_id")

    @_builtins.property
    @pulumi.getter(name="obsPeriod")
    def obs_period(self) -> _builtins.int:
        """
        The length of the transfer interval for an OBS transfer task.
        """
        return pulumi.get(self, "obs_period")

    @_builtins.property
    @pulumi.getter(name="obsPeriodUnit")
    def obs_period_unit(self) -> _builtins.str:
        """
        The unit of the transfer interval for an OBS transfer task.
        """
        return pulumi.get(self, "obs_period_unit")

    @_builtins.property
    @pulumi.getter(name="obsPrefixName")
    def obs_prefix_name(self) -> _builtins.str:
        """
        The transfer file prefix of an OBS transfer task.
        """
        return pulumi.get(self, "obs_prefix_name")

    @_builtins.property
    @pulumi.getter(name="obsTimeZone")
    def obs_time_zone(self) -> _builtins.str:
        """
        The time zone for an OBS transfer task.
        """
        return pulumi.get(self, "obs_time_zone")

    @_builtins.property
    @pulumi.getter(name="obsTimeZoneId")
    def obs_time_zone_id(self) -> _builtins.str:
        """
        ID of the time zone for an OBS transfer task.
        """
        return pulumi.get(self, "obs_time_zone_id")

    @_builtins.property
    @pulumi.getter(name="obsTransferPath")
    def obs_transfer_path(self) -> _builtins.str:
        """
        The storage path of the OBS bucket, which is the log transfer destination.
        """
        return pulumi.get(self, "obs_transfer_path")


