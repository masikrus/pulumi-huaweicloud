# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DeploymentV2SelectorArgs',
    'DeploymentV2SelectorArgsDict',
    'DeploymentV2SelectorMatchExpressionArgs',
    'DeploymentV2SelectorMatchExpressionArgsDict',
    'DeploymentV2StatusArgs',
    'DeploymentV2StatusArgsDict',
    'DeploymentV2StatusConditionArgs',
    'DeploymentV2StatusConditionArgsDict',
    'DeploymentV2StrategyArgs',
    'DeploymentV2StrategyArgsDict',
    'DeploymentV2TemplateArgs',
    'DeploymentV2TemplateArgsDict',
    'DeploymentV2TemplateMetadataArgs',
    'DeploymentV2TemplateMetadataArgsDict',
    'DeploymentV2TemplateSpecArgs',
    'DeploymentV2TemplateSpecArgsDict',
    'DeploymentV2TemplateSpecAffinityArgs',
    'DeploymentV2TemplateSpecAffinityArgsDict',
    'DeploymentV2TemplateSpecAffinityNodeAffinityArgs',
    'DeploymentV2TemplateSpecAffinityNodeAffinityArgsDict',
    'DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict',
    'DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs',
    'DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict',
    'DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs',
    'DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs',
    'DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict',
    'DeploymentV2TemplateSpecContainerArgs',
    'DeploymentV2TemplateSpecContainerArgsDict',
    'DeploymentV2TemplateSpecContainerEnvArgs',
    'DeploymentV2TemplateSpecContainerEnvArgsDict',
    'DeploymentV2TemplateSpecContainerEnvFromArgs',
    'DeploymentV2TemplateSpecContainerEnvFromArgsDict',
    'DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgs',
    'DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgsDict',
    'DeploymentV2TemplateSpecContainerEnvFromSecretRefArgs',
    'DeploymentV2TemplateSpecContainerEnvFromSecretRefArgsDict',
    'DeploymentV2TemplateSpecContainerLifecycleArgs',
    'DeploymentV2TemplateSpecContainerLifecycleArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgsDict',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs',
    'DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgsDict',
    'DeploymentV2TemplateSpecContainerLivenessProbeArgs',
    'DeploymentV2TemplateSpecContainerLivenessProbeArgsDict',
    'DeploymentV2TemplateSpecContainerLivenessProbeExecArgs',
    'DeploymentV2TemplateSpecContainerLivenessProbeExecArgsDict',
    'DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgs',
    'DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgsDict',
    'DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs',
    'DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgsDict',
    'DeploymentV2TemplateSpecContainerPortArgs',
    'DeploymentV2TemplateSpecContainerPortArgsDict',
    'DeploymentV2TemplateSpecContainerReadinessProbeArgs',
    'DeploymentV2TemplateSpecContainerReadinessProbeArgsDict',
    'DeploymentV2TemplateSpecContainerReadinessProbeExecArgs',
    'DeploymentV2TemplateSpecContainerReadinessProbeExecArgsDict',
    'DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgs',
    'DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgsDict',
    'DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs',
    'DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgsDict',
    'DeploymentV2TemplateSpecContainerResourcesArgs',
    'DeploymentV2TemplateSpecContainerResourcesArgsDict',
    'DeploymentV2TemplateSpecContainerSecurityContextArgs',
    'DeploymentV2TemplateSpecContainerSecurityContextArgsDict',
    'DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgs',
    'DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgsDict',
    'DeploymentV2TemplateSpecContainerStartupProbeArgs',
    'DeploymentV2TemplateSpecContainerStartupProbeArgsDict',
    'DeploymentV2TemplateSpecContainerStartupProbeExecArgs',
    'DeploymentV2TemplateSpecContainerStartupProbeExecArgsDict',
    'DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgs',
    'DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgsDict',
    'DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs',
    'DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgsDict',
    'DeploymentV2TemplateSpecContainerVolumeMountArgs',
    'DeploymentV2TemplateSpecContainerVolumeMountArgsDict',
    'DeploymentV2TemplateSpecImagePullSecretArgs',
    'DeploymentV2TemplateSpecImagePullSecretArgsDict',
    'HpaV2BehaviorArgs',
    'HpaV2BehaviorArgsDict',
    'HpaV2BehaviorScaleDownArgs',
    'HpaV2BehaviorScaleDownArgsDict',
    'HpaV2BehaviorScaleDownPolicyArgs',
    'HpaV2BehaviorScaleDownPolicyArgsDict',
    'HpaV2BehaviorScaleUpArgs',
    'HpaV2BehaviorScaleUpArgsDict',
    'HpaV2BehaviorScaleUpPolicyArgs',
    'HpaV2BehaviorScaleUpPolicyArgsDict',
    'HpaV2MetricArgs',
    'HpaV2MetricArgsDict',
    'HpaV2MetricContainerResourceArgs',
    'HpaV2MetricContainerResourceArgsDict',
    'HpaV2MetricContainerResourceTargetArgs',
    'HpaV2MetricContainerResourceTargetArgsDict',
    'HpaV2MetricExternalArgs',
    'HpaV2MetricExternalArgsDict',
    'HpaV2MetricExternalMetricArgs',
    'HpaV2MetricExternalMetricArgsDict',
    'HpaV2MetricExternalMetricSelectorArgs',
    'HpaV2MetricExternalMetricSelectorArgsDict',
    'HpaV2MetricExternalMetricSelectorMatchExpressionArgs',
    'HpaV2MetricExternalMetricSelectorMatchExpressionArgsDict',
    'HpaV2MetricExternalTargetArgs',
    'HpaV2MetricExternalTargetArgsDict',
    'HpaV2MetricObjectArgs',
    'HpaV2MetricObjectArgsDict',
    'HpaV2MetricObjectDescribedObjectArgs',
    'HpaV2MetricObjectDescribedObjectArgsDict',
    'HpaV2MetricObjectMetricArgs',
    'HpaV2MetricObjectMetricArgsDict',
    'HpaV2MetricObjectMetricSelectorArgs',
    'HpaV2MetricObjectMetricSelectorArgsDict',
    'HpaV2MetricObjectMetricSelectorMatchExpressionArgs',
    'HpaV2MetricObjectMetricSelectorMatchExpressionArgsDict',
    'HpaV2MetricObjectTargetArgs',
    'HpaV2MetricObjectTargetArgsDict',
    'HpaV2MetricPodsArgs',
    'HpaV2MetricPodsArgsDict',
    'HpaV2MetricPodsMetricArgs',
    'HpaV2MetricPodsMetricArgsDict',
    'HpaV2MetricPodsMetricSelectorArgs',
    'HpaV2MetricPodsMetricSelectorArgsDict',
    'HpaV2MetricPodsMetricSelectorMatchExpressionArgs',
    'HpaV2MetricPodsMetricSelectorMatchExpressionArgsDict',
    'HpaV2MetricPodsTargetArgs',
    'HpaV2MetricPodsTargetArgsDict',
    'HpaV2MetricResourcesArgs',
    'HpaV2MetricResourcesArgsDict',
    'HpaV2MetricResourcesTargetArgs',
    'HpaV2MetricResourcesTargetArgsDict',
    'HpaV2ScaleTargetRefArgs',
    'HpaV2ScaleTargetRefArgsDict',
    'HpaV2StatusArgs',
    'HpaV2StatusArgsDict',
    'HpaV2StatusConditionArgs',
    'HpaV2StatusConditionArgsDict',
    'HpaV2StatusCurrentMetricArgs',
    'HpaV2StatusCurrentMetricArgsDict',
    'HpaV2StatusCurrentMetricContainerResourceArgs',
    'HpaV2StatusCurrentMetricContainerResourceArgsDict',
    'HpaV2StatusCurrentMetricContainerResourceTargetArgs',
    'HpaV2StatusCurrentMetricContainerResourceTargetArgsDict',
    'HpaV2StatusCurrentMetricExternalArgs',
    'HpaV2StatusCurrentMetricExternalArgsDict',
    'HpaV2StatusCurrentMetricExternalMetricArgs',
    'HpaV2StatusCurrentMetricExternalMetricArgsDict',
    'HpaV2StatusCurrentMetricExternalMetricSelectorArgs',
    'HpaV2StatusCurrentMetricExternalMetricSelectorArgsDict',
    'HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgs',
    'HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgsDict',
    'HpaV2StatusCurrentMetricExternalTargetArgs',
    'HpaV2StatusCurrentMetricExternalTargetArgsDict',
    'HpaV2StatusCurrentMetricObjectArgs',
    'HpaV2StatusCurrentMetricObjectArgsDict',
    'HpaV2StatusCurrentMetricObjectDescribedObjectArgs',
    'HpaV2StatusCurrentMetricObjectDescribedObjectArgsDict',
    'HpaV2StatusCurrentMetricObjectMetricArgs',
    'HpaV2StatusCurrentMetricObjectMetricArgsDict',
    'HpaV2StatusCurrentMetricObjectMetricSelectorArgs',
    'HpaV2StatusCurrentMetricObjectMetricSelectorArgsDict',
    'HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgs',
    'HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgsDict',
    'HpaV2StatusCurrentMetricObjectTargetArgs',
    'HpaV2StatusCurrentMetricObjectTargetArgsDict',
    'HpaV2StatusCurrentMetricPodsArgs',
    'HpaV2StatusCurrentMetricPodsArgsDict',
    'HpaV2StatusCurrentMetricPodsMetricArgs',
    'HpaV2StatusCurrentMetricPodsMetricArgsDict',
    'HpaV2StatusCurrentMetricPodsMetricSelectorArgs',
    'HpaV2StatusCurrentMetricPodsMetricSelectorArgsDict',
    'HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgs',
    'HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgsDict',
    'HpaV2StatusCurrentMetricPodsTargetArgs',
    'HpaV2StatusCurrentMetricPodsTargetArgsDict',
    'HpaV2StatusCurrentMetricResourcesArgs',
    'HpaV2StatusCurrentMetricResourcesArgsDict',
    'HpaV2StatusCurrentMetricResourcesTargetArgs',
    'HpaV2StatusCurrentMetricResourcesTargetArgsDict',
    'ImageSnapshotV2BuildingConfigArgs',
    'ImageSnapshotV2BuildingConfigArgsDict',
    'ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgs',
    'ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgsDict',
    'ImageSnapshotV2ImageArgs',
    'ImageSnapshotV2ImageArgsDict',
    'ImageSnapshotV2RegistryArgs',
    'ImageSnapshotV2RegistryArgsDict',
    'ImageSnapshotV2StatusArgs',
    'ImageSnapshotV2StatusArgsDict',
    'ImageSnapshotV2StatusImageArgs',
    'ImageSnapshotV2StatusImageArgsDict',
    'NetworkV2StatusArgs',
    'NetworkV2StatusArgsDict',
    'NetworkV2StatusConditionArgs',
    'NetworkV2StatusConditionArgsDict',
    'NetworkV2StatusSubnetAttrArgs',
    'NetworkV2StatusSubnetAttrArgsDict',
    'NetworkV2SubnetArgs',
    'NetworkV2SubnetArgsDict',
    'PersistentVolumeClaimV2ResourcesArgs',
    'PersistentVolumeClaimV2ResourcesArgsDict',
    'PersistentVolumeClaimV2SelectorArgs',
    'PersistentVolumeClaimV2SelectorArgsDict',
    'PersistentVolumeClaimV2SelectorMatchExpressionArgs',
    'PersistentVolumeClaimV2SelectorMatchExpressionArgsDict',
    'PersistentVolumeV2ClaimRefArgs',
    'PersistentVolumeV2ClaimRefArgsDict',
    'PersistentVolumeV2CsiArgs',
    'PersistentVolumeV2CsiArgsDict',
    'PersistentVolumeV2CsiControllerExpandSecretRefArgs',
    'PersistentVolumeV2CsiControllerExpandSecretRefArgsDict',
    'PersistentVolumeV2CsiControllerPublishSecretRefArgs',
    'PersistentVolumeV2CsiControllerPublishSecretRefArgsDict',
    'PersistentVolumeV2CsiNodeExpandSecretRefArgs',
    'PersistentVolumeV2CsiNodeExpandSecretRefArgsDict',
    'PersistentVolumeV2CsiNodePublishSecretRefArgs',
    'PersistentVolumeV2CsiNodePublishSecretRefArgsDict',
    'PersistentVolumeV2CsiNodeStageSecretRefArgs',
    'PersistentVolumeV2CsiNodeStageSecretRefArgsDict',
    'PersistentVolumeV2NodeAffinityArgs',
    'PersistentVolumeV2NodeAffinityArgsDict',
    'PersistentVolumeV2NodeAffinityRequiredArgs',
    'PersistentVolumeV2NodeAffinityRequiredArgsDict',
    'PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgs',
    'PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgsDict',
    'PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgs',
    'PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgsDict',
    'PersistentVolumeV2StatusArgs',
    'PersistentVolumeV2StatusArgsDict',
    'PodV2AffinityArgs',
    'PodV2AffinityArgsDict',
    'PodV2AffinityNodeAffinityArgs',
    'PodV2AffinityNodeAffinityArgsDict',
    'PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict',
    'PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs',
    'PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict',
    'PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs',
    'PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict',
    'PodV2AffinityPodAntiAffinityArgs',
    'PodV2AffinityPodAntiAffinityArgsDict',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs',
    'PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict',
    'PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict',
    'PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict',
    'PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs',
    'PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict',
    'PodV2ContainerArgs',
    'PodV2ContainerArgsDict',
    'PodV2ContainerEnvArgs',
    'PodV2ContainerEnvArgsDict',
    'PodV2ContainerEnvFromArgs',
    'PodV2ContainerEnvFromArgsDict',
    'PodV2ContainerEnvFromConfigMapRefArgs',
    'PodV2ContainerEnvFromConfigMapRefArgsDict',
    'PodV2ContainerEnvFromSecretRefArgs',
    'PodV2ContainerEnvFromSecretRefArgsDict',
    'PodV2ContainerLifecycleArgs',
    'PodV2ContainerLifecycleArgsDict',
    'PodV2ContainerLifecyclePostStartArgs',
    'PodV2ContainerLifecyclePostStartArgsDict',
    'PodV2ContainerLifecyclePostStartExecArgs',
    'PodV2ContainerLifecyclePostStartExecArgsDict',
    'PodV2ContainerLifecyclePostStartHttpGetArgs',
    'PodV2ContainerLifecyclePostStartHttpGetArgsDict',
    'PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgs',
    'PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgsDict',
    'PodV2ContainerLifecyclePreStopArgs',
    'PodV2ContainerLifecyclePreStopArgsDict',
    'PodV2ContainerLifecyclePreStopExecArgs',
    'PodV2ContainerLifecyclePreStopExecArgsDict',
    'PodV2ContainerLifecyclePreStopHttpGetArgs',
    'PodV2ContainerLifecyclePreStopHttpGetArgsDict',
    'PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgs',
    'PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgsDict',
    'PodV2ContainerLivenessProbeArgs',
    'PodV2ContainerLivenessProbeArgsDict',
    'PodV2ContainerLivenessProbeExecArgs',
    'PodV2ContainerLivenessProbeExecArgsDict',
    'PodV2ContainerLivenessProbeHttpGetArgs',
    'PodV2ContainerLivenessProbeHttpGetArgsDict',
    'PodV2ContainerLivenessProbeHttpGetHttpHeaderArgs',
    'PodV2ContainerLivenessProbeHttpGetHttpHeaderArgsDict',
    'PodV2ContainerPortArgs',
    'PodV2ContainerPortArgsDict',
    'PodV2ContainerReadinessProbeArgs',
    'PodV2ContainerReadinessProbeArgsDict',
    'PodV2ContainerReadinessProbeExecArgs',
    'PodV2ContainerReadinessProbeExecArgsDict',
    'PodV2ContainerReadinessProbeHttpGetArgs',
    'PodV2ContainerReadinessProbeHttpGetArgsDict',
    'PodV2ContainerReadinessProbeHttpGetHttpHeaderArgs',
    'PodV2ContainerReadinessProbeHttpGetHttpHeaderArgsDict',
    'PodV2ContainerResourcesArgs',
    'PodV2ContainerResourcesArgsDict',
    'PodV2ContainerSecurityContextArgs',
    'PodV2ContainerSecurityContextArgsDict',
    'PodV2ContainerSecurityContextCapabilitiesArgs',
    'PodV2ContainerSecurityContextCapabilitiesArgsDict',
    'PodV2ContainerStartupProbeArgs',
    'PodV2ContainerStartupProbeArgsDict',
    'PodV2ContainerStartupProbeExecArgs',
    'PodV2ContainerStartupProbeExecArgsDict',
    'PodV2ContainerStartupProbeHttpGetArgs',
    'PodV2ContainerStartupProbeHttpGetArgsDict',
    'PodV2ContainerStartupProbeHttpGetHttpHeaderArgs',
    'PodV2ContainerStartupProbeHttpGetHttpHeaderArgsDict',
    'PodV2ContainerVolumeMountArgs',
    'PodV2ContainerVolumeMountArgsDict',
    'PodV2DnsConfigArgs',
    'PodV2DnsConfigArgsDict',
    'PodV2DnsConfigOptionArgs',
    'PodV2DnsConfigOptionArgsDict',
    'PodV2EphemeralContainerArgs',
    'PodV2EphemeralContainerArgsDict',
    'PodV2EphemeralContainerEnvArgs',
    'PodV2EphemeralContainerEnvArgsDict',
    'PodV2EphemeralContainerEnvFromArgs',
    'PodV2EphemeralContainerEnvFromArgsDict',
    'PodV2EphemeralContainerEnvFromConfigMapRefArgs',
    'PodV2EphemeralContainerEnvFromConfigMapRefArgsDict',
    'PodV2EphemeralContainerEnvFromSecretRefArgs',
    'PodV2EphemeralContainerEnvFromSecretRefArgsDict',
    'PodV2EphemeralContainerLifecycleArgs',
    'PodV2EphemeralContainerLifecycleArgsDict',
    'PodV2EphemeralContainerLifecyclePostStartArgs',
    'PodV2EphemeralContainerLifecyclePostStartArgsDict',
    'PodV2EphemeralContainerLifecyclePostStartExecArgs',
    'PodV2EphemeralContainerLifecyclePostStartExecArgsDict',
    'PodV2EphemeralContainerLifecyclePostStartHttpGetArgs',
    'PodV2EphemeralContainerLifecyclePostStartHttpGetArgsDict',
    'PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgs',
    'PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgsDict',
    'PodV2EphemeralContainerLifecyclePreStopArgs',
    'PodV2EphemeralContainerLifecyclePreStopArgsDict',
    'PodV2EphemeralContainerLifecyclePreStopExecArgs',
    'PodV2EphemeralContainerLifecyclePreStopExecArgsDict',
    'PodV2EphemeralContainerLifecyclePreStopHttpGetArgs',
    'PodV2EphemeralContainerLifecyclePreStopHttpGetArgsDict',
    'PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgs',
    'PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgsDict',
    'PodV2EphemeralContainerLivenessProbeArgs',
    'PodV2EphemeralContainerLivenessProbeArgsDict',
    'PodV2EphemeralContainerLivenessProbeExecArgs',
    'PodV2EphemeralContainerLivenessProbeExecArgsDict',
    'PodV2EphemeralContainerLivenessProbeHttpGetArgs',
    'PodV2EphemeralContainerLivenessProbeHttpGetArgsDict',
    'PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgs',
    'PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgsDict',
    'PodV2EphemeralContainerPortArgs',
    'PodV2EphemeralContainerPortArgsDict',
    'PodV2EphemeralContainerReadinessProbeArgs',
    'PodV2EphemeralContainerReadinessProbeArgsDict',
    'PodV2EphemeralContainerReadinessProbeExecArgs',
    'PodV2EphemeralContainerReadinessProbeExecArgsDict',
    'PodV2EphemeralContainerReadinessProbeHttpGetArgs',
    'PodV2EphemeralContainerReadinessProbeHttpGetArgsDict',
    'PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgs',
    'PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgsDict',
    'PodV2EphemeralContainerResourcesArgs',
    'PodV2EphemeralContainerResourcesArgsDict',
    'PodV2EphemeralContainerSecurityContextArgs',
    'PodV2EphemeralContainerSecurityContextArgsDict',
    'PodV2EphemeralContainerSecurityContextCapabilitiesArgs',
    'PodV2EphemeralContainerSecurityContextCapabilitiesArgsDict',
    'PodV2EphemeralContainerStartupProbeArgs',
    'PodV2EphemeralContainerStartupProbeArgsDict',
    'PodV2EphemeralContainerStartupProbeExecArgs',
    'PodV2EphemeralContainerStartupProbeExecArgsDict',
    'PodV2EphemeralContainerStartupProbeHttpGetArgs',
    'PodV2EphemeralContainerStartupProbeHttpGetArgsDict',
    'PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgs',
    'PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgsDict',
    'PodV2EphemeralContainerVolumeMountArgs',
    'PodV2EphemeralContainerVolumeMountArgsDict',
    'PodV2HostAliasArgs',
    'PodV2HostAliasArgsDict',
    'PodV2ImagePullSecretArgs',
    'PodV2ImagePullSecretArgsDict',
    'PodV2InitContainerArgs',
    'PodV2InitContainerArgsDict',
    'PodV2InitContainerEnvArgs',
    'PodV2InitContainerEnvArgsDict',
    'PodV2InitContainerEnvFromArgs',
    'PodV2InitContainerEnvFromArgsDict',
    'PodV2InitContainerEnvFromConfigMapRefArgs',
    'PodV2InitContainerEnvFromConfigMapRefArgsDict',
    'PodV2InitContainerEnvFromSecretRefArgs',
    'PodV2InitContainerEnvFromSecretRefArgsDict',
    'PodV2InitContainerLifecycleArgs',
    'PodV2InitContainerLifecycleArgsDict',
    'PodV2InitContainerLifecyclePostStartArgs',
    'PodV2InitContainerLifecyclePostStartArgsDict',
    'PodV2InitContainerLifecyclePostStartExecArgs',
    'PodV2InitContainerLifecyclePostStartExecArgsDict',
    'PodV2InitContainerLifecyclePostStartHttpGetArgs',
    'PodV2InitContainerLifecyclePostStartHttpGetArgsDict',
    'PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgs',
    'PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgsDict',
    'PodV2InitContainerLifecyclePreStopArgs',
    'PodV2InitContainerLifecyclePreStopArgsDict',
    'PodV2InitContainerLifecyclePreStopExecArgs',
    'PodV2InitContainerLifecyclePreStopExecArgsDict',
    'PodV2InitContainerLifecyclePreStopHttpGetArgs',
    'PodV2InitContainerLifecyclePreStopHttpGetArgsDict',
    'PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgs',
    'PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgsDict',
    'PodV2InitContainerLivenessProbeArgs',
    'PodV2InitContainerLivenessProbeArgsDict',
    'PodV2InitContainerLivenessProbeExecArgs',
    'PodV2InitContainerLivenessProbeExecArgsDict',
    'PodV2InitContainerLivenessProbeHttpGetArgs',
    'PodV2InitContainerLivenessProbeHttpGetArgsDict',
    'PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgs',
    'PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgsDict',
    'PodV2InitContainerPortArgs',
    'PodV2InitContainerPortArgsDict',
    'PodV2InitContainerReadinessProbeArgs',
    'PodV2InitContainerReadinessProbeArgsDict',
    'PodV2InitContainerReadinessProbeExecArgs',
    'PodV2InitContainerReadinessProbeExecArgsDict',
    'PodV2InitContainerReadinessProbeHttpGetArgs',
    'PodV2InitContainerReadinessProbeHttpGetArgsDict',
    'PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgs',
    'PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgsDict',
    'PodV2InitContainerResourcesArgs',
    'PodV2InitContainerResourcesArgsDict',
    'PodV2InitContainerSecurityContextArgs',
    'PodV2InitContainerSecurityContextArgsDict',
    'PodV2InitContainerSecurityContextCapabilitiesArgs',
    'PodV2InitContainerSecurityContextCapabilitiesArgsDict',
    'PodV2InitContainerStartupProbeArgs',
    'PodV2InitContainerStartupProbeArgsDict',
    'PodV2InitContainerStartupProbeExecArgs',
    'PodV2InitContainerStartupProbeExecArgsDict',
    'PodV2InitContainerStartupProbeHttpGetArgs',
    'PodV2InitContainerStartupProbeHttpGetArgsDict',
    'PodV2InitContainerStartupProbeHttpGetHttpHeaderArgs',
    'PodV2InitContainerStartupProbeHttpGetHttpHeaderArgsDict',
    'PodV2InitContainerVolumeMountArgs',
    'PodV2InitContainerVolumeMountArgsDict',
    'PodV2ReadinessGateArgs',
    'PodV2ReadinessGateArgsDict',
    'PodV2SecurityContextArgs',
    'PodV2SecurityContextArgsDict',
    'PodV2SecurityContextSysctlArgs',
    'PodV2SecurityContextSysctlArgsDict',
    'PodV2StatusArgs',
    'PodV2StatusArgsDict',
    'PodV2StatusConditionArgs',
    'PodV2StatusConditionArgsDict',
    'PodV2VolumeArgs',
    'PodV2VolumeArgsDict',
    'PodV2VolumeConfigMapArgs',
    'PodV2VolumeConfigMapArgsDict',
    'PodV2VolumeConfigMapItemsArgs',
    'PodV2VolumeConfigMapItemsArgsDict',
    'PodV2VolumeNfsArgs',
    'PodV2VolumeNfsArgsDict',
    'PodV2VolumePersistentVolumeClaimArgs',
    'PodV2VolumePersistentVolumeClaimArgsDict',
    'PodV2VolumeProjectedArgs',
    'PodV2VolumeProjectedArgsDict',
    'PodV2VolumeProjectedSourceArgs',
    'PodV2VolumeProjectedSourceArgsDict',
    'PodV2VolumeProjectedSourceConfigMapArgs',
    'PodV2VolumeProjectedSourceConfigMapArgsDict',
    'PodV2VolumeProjectedSourceConfigMapItemArgs',
    'PodV2VolumeProjectedSourceConfigMapItemArgsDict',
    'PodV2VolumeProjectedSourceDownwardApiArgs',
    'PodV2VolumeProjectedSourceDownwardApiArgsDict',
    'PodV2VolumeProjectedSourceDownwardApiItemArgs',
    'PodV2VolumeProjectedSourceDownwardApiItemArgsDict',
    'PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgs',
    'PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgsDict',
    'PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgs',
    'PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgsDict',
    'PodV2VolumeProjectedSourceSecretArgs',
    'PodV2VolumeProjectedSourceSecretArgsDict',
    'PodV2VolumeProjectedSourceSecretItemArgs',
    'PodV2VolumeProjectedSourceSecretItemArgsDict',
    'PodV2VolumeSecretArgs',
    'PodV2VolumeSecretArgsDict',
    'PodV2VolumeSecretItemsArgs',
    'PodV2VolumeSecretItemsArgsDict',
    'PoolBindingOwnerReferenceArgs',
    'PoolBindingOwnerReferenceArgsDict',
    'PoolBindingPoolRefArgs',
    'PoolBindingPoolRefArgsDict',
    'PoolBindingTargetRefArgs',
    'PoolBindingTargetRefArgsDict',
    'PvcV2ResourcesArgs',
    'PvcV2ResourcesArgsDict',
    'PvcV2SelectorArgs',
    'PvcV2SelectorArgsDict',
    'PvcV2SelectorMatchExpressionArgs',
    'PvcV2SelectorMatchExpressionArgsDict',
    'ServiceV2PortArgs',
    'ServiceV2PortArgsDict',
    'ServiceV2StatusArgs',
    'ServiceV2StatusArgsDict',
    'ServiceV2StatusConditionArgs',
    'ServiceV2StatusConditionArgsDict',
    'ServiceV2StatusLoadbalancerArgs',
    'ServiceV2StatusLoadbalancerArgsDict',
    'ServiceV2StatusLoadbalancerIngressArgs',
    'ServiceV2StatusLoadbalancerIngressArgsDict',
    'ServiceV2StatusLoadbalancerIngressPortArgs',
    'ServiceV2StatusLoadbalancerIngressPortArgsDict',
]

MYPY = False

if not MYPY:
    class DeploymentV2SelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2SelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2SelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2SelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2SelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2SelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2SelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class DeploymentV2SelectorMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2SelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2SelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentV2StatusArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2StatusConditionArgsDict']]]]
        observed_generation: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DeploymentV2StatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2StatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2StatusConditionArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[_builtins.int]] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2StatusConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2StatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "observed_generation", value)


if not MYPY:
    class DeploymentV2StatusConditionArgsDict(TypedDict):
        last_transition_time: NotRequired[pulumi.Input[_builtins.str]]
        last_update_time: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        reason: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeploymentV2StatusConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2StatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[_builtins.str]] = None,
                 last_update_time: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_update_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentV2StrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeploymentV2StrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2StrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "rolling_update", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DeploymentV2TemplateArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input['DeploymentV2TemplateMetadataArgsDict']]
        spec: NotRequired[pulumi.Input['DeploymentV2TemplateSpecArgsDict']]
elif False:
    DeploymentV2TemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['DeploymentV2TemplateMetadataArgs']] = None,
                 spec: Optional[pulumi.Input['DeploymentV2TemplateSpecArgs']] = None):
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['DeploymentV2TemplateMetadataArgs']]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['DeploymentV2TemplateMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecArgs']]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class DeploymentV2TemplateMetadataArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class DeploymentV2TemplateSpecArgsDict(TypedDict):
        containers: pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerArgsDict']]]
        active_deadline_seconds: NotRequired[pulumi.Input[_builtins.int]]
        affinity: NotRequired[pulumi.Input['DeploymentV2TemplateSpecAffinityArgsDict']]
        dns_policy: NotRequired[pulumi.Input[_builtins.str]]
        hostname: NotRequired[pulumi.Input[_builtins.str]]
        image_pull_secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecImagePullSecretArgsDict']]]]
        node_name: NotRequired[pulumi.Input[_builtins.str]]
        overhead: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        restart_policy: NotRequired[pulumi.Input[_builtins.str]]
        scheduler_name: NotRequired[pulumi.Input[_builtins.str]]
        set_hostname_as_pqdn: NotRequired[pulumi.Input[_builtins.bool]]
        share_process_namespace: NotRequired[pulumi.Input[_builtins.bool]]
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DeploymentV2TemplateSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecArgs:
    def __init__(__self__, *,
                 containers: pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerArgs']]],
                 active_deadline_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 affinity: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityArgs']] = None,
                 dns_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecImagePullSecretArgs']]]] = None,
                 node_name: Optional[pulumi.Input[_builtins.str]] = None,
                 overhead: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 restart_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 scheduler_name: Optional[pulumi.Input[_builtins.str]] = None,
                 set_hostname_as_pqdn: Optional[pulumi.Input[_builtins.bool]] = None,
                 share_process_namespace: Optional[pulumi.Input[_builtins.bool]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "containers", containers)
        if active_deadline_seconds is not None:
            pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if set_hostname_as_pqdn is not None:
            pulumi.set(__self__, "set_hostname_as_pqdn", set_hostname_as_pqdn)
        if share_process_namespace is not None:
            pulumi.set(__self__, "share_process_namespace", share_process_namespace)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter
    def containers(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerArgs']]]:
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerArgs']]]):
        pulumi.set(self, "containers", value)

    @_builtins.property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "active_deadline_seconds")

    @active_deadline_seconds.setter
    def active_deadline_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "active_deadline_seconds", value)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityArgs']]:
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @_builtins.property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dns_policy")

    @dns_policy.setter
    def dns_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_policy", value)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname", value)

    @_builtins.property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecImagePullSecretArgs']]]]:
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecImagePullSecretArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_name", value)

    @_builtins.property
    @pulumi.getter
    def overhead(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "overhead")

    @overhead.setter
    def overhead(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "overhead", value)

    @_builtins.property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "restart_policy")

    @restart_policy.setter
    def restart_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restart_policy", value)

    @_builtins.property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheduler_name", value)

    @_builtins.property
    @pulumi.getter(name="setHostnameAsPqdn")
    def set_hostname_as_pqdn(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "set_hostname_as_pqdn")

    @set_hostname_as_pqdn.setter
    def set_hostname_as_pqdn(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "set_hostname_as_pqdn", value)

    @_builtins.property
    @pulumi.getter(name="shareProcessNamespace")
    def share_process_namespace(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "share_process_namespace")

    @share_process_namespace.setter
    def share_process_namespace(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "share_process_namespace", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityArgsDict(TypedDict):
        node_affinity: NotRequired[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityArgsDict']]
        pod_anti_affinity: NotRequired[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityArgsDict']]
elif False:
    DeploymentV2TemplateSpecAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityArgs']] = None):
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @_builtins.property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @_builtins.property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityNodeAffinityArgsDict(TypedDict):
        required_during_scheduling_ignored_during_execution: NotRequired[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict']]
elif False:
    DeploymentV2TemplateSpecAffinityNodeAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @_builtins.property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict(TypedDict):
        node_selector_terms: pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict']]]
elif False:
    DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs']]]):
        pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @_builtins.property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs']]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs']]]):
        pulumi.set(self, "node_selector_terms", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict']]]]
elif False:
    DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityArgsDict(TypedDict):
        preferred_during_scheduling_ignored_during_executions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict']]]]
        required_during_scheduling_ignored_during_executions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict']]]]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_executions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @_builtins.property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @preferred_during_scheduling_ignored_during_executions.setter
    def preferred_during_scheduling_ignored_during_executions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_executions", value)

    @_builtins.property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")

    @required_during_scheduling_ignored_during_executions.setter
    def required_during_scheduling_ignored_during_executions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_executions", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict(TypedDict):
        pod_affinity_term: pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict']
        weight: pulumi.Input[_builtins.int]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs'],
                 weight: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']):
        pulumi.set(self, "pod_affinity_term", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict(TypedDict):
        topology_key: pulumi.Input[_builtins.str]
        label_selector: NotRequired[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict']]
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[_builtins.str],
                 label_selector: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @_builtins.property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topology_key", value)

    @_builtins.property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict(TypedDict):
        topology_key: pulumi.Input[_builtins.str]
        label_selector: NotRequired[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict']]
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[_builtins.str],
                 label_selector: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @_builtins.property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topology_key", value)

    @_builtins.property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the container.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the arguments to the entrypoint of the container.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the command of the container.
        """
        env_froms: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromArgsDict']]]]
        """
        The sources to populate environment variables of the container.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvArgsDict']]]]
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image name of the CCI Pod container.
        """
        lifecycle: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLifecycleArgsDict']]
        """
        Specifies the lifecycle of the container.
        """
        liveness_probe: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeArgsDict']]
        """
        Specifies the liveness probe of the container.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerPortArgsDict']]]]
        """
        Specifies the ports of the container.
        """
        readiness_probe: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeArgsDict']]
        """
        Specifies the readiness probe of the container.
        """
        resources: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerResourcesArgsDict']]
        """
        Specifies the resources of the container.
        """
        security_context: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextArgsDict']]
        """
        Specifies the security context of the container.
        """
        startup_probe: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeArgsDict']]
        """
        Specifies the startup probe of the container.
        """
        stdin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        stdin_once: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        termination_message_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message path of the CCI Pod container.
        """
        termination_message_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        tty: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerVolumeMountArgsDict']]]]
        working_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the working directory of the CCI Pod container.
        """
elif False:
    DeploymentV2TemplateSpecContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 env_froms: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromArgs']]]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvArgs']]]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 lifecycle: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecycleArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeArgs']] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerPortArgs']]]] = None,
                 readiness_probe: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerResourcesArgs']] = None,
                 security_context: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextArgs']] = None,
                 startup_probe: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeArgs']] = None,
                 stdin: Optional[pulumi.Input[_builtins.bool]] = None,
                 stdin_once: Optional[pulumi.Input[_builtins.bool]] = None,
                 termination_message_path: Optional[pulumi.Input[_builtins.str]] = None,
                 termination_message_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 tty: Optional[pulumi.Input[_builtins.bool]] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerVolumeMountArgs']]]] = None,
                 working_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Specifies the arguments to the entrypoint of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Specifies the command of the container.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromArgs']]] env_froms: The sources to populate environment variables of the container.
        :param pulumi.Input[_builtins.str] image: Specifies the image name of the CCI Pod container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLifecycleArgs'] lifecycle: Specifies the lifecycle of the container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeArgs'] liveness_probe: Specifies the liveness probe of the container.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerPortArgs']]] ports: Specifies the ports of the container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeArgs'] readiness_probe: Specifies the readiness probe of the container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerResourcesArgs'] resources: Specifies the resources of the container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextArgs'] security_context: Specifies the security context of the container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeArgs'] startup_probe: Specifies the startup probe of the container.
        :param pulumi.Input[_builtins.bool] stdin: Specifies whether this container should allocate a buffer for stdin in the container runtime.
        :param pulumi.Input[_builtins.bool] stdin_once: Specifies whether this container runtime should close the stdin channel.
        :param pulumi.Input[_builtins.str] termination_message_path: Specifies the termination message path of the CCI Pod container.
        :param pulumi.Input[_builtins.str] termination_message_policy: Specifies the termination message policy of the CCI Pod container.
        :param pulumi.Input[_builtins.bool] tty: Specifies whether this container should allocate a TTY for itself.
        :param pulumi.Input[_builtins.str] working_dir: Specifies the working directory of the CCI Pod container.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the arguments to the entrypoint of the container.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the command of the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromArgs']]]]:
        """
        The sources to populate environment variables of the container.
        """
        return pulumi.get(self, "env_froms")

    @env_froms.setter
    def env_froms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromArgs']]]]):
        pulumi.set(self, "env_froms", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvArgs']]]]:
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image name of the CCI Pod container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecycleArgs']]:
        """
        Specifies the lifecycle of the container.
        """
        return pulumi.get(self, "lifecycle")

    @lifecycle.setter
    def lifecycle(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecycleArgs']]):
        pulumi.set(self, "lifecycle", value)

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeArgs']]:
        """
        Specifies the liveness probe of the container.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerPortArgs']]]]:
        """
        Specifies the ports of the container.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerPortArgs']]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeArgs']]:
        """
        Specifies the readiness probe of the container.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerResourcesArgs']]:
        """
        Specifies the resources of the container.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextArgs']]:
        """
        Specifies the security context of the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @_builtins.property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeArgs']]:
        """
        Specifies the startup probe of the container.
        """
        return pulumi.get(self, "startup_probe")

    @startup_probe.setter
    def startup_probe(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeArgs']]):
        pulumi.set(self, "startup_probe", value)

    @_builtins.property
    @pulumi.getter
    def stdin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        return pulumi.get(self, "stdin")

    @stdin.setter
    def stdin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin", value)

    @_builtins.property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        return pulumi.get(self, "stdin_once")

    @stdin_once.setter
    def stdin_once(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin_once", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message path of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_path")

    @termination_message_path.setter
    def termination_message_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_path", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_policy")

    @termination_message_policy.setter
    def termination_message_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_policy", value)

    @_builtins.property
    @pulumi.getter
    def tty(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        return pulumi.get(self, "tty")

    @tty.setter
    def tty(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tty", value)

    @_builtins.property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerVolumeMountArgs']]]]:
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerVolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)

    @_builtins.property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the working directory of the CCI Pod container.
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerEnvArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeploymentV2TemplateSpecContainerEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerEnvFromArgsDict(TypedDict):
        config_map_ref: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgsDict']]
        """
        Specifies the config map.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prefix.
        """
        secret_ref: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromSecretRefArgsDict']]
        """
        Specifies the secret.
        """
elif False:
    DeploymentV2TemplateSpecContainerEnvFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerEnvFromArgs:
    def __init__(__self__, *,
                 config_map_ref: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromSecretRefArgs']] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgs'] config_map_ref: Specifies the config map.
        :param pulumi.Input[_builtins.str] prefix: Specifies the prefix.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromSecretRefArgs'] secret_ref: Specifies the secret.
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgs']]:
        """
        Specifies the config map.
        """
        return pulumi.get(self, "config_map_ref")

    @config_map_ref.setter
    def config_map_ref(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgs']]):
        pulumi.set(self, "config_map_ref", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromSecretRefArgs']]:
        """
        Specifies the secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerEnvFromSecretRefArgs']]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerEnvFromConfigMapRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerEnvFromSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    DeploymentV2TemplateSpecContainerEnvFromSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerEnvFromSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecycleArgsDict(TypedDict):
        post_start: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        pre_stop: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecycleArgs:
    def __init__(__self__, *,
                 post_start: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartArgs']] = None,
                 pre_stop: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopArgs']] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartArgs'] post_start: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopArgs'] pre_stop: The lifecycle pre stop of the CCI Pod container.
        """
        if post_start is not None:
            pulumi.set(__self__, "post_start", post_start)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @_builtins.property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "post_start")

    @post_start.setter
    def post_start(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartArgs']]):
        pulumi.set(self, "post_start", value)

    @_builtins.property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "pre_stop")

    @pre_stop.setter
    def pre_stop(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopArgs']]):
        pulumi.set(self, "pre_stop", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePostStartArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePostStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePostStartArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgs']] = None,
                 http_get: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgs']] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePostStartExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePostStartHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePreStopArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePreStopArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgs']] = None,
                 http_get: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgs']] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePreStopExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLifecyclePreStopHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLivenessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DeploymentV2TemplateSpecContainerLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLivenessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLivenessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    DeploymentV2TemplateSpecContainerLivenessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLivenessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLivenessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerLivenessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerPortArgsDict(TypedDict):
        container_port: pulumi.Input[_builtins.int]
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the port name of the container.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the protocol for container port.
        """
elif False:
    DeploymentV2TemplateSpecContainerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerPortArgs:
    def __init__(__self__, *,
                 container_port: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] container_port: Specifies the number of port to expose on the IP address of pod.
        :param pulumi.Input[_builtins.str] name: Specifies the port name of the container.
        :param pulumi.Input[_builtins.str] protocol: Specifies the protocol for container port.
        """
        pulumi.set(__self__, "container_port", container_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the port name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the protocol for container port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerReadinessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DeploymentV2TemplateSpecContainerReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerReadinessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerReadinessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    DeploymentV2TemplateSpecContainerReadinessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerReadinessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerReadinessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerReadinessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the limits of resource.
        """
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the requests of the resource.
        """
elif False:
    DeploymentV2TemplateSpecContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] limits: Specifies the limits of resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] requests: Specifies the requests of the resource.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the limits of resource.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the requests of the resource.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerSecurityContextArgsDict(TypedDict):
        capabilities: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgsDict']]
        """
        Specifies the capabilities of the security context.
        """
        proc_mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        read_only_root_file_system: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this container has a read-only root file system.
        """
        run_as_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        The GID TO run the entrypoint of the container process.
        """
        run_as_non_root: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The container must run as a non-root user.
        """
        run_as_user: NotRequired[pulumi.Input[_builtins.int]]
        """
        The UID to run the entrypoint of the container process.
        """
elif False:
    DeploymentV2TemplateSpecContainerSecurityContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerSecurityContextArgs:
    def __init__(__self__, *,
                 capabilities: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgs']] = None,
                 proc_mount: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only_root_file_system: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_group: Optional[pulumi.Input[_builtins.int]] = None,
                 run_as_non_root: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_user: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgs'] capabilities: Specifies the capabilities of the security context.
        :param pulumi.Input[_builtins.str] proc_mount: Specifies the denotes the type of proc mount to use for the containers.
        :param pulumi.Input[_builtins.bool] read_only_root_file_system: Whether this container has a read-only root file system.
        :param pulumi.Input[_builtins.int] run_as_group: The GID TO run the entrypoint of the container process.
        :param pulumi.Input[_builtins.bool] run_as_non_root: The container must run as a non-root user.
        :param pulumi.Input[_builtins.int] run_as_user: The UID to run the entrypoint of the container process.
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_file_system is not None:
            pulumi.set(__self__, "read_only_root_file_system", read_only_root_file_system)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgs']]:
        """
        Specifies the capabilities of the security context.
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @_builtins.property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proc_mount", value)

    @_builtins.property
    @pulumi.getter(name="readOnlyRootFileSystem")
    def read_only_root_file_system(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this container has a read-only root file system.
        """
        return pulumi.get(self, "read_only_root_file_system")

    @read_only_root_file_system.setter
    def read_only_root_file_system(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only_root_file_system", value)

    @_builtins.property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The GID TO run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_group", value)

    @_builtins.property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The container must run as a non-root user.
        """
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @_builtins.property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The UID to run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_user", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgsDict(TypedDict):
        adds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        drops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 adds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 drops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @_builtins.property
    @pulumi.getter
    def adds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "adds")

    @adds.setter
    def adds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "adds", value)

    @_builtins.property
    @pulumi.getter
    def drops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "drops")

    @drops.setter
    def drops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "drops", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerStartupProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DeploymentV2TemplateSpecContainerStartupProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerStartupProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerStartupProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    DeploymentV2TemplateSpecContainerStartupProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerStartupProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerStartupProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerStartupProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentV2TemplateSpecContainerVolumeMountArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        extend_path_mode: NotRequired[pulumi.Input[_builtins.str]]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        sub_path: NotRequired[pulumi.Input[_builtins.str]]
        sub_path_expr: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeploymentV2TemplateSpecContainerVolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecContainerVolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 extend_path_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 sub_path: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_path_expr: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if extend_path_mode is not None:
            pulumi.set(__self__, "extend_path_mode", extend_path_mode)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="extendPathMode")
    def extend_path_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_path_mode")

    @extend_path_mode.setter
    def extend_path_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_path_mode", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path", value)

    @_builtins.property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path_expr")

    @sub_path_expr.setter
    def sub_path_expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path_expr", value)


if not MYPY:
    class DeploymentV2TemplateSpecImagePullSecretArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DeploymentV2TemplateSpecImagePullSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentV2TemplateSpecImagePullSecretArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HpaV2BehaviorArgsDict(TypedDict):
        scale_down: NotRequired[pulumi.Input['HpaV2BehaviorScaleDownArgsDict']]
        scale_up: NotRequired[pulumi.Input['HpaV2BehaviorScaleUpArgsDict']]
elif False:
    HpaV2BehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2BehaviorArgs:
    def __init__(__self__, *,
                 scale_down: Optional[pulumi.Input['HpaV2BehaviorScaleDownArgs']] = None,
                 scale_up: Optional[pulumi.Input['HpaV2BehaviorScaleUpArgs']] = None):
        if scale_down is not None:
            pulumi.set(__self__, "scale_down", scale_down)
        if scale_up is not None:
            pulumi.set(__self__, "scale_up", scale_up)

    @_builtins.property
    @pulumi.getter(name="scaleDown")
    def scale_down(self) -> Optional[pulumi.Input['HpaV2BehaviorScaleDownArgs']]:
        return pulumi.get(self, "scale_down")

    @scale_down.setter
    def scale_down(self, value: Optional[pulumi.Input['HpaV2BehaviorScaleDownArgs']]):
        pulumi.set(self, "scale_down", value)

    @_builtins.property
    @pulumi.getter(name="scaleUp")
    def scale_up(self) -> Optional[pulumi.Input['HpaV2BehaviorScaleUpArgs']]:
        return pulumi.get(self, "scale_up")

    @scale_up.setter
    def scale_up(self, value: Optional[pulumi.Input['HpaV2BehaviorScaleUpArgs']]):
        pulumi.set(self, "scale_up", value)


if not MYPY:
    class HpaV2BehaviorScaleDownArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleDownPolicyArgsDict']]]]
        select_policy: NotRequired[pulumi.Input[_builtins.str]]
        stabilization_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    HpaV2BehaviorScaleDownArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2BehaviorScaleDownArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleDownPolicyArgs']]]] = None,
                 select_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if select_policy is not None:
            pulumi.set(__self__, "select_policy", select_policy)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleDownPolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleDownPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="selectPolicy")
    def select_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "select_policy")

    @select_policy.setter
    def select_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "select_policy", value)

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stabilization_window_seconds", value)


if not MYPY:
    class HpaV2BehaviorScaleDownPolicyArgsDict(TypedDict):
        period_seconds: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.int]
elif False:
    HpaV2BehaviorScaleDownPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2BehaviorScaleDownPolicyArgs:
    def __init__(__self__, *,
                 period_seconds: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2BehaviorScaleUpArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleUpPolicyArgsDict']]]]
        select_policy: NotRequired[pulumi.Input[_builtins.str]]
        stabilization_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    HpaV2BehaviorScaleUpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2BehaviorScaleUpArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleUpPolicyArgs']]]] = None,
                 select_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 stabilization_window_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if select_policy is not None:
            pulumi.set(__self__, "select_policy", select_policy)
        if stabilization_window_seconds is not None:
            pulumi.set(__self__, "stabilization_window_seconds", stabilization_window_seconds)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleUpPolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2BehaviorScaleUpPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="selectPolicy")
    def select_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "select_policy")

    @select_policy.setter
    def select_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "select_policy", value)

    @_builtins.property
    @pulumi.getter(name="stabilizationWindowSeconds")
    def stabilization_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "stabilization_window_seconds")

    @stabilization_window_seconds.setter
    def stabilization_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stabilization_window_seconds", value)


if not MYPY:
    class HpaV2BehaviorScaleUpPolicyArgsDict(TypedDict):
        period_seconds: pulumi.Input[_builtins.int]
        type: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.int]
elif False:
    HpaV2BehaviorScaleUpPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2BehaviorScaleUpPolicyArgs:
    def __init__(__self__, *,
                 period_seconds: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2MetricArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        container_resource: NotRequired[pulumi.Input['HpaV2MetricContainerResourceArgsDict']]
        external: NotRequired[pulumi.Input['HpaV2MetricExternalArgsDict']]
        object: NotRequired[pulumi.Input['HpaV2MetricObjectArgsDict']]
        pods: NotRequired[pulumi.Input['HpaV2MetricPodsArgsDict']]
        resources: NotRequired[pulumi.Input['HpaV2MetricResourcesArgsDict']]
elif False:
    HpaV2MetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 container_resource: Optional[pulumi.Input['HpaV2MetricContainerResourceArgs']] = None,
                 external: Optional[pulumi.Input['HpaV2MetricExternalArgs']] = None,
                 object: Optional[pulumi.Input['HpaV2MetricObjectArgs']] = None,
                 pods: Optional[pulumi.Input['HpaV2MetricPodsArgs']] = None,
                 resources: Optional[pulumi.Input['HpaV2MetricResourcesArgs']] = None):
        pulumi.set(__self__, "type", type)
        if container_resource is not None:
            pulumi.set(__self__, "container_resource", container_resource)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="containerResource")
    def container_resource(self) -> Optional[pulumi.Input['HpaV2MetricContainerResourceArgs']]:
        return pulumi.get(self, "container_resource")

    @container_resource.setter
    def container_resource(self, value: Optional[pulumi.Input['HpaV2MetricContainerResourceArgs']]):
        pulumi.set(self, "container_resource", value)

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['HpaV2MetricExternalArgs']]:
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['HpaV2MetricExternalArgs']]):
        pulumi.set(self, "external", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input['HpaV2MetricObjectArgs']]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input['HpaV2MetricObjectArgs']]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input['HpaV2MetricPodsArgs']]:
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input['HpaV2MetricPodsArgs']]):
        pulumi.set(self, "pods", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['HpaV2MetricResourcesArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['HpaV2MetricResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class HpaV2MetricContainerResourceArgsDict(TypedDict):
        container: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        target: NotRequired[pulumi.Input['HpaV2MetricContainerResourceTargetArgsDict']]
elif False:
    HpaV2MetricContainerResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricContainerResourceArgs:
    def __init__(__self__, *,
                 container: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input['HpaV2MetricContainerResourceTargetArgs']] = None):
        if container is not None:
            pulumi.set(__self__, "container", container)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['HpaV2MetricContainerResourceTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['HpaV2MetricContainerResourceTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2MetricContainerResourceTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricContainerResourceTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricContainerResourceTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2MetricExternalArgsDict(TypedDict):
        metric: pulumi.Input['HpaV2MetricExternalMetricArgsDict']
        target: pulumi.Input['HpaV2MetricExternalTargetArgsDict']
elif False:
    HpaV2MetricExternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricExternalArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input['HpaV2MetricExternalMetricArgs'],
                 target: pulumi.Input['HpaV2MetricExternalTargetArgs']):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> pulumi.Input['HpaV2MetricExternalMetricArgs']:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input['HpaV2MetricExternalMetricArgs']):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input['HpaV2MetricExternalTargetArgs']:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['HpaV2MetricExternalTargetArgs']):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2MetricExternalMetricArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        selector: NotRequired[pulumi.Input['HpaV2MetricExternalMetricSelectorArgsDict']]
elif False:
    HpaV2MetricExternalMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricExternalMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector: Optional[pulumi.Input['HpaV2MetricExternalMetricSelectorArgs']] = None):
        pulumi.set(__self__, "name", name)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['HpaV2MetricExternalMetricSelectorArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['HpaV2MetricExternalMetricSelectorArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class HpaV2MetricExternalMetricSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricExternalMetricSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricExternalMetricSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricExternalMetricSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricExternalMetricSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricExternalMetricSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricExternalMetricSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class HpaV2MetricExternalMetricSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricExternalMetricSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricExternalMetricSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HpaV2MetricExternalTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricExternalTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricExternalTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2MetricObjectArgsDict(TypedDict):
        described_object: pulumi.Input['HpaV2MetricObjectDescribedObjectArgsDict']
        metric: pulumi.Input['HpaV2MetricObjectMetricArgsDict']
        target: pulumi.Input['HpaV2MetricObjectTargetArgsDict']
elif False:
    HpaV2MetricObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricObjectArgs:
    def __init__(__self__, *,
                 described_object: pulumi.Input['HpaV2MetricObjectDescribedObjectArgs'],
                 metric: pulumi.Input['HpaV2MetricObjectMetricArgs'],
                 target: pulumi.Input['HpaV2MetricObjectTargetArgs']):
        pulumi.set(__self__, "described_object", described_object)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="describedObject")
    def described_object(self) -> pulumi.Input['HpaV2MetricObjectDescribedObjectArgs']:
        return pulumi.get(self, "described_object")

    @described_object.setter
    def described_object(self, value: pulumi.Input['HpaV2MetricObjectDescribedObjectArgs']):
        pulumi.set(self, "described_object", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> pulumi.Input['HpaV2MetricObjectMetricArgs']:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input['HpaV2MetricObjectMetricArgs']):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input['HpaV2MetricObjectTargetArgs']:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['HpaV2MetricObjectTargetArgs']):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2MetricObjectDescribedObjectArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    HpaV2MetricObjectDescribedObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricObjectDescribedObjectArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HpaV2MetricObjectMetricArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        selector: NotRequired[pulumi.Input['HpaV2MetricObjectMetricSelectorArgsDict']]
elif False:
    HpaV2MetricObjectMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricObjectMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector: Optional[pulumi.Input['HpaV2MetricObjectMetricSelectorArgs']] = None):
        pulumi.set(__self__, "name", name)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['HpaV2MetricObjectMetricSelectorArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['HpaV2MetricObjectMetricSelectorArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class HpaV2MetricObjectMetricSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricObjectMetricSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricObjectMetricSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricObjectMetricSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricObjectMetricSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricObjectMetricSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricObjectMetricSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class HpaV2MetricObjectMetricSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricObjectMetricSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricObjectMetricSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HpaV2MetricObjectTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricObjectTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricObjectTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2MetricPodsArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input['HpaV2MetricPodsMetricArgsDict']]
        target: NotRequired[pulumi.Input['HpaV2MetricPodsTargetArgsDict']]
elif False:
    HpaV2MetricPodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricPodsArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input['HpaV2MetricPodsMetricArgs']] = None,
                 target: Optional[pulumi.Input['HpaV2MetricPodsTargetArgs']] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['HpaV2MetricPodsMetricArgs']]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['HpaV2MetricPodsMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['HpaV2MetricPodsTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['HpaV2MetricPodsTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2MetricPodsMetricArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        selector: NotRequired[pulumi.Input['HpaV2MetricPodsMetricSelectorArgsDict']]
elif False:
    HpaV2MetricPodsMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricPodsMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector: Optional[pulumi.Input['HpaV2MetricPodsMetricSelectorArgs']] = None):
        pulumi.set(__self__, "name", name)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['HpaV2MetricPodsMetricSelectorArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['HpaV2MetricPodsMetricSelectorArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class HpaV2MetricPodsMetricSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricPodsMetricSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricPodsMetricSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricPodsMetricSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricPodsMetricSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricPodsMetricSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2MetricPodsMetricSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class HpaV2MetricPodsMetricSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricPodsMetricSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricPodsMetricSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HpaV2MetricPodsTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricPodsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricPodsTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2MetricResourcesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        target: NotRequired[pulumi.Input['HpaV2MetricResourcesTargetArgsDict']]
elif False:
    HpaV2MetricResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricResourcesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input['HpaV2MetricResourcesTargetArgs']] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['HpaV2MetricResourcesTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['HpaV2MetricResourcesTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2MetricResourcesTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2MetricResourcesTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2MetricResourcesTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2ScaleTargetRefArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    HpaV2ScaleTargetRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2ScaleTargetRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HpaV2StatusArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusConditionArgsDict']]]]
        current_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricArgsDict']]]]
        current_replicas: NotRequired[pulumi.Input[_builtins.int]]
        desired_replicas: NotRequired[pulumi.Input[_builtins.int]]
        last_scale_time: NotRequired[pulumi.Input[_builtins.str]]
        observed_generation: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    HpaV2StatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusConditionArgs']]]] = None,
                 current_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricArgs']]]] = None,
                 current_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 desired_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 last_scale_time: Optional[pulumi.Input[_builtins.str]] = None,
                 observed_generation: Optional[pulumi.Input[_builtins.int]] = None):
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if current_metrics is not None:
            pulumi.set(__self__, "current_metrics", current_metrics)
        if current_replicas is not None:
            pulumi.set(__self__, "current_replicas", current_replicas)
        if desired_replicas is not None:
            pulumi.set(__self__, "desired_replicas", desired_replicas)
        if last_scale_time is not None:
            pulumi.set(__self__, "last_scale_time", last_scale_time)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="currentMetrics")
    def current_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricArgs']]]]:
        return pulumi.get(self, "current_metrics")

    @current_metrics.setter
    def current_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricArgs']]]]):
        pulumi.set(self, "current_metrics", value)

    @_builtins.property
    @pulumi.getter(name="currentReplicas")
    def current_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "current_replicas")

    @current_replicas.setter
    def current_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "current_replicas", value)

    @_builtins.property
    @pulumi.getter(name="desiredReplicas")
    def desired_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "desired_replicas")

    @desired_replicas.setter
    def desired_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "desired_replicas", value)

    @_builtins.property
    @pulumi.getter(name="lastScaleTime")
    def last_scale_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_scale_time")

    @last_scale_time.setter
    def last_scale_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_scale_time", value)

    @_builtins.property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "observed_generation", value)


if not MYPY:
    class HpaV2StatusConditionArgsDict(TypedDict):
        last_transition_time: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        reason: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    HpaV2StatusConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HpaV2StatusCurrentMetricArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        container_resource: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceArgsDict']]
        external: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricExternalArgsDict']]
        object: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricObjectArgsDict']]
        pods: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricPodsArgsDict']]
        resources: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricResourcesArgsDict']]
elif False:
    HpaV2StatusCurrentMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 container_resource: Optional[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceArgs']] = None,
                 external: Optional[pulumi.Input['HpaV2StatusCurrentMetricExternalArgs']] = None,
                 object: Optional[pulumi.Input['HpaV2StatusCurrentMetricObjectArgs']] = None,
                 pods: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsArgs']] = None,
                 resources: Optional[pulumi.Input['HpaV2StatusCurrentMetricResourcesArgs']] = None):
        pulumi.set(__self__, "type", type)
        if container_resource is not None:
            pulumi.set(__self__, "container_resource", container_resource)
        if external is not None:
            pulumi.set(__self__, "external", external)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="containerResource")
    def container_resource(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceArgs']]:
        return pulumi.get(self, "container_resource")

    @container_resource.setter
    def container_resource(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceArgs']]):
        pulumi.set(self, "container_resource", value)

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricExternalArgs']]:
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricExternalArgs']]):
        pulumi.set(self, "external", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricObjectArgs']]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricObjectArgs']]):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsArgs']]:
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsArgs']]):
        pulumi.set(self, "pods", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricResourcesArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class HpaV2StatusCurrentMetricContainerResourceArgsDict(TypedDict):
        container: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        target: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceTargetArgsDict']]
elif False:
    HpaV2StatusCurrentMetricContainerResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricContainerResourceArgs:
    def __init__(__self__, *,
                 container: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceTargetArgs']] = None):
        if container is not None:
            pulumi.set(__self__, "container", container)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricContainerResourceTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2StatusCurrentMetricContainerResourceTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricContainerResourceTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricContainerResourceTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2StatusCurrentMetricExternalArgsDict(TypedDict):
        metric: pulumi.Input['HpaV2StatusCurrentMetricExternalMetricArgsDict']
        target: pulumi.Input['HpaV2StatusCurrentMetricExternalTargetArgsDict']
elif False:
    HpaV2StatusCurrentMetricExternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricExternalArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input['HpaV2StatusCurrentMetricExternalMetricArgs'],
                 target: pulumi.Input['HpaV2StatusCurrentMetricExternalTargetArgs']):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> pulumi.Input['HpaV2StatusCurrentMetricExternalMetricArgs']:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input['HpaV2StatusCurrentMetricExternalMetricArgs']):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input['HpaV2StatusCurrentMetricExternalTargetArgs']:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['HpaV2StatusCurrentMetricExternalTargetArgs']):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2StatusCurrentMetricExternalMetricArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        selector: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorArgsDict']]
elif False:
    HpaV2StatusCurrentMetricExternalMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricExternalMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector: Optional[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorArgs']] = None):
        pulumi.set(__self__, "name", name)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class HpaV2StatusCurrentMetricExternalMetricSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricExternalMetricSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricExternalMetricSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricExternalMetricSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HpaV2StatusCurrentMetricExternalTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricExternalTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricExternalTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2StatusCurrentMetricObjectArgsDict(TypedDict):
        described_object: pulumi.Input['HpaV2StatusCurrentMetricObjectDescribedObjectArgsDict']
        metric: pulumi.Input['HpaV2StatusCurrentMetricObjectMetricArgsDict']
        target: pulumi.Input['HpaV2StatusCurrentMetricObjectTargetArgsDict']
elif False:
    HpaV2StatusCurrentMetricObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricObjectArgs:
    def __init__(__self__, *,
                 described_object: pulumi.Input['HpaV2StatusCurrentMetricObjectDescribedObjectArgs'],
                 metric: pulumi.Input['HpaV2StatusCurrentMetricObjectMetricArgs'],
                 target: pulumi.Input['HpaV2StatusCurrentMetricObjectTargetArgs']):
        pulumi.set(__self__, "described_object", described_object)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="describedObject")
    def described_object(self) -> pulumi.Input['HpaV2StatusCurrentMetricObjectDescribedObjectArgs']:
        return pulumi.get(self, "described_object")

    @described_object.setter
    def described_object(self, value: pulumi.Input['HpaV2StatusCurrentMetricObjectDescribedObjectArgs']):
        pulumi.set(self, "described_object", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> pulumi.Input['HpaV2StatusCurrentMetricObjectMetricArgs']:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input['HpaV2StatusCurrentMetricObjectMetricArgs']):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input['HpaV2StatusCurrentMetricObjectTargetArgs']:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['HpaV2StatusCurrentMetricObjectTargetArgs']):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2StatusCurrentMetricObjectDescribedObjectArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    HpaV2StatusCurrentMetricObjectDescribedObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricObjectDescribedObjectArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HpaV2StatusCurrentMetricObjectMetricArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        selector: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorArgsDict']]
elif False:
    HpaV2StatusCurrentMetricObjectMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricObjectMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector: Optional[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorArgs']] = None):
        pulumi.set(__self__, "name", name)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class HpaV2StatusCurrentMetricObjectMetricSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricObjectMetricSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricObjectMetricSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricObjectMetricSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HpaV2StatusCurrentMetricObjectTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricObjectTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricObjectTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2StatusCurrentMetricPodsArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricArgsDict']]
        target: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricPodsTargetArgsDict']]
elif False:
    HpaV2StatusCurrentMetricPodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricPodsArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricArgs']] = None,
                 target: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsTargetArgs']] = None):
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricArgs']]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricArgs']]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2StatusCurrentMetricPodsMetricArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        selector: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorArgsDict']]
elif False:
    HpaV2StatusCurrentMetricPodsMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricPodsMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorArgs']] = None):
        pulumi.set(__self__, "name", name)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorArgs']]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorArgs']]):
        pulumi.set(self, "selector", value)


if not MYPY:
    class HpaV2StatusCurrentMetricPodsMetricSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricPodsMetricSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricPodsMetricSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricPodsMetricSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class HpaV2StatusCurrentMetricPodsTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricPodsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricPodsTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HpaV2StatusCurrentMetricResourcesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        target: NotRequired[pulumi.Input['HpaV2StatusCurrentMetricResourcesTargetArgsDict']]
elif False:
    HpaV2StatusCurrentMetricResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricResourcesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input['HpaV2StatusCurrentMetricResourcesTargetArgs']] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['HpaV2StatusCurrentMetricResourcesTargetArgs']]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['HpaV2StatusCurrentMetricResourcesTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class HpaV2StatusCurrentMetricResourcesTargetArgsDict(TypedDict):
        average_utilization: NotRequired[pulumi.Input[_builtins.int]]
        average_value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    HpaV2StatusCurrentMetricResourcesTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HpaV2StatusCurrentMetricResourcesTargetArgs:
    def __init__(__self__, *,
                 average_utilization: Optional[pulumi.Input[_builtins.int]] = None,
                 average_value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if average_utilization is not None:
            pulumi.set(__self__, "average_utilization", average_utilization)
        if average_value is not None:
            pulumi.set(__self__, "average_value", average_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="averageUtilization")
    def average_utilization(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "average_utilization")

    @average_utilization.setter
    def average_utilization(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "average_utilization", value)

    @_builtins.property
    @pulumi.getter(name="averageValue")
    def average_value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "average_value")

    @average_value.setter
    def average_value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "average_value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ImageSnapshotV2BuildingConfigArgsDict(TypedDict):
        auto_create_eip: NotRequired[pulumi.Input[_builtins.bool]]
        auto_create_eip_attribute: NotRequired[pulumi.Input['ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgsDict']]
        eip_id: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ImageSnapshotV2BuildingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageSnapshotV2BuildingConfigArgs:
    def __init__(__self__, *,
                 auto_create_eip: Optional[pulumi.Input[_builtins.bool]] = None,
                 auto_create_eip_attribute: Optional[pulumi.Input['ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgs']] = None,
                 eip_id: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        if auto_create_eip is not None:
            pulumi.set(__self__, "auto_create_eip", auto_create_eip)
        if auto_create_eip_attribute is not None:
            pulumi.set(__self__, "auto_create_eip_attribute", auto_create_eip_attribute)
        if eip_id is not None:
            pulumi.set(__self__, "eip_id", eip_id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="autoCreateEip")
    def auto_create_eip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "auto_create_eip")

    @auto_create_eip.setter
    def auto_create_eip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_create_eip", value)

    @_builtins.property
    @pulumi.getter(name="autoCreateEipAttribute")
    def auto_create_eip_attribute(self) -> Optional[pulumi.Input['ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgs']]:
        return pulumi.get(self, "auto_create_eip_attribute")

    @auto_create_eip_attribute.setter
    def auto_create_eip_attribute(self, value: Optional[pulumi.Input['ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgs']]):
        pulumi.set(self, "auto_create_eip_attribute", value)

    @_builtins.property
    @pulumi.getter(name="eipId")
    def eip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "eip_id")

    @eip_id.setter
    def eip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "eip_id", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgsDict(TypedDict):
        bandwidth_charge_mode: NotRequired[pulumi.Input[_builtins.str]]
        bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        bandwidth_size: NotRequired[pulumi.Input[_builtins.int]]
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageSnapshotV2BuildingConfigAutoCreateEipAttributeArgs:
    def __init__(__self__, *,
                 bandwidth_charge_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[_builtins.int]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if bandwidth_charge_mode is not None:
            pulumi.set(__self__, "bandwidth_charge_mode", bandwidth_charge_mode)
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="bandwidthChargeMode")
    def bandwidth_charge_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bandwidth_charge_mode")

    @bandwidth_charge_mode.setter
    def bandwidth_charge_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_charge_mode", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ImageSnapshotV2ImageArgsDict(TypedDict):
        image: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ImageSnapshotV2ImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageSnapshotV2ImageArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[_builtins.str]] = None):
        if image is not None:
            pulumi.set(__self__, "image", image)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class ImageSnapshotV2RegistryArgsDict(TypedDict):
        image_pull_secret: NotRequired[pulumi.Input[_builtins.str]]
        insecure_skip_verify: NotRequired[pulumi.Input[_builtins.bool]]
        plain_http: NotRequired[pulumi.Input[_builtins.bool]]
        server: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ImageSnapshotV2RegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageSnapshotV2RegistryArgs:
    def __init__(__self__, *,
                 image_pull_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 plain_http: Optional[pulumi.Input[_builtins.bool]] = None,
                 server: Optional[pulumi.Input[_builtins.str]] = None):
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if plain_http is not None:
            pulumi.set(__self__, "plain_http", plain_http)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "image_pull_secret")

    @image_pull_secret.setter
    def image_pull_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_pull_secret", value)

    @_builtins.property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @_builtins.property
    @pulumi.getter(name="plainHttp")
    def plain_http(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "plain_http")

    @plain_http.setter
    def plain_http(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "plain_http", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server", value)


if not MYPY:
    class ImageSnapshotV2StatusArgsDict(TypedDict):
        expire_date_time: NotRequired[pulumi.Input[_builtins.str]]
        images: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImageSnapshotV2StatusImageArgsDict']]]]
        last_updated_time: NotRequired[pulumi.Input[_builtins.str]]
        message: NotRequired[pulumi.Input[_builtins.str]]
        phase: NotRequired[pulumi.Input[_builtins.str]]
        reason: NotRequired[pulumi.Input[_builtins.str]]
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        snapshot_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ImageSnapshotV2StatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageSnapshotV2StatusArgs:
    def __init__(__self__, *,
                 expire_date_time: Optional[pulumi.Input[_builtins.str]] = None,
                 images: Optional[pulumi.Input[Sequence[pulumi.Input['ImageSnapshotV2StatusImageArgs']]]] = None,
                 last_updated_time: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 phase: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_name: Optional[pulumi.Input[_builtins.str]] = None):
        if expire_date_time is not None:
            pulumi.set(__self__, "expire_date_time", expire_date_time)
        if images is not None:
            pulumi.set(__self__, "images", images)
        if last_updated_time is not None:
            pulumi.set(__self__, "last_updated_time", last_updated_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if snapshot_name is not None:
            pulumi.set(__self__, "snapshot_name", snapshot_name)

    @_builtins.property
    @pulumi.getter(name="expireDateTime")
    def expire_date_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "expire_date_time")

    @expire_date_time.setter
    def expire_date_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire_date_time", value)

    @_builtins.property
    @pulumi.getter
    def images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImageSnapshotV2StatusImageArgs']]]]:
        return pulumi.get(self, "images")

    @images.setter
    def images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImageSnapshotV2StatusImageArgs']]]]):
        pulumi.set(self, "images", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdatedTime")
    def last_updated_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "last_updated_time")

    @last_updated_time.setter
    def last_updated_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_updated_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotName")
    def snapshot_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "snapshot_name")

    @snapshot_name.setter
    def snapshot_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_name", value)


if not MYPY:
    class ImageSnapshotV2StatusImageArgsDict(TypedDict):
        digest: NotRequired[pulumi.Input[_builtins.str]]
        image: NotRequired[pulumi.Input[_builtins.str]]
        size_bytes: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ImageSnapshotV2StatusImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageSnapshotV2StatusImageArgs:
    def __init__(__self__, *,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 size_bytes: Optional[pulumi.Input[_builtins.int]] = None):
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size_bytes", value)


if not MYPY:
    class NetworkV2StatusArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusConditionArgsDict']]]]
        """
        Tthe conditions of the CCI network.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the CCI network.
        """
        subnet_attrs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusSubnetAttrArgsDict']]]]
        """
        The subnet attributes of the CCI network.
        """
elif False:
    NetworkV2StatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkV2StatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusConditionArgs']]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_attrs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusSubnetAttrArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusConditionArgs']]] conditions: Tthe conditions of the CCI network.
        :param pulumi.Input[_builtins.str] status: The status of the CCI network.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusSubnetAttrArgs']]] subnet_attrs: The subnet attributes of the CCI network.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if subnet_attrs is not None:
            pulumi.set(__self__, "subnet_attrs", subnet_attrs)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusConditionArgs']]]]:
        """
        Tthe conditions of the CCI network.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the CCI network.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="subnetAttrs")
    def subnet_attrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusSubnetAttrArgs']]]]:
        """
        The subnet attributes of the CCI network.
        """
        return pulumi.get(self, "subnet_attrs")

    @subnet_attrs.setter
    def subnet_attrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkV2StatusSubnetAttrArgs']]]]):
        pulumi.set(self, "subnet_attrs", value)


if not MYPY:
    class NetworkV2StatusConditionArgsDict(TypedDict):
        last_transition_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last transition time of the CCI network conditions.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The message of the CCI network conditions.
        """
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reason of the CCI network conditions.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tthe status of the CCI network conditions.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the CCI network conditions.
        """
elif False:
    NetworkV2StatusConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkV2StatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] last_transition_time: The last transition time of the CCI network conditions.
        :param pulumi.Input[_builtins.str] message: The message of the CCI network conditions.
        :param pulumi.Input[_builtins.str] reason: The reason of the CCI network conditions.
        :param pulumi.Input[_builtins.str] status: Tthe status of the CCI network conditions.
        :param pulumi.Input[_builtins.str] type: The type of the CCI network conditions.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last transition time of the CCI network conditions.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The message of the CCI network conditions.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reason of the CCI network conditions.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tthe status of the CCI network conditions.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the CCI network conditions.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkV2StatusSubnetAttrArgsDict(TypedDict):
        network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the CCI network.
        """
        subnet_v4_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet IPv4 ID of the CCI network.
        """
        subnet_v6_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subnet IPv6 ID of the CCI network.
        """
elif False:
    NetworkV2StatusSubnetAttrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkV2StatusSubnetAttrArgs:
    def __init__(__self__, *,
                 network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_v4_id: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_v6_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] network_id: The ID of the CCI network.
        :param pulumi.Input[_builtins.str] subnet_v4_id: The subnet IPv4 ID of the CCI network.
        :param pulumi.Input[_builtins.str] subnet_v6_id: The subnet IPv6 ID of the CCI network.
        """
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if subnet_v4_id is not None:
            pulumi.set(__self__, "subnet_v4_id", subnet_v4_id)
        if subnet_v6_id is not None:
            pulumi.set(__self__, "subnet_v6_id", subnet_v6_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the CCI network.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetV4Id")
    def subnet_v4_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet IPv4 ID of the CCI network.
        """
        return pulumi.get(self, "subnet_v4_id")

    @subnet_v4_id.setter
    def subnet_v4_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_v4_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetV6Id")
    def subnet_v6_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subnet IPv6 ID of the CCI network.
        """
        return pulumi.get(self, "subnet_v6_id")

    @subnet_v6_id.setter
    def subnet_v6_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_v6_id", value)


if not MYPY:
    class NetworkV2SubnetArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the subnet ID of the CCI network.
        """
elif False:
    NetworkV2SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkV2SubnetArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Specifies the subnet ID of the CCI network.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the subnet ID of the CCI network.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class PersistentVolumeClaimV2ResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    PersistentVolumeClaimV2ResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeClaimV2ResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class PersistentVolumeClaimV2SelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeClaimV2SelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    PersistentVolumeClaimV2SelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeClaimV2SelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeClaimV2SelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeClaimV2SelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeClaimV2SelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class PersistentVolumeClaimV2SelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PersistentVolumeClaimV2SelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeClaimV2SelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PersistentVolumeV2ClaimRefArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        field_path: NotRequired[pulumi.Input[_builtins.str]]
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        resource_version: NotRequired[pulumi.Input[_builtins.str]]
        uid: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PersistentVolumeV2ClaimRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2ClaimRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 field_path: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_version: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_path", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_version", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class PersistentVolumeV2CsiArgsDict(TypedDict):
        driver: pulumi.Input[_builtins.str]
        volume_handle: pulumi.Input[_builtins.str]
        controller_expand_secret_ref: NotRequired[pulumi.Input['PersistentVolumeV2CsiControllerExpandSecretRefArgsDict']]
        controller_publish_secret_ref: NotRequired[pulumi.Input['PersistentVolumeV2CsiControllerPublishSecretRefArgsDict']]
        fs_type: NotRequired[pulumi.Input[_builtins.str]]
        node_expand_secret_ref: NotRequired[pulumi.Input['PersistentVolumeV2CsiNodeExpandSecretRefArgsDict']]
        node_publish_secret_ref: NotRequired[pulumi.Input['PersistentVolumeV2CsiNodePublishSecretRefArgsDict']]
        node_stage_secret_ref: NotRequired[pulumi.Input['PersistentVolumeV2CsiNodeStageSecretRefArgsDict']]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        volume_attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    PersistentVolumeV2CsiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2CsiArgs:
    def __init__(__self__, *,
                 driver: pulumi.Input[_builtins.str],
                 volume_handle: pulumi.Input[_builtins.str],
                 controller_expand_secret_ref: Optional[pulumi.Input['PersistentVolumeV2CsiControllerExpandSecretRefArgs']] = None,
                 controller_publish_secret_ref: Optional[pulumi.Input['PersistentVolumeV2CsiControllerPublishSecretRefArgs']] = None,
                 fs_type: Optional[pulumi.Input[_builtins.str]] = None,
                 node_expand_secret_ref: Optional[pulumi.Input['PersistentVolumeV2CsiNodeExpandSecretRefArgs']] = None,
                 node_publish_secret_ref: Optional[pulumi.Input['PersistentVolumeV2CsiNodePublishSecretRefArgs']] = None,
                 node_stage_secret_ref: Optional[pulumi.Input['PersistentVolumeV2CsiNodeStageSecretRefArgs']] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 volume_attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "driver", driver)
        pulumi.set(__self__, "volume_handle", volume_handle)
        if controller_expand_secret_ref is not None:
            pulumi.set(__self__, "controller_expand_secret_ref", controller_expand_secret_ref)
        if controller_publish_secret_ref is not None:
            pulumi.set(__self__, "controller_publish_secret_ref", controller_publish_secret_ref)
        if fs_type is not None:
            pulumi.set(__self__, "fs_type", fs_type)
        if node_expand_secret_ref is not None:
            pulumi.set(__self__, "node_expand_secret_ref", node_expand_secret_ref)
        if node_publish_secret_ref is not None:
            pulumi.set(__self__, "node_publish_secret_ref", node_publish_secret_ref)
        if node_stage_secret_ref is not None:
            pulumi.set(__self__, "node_stage_secret_ref", node_stage_secret_ref)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if volume_attributes is not None:
            pulumi.set(__self__, "volume_attributes", volume_attributes)

    @_builtins.property
    @pulumi.getter
    def driver(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "driver")

    @driver.setter
    def driver(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "driver", value)

    @_builtins.property
    @pulumi.getter(name="volumeHandle")
    def volume_handle(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_handle")

    @volume_handle.setter
    def volume_handle(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_handle", value)

    @_builtins.property
    @pulumi.getter(name="controllerExpandSecretRef")
    def controller_expand_secret_ref(self) -> Optional[pulumi.Input['PersistentVolumeV2CsiControllerExpandSecretRefArgs']]:
        return pulumi.get(self, "controller_expand_secret_ref")

    @controller_expand_secret_ref.setter
    def controller_expand_secret_ref(self, value: Optional[pulumi.Input['PersistentVolumeV2CsiControllerExpandSecretRefArgs']]):
        pulumi.set(self, "controller_expand_secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="controllerPublishSecretRef")
    def controller_publish_secret_ref(self) -> Optional[pulumi.Input['PersistentVolumeV2CsiControllerPublishSecretRefArgs']]:
        return pulumi.get(self, "controller_publish_secret_ref")

    @controller_publish_secret_ref.setter
    def controller_publish_secret_ref(self, value: Optional[pulumi.Input['PersistentVolumeV2CsiControllerPublishSecretRefArgs']]):
        pulumi.set(self, "controller_publish_secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="fsType")
    def fs_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fs_type")

    @fs_type.setter
    def fs_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fs_type", value)

    @_builtins.property
    @pulumi.getter(name="nodeExpandSecretRef")
    def node_expand_secret_ref(self) -> Optional[pulumi.Input['PersistentVolumeV2CsiNodeExpandSecretRefArgs']]:
        return pulumi.get(self, "node_expand_secret_ref")

    @node_expand_secret_ref.setter
    def node_expand_secret_ref(self, value: Optional[pulumi.Input['PersistentVolumeV2CsiNodeExpandSecretRefArgs']]):
        pulumi.set(self, "node_expand_secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="nodePublishSecretRef")
    def node_publish_secret_ref(self) -> Optional[pulumi.Input['PersistentVolumeV2CsiNodePublishSecretRefArgs']]:
        return pulumi.get(self, "node_publish_secret_ref")

    @node_publish_secret_ref.setter
    def node_publish_secret_ref(self, value: Optional[pulumi.Input['PersistentVolumeV2CsiNodePublishSecretRefArgs']]):
        pulumi.set(self, "node_publish_secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="nodeStageSecretRef")
    def node_stage_secret_ref(self) -> Optional[pulumi.Input['PersistentVolumeV2CsiNodeStageSecretRefArgs']]:
        return pulumi.get(self, "node_stage_secret_ref")

    @node_stage_secret_ref.setter
    def node_stage_secret_ref(self, value: Optional[pulumi.Input['PersistentVolumeV2CsiNodeStageSecretRefArgs']]):
        pulumi.set(self, "node_stage_secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="volumeAttributes")
    def volume_attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "volume_attributes")

    @volume_attributes.setter
    def volume_attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "volume_attributes", value)


if not MYPY:
    class PersistentVolumeV2CsiControllerExpandSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PersistentVolumeV2CsiControllerExpandSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2CsiControllerExpandSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PersistentVolumeV2CsiControllerPublishSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PersistentVolumeV2CsiControllerPublishSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2CsiControllerPublishSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PersistentVolumeV2CsiNodeExpandSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PersistentVolumeV2CsiNodeExpandSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2CsiNodeExpandSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PersistentVolumeV2CsiNodePublishSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PersistentVolumeV2CsiNodePublishSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2CsiNodePublishSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PersistentVolumeV2CsiNodeStageSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PersistentVolumeV2CsiNodeStageSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2CsiNodeStageSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PersistentVolumeV2NodeAffinityArgsDict(TypedDict):
        required: NotRequired[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredArgsDict']]
elif False:
    PersistentVolumeV2NodeAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2NodeAffinityArgs:
    def __init__(__self__, *,
                 required: Optional[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredArgs']] = None):
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredArgs']]:
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredArgs']]):
        pulumi.set(self, "required", value)


if not MYPY:
    class PersistentVolumeV2NodeAffinityRequiredArgsDict(TypedDict):
        node_selector_terms: pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgsDict']]]
elif False:
    PersistentVolumeV2NodeAffinityRequiredArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2NodeAffinityRequiredArgs:
    def __init__(__self__, *,
                 node_selector_terms: pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgs']]]):
        pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @_builtins.property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgs']]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgs']]]):
        pulumi.set(self, "node_selector_terms", value)


if not MYPY:
    class PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgsDict']]]]
elif False:
    PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)


if not MYPY:
    class PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2NodeAffinityRequiredNodeSelectorTermMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PersistentVolumeV2StatusArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[_builtins.str]]
        phase: NotRequired[pulumi.Input[_builtins.str]]
        reason: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PersistentVolumeV2StatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PersistentVolumeV2StatusArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 phase: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None):
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)


if not MYPY:
    class PodV2AffinityArgsDict(TypedDict):
        node_affinity: NotRequired[pulumi.Input['PodV2AffinityNodeAffinityArgsDict']]
        pod_anti_affinity: NotRequired[pulumi.Input['PodV2AffinityPodAntiAffinityArgsDict']]
elif False:
    PodV2AffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['PodV2AffinityNodeAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['PodV2AffinityPodAntiAffinityArgs']] = None):
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @_builtins.property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['PodV2AffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['PodV2AffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @_builtins.property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['PodV2AffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['PodV2AffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


if not MYPY:
    class PodV2AffinityNodeAffinityArgsDict(TypedDict):
        required_during_scheduling_ignored_during_execution: NotRequired[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict']]
elif False:
    PodV2AffinityNodeAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @_builtins.property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


if not MYPY:
    class PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict(TypedDict):
        node_selector_terms: pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict']]]
elif False:
    PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs']]]):
        pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @_builtins.property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs']]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs']]]):
        pulumi.set(self, "node_selector_terms", value)


if not MYPY:
    class PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict']]]]
elif False:
    PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)


if not MYPY:
    class PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityArgsDict(TypedDict):
        preferred_during_scheduling_ignored_during_executions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict']]]]
        required_during_scheduling_ignored_during_executions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict']]]]
elif False:
    PodV2AffinityPodAntiAffinityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_executions: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_executions: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_executions", preferred_during_scheduling_ignored_during_executions)
        if required_during_scheduling_ignored_during_executions is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_executions", required_during_scheduling_ignored_during_executions)

    @_builtins.property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecutions")
    def preferred_during_scheduling_ignored_during_executions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_executions")

    @preferred_during_scheduling_ignored_during_executions.setter
    def preferred_during_scheduling_ignored_during_executions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_executions", value)

    @_builtins.property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecutions")
    def required_during_scheduling_ignored_during_executions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_executions")

    @required_during_scheduling_ignored_during_executions.setter
    def required_during_scheduling_ignored_during_executions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_executions", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict(TypedDict):
        pod_affinity_term: pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict']
        weight: pulumi.Input[_builtins.int]
elif False:
    PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs'],
                 weight: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']):
        pulumi.set(self, "pod_affinity_term", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict(TypedDict):
        topology_key: pulumi.Input[_builtins.str]
        label_selector: NotRequired[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict']]
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[_builtins.str],
                 label_selector: Optional[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @_builtins.property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topology_key", value)

    @_builtins.property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict(TypedDict):
        topology_key: pulumi.Input[_builtins.str]
        label_selector: NotRequired[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict']]
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[_builtins.str],
                 label_selector: Optional[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @_builtins.property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topology_key", value)

    @_builtins.property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "namespaces", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        operator: pulumi.Input[_builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2AffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PodV2ContainerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the container.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the arguments to the entrypoint of the container.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the command of the container.
        """
        env_froms: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvFromArgsDict']]]]
        """
        The sources to populate environment variables of the container.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvArgsDict']]]]
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image name of the CCI Pod container.
        """
        lifecycle: NotRequired[pulumi.Input['PodV2ContainerLifecycleArgsDict']]
        """
        Specifies the lifecycle of the container.
        """
        liveness_probe: NotRequired[pulumi.Input['PodV2ContainerLivenessProbeArgsDict']]
        """
        Specifies the liveness probe of the container.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerPortArgsDict']]]]
        """
        Specifies the ports of the container.
        """
        readiness_probe: NotRequired[pulumi.Input['PodV2ContainerReadinessProbeArgsDict']]
        """
        Specifies the readiness probe of the container.
        """
        resources: NotRequired[pulumi.Input['PodV2ContainerResourcesArgsDict']]
        """
        Specifies the resources of the container.
        """
        security_context: NotRequired[pulumi.Input['PodV2ContainerSecurityContextArgsDict']]
        """
        Specifies the security context of the container.
        """
        startup_probe: NotRequired[pulumi.Input['PodV2ContainerStartupProbeArgsDict']]
        """
        Specifies the startup probe of the container.
        """
        stdin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        stdin_once: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        termination_message_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message path of the CCI Pod container.
        """
        termination_message_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        tty: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerVolumeMountArgsDict']]]]
        working_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the working directory of the CCI Pod container.
        """
elif False:
    PodV2ContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 env_froms: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvFromArgs']]]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvArgs']]]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 lifecycle: Optional[pulumi.Input['PodV2ContainerLifecycleArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['PodV2ContainerLivenessProbeArgs']] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerPortArgs']]]] = None,
                 readiness_probe: Optional[pulumi.Input['PodV2ContainerReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['PodV2ContainerResourcesArgs']] = None,
                 security_context: Optional[pulumi.Input['PodV2ContainerSecurityContextArgs']] = None,
                 startup_probe: Optional[pulumi.Input['PodV2ContainerStartupProbeArgs']] = None,
                 stdin: Optional[pulumi.Input[_builtins.bool]] = None,
                 stdin_once: Optional[pulumi.Input[_builtins.bool]] = None,
                 termination_message_path: Optional[pulumi.Input[_builtins.str]] = None,
                 termination_message_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 tty: Optional[pulumi.Input[_builtins.bool]] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerVolumeMountArgs']]]] = None,
                 working_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Specifies the arguments to the entrypoint of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Specifies the command of the container.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvFromArgs']]] env_froms: The sources to populate environment variables of the container.
        :param pulumi.Input[_builtins.str] image: Specifies the image name of the CCI Pod container.
        :param pulumi.Input['PodV2ContainerLifecycleArgs'] lifecycle: Specifies the lifecycle of the container.
        :param pulumi.Input['PodV2ContainerLivenessProbeArgs'] liveness_probe: Specifies the liveness probe of the container.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerPortArgs']]] ports: Specifies the ports of the container.
        :param pulumi.Input['PodV2ContainerReadinessProbeArgs'] readiness_probe: Specifies the readiness probe of the container.
        :param pulumi.Input['PodV2ContainerResourcesArgs'] resources: Specifies the resources of the container.
        :param pulumi.Input['PodV2ContainerSecurityContextArgs'] security_context: Specifies the security context of the container.
        :param pulumi.Input['PodV2ContainerStartupProbeArgs'] startup_probe: Specifies the startup probe of the container.
        :param pulumi.Input[_builtins.bool] stdin: Specifies whether this container should allocate a buffer for stdin in the container runtime.
        :param pulumi.Input[_builtins.bool] stdin_once: Specifies whether this container runtime should close the stdin channel.
        :param pulumi.Input[_builtins.str] termination_message_path: Specifies the termination message path of the CCI Pod container.
        :param pulumi.Input[_builtins.str] termination_message_policy: Specifies the termination message policy of the CCI Pod container.
        :param pulumi.Input[_builtins.bool] tty: Specifies whether this container should allocate a TTY for itself.
        :param pulumi.Input[_builtins.str] working_dir: Specifies the working directory of the CCI Pod container.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the arguments to the entrypoint of the container.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the command of the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvFromArgs']]]]:
        """
        The sources to populate environment variables of the container.
        """
        return pulumi.get(self, "env_froms")

    @env_froms.setter
    def env_froms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvFromArgs']]]]):
        pulumi.set(self, "env_froms", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvArgs']]]]:
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image name of the CCI Pod container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[pulumi.Input['PodV2ContainerLifecycleArgs']]:
        """
        Specifies the lifecycle of the container.
        """
        return pulumi.get(self, "lifecycle")

    @lifecycle.setter
    def lifecycle(self, value: Optional[pulumi.Input['PodV2ContainerLifecycleArgs']]):
        pulumi.set(self, "lifecycle", value)

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['PodV2ContainerLivenessProbeArgs']]:
        """
        Specifies the liveness probe of the container.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['PodV2ContainerLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerPortArgs']]]]:
        """
        Specifies the ports of the container.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerPortArgs']]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['PodV2ContainerReadinessProbeArgs']]:
        """
        Specifies the readiness probe of the container.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['PodV2ContainerReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['PodV2ContainerResourcesArgs']]:
        """
        Specifies the resources of the container.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['PodV2ContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['PodV2ContainerSecurityContextArgs']]:
        """
        Specifies the security context of the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['PodV2ContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @_builtins.property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional[pulumi.Input['PodV2ContainerStartupProbeArgs']]:
        """
        Specifies the startup probe of the container.
        """
        return pulumi.get(self, "startup_probe")

    @startup_probe.setter
    def startup_probe(self, value: Optional[pulumi.Input['PodV2ContainerStartupProbeArgs']]):
        pulumi.set(self, "startup_probe", value)

    @_builtins.property
    @pulumi.getter
    def stdin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        return pulumi.get(self, "stdin")

    @stdin.setter
    def stdin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin", value)

    @_builtins.property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        return pulumi.get(self, "stdin_once")

    @stdin_once.setter
    def stdin_once(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin_once", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message path of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_path")

    @termination_message_path.setter
    def termination_message_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_path", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_policy")

    @termination_message_policy.setter
    def termination_message_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_policy", value)

    @_builtins.property
    @pulumi.getter
    def tty(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        return pulumi.get(self, "tty")

    @tty.setter
    def tty(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tty", value)

    @_builtins.property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerVolumeMountArgs']]]]:
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerVolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)

    @_builtins.property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the working directory of the CCI Pod container.
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class PodV2ContainerEnvArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2ContainerEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2ContainerEnvFromArgsDict(TypedDict):
        config_map_ref: NotRequired[pulumi.Input['PodV2ContainerEnvFromConfigMapRefArgsDict']]
        """
        Specifies the config map.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prefix.
        """
        secret_ref: NotRequired[pulumi.Input['PodV2ContainerEnvFromSecretRefArgsDict']]
        """
        Specifies the secret.
        """
elif False:
    PodV2ContainerEnvFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerEnvFromArgs:
    def __init__(__self__, *,
                 config_map_ref: Optional[pulumi.Input['PodV2ContainerEnvFromConfigMapRefArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input['PodV2ContainerEnvFromSecretRefArgs']] = None):
        """
        :param pulumi.Input['PodV2ContainerEnvFromConfigMapRefArgs'] config_map_ref: Specifies the config map.
        :param pulumi.Input[_builtins.str] prefix: Specifies the prefix.
        :param pulumi.Input['PodV2ContainerEnvFromSecretRefArgs'] secret_ref: Specifies the secret.
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional[pulumi.Input['PodV2ContainerEnvFromConfigMapRefArgs']]:
        """
        Specifies the config map.
        """
        return pulumi.get(self, "config_map_ref")

    @config_map_ref.setter
    def config_map_ref(self, value: Optional[pulumi.Input['PodV2ContainerEnvFromConfigMapRefArgs']]):
        pulumi.set(self, "config_map_ref", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input['PodV2ContainerEnvFromSecretRefArgs']]:
        """
        Specifies the secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input['PodV2ContainerEnvFromSecretRefArgs']]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class PodV2ContainerEnvFromConfigMapRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    PodV2ContainerEnvFromConfigMapRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerEnvFromConfigMapRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2ContainerEnvFromSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    PodV2ContainerEnvFromSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerEnvFromSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2ContainerLifecycleArgsDict(TypedDict):
        post_start: NotRequired[pulumi.Input['PodV2ContainerLifecyclePostStartArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        pre_stop: NotRequired[pulumi.Input['PodV2ContainerLifecyclePreStopArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2ContainerLifecycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecycleArgs:
    def __init__(__self__, *,
                 post_start: Optional[pulumi.Input['PodV2ContainerLifecyclePostStartArgs']] = None,
                 pre_stop: Optional[pulumi.Input['PodV2ContainerLifecyclePreStopArgs']] = None):
        """
        :param pulumi.Input['PodV2ContainerLifecyclePostStartArgs'] post_start: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2ContainerLifecyclePreStopArgs'] pre_stop: The lifecycle pre stop of the CCI Pod container.
        """
        if post_start is not None:
            pulumi.set(__self__, "post_start", post_start)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @_builtins.property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional[pulumi.Input['PodV2ContainerLifecyclePostStartArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "post_start")

    @post_start.setter
    def post_start(self, value: Optional[pulumi.Input['PodV2ContainerLifecyclePostStartArgs']]):
        pulumi.set(self, "post_start", value)

    @_builtins.property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional[pulumi.Input['PodV2ContainerLifecyclePreStopArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "pre_stop")

    @pre_stop.setter
    def pre_stop(self, value: Optional[pulumi.Input['PodV2ContainerLifecyclePreStopArgs']]):
        pulumi.set(self, "pre_stop", value)


if not MYPY:
    class PodV2ContainerLifecyclePostStartArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2ContainerLifecyclePostStartExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2ContainerLifecyclePostStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePostStartArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2ContainerLifecyclePostStartExecArgs']] = None,
                 http_get: Optional[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetArgs']] = None):
        """
        :param pulumi.Input['PodV2ContainerLifecyclePostStartExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2ContainerLifecyclePostStartExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2ContainerLifecyclePostStartExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class PodV2ContainerLifecyclePostStartExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2ContainerLifecyclePostStartExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePostStartExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2ContainerLifecyclePostStartHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2ContainerLifecyclePostStartHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePostStartHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePostStartHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2ContainerLifecyclePreStopArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2ContainerLifecyclePreStopExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2ContainerLifecyclePreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePreStopArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2ContainerLifecyclePreStopExecArgs']] = None,
                 http_get: Optional[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetArgs']] = None):
        """
        :param pulumi.Input['PodV2ContainerLifecyclePreStopExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2ContainerLifecyclePreStopExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2ContainerLifecyclePreStopExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class PodV2ContainerLifecyclePreStopExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2ContainerLifecyclePreStopExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePreStopExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2ContainerLifecyclePreStopHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2ContainerLifecyclePreStopHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePreStopHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLifecyclePreStopHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2ContainerLivenessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2ContainerLivenessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2ContainerLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLivenessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2ContainerLivenessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2ContainerLivenessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2ContainerLivenessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2ContainerLivenessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2ContainerLivenessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2ContainerLivenessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLivenessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2ContainerLivenessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2ContainerLivenessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLivenessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerLivenessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2ContainerLivenessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2ContainerLivenessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerLivenessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2ContainerPortArgsDict(TypedDict):
        container_port: pulumi.Input[_builtins.int]
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the port name of the container.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the protocol for container port.
        """
elif False:
    PodV2ContainerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerPortArgs:
    def __init__(__self__, *,
                 container_port: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] container_port: Specifies the number of port to expose on the IP address of pod.
        :param pulumi.Input[_builtins.str] name: Specifies the port name of the container.
        :param pulumi.Input[_builtins.str] protocol: Specifies the protocol for container port.
        """
        pulumi.set(__self__, "container_port", container_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the port name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the protocol for container port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class PodV2ContainerReadinessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2ContainerReadinessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2ContainerReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerReadinessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2ContainerReadinessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2ContainerReadinessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2ContainerReadinessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2ContainerReadinessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2ContainerReadinessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2ContainerReadinessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerReadinessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2ContainerReadinessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2ContainerReadinessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerReadinessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerReadinessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2ContainerReadinessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2ContainerReadinessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerReadinessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2ContainerResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the limits of resource.
        """
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the requests of the resource.
        """
elif False:
    PodV2ContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] limits: Specifies the limits of resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] requests: Specifies the requests of the resource.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the limits of resource.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the requests of the resource.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class PodV2ContainerSecurityContextArgsDict(TypedDict):
        capabilities: NotRequired[pulumi.Input['PodV2ContainerSecurityContextCapabilitiesArgsDict']]
        """
        Specifies the capabilities of the security context.
        """
        proc_mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        read_only_root_file_system: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this container has a read-only root file system.
        """
        run_as_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        The GID TO run the entrypoint of the container process.
        """
        run_as_non_root: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The container must run as a non-root user.
        """
        run_as_user: NotRequired[pulumi.Input[_builtins.int]]
        """
        The UID to run the entrypoint of the container process.
        """
elif False:
    PodV2ContainerSecurityContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerSecurityContextArgs:
    def __init__(__self__, *,
                 capabilities: Optional[pulumi.Input['PodV2ContainerSecurityContextCapabilitiesArgs']] = None,
                 proc_mount: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only_root_file_system: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_group: Optional[pulumi.Input[_builtins.int]] = None,
                 run_as_non_root: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_user: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2ContainerSecurityContextCapabilitiesArgs'] capabilities: Specifies the capabilities of the security context.
        :param pulumi.Input[_builtins.str] proc_mount: Specifies the denotes the type of proc mount to use for the containers.
        :param pulumi.Input[_builtins.bool] read_only_root_file_system: Whether this container has a read-only root file system.
        :param pulumi.Input[_builtins.int] run_as_group: The GID TO run the entrypoint of the container process.
        :param pulumi.Input[_builtins.bool] run_as_non_root: The container must run as a non-root user.
        :param pulumi.Input[_builtins.int] run_as_user: The UID to run the entrypoint of the container process.
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_file_system is not None:
            pulumi.set(__self__, "read_only_root_file_system", read_only_root_file_system)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['PodV2ContainerSecurityContextCapabilitiesArgs']]:
        """
        Specifies the capabilities of the security context.
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['PodV2ContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @_builtins.property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proc_mount", value)

    @_builtins.property
    @pulumi.getter(name="readOnlyRootFileSystem")
    def read_only_root_file_system(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this container has a read-only root file system.
        """
        return pulumi.get(self, "read_only_root_file_system")

    @read_only_root_file_system.setter
    def read_only_root_file_system(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only_root_file_system", value)

    @_builtins.property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The GID TO run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_group", value)

    @_builtins.property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The container must run as a non-root user.
        """
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @_builtins.property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The UID to run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_user", value)


if not MYPY:
    class PodV2ContainerSecurityContextCapabilitiesArgsDict(TypedDict):
        adds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        drops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2ContainerSecurityContextCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 adds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 drops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @_builtins.property
    @pulumi.getter
    def adds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "adds")

    @adds.setter
    def adds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "adds", value)

    @_builtins.property
    @pulumi.getter
    def drops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "drops")

    @drops.setter
    def drops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "drops", value)


if not MYPY:
    class PodV2ContainerStartupProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2ContainerStartupProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2ContainerStartupProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerStartupProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2ContainerStartupProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2ContainerStartupProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2ContainerStartupProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2ContainerStartupProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2ContainerStartupProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2ContainerStartupProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerStartupProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2ContainerStartupProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2ContainerStartupProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerStartupProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2ContainerStartupProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2ContainerStartupProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2ContainerStartupProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerStartupProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2ContainerVolumeMountArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        extend_path_mode: NotRequired[pulumi.Input[_builtins.str]]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        sub_path: NotRequired[pulumi.Input[_builtins.str]]
        sub_path_expr: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2ContainerVolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ContainerVolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 extend_path_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 sub_path: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_path_expr: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if extend_path_mode is not None:
            pulumi.set(__self__, "extend_path_mode", extend_path_mode)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="extendPathMode")
    def extend_path_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_path_mode")

    @extend_path_mode.setter
    def extend_path_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_path_mode", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path", value)

    @_builtins.property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path_expr")

    @sub_path_expr.setter
    def sub_path_expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path_expr", value)


if not MYPY:
    class PodV2DnsConfigArgsDict(TypedDict):
        nameservers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the name servers of the DNS config.
        """
        options: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2DnsConfigOptionArgsDict']]]]
        """
        Specifies the options of the DNS config.
        """
        searches: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the searches of the DNS config.
        """
elif False:
    PodV2DnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2DnsConfigArgs:
    def __init__(__self__, *,
                 nameservers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 options: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2DnsConfigOptionArgs']]]] = None,
                 searches: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nameservers: Specifies the name servers of the DNS config.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2DnsConfigOptionArgs']]] options: Specifies the options of the DNS config.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] searches: Specifies the searches of the DNS config.
        """
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)

    @_builtins.property
    @pulumi.getter
    def nameservers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the name servers of the DNS config.
        """
        return pulumi.get(self, "nameservers")

    @nameservers.setter
    def nameservers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nameservers", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2DnsConfigOptionArgs']]]]:
        """
        Specifies the options of the DNS config.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2DnsConfigOptionArgs']]]]):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def searches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the searches of the DNS config.
        """
        return pulumi.get(self, "searches")

    @searches.setter
    def searches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "searches", value)


if not MYPY:
    class PodV2DnsConfigOptionArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the options.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value of the options.
        """
elif False:
    PodV2DnsConfigOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2DnsConfigOptionArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the options.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the options.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the options.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value of the options.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2EphemeralContainerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the container.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the arguments to the entrypoint of the container.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the command of the container.
        """
        env_froms: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvFromArgsDict']]]]
        """
        The sources to populate environment variables of the container.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvArgsDict']]]]
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image name of the CCI Pod container.
        """
        lifecycle: NotRequired[pulumi.Input['PodV2EphemeralContainerLifecycleArgsDict']]
        """
        Specifies the lifecycle of the container.
        """
        liveness_probe: NotRequired[pulumi.Input['PodV2EphemeralContainerLivenessProbeArgsDict']]
        """
        Specifies the liveness probe of the container.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerPortArgsDict']]]]
        """
        Specifies the ports of the container.
        """
        readiness_probe: NotRequired[pulumi.Input['PodV2EphemeralContainerReadinessProbeArgsDict']]
        """
        Specifies the readiness probe of the container.
        """
        resources: NotRequired[pulumi.Input['PodV2EphemeralContainerResourcesArgsDict']]
        """
        Specifies the resources of the container.
        """
        security_context: NotRequired[pulumi.Input['PodV2EphemeralContainerSecurityContextArgsDict']]
        """
        Specifies the security context of the container.
        """
        startup_probe: NotRequired[pulumi.Input['PodV2EphemeralContainerStartupProbeArgsDict']]
        """
        Specifies the startup probe of the container.
        """
        stdin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        stdin_once: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        termination_message_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message path of the CCI Pod container.
        """
        termination_message_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        tty: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerVolumeMountArgsDict']]]]
        working_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the working directory of the CCI Pod container.
        """
elif False:
    PodV2EphemeralContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 env_froms: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvFromArgs']]]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvArgs']]]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 lifecycle: Optional[pulumi.Input['PodV2EphemeralContainerLifecycleArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['PodV2EphemeralContainerLivenessProbeArgs']] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerPortArgs']]]] = None,
                 readiness_probe: Optional[pulumi.Input['PodV2EphemeralContainerReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['PodV2EphemeralContainerResourcesArgs']] = None,
                 security_context: Optional[pulumi.Input['PodV2EphemeralContainerSecurityContextArgs']] = None,
                 startup_probe: Optional[pulumi.Input['PodV2EphemeralContainerStartupProbeArgs']] = None,
                 stdin: Optional[pulumi.Input[_builtins.bool]] = None,
                 stdin_once: Optional[pulumi.Input[_builtins.bool]] = None,
                 termination_message_path: Optional[pulumi.Input[_builtins.str]] = None,
                 termination_message_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 tty: Optional[pulumi.Input[_builtins.bool]] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerVolumeMountArgs']]]] = None,
                 working_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Specifies the arguments to the entrypoint of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Specifies the command of the container.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvFromArgs']]] env_froms: The sources to populate environment variables of the container.
        :param pulumi.Input[_builtins.str] image: Specifies the image name of the CCI Pod container.
        :param pulumi.Input['PodV2EphemeralContainerLifecycleArgs'] lifecycle: Specifies the lifecycle of the container.
        :param pulumi.Input['PodV2EphemeralContainerLivenessProbeArgs'] liveness_probe: Specifies the liveness probe of the container.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerPortArgs']]] ports: Specifies the ports of the container.
        :param pulumi.Input['PodV2EphemeralContainerReadinessProbeArgs'] readiness_probe: Specifies the readiness probe of the container.
        :param pulumi.Input['PodV2EphemeralContainerResourcesArgs'] resources: Specifies the resources of the container.
        :param pulumi.Input['PodV2EphemeralContainerSecurityContextArgs'] security_context: Specifies the security context of the container.
        :param pulumi.Input['PodV2EphemeralContainerStartupProbeArgs'] startup_probe: Specifies the startup probe of the container.
        :param pulumi.Input[_builtins.bool] stdin: Specifies whether this container should allocate a buffer for stdin in the container runtime.
        :param pulumi.Input[_builtins.bool] stdin_once: Specifies whether this container runtime should close the stdin channel.
        :param pulumi.Input[_builtins.str] termination_message_path: Specifies the termination message path of the CCI Pod container.
        :param pulumi.Input[_builtins.str] termination_message_policy: Specifies the termination message policy of the CCI Pod container.
        :param pulumi.Input[_builtins.bool] tty: Specifies whether this container should allocate a TTY for itself.
        :param pulumi.Input[_builtins.str] working_dir: Specifies the working directory of the CCI Pod container.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the arguments to the entrypoint of the container.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the command of the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvFromArgs']]]]:
        """
        The sources to populate environment variables of the container.
        """
        return pulumi.get(self, "env_froms")

    @env_froms.setter
    def env_froms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvFromArgs']]]]):
        pulumi.set(self, "env_froms", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvArgs']]]]:
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image name of the CCI Pod container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLifecycleArgs']]:
        """
        Specifies the lifecycle of the container.
        """
        return pulumi.get(self, "lifecycle")

    @lifecycle.setter
    def lifecycle(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLifecycleArgs']]):
        pulumi.set(self, "lifecycle", value)

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLivenessProbeArgs']]:
        """
        Specifies the liveness probe of the container.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerPortArgs']]]]:
        """
        Specifies the ports of the container.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerPortArgs']]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['PodV2EphemeralContainerReadinessProbeArgs']]:
        """
        Specifies the readiness probe of the container.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['PodV2EphemeralContainerReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['PodV2EphemeralContainerResourcesArgs']]:
        """
        Specifies the resources of the container.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['PodV2EphemeralContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['PodV2EphemeralContainerSecurityContextArgs']]:
        """
        Specifies the security context of the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['PodV2EphemeralContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @_builtins.property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional[pulumi.Input['PodV2EphemeralContainerStartupProbeArgs']]:
        """
        Specifies the startup probe of the container.
        """
        return pulumi.get(self, "startup_probe")

    @startup_probe.setter
    def startup_probe(self, value: Optional[pulumi.Input['PodV2EphemeralContainerStartupProbeArgs']]):
        pulumi.set(self, "startup_probe", value)

    @_builtins.property
    @pulumi.getter
    def stdin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        return pulumi.get(self, "stdin")

    @stdin.setter
    def stdin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin", value)

    @_builtins.property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        return pulumi.get(self, "stdin_once")

    @stdin_once.setter
    def stdin_once(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin_once", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message path of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_path")

    @termination_message_path.setter
    def termination_message_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_path", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_policy")

    @termination_message_policy.setter
    def termination_message_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_policy", value)

    @_builtins.property
    @pulumi.getter
    def tty(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        return pulumi.get(self, "tty")

    @tty.setter
    def tty(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tty", value)

    @_builtins.property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerVolumeMountArgs']]]]:
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerVolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)

    @_builtins.property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the working directory of the CCI Pod container.
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class PodV2EphemeralContainerEnvArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2EphemeralContainerEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2EphemeralContainerEnvFromArgsDict(TypedDict):
        config_map_ref: NotRequired[pulumi.Input['PodV2EphemeralContainerEnvFromConfigMapRefArgsDict']]
        """
        Specifies the config map.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prefix.
        """
        secret_ref: NotRequired[pulumi.Input['PodV2EphemeralContainerEnvFromSecretRefArgsDict']]
        """
        Specifies the secret.
        """
elif False:
    PodV2EphemeralContainerEnvFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerEnvFromArgs:
    def __init__(__self__, *,
                 config_map_ref: Optional[pulumi.Input['PodV2EphemeralContainerEnvFromConfigMapRefArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input['PodV2EphemeralContainerEnvFromSecretRefArgs']] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerEnvFromConfigMapRefArgs'] config_map_ref: Specifies the config map.
        :param pulumi.Input[_builtins.str] prefix: Specifies the prefix.
        :param pulumi.Input['PodV2EphemeralContainerEnvFromSecretRefArgs'] secret_ref: Specifies the secret.
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional[pulumi.Input['PodV2EphemeralContainerEnvFromConfigMapRefArgs']]:
        """
        Specifies the config map.
        """
        return pulumi.get(self, "config_map_ref")

    @config_map_ref.setter
    def config_map_ref(self, value: Optional[pulumi.Input['PodV2EphemeralContainerEnvFromConfigMapRefArgs']]):
        pulumi.set(self, "config_map_ref", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input['PodV2EphemeralContainerEnvFromSecretRefArgs']]:
        """
        Specifies the secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input['PodV2EphemeralContainerEnvFromSecretRefArgs']]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class PodV2EphemeralContainerEnvFromConfigMapRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    PodV2EphemeralContainerEnvFromConfigMapRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerEnvFromConfigMapRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2EphemeralContainerEnvFromSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    PodV2EphemeralContainerEnvFromSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerEnvFromSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2EphemeralContainerLifecycleArgsDict(TypedDict):
        post_start: NotRequired[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        pre_stop: NotRequired[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2EphemeralContainerLifecycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecycleArgs:
    def __init__(__self__, *,
                 post_start: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartArgs']] = None,
                 pre_stop: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopArgs']] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerLifecyclePostStartArgs'] post_start: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2EphemeralContainerLifecyclePreStopArgs'] pre_stop: The lifecycle pre stop of the CCI Pod container.
        """
        if post_start is not None:
            pulumi.set(__self__, "post_start", post_start)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @_builtins.property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "post_start")

    @post_start.setter
    def post_start(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartArgs']]):
        pulumi.set(self, "post_start", value)

    @_builtins.property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "pre_stop")

    @pre_stop.setter
    def pre_stop(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopArgs']]):
        pulumi.set(self, "pre_stop", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePostStartArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2EphemeralContainerLifecyclePostStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePostStartArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartExecArgs']] = None,
                 http_get: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetArgs']] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerLifecyclePostStartExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePostStartExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2EphemeralContainerLifecyclePostStartExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePostStartExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePostStartHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2EphemeralContainerLifecyclePostStartHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePostStartHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePostStartHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePreStopArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2EphemeralContainerLifecyclePreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePreStopArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopExecArgs']] = None,
                 http_get: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetArgs']] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerLifecyclePreStopExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePreStopExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2EphemeralContainerLifecyclePreStopExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePreStopExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePreStopHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2EphemeralContainerLifecyclePreStopHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePreStopHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLifecyclePreStopHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2EphemeralContainerLivenessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2EphemeralContainerLivenessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2EphemeralContainerLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLivenessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2EphemeralContainerLivenessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerLivenessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2EphemeralContainerLivenessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2EphemeralContainerLivenessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2EphemeralContainerLivenessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2EphemeralContainerLivenessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLivenessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2EphemeralContainerLivenessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2EphemeralContainerLivenessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLivenessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerLivenessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2EphemeralContainerPortArgsDict(TypedDict):
        container_port: pulumi.Input[_builtins.int]
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the port name of the container.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the protocol for container port.
        """
elif False:
    PodV2EphemeralContainerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerPortArgs:
    def __init__(__self__, *,
                 container_port: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] container_port: Specifies the number of port to expose on the IP address of pod.
        :param pulumi.Input[_builtins.str] name: Specifies the port name of the container.
        :param pulumi.Input[_builtins.str] protocol: Specifies the protocol for container port.
        """
        pulumi.set(__self__, "container_port", container_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the port name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the protocol for container port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class PodV2EphemeralContainerReadinessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2EphemeralContainerReadinessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2EphemeralContainerReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerReadinessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2EphemeralContainerReadinessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerReadinessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2EphemeralContainerReadinessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2EphemeralContainerReadinessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2EphemeralContainerReadinessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2EphemeralContainerReadinessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerReadinessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2EphemeralContainerReadinessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2EphemeralContainerReadinessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerReadinessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerReadinessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2EphemeralContainerResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the limits of resource.
        """
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the requests of the resource.
        """
elif False:
    PodV2EphemeralContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] limits: Specifies the limits of resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] requests: Specifies the requests of the resource.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the limits of resource.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the requests of the resource.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class PodV2EphemeralContainerSecurityContextArgsDict(TypedDict):
        capabilities: NotRequired[pulumi.Input['PodV2EphemeralContainerSecurityContextCapabilitiesArgsDict']]
        """
        Specifies the capabilities of the security context.
        """
        proc_mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        read_only_root_file_system: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this container has a read-only root file system.
        """
        run_as_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        The GID TO run the entrypoint of the container process.
        """
        run_as_non_root: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The container must run as a non-root user.
        """
        run_as_user: NotRequired[pulumi.Input[_builtins.int]]
        """
        The UID to run the entrypoint of the container process.
        """
elif False:
    PodV2EphemeralContainerSecurityContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerSecurityContextArgs:
    def __init__(__self__, *,
                 capabilities: Optional[pulumi.Input['PodV2EphemeralContainerSecurityContextCapabilitiesArgs']] = None,
                 proc_mount: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only_root_file_system: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_group: Optional[pulumi.Input[_builtins.int]] = None,
                 run_as_non_root: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_user: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerSecurityContextCapabilitiesArgs'] capabilities: Specifies the capabilities of the security context.
        :param pulumi.Input[_builtins.str] proc_mount: Specifies the denotes the type of proc mount to use for the containers.
        :param pulumi.Input[_builtins.bool] read_only_root_file_system: Whether this container has a read-only root file system.
        :param pulumi.Input[_builtins.int] run_as_group: The GID TO run the entrypoint of the container process.
        :param pulumi.Input[_builtins.bool] run_as_non_root: The container must run as a non-root user.
        :param pulumi.Input[_builtins.int] run_as_user: The UID to run the entrypoint of the container process.
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_file_system is not None:
            pulumi.set(__self__, "read_only_root_file_system", read_only_root_file_system)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['PodV2EphemeralContainerSecurityContextCapabilitiesArgs']]:
        """
        Specifies the capabilities of the security context.
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['PodV2EphemeralContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @_builtins.property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proc_mount", value)

    @_builtins.property
    @pulumi.getter(name="readOnlyRootFileSystem")
    def read_only_root_file_system(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this container has a read-only root file system.
        """
        return pulumi.get(self, "read_only_root_file_system")

    @read_only_root_file_system.setter
    def read_only_root_file_system(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only_root_file_system", value)

    @_builtins.property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The GID TO run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_group", value)

    @_builtins.property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The container must run as a non-root user.
        """
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @_builtins.property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The UID to run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_user", value)


if not MYPY:
    class PodV2EphemeralContainerSecurityContextCapabilitiesArgsDict(TypedDict):
        adds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        drops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2EphemeralContainerSecurityContextCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 adds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 drops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @_builtins.property
    @pulumi.getter
    def adds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "adds")

    @adds.setter
    def adds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "adds", value)

    @_builtins.property
    @pulumi.getter
    def drops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "drops")

    @drops.setter
    def drops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "drops", value)


if not MYPY:
    class PodV2EphemeralContainerStartupProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2EphemeralContainerStartupProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2EphemeralContainerStartupProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerStartupProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2EphemeralContainerStartupProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2EphemeralContainerStartupProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2EphemeralContainerStartupProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2EphemeralContainerStartupProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2EphemeralContainerStartupProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2EphemeralContainerStartupProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerStartupProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2EphemeralContainerStartupProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2EphemeralContainerStartupProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerStartupProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerStartupProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2EphemeralContainerVolumeMountArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        extend_path_mode: NotRequired[pulumi.Input[_builtins.str]]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        sub_path: NotRequired[pulumi.Input[_builtins.str]]
        sub_path_expr: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2EphemeralContainerVolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2EphemeralContainerVolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 extend_path_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 sub_path: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_path_expr: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if extend_path_mode is not None:
            pulumi.set(__self__, "extend_path_mode", extend_path_mode)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="extendPathMode")
    def extend_path_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_path_mode")

    @extend_path_mode.setter
    def extend_path_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_path_mode", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path", value)

    @_builtins.property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path_expr")

    @sub_path_expr.setter
    def sub_path_expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path_expr", value)


if not MYPY:
    class PodV2HostAliasArgsDict(TypedDict):
        hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        ip: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2HostAliasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2HostAliasArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "hostnames", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class PodV2ImagePullSecretArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2ImagePullSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ImagePullSecretArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PodV2InitContainerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the container.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the arguments to the entrypoint of the container.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the command of the container.
        """
        env_froms: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvFromArgsDict']]]]
        """
        The sources to populate environment variables of the container.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvArgsDict']]]]
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image name of the CCI Pod container.
        """
        lifecycle: NotRequired[pulumi.Input['PodV2InitContainerLifecycleArgsDict']]
        """
        Specifies the lifecycle of the container.
        """
        liveness_probe: NotRequired[pulumi.Input['PodV2InitContainerLivenessProbeArgsDict']]
        """
        Specifies the liveness probe of the container.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerPortArgsDict']]]]
        """
        Specifies the ports of the container.
        """
        readiness_probe: NotRequired[pulumi.Input['PodV2InitContainerReadinessProbeArgsDict']]
        """
        Specifies the readiness probe of the container.
        """
        resources: NotRequired[pulumi.Input['PodV2InitContainerResourcesArgsDict']]
        """
        Specifies the resources of the container.
        """
        security_context: NotRequired[pulumi.Input['PodV2InitContainerSecurityContextArgsDict']]
        """
        Specifies the security context of the container.
        """
        startup_probe: NotRequired[pulumi.Input['PodV2InitContainerStartupProbeArgsDict']]
        """
        Specifies the startup probe of the container.
        """
        stdin: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        stdin_once: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        termination_message_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message path of the CCI Pod container.
        """
        termination_message_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        tty: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerVolumeMountArgsDict']]]]
        working_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the working directory of the CCI Pod container.
        """
elif False:
    PodV2InitContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 env_froms: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvFromArgs']]]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvArgs']]]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 lifecycle: Optional[pulumi.Input['PodV2InitContainerLifecycleArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['PodV2InitContainerLivenessProbeArgs']] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerPortArgs']]]] = None,
                 readiness_probe: Optional[pulumi.Input['PodV2InitContainerReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['PodV2InitContainerResourcesArgs']] = None,
                 security_context: Optional[pulumi.Input['PodV2InitContainerSecurityContextArgs']] = None,
                 startup_probe: Optional[pulumi.Input['PodV2InitContainerStartupProbeArgs']] = None,
                 stdin: Optional[pulumi.Input[_builtins.bool]] = None,
                 stdin_once: Optional[pulumi.Input[_builtins.bool]] = None,
                 termination_message_path: Optional[pulumi.Input[_builtins.str]] = None,
                 termination_message_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 tty: Optional[pulumi.Input[_builtins.bool]] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerVolumeMountArgs']]]] = None,
                 working_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Specifies the arguments to the entrypoint of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Specifies the command of the container.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvFromArgs']]] env_froms: The sources to populate environment variables of the container.
        :param pulumi.Input[_builtins.str] image: Specifies the image name of the CCI Pod container.
        :param pulumi.Input['PodV2InitContainerLifecycleArgs'] lifecycle: Specifies the lifecycle of the container.
        :param pulumi.Input['PodV2InitContainerLivenessProbeArgs'] liveness_probe: Specifies the liveness probe of the container.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerPortArgs']]] ports: Specifies the ports of the container.
        :param pulumi.Input['PodV2InitContainerReadinessProbeArgs'] readiness_probe: Specifies the readiness probe of the container.
        :param pulumi.Input['PodV2InitContainerResourcesArgs'] resources: Specifies the resources of the container.
        :param pulumi.Input['PodV2InitContainerSecurityContextArgs'] security_context: Specifies the security context of the container.
        :param pulumi.Input['PodV2InitContainerStartupProbeArgs'] startup_probe: Specifies the startup probe of the container.
        :param pulumi.Input[_builtins.bool] stdin: Specifies whether this container should allocate a buffer for stdin in the container runtime.
        :param pulumi.Input[_builtins.bool] stdin_once: Specifies whether this container runtime should close the stdin channel.
        :param pulumi.Input[_builtins.str] termination_message_path: Specifies the termination message path of the CCI Pod container.
        :param pulumi.Input[_builtins.str] termination_message_policy: Specifies the termination message policy of the CCI Pod container.
        :param pulumi.Input[_builtins.bool] tty: Specifies whether this container should allocate a TTY for itself.
        :param pulumi.Input[_builtins.str] working_dir: Specifies the working directory of the CCI Pod container.
        """
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if env_froms is not None:
            pulumi.set(__self__, "env_froms", env_froms)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if startup_probe is not None:
            pulumi.set(__self__, "startup_probe", startup_probe)
        if stdin is not None:
            pulumi.set(__self__, "stdin", stdin)
        if stdin_once is not None:
            pulumi.set(__self__, "stdin_once", stdin_once)
        if termination_message_path is not None:
            pulumi.set(__self__, "termination_message_path", termination_message_path)
        if termination_message_policy is not None:
            pulumi.set(__self__, "termination_message_policy", termination_message_policy)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the arguments to the entrypoint of the container.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the command of the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter(name="envFroms")
    def env_froms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvFromArgs']]]]:
        """
        The sources to populate environment variables of the container.
        """
        return pulumi.get(self, "env_froms")

    @env_froms.setter
    def env_froms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvFromArgs']]]]):
        pulumi.set(self, "env_froms", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvArgs']]]]:
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image name of the CCI Pod container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[pulumi.Input['PodV2InitContainerLifecycleArgs']]:
        """
        Specifies the lifecycle of the container.
        """
        return pulumi.get(self, "lifecycle")

    @lifecycle.setter
    def lifecycle(self, value: Optional[pulumi.Input['PodV2InitContainerLifecycleArgs']]):
        pulumi.set(self, "lifecycle", value)

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['PodV2InitContainerLivenessProbeArgs']]:
        """
        Specifies the liveness probe of the container.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['PodV2InitContainerLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerPortArgs']]]]:
        """
        Specifies the ports of the container.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerPortArgs']]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['PodV2InitContainerReadinessProbeArgs']]:
        """
        Specifies the readiness probe of the container.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['PodV2InitContainerReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['PodV2InitContainerResourcesArgs']]:
        """
        Specifies the resources of the container.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['PodV2InitContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @_builtins.property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['PodV2InitContainerSecurityContextArgs']]:
        """
        Specifies the security context of the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['PodV2InitContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @_builtins.property
    @pulumi.getter(name="startupProbe")
    def startup_probe(self) -> Optional[pulumi.Input['PodV2InitContainerStartupProbeArgs']]:
        """
        Specifies the startup probe of the container.
        """
        return pulumi.get(self, "startup_probe")

    @startup_probe.setter
    def startup_probe(self, value: Optional[pulumi.Input['PodV2InitContainerStartupProbeArgs']]):
        pulumi.set(self, "startup_probe", value)

    @_builtins.property
    @pulumi.getter
    def stdin(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a buffer for stdin in the container runtime.
        """
        return pulumi.get(self, "stdin")

    @stdin.setter
    def stdin(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin", value)

    @_builtins.property
    @pulumi.getter(name="stdinOnce")
    def stdin_once(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container runtime should close the stdin channel.
        """
        return pulumi.get(self, "stdin_once")

    @stdin_once.setter
    def stdin_once(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "stdin_once", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePath")
    def termination_message_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message path of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_path")

    @termination_message_path.setter
    def termination_message_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_path", value)

    @_builtins.property
    @pulumi.getter(name="terminationMessagePolicy")
    def termination_message_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the termination message policy of the CCI Pod container.
        """
        return pulumi.get(self, "termination_message_policy")

    @termination_message_policy.setter
    def termination_message_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "termination_message_policy", value)

    @_builtins.property
    @pulumi.getter
    def tty(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether this container should allocate a TTY for itself.
        """
        return pulumi.get(self, "tty")

    @tty.setter
    def tty(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tty", value)

    @_builtins.property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerVolumeMountArgs']]]]:
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerVolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)

    @_builtins.property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the working directory of the CCI Pod container.
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class PodV2InitContainerEnvArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2InitContainerEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2InitContainerEnvFromArgsDict(TypedDict):
        config_map_ref: NotRequired[pulumi.Input['PodV2InitContainerEnvFromConfigMapRefArgsDict']]
        """
        Specifies the config map.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prefix.
        """
        secret_ref: NotRequired[pulumi.Input['PodV2InitContainerEnvFromSecretRefArgsDict']]
        """
        Specifies the secret.
        """
elif False:
    PodV2InitContainerEnvFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerEnvFromArgs:
    def __init__(__self__, *,
                 config_map_ref: Optional[pulumi.Input['PodV2InitContainerEnvFromConfigMapRefArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input['PodV2InitContainerEnvFromSecretRefArgs']] = None):
        """
        :param pulumi.Input['PodV2InitContainerEnvFromConfigMapRefArgs'] config_map_ref: Specifies the config map.
        :param pulumi.Input[_builtins.str] prefix: Specifies the prefix.
        :param pulumi.Input['PodV2InitContainerEnvFromSecretRefArgs'] secret_ref: Specifies the secret.
        """
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional[pulumi.Input['PodV2InitContainerEnvFromConfigMapRefArgs']]:
        """
        Specifies the config map.
        """
        return pulumi.get(self, "config_map_ref")

    @config_map_ref.setter
    def config_map_ref(self, value: Optional[pulumi.Input['PodV2InitContainerEnvFromConfigMapRefArgs']]):
        pulumi.set(self, "config_map_ref", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input['PodV2InitContainerEnvFromSecretRefArgs']]:
        """
        Specifies the secret.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input['PodV2InitContainerEnvFromSecretRefArgs']]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class PodV2InitContainerEnvFromConfigMapRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    PodV2InitContainerEnvFromConfigMapRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerEnvFromConfigMapRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2InitContainerEnvFromSecretRefArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to be defined.
        """
elif False:
    PodV2InitContainerEnvFromSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerEnvFromSecretRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name.
        :param pulumi.Input[_builtins.bool] optional: Specifies whether to be defined.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to be defined.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2InitContainerLifecycleArgsDict(TypedDict):
        post_start: NotRequired[pulumi.Input['PodV2InitContainerLifecyclePostStartArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        pre_stop: NotRequired[pulumi.Input['PodV2InitContainerLifecyclePreStopArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2InitContainerLifecycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecycleArgs:
    def __init__(__self__, *,
                 post_start: Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartArgs']] = None,
                 pre_stop: Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopArgs']] = None):
        """
        :param pulumi.Input['PodV2InitContainerLifecyclePostStartArgs'] post_start: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2InitContainerLifecyclePreStopArgs'] pre_stop: The lifecycle pre stop of the CCI Pod container.
        """
        if post_start is not None:
            pulumi.set(__self__, "post_start", post_start)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @_builtins.property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "post_start")

    @post_start.setter
    def post_start(self, value: Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartArgs']]):
        pulumi.set(self, "post_start", value)

    @_builtins.property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "pre_stop")

    @pre_stop.setter
    def pre_stop(self, value: Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopArgs']]):
        pulumi.set(self, "pre_stop", value)


if not MYPY:
    class PodV2InitContainerLifecyclePostStartArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2InitContainerLifecyclePostStartExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2InitContainerLifecyclePostStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePostStartArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartExecArgs']] = None,
                 http_get: Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetArgs']] = None):
        """
        :param pulumi.Input['PodV2InitContainerLifecyclePostStartExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class PodV2InitContainerLifecyclePostStartExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2InitContainerLifecyclePostStartExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePostStartExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2InitContainerLifecyclePostStartHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2InitContainerLifecyclePostStartHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePostStartHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePostStartHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2InitContainerLifecyclePreStopArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2InitContainerLifecyclePreStopExecArgsDict']]
        """
        The lifecycle post start of the CCI Pod container.
        """
        http_get: NotRequired[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetArgsDict']]
        """
        The lifecycle pre stop of the CCI Pod container.
        """
elif False:
    PodV2InitContainerLifecyclePreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePreStopArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopExecArgs']] = None,
                 http_get: Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetArgs']] = None):
        """
        :param pulumi.Input['PodV2InitContainerLifecyclePreStopExecArgs'] exec_: The lifecycle post start of the CCI Pod container.
        :param pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetArgs'] http_get: The lifecycle pre stop of the CCI Pod container.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopExecArgs']]:
        """
        The lifecycle post start of the CCI Pod container.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetArgs']]:
        """
        The lifecycle pre stop of the CCI Pod container.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetArgs']]):
        pulumi.set(self, "http_get", value)


if not MYPY:
    class PodV2InitContainerLifecyclePreStopExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2InitContainerLifecyclePreStopExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePreStopExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2InitContainerLifecyclePreStopHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2InitContainerLifecyclePreStopHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePreStopHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLifecyclePreStopHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2InitContainerLivenessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2InitContainerLivenessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2InitContainerLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLivenessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2InitContainerLivenessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2InitContainerLivenessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2InitContainerLivenessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2InitContainerLivenessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2InitContainerLivenessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2InitContainerLivenessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLivenessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2InitContainerLivenessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2InitContainerLivenessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLivenessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerLivenessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2InitContainerPortArgsDict(TypedDict):
        container_port: pulumi.Input[_builtins.int]
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the port name of the container.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the protocol for container port.
        """
elif False:
    PodV2InitContainerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerPortArgs:
    def __init__(__self__, *,
                 container_port: pulumi.Input[_builtins.int],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] container_port: Specifies the number of port to expose on the IP address of pod.
        :param pulumi.Input[_builtins.str] name: Specifies the port name of the container.
        :param pulumi.Input[_builtins.str] protocol: Specifies the protocol for container port.
        """
        pulumi.set(__self__, "container_port", container_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of port to expose on the IP address of pod.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the port name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the protocol for container port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class PodV2InitContainerReadinessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2InitContainerReadinessProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2InitContainerReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerReadinessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2InitContainerReadinessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2InitContainerReadinessProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2InitContainerReadinessProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2InitContainerReadinessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2InitContainerReadinessProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2InitContainerReadinessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerReadinessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2InitContainerReadinessProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2InitContainerReadinessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerReadinessProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerReadinessProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2InitContainerResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the limits of resource.
        """
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the requests of the resource.
        """
elif False:
    PodV2InitContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] limits: Specifies the limits of resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] requests: Specifies the requests of the resource.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the limits of resource.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the requests of the resource.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class PodV2InitContainerSecurityContextArgsDict(TypedDict):
        capabilities: NotRequired[pulumi.Input['PodV2InitContainerSecurityContextCapabilitiesArgsDict']]
        """
        Specifies the capabilities of the security context.
        """
        proc_mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        read_only_root_file_system: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this container has a read-only root file system.
        """
        run_as_group: NotRequired[pulumi.Input[_builtins.int]]
        """
        The GID TO run the entrypoint of the container process.
        """
        run_as_non_root: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The container must run as a non-root user.
        """
        run_as_user: NotRequired[pulumi.Input[_builtins.int]]
        """
        The UID to run the entrypoint of the container process.
        """
elif False:
    PodV2InitContainerSecurityContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerSecurityContextArgs:
    def __init__(__self__, *,
                 capabilities: Optional[pulumi.Input['PodV2InitContainerSecurityContextCapabilitiesArgs']] = None,
                 proc_mount: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only_root_file_system: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_group: Optional[pulumi.Input[_builtins.int]] = None,
                 run_as_non_root: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_user: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2InitContainerSecurityContextCapabilitiesArgs'] capabilities: Specifies the capabilities of the security context.
        :param pulumi.Input[_builtins.str] proc_mount: Specifies the denotes the type of proc mount to use for the containers.
        :param pulumi.Input[_builtins.bool] read_only_root_file_system: Whether this container has a read-only root file system.
        :param pulumi.Input[_builtins.int] run_as_group: The GID TO run the entrypoint of the container process.
        :param pulumi.Input[_builtins.bool] run_as_non_root: The container must run as a non-root user.
        :param pulumi.Input[_builtins.int] run_as_user: The UID to run the entrypoint of the container process.
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_file_system is not None:
            pulumi.set(__self__, "read_only_root_file_system", read_only_root_file_system)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['PodV2InitContainerSecurityContextCapabilitiesArgs']]:
        """
        Specifies the capabilities of the security context.
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['PodV2InitContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @_builtins.property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the denotes the type of proc mount to use for the containers.
        """
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proc_mount", value)

    @_builtins.property
    @pulumi.getter(name="readOnlyRootFileSystem")
    def read_only_root_file_system(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this container has a read-only root file system.
        """
        return pulumi.get(self, "read_only_root_file_system")

    @read_only_root_file_system.setter
    def read_only_root_file_system(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only_root_file_system", value)

    @_builtins.property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The GID TO run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_group", value)

    @_builtins.property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The container must run as a non-root user.
        """
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @_builtins.property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The UID to run the entrypoint of the container process.
        """
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_user", value)


if not MYPY:
    class PodV2InitContainerSecurityContextCapabilitiesArgsDict(TypedDict):
        adds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        drops: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PodV2InitContainerSecurityContextCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 adds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 drops: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if adds is not None:
            pulumi.set(__self__, "adds", adds)
        if drops is not None:
            pulumi.set(__self__, "drops", drops)

    @_builtins.property
    @pulumi.getter
    def adds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "adds")

    @adds.setter
    def adds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "adds", value)

    @_builtins.property
    @pulumi.getter
    def drops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "drops")

    @drops.setter
    def drops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "drops", value)


if not MYPY:
    class PodV2InitContainerStartupProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['PodV2InitContainerStartupProbeExecArgsDict']]
        """
        Specifies the exec.
        """
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        http_gets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetArgsDict']]]]
        """
        Specifies the HTTP get.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies how often to perform the probe.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2InitContainerStartupProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerStartupProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['PodV2InitContainerStartupProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_gets: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetArgs']]]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['PodV2InitContainerStartupProbeExecArgs'] exec_: Specifies the exec.
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetArgs']]] http_gets: Specifies the HTTP get.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds after the container has started before liveness probes are initialed.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies how often to perform the probe.
        :param pulumi.Input[_builtins.int] success_threshold: The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['PodV2InitContainerStartupProbeExecArgs']]:
        """
        Specifies the exec.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['PodV2InitContainerStartupProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum consecutive failures for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetArgs']]]]:
        """
        Specifies the HTTP get.
        """
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetArgs']]]]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after the container has started before liveness probes are initialed.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies how often to perform the probe.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum consecutive successes for the probe to be considered failed after having succeeded.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class PodV2InitContainerStartupProbeExecArgsDict(TypedDict):
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The command line to execute inside the container.
        """
elif False:
    PodV2InitContainerStartupProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerStartupProbeExecArgs:
    def __init__(__self__, *,
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: The command line to execute inside the container.
        """
        if commands is not None:
            pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The command line to execute inside the container.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class PodV2InitContainerStartupProbeHttpGetArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host name.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetHttpHeaderArgsDict']]]]
        """
        The custom headers to set in the request.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to access on the HTTP server.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to use for connecting to the host.
        """
elif False:
    PodV2InitContainerStartupProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerStartupProbeHttpGetArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetHttpHeaderArgs']]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host name.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetHttpHeaderArgs']]] http_headers: The custom headers to set in the request.
        :param pulumi.Input[_builtins.str] path: The path to access on the HTTP server.
        :param pulumi.Input[_builtins.str] port: The port to access on the HTTP server.
        :param pulumi.Input[_builtins.str] scheme: The scheme to use for connecting to the host.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host name.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetHttpHeaderArgs']]]]:
        """
        The custom headers to set in the request.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2InitContainerStartupProbeHttpGetHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port to access on the HTTP server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to use for connecting to the host.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class PodV2InitContainerStartupProbeHttpGetHttpHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the custom HTTP headers.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the custom HTTP headers.
        """
elif False:
    PodV2InitContainerStartupProbeHttpGetHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerStartupProbeHttpGetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the custom HTTP headers.
        :param pulumi.Input[_builtins.str] value: The value of the custom HTTP headers.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the custom HTTP headers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the custom HTTP headers.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2InitContainerVolumeMountArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        extend_path_mode: NotRequired[pulumi.Input[_builtins.str]]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        sub_path: NotRequired[pulumi.Input[_builtins.str]]
        sub_path_expr: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2InitContainerVolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2InitContainerVolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 extend_path_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 sub_path: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_path_expr: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if extend_path_mode is not None:
            pulumi.set(__self__, "extend_path_mode", extend_path_mode)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="extendPathMode")
    def extend_path_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_path_mode")

    @extend_path_mode.setter
    def extend_path_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_path_mode", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path", value)

    @_builtins.property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sub_path_expr")

    @sub_path_expr.setter
    def sub_path_expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path_expr", value)


if not MYPY:
    class PodV2ReadinessGateArgsDict(TypedDict):
        condition_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2ReadinessGateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2ReadinessGateArgs:
    def __init__(__self__, *,
                 condition_type: Optional[pulumi.Input[_builtins.str]] = None):
        if condition_type is not None:
            pulumi.set(__self__, "condition_type", condition_type)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition_type", value)


if not MYPY:
    class PodV2SecurityContextArgsDict(TypedDict):
        fs_group: NotRequired[pulumi.Input[_builtins.int]]
        fs_group_change_policy: NotRequired[pulumi.Input[_builtins.str]]
        run_as_group: NotRequired[pulumi.Input[_builtins.int]]
        run_as_non_root: NotRequired[pulumi.Input[_builtins.bool]]
        run_as_user: NotRequired[pulumi.Input[_builtins.int]]
        supplemental_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        sysctls: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2SecurityContextSysctlArgsDict']]]]
elif False:
    PodV2SecurityContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2SecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[_builtins.int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 run_as_group: Optional[pulumi.Input[_builtins.int]] = None,
                 run_as_non_root: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_as_user: Optional[pulumi.Input[_builtins.int]] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2SecurityContextSysctlArgs']]]] = None):
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)

    @_builtins.property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fs_group", value)

    @_builtins.property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @_builtins.property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_group", value)

    @_builtins.property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @_builtins.property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "run_as_user", value)

    @_builtins.property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @_builtins.property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2SecurityContextSysctlArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2SecurityContextSysctlArgs']]]]):
        pulumi.set(self, "sysctls", value)


if not MYPY:
    class PodV2SecurityContextSysctlArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    PodV2SecurityContextSysctlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2SecurityContextSysctlArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PodV2StatusArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2StatusConditionArgsDict']]]]
        """
        Tthe conditions of the CCI Pod.
        """
        observed_generation: NotRequired[pulumi.Input[_builtins.int]]
        """
        The observed generation of the CCI Pod.
        """
elif False:
    PodV2StatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2StatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2StatusConditionArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PodV2StatusConditionArgs']]] conditions: Tthe conditions of the CCI Pod.
        :param pulumi.Input[_builtins.int] observed_generation: The observed generation of the CCI Pod.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2StatusConditionArgs']]]]:
        """
        Tthe conditions of the CCI Pod.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2StatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The observed generation of the CCI Pod.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "observed_generation", value)


if not MYPY:
    class PodV2StatusConditionArgsDict(TypedDict):
        last_transition_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last transition time of the CCI Pod conditions.
        """
        last_update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last update time of the CCI Pod conditions.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The message of the CCI Pod conditions.
        """
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reason of the CCI Pod conditions.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tthe status of the CCI Pod conditions.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the CCI Pod conditions.
        """
elif False:
    PodV2StatusConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2StatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[_builtins.str]] = None,
                 last_update_time: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] last_transition_time: The last transition time of the CCI Pod conditions.
        :param pulumi.Input[_builtins.str] last_update_time: The last update time of the CCI Pod conditions.
        :param pulumi.Input[_builtins.str] message: The message of the CCI Pod conditions.
        :param pulumi.Input[_builtins.str] reason: The reason of the CCI Pod conditions.
        :param pulumi.Input[_builtins.str] status: Tthe status of the CCI Pod conditions.
        :param pulumi.Input[_builtins.str] type: The type of the CCI Pod conditions.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last transition time of the CCI Pod conditions.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last update time of the CCI Pod conditions.
        """
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_update_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The message of the CCI Pod conditions.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reason of the CCI Pod conditions.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tthe status of the CCI Pod conditions.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the CCI Pod conditions.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PodV2VolumeArgsDict(TypedDict):
        config_map: NotRequired[pulumi.Input['PodV2VolumeConfigMapArgsDict']]
        name: NotRequired[pulumi.Input[_builtins.str]]
        nfs: NotRequired[pulumi.Input['PodV2VolumeNfsArgsDict']]
        persistent_volume_claim: NotRequired[pulumi.Input['PodV2VolumePersistentVolumeClaimArgsDict']]
        projected: NotRequired[pulumi.Input['PodV2VolumeProjectedArgsDict']]
        secret: NotRequired[pulumi.Input['PodV2VolumeSecretArgsDict']]
elif False:
    PodV2VolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeArgs:
    def __init__(__self__, *,
                 config_map: Optional[pulumi.Input['PodV2VolumeConfigMapArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 nfs: Optional[pulumi.Input['PodV2VolumeNfsArgs']] = None,
                 persistent_volume_claim: Optional[pulumi.Input['PodV2VolumePersistentVolumeClaimArgs']] = None,
                 projected: Optional[pulumi.Input['PodV2VolumeProjectedArgs']] = None,
                 secret: Optional[pulumi.Input['PodV2VolumeSecretArgs']] = None):
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nfs is not None:
            pulumi.set(__self__, "nfs", nfs)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if projected is not None:
            pulumi.set(__self__, "projected", projected)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional[pulumi.Input['PodV2VolumeConfigMapArgs']]:
        return pulumi.get(self, "config_map")

    @config_map.setter
    def config_map(self, value: Optional[pulumi.Input['PodV2VolumeConfigMapArgs']]):
        pulumi.set(self, "config_map", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def nfs(self) -> Optional[pulumi.Input['PodV2VolumeNfsArgs']]:
        return pulumi.get(self, "nfs")

    @nfs.setter
    def nfs(self, value: Optional[pulumi.Input['PodV2VolumeNfsArgs']]):
        pulumi.set(self, "nfs", value)

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional[pulumi.Input['PodV2VolumePersistentVolumeClaimArgs']]:
        return pulumi.get(self, "persistent_volume_claim")

    @persistent_volume_claim.setter
    def persistent_volume_claim(self, value: Optional[pulumi.Input['PodV2VolumePersistentVolumeClaimArgs']]):
        pulumi.set(self, "persistent_volume_claim", value)

    @_builtins.property
    @pulumi.getter
    def projected(self) -> Optional[pulumi.Input['PodV2VolumeProjectedArgs']]:
        return pulumi.get(self, "projected")

    @projected.setter
    def projected(self, value: Optional[pulumi.Input['PodV2VolumeProjectedArgs']]):
        pulumi.set(self, "projected", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['PodV2VolumeSecretArgs']]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['PodV2VolumeSecretArgs']]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class PodV2VolumeConfigMapArgsDict(TypedDict):
        default_mode: NotRequired[pulumi.Input[_builtins.int]]
        items: NotRequired[pulumi.Input['PodV2VolumeConfigMapItemsArgsDict']]
        name: NotRequired[pulumi.Input[_builtins.str]]
        optional: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PodV2VolumeConfigMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeConfigMapArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[_builtins.int]] = None,
                 items: Optional[pulumi.Input['PodV2VolumeConfigMapItemsArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_mode", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['PodV2VolumeConfigMapItemsArgs']]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['PodV2VolumeConfigMapItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2VolumeConfigMapItemsArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
        mode: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2VolumeConfigMapItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeConfigMapItemsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 mode: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PodV2VolumeNfsArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        server: pulumi.Input[_builtins.str]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PodV2VolumeNfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeNfsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 server: pulumi.Input[_builtins.str],
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "server", server)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class PodV2VolumePersistentVolumeClaimArgsDict(TypedDict):
        claim_name: pulumi.Input[_builtins.str]
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PodV2VolumePersistentVolumeClaimArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumePersistentVolumeClaimArgs:
    def __init__(__self__, *,
                 claim_name: pulumi.Input[_builtins.str],
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "claim_name", claim_name)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @_builtins.property
    @pulumi.getter(name="claimName")
    def claim_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "claim_name")

    @claim_name.setter
    def claim_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "claim_name", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class PodV2VolumeProjectedArgsDict(TypedDict):
        default_mode: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the rolling update config of the CCI Pod strategy.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceArgsDict']]]]
        """
        Specifies the type of the CCI Pod strategy.
        """
elif False:
    PodV2VolumeProjectedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[_builtins.int]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] default_mode: Specifies the rolling update config of the CCI Pod strategy.
        :param pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceArgs']]] sources: Specifies the type of the CCI Pod strategy.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the rolling update config of the CCI Pod strategy.
        """
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_mode", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceArgs']]]]:
        """
        Specifies the type of the CCI Pod strategy.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceArgs']]]]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class PodV2VolumeProjectedSourceArgsDict(TypedDict):
        config_map: NotRequired[pulumi.Input['PodV2VolumeProjectedSourceConfigMapArgsDict']]
        downward_api: NotRequired[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiArgsDict']]
        secret: NotRequired[pulumi.Input['PodV2VolumeProjectedSourceSecretArgsDict']]
elif False:
    PodV2VolumeProjectedSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceArgs:
    def __init__(__self__, *,
                 config_map: Optional[pulumi.Input['PodV2VolumeProjectedSourceConfigMapArgs']] = None,
                 downward_api: Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiArgs']] = None,
                 secret: Optional[pulumi.Input['PodV2VolumeProjectedSourceSecretArgs']] = None):
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if downward_api is not None:
            pulumi.set(__self__, "downward_api", downward_api)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional[pulumi.Input['PodV2VolumeProjectedSourceConfigMapArgs']]:
        return pulumi.get(self, "config_map")

    @config_map.setter
    def config_map(self, value: Optional[pulumi.Input['PodV2VolumeProjectedSourceConfigMapArgs']]):
        pulumi.set(self, "config_map", value)

    @_builtins.property
    @pulumi.getter(name="downwardApi")
    def downward_api(self) -> Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiArgs']]:
        return pulumi.get(self, "downward_api")

    @downward_api.setter
    def downward_api(self, value: Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiArgs']]):
        pulumi.set(self, "downward_api", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['PodV2VolumeProjectedSourceSecretArgs']]:
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['PodV2VolumeProjectedSourceSecretArgs']]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class PodV2VolumeProjectedSourceConfigMapArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceConfigMapItemArgsDict']]]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        optional: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PodV2VolumeProjectedSourceConfigMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceConfigMapArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceConfigMapItemArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceConfigMapItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceConfigMapItemArgs']]]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2VolumeProjectedSourceConfigMapItemArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
        mode: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2VolumeProjectedSourceConfigMapItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceConfigMapItemArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 mode: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PodV2VolumeProjectedSourceDownwardApiArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemArgsDict']]]]
elif False:
    PodV2VolumeProjectedSourceDownwardApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceDownwardApiArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemArgs']]]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class PodV2VolumeProjectedSourceDownwardApiItemArgsDict(TypedDict):
        field_ref: NotRequired[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgsDict']]
        mode: NotRequired[pulumi.Input[_builtins.int]]
        path: NotRequired[pulumi.Input[_builtins.str]]
        resource_file_ref: NotRequired[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgsDict']]
elif False:
    PodV2VolumeProjectedSourceDownwardApiItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceDownwardApiItemArgs:
    def __init__(__self__, *,
                 field_ref: Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgs']] = None,
                 mode: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_file_ref: Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgs']] = None):
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if resource_file_ref is not None:
            pulumi.set(__self__, "resource_file_ref", resource_file_ref)

    @_builtins.property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgs']]:
        return pulumi.get(self, "field_ref")

    @field_ref.setter
    def field_ref(self, value: Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgs']]):
        pulumi.set(self, "field_ref", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="resourceFileRef")
    def resource_file_ref(self) -> Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgs']]:
        return pulumi.get(self, "resource_file_ref")

    @resource_file_ref.setter
    def resource_file_ref(self, value: Optional[pulumi.Input['PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgs']]):
        pulumi.set(self, "resource_file_ref", value)


if not MYPY:
    class PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgsDict(TypedDict):
        field_path: pulumi.Input[_builtins.str]
        api_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceDownwardApiItemFieldRefArgs:
    def __init__(__self__, *,
                 field_path: pulumi.Input[_builtins.str],
                 api_version: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @_builtins.property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_path", value)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)


if not MYPY:
    class PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgsDict(TypedDict):
        resource: pulumi.Input[_builtins.str]
        container_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceDownwardApiItemResourceFileRefArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[_builtins.str],
                 container_name: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource", value)

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_name", value)


if not MYPY:
    class PodV2VolumeProjectedSourceSecretArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceSecretItemArgsDict']]]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        optional: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PodV2VolumeProjectedSourceSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceSecretArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceSecretItemArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceSecretItemArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PodV2VolumeProjectedSourceSecretItemArgs']]]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class PodV2VolumeProjectedSourceSecretItemArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
        mode: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2VolumeProjectedSourceSecretItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeProjectedSourceSecretItemArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 mode: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PodV2VolumeSecretArgsDict(TypedDict):
        default_mode: NotRequired[pulumi.Input[_builtins.int]]
        items: NotRequired[pulumi.Input['PodV2VolumeSecretItemsArgsDict']]
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PodV2VolumeSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeSecretArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[_builtins.int]] = None,
                 items: Optional[pulumi.Input['PodV2VolumeSecretItemsArgs']] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None):
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "default_mode", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input['PodV2VolumeSecretItemsArgs']]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input['PodV2VolumeSecretItemsArgs']]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class PodV2VolumeSecretItemsArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
        mode: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PodV2VolumeSecretItemsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodV2VolumeSecretItemsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 mode: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PoolBindingOwnerReferenceArgsDict(TypedDict):
        api_version: pulumi.Input[_builtins.str]
        kind: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        uid: pulumi.Input[_builtins.str]
        block_owner_deletion: NotRequired[pulumi.Input[_builtins.bool]]
        controller: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PoolBindingOwnerReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PoolBindingOwnerReferenceArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[_builtins.str],
                 kind: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 uid: pulumi.Input[_builtins.str],
                 block_owner_deletion: Optional[pulumi.Input[_builtins.bool]] = None,
                 controller: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)
        if block_owner_deletion is not None:
            pulumi.set(__self__, "block_owner_deletion", block_owner_deletion)
        if controller is not None:
            pulumi.set(__self__, "controller", controller)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uid", value)

    @_builtins.property
    @pulumi.getter(name="blockOwnerDeletion")
    def block_owner_deletion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "block_owner_deletion")

    @block_owner_deletion.setter
    def block_owner_deletion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "block_owner_deletion", value)

    @_builtins.property
    @pulumi.getter
    def controller(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "controller")

    @controller.setter
    def controller(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "controller", value)


if not MYPY:
    class PoolBindingPoolRefArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PoolBindingPoolRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PoolBindingPoolRefArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PoolBindingTargetRefArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        group: NotRequired[pulumi.Input[_builtins.str]]
        kind: NotRequired[pulumi.Input[_builtins.str]]
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PoolBindingTargetRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PoolBindingTargetRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 group: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "name", name)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class PvcV2ResourcesArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    PvcV2ResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PvcV2ResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class PvcV2SelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PvcV2SelectorMatchExpressionArgsDict']]]]
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    PvcV2SelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PvcV2SelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['PvcV2SelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PvcV2SelectorMatchExpressionArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PvcV2SelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class PvcV2SelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        operator: NotRequired[pulumi.Input[_builtins.str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    PvcV2SelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PvcV2SelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ServiceV2PortArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        The port.
        """
        app_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The app protocol.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol.
        """
        target_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The target port.
        """
elif False:
    ServiceV2PortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2PortArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 app_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 target_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: The port.
        :param pulumi.Input[_builtins.str] app_protocol: The app protocol.
        :param pulumi.Input[_builtins.str] name: The name.
        :param pulumi.Input[_builtins.str] protocol: The protocol.
        :param pulumi.Input[_builtins.int] target_port: The target port.
        """
        pulumi.set(__self__, "port", port)
        if app_protocol is not None:
            pulumi.set(__self__, "app_protocol", app_protocol)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="appProtocol")
    def app_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The app protocol.
        """
        return pulumi.get(self, "app_protocol")

    @app_protocol.setter
    def app_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_protocol", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The target port.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class ServiceV2StatusArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusConditionArgsDict']]]]
        """
        Tthe conditions of the CCI Service.
        """
        loadbalancers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerArgsDict']]]]
        """
        The loadbalancer of the CCI Service.
        """
elif False:
    ServiceV2StatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2StatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusConditionArgs']]]] = None,
                 loadbalancers: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusConditionArgs']]] conditions: Tthe conditions of the CCI Service.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerArgs']]] loadbalancers: The loadbalancer of the CCI Service.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if loadbalancers is not None:
            pulumi.set(__self__, "loadbalancers", loadbalancers)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusConditionArgs']]]]:
        """
        Tthe conditions of the CCI Service.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def loadbalancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerArgs']]]]:
        """
        The loadbalancer of the CCI Service.
        """
        return pulumi.get(self, "loadbalancers")

    @loadbalancers.setter
    def loadbalancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerArgs']]]]):
        pulumi.set(self, "loadbalancers", value)


if not MYPY:
    class ServiceV2StatusConditionArgsDict(TypedDict):
        last_transition_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last transition time.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The message.
        """
        observe_generation: NotRequired[pulumi.Input[_builtins.str]]
        """
        The observe generation.
        """
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reason.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tthe status.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type.
        """
elif False:
    ServiceV2StatusConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2StatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 observe_generation: Optional[pulumi.Input[_builtins.str]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] last_transition_time: The last transition time.
        :param pulumi.Input[_builtins.str] message: The message.
        :param pulumi.Input[_builtins.str] observe_generation: The observe generation.
        :param pulumi.Input[_builtins.str] reason: The reason.
        :param pulumi.Input[_builtins.str] status: Tthe status.
        :param pulumi.Input[_builtins.str] type: The type.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if observe_generation is not None:
            pulumi.set(__self__, "observe_generation", observe_generation)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last transition time.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_transition_time", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="observeGeneration")
    def observe_generation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The observe generation.
        """
        return pulumi.get(self, "observe_generation")

    @observe_generation.setter
    def observe_generation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "observe_generation", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reason.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tthe status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceV2StatusLoadbalancerArgsDict(TypedDict):
        ingresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressArgsDict']]]]
        """
        The ingress of the loadbalancer.
        """
elif False:
    ServiceV2StatusLoadbalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2StatusLoadbalancerArgs:
    def __init__(__self__, *,
                 ingresses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressArgs']]] ingresses: The ingress of the loadbalancer.
        """
        if ingresses is not None:
            pulumi.set(__self__, "ingresses", ingresses)

    @_builtins.property
    @pulumi.getter
    def ingresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressArgs']]]]:
        """
        The ingress of the loadbalancer.
        """
        return pulumi.get(self, "ingresses")

    @ingresses.setter
    def ingresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressArgs']]]]):
        pulumi.set(self, "ingresses", value)


if not MYPY:
    class ServiceV2StatusLoadbalancerIngressArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP of the loadbalancer.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressPortArgsDict']]]]
        """
        The ports of the loadbalancer.
        """
elif False:
    ServiceV2StatusLoadbalancerIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2StatusLoadbalancerIngressArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressPortArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP of the loadbalancer.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressPortArgs']]] ports: The ports of the loadbalancer.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP of the loadbalancer.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressPortArgs']]]]:
        """
        The ports of the loadbalancer.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2StatusLoadbalancerIngressPortArgs']]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class ServiceV2StatusLoadbalancerIngressPortArgsDict(TypedDict):
        error: NotRequired[pulumi.Input[_builtins.str]]
        """
        The error.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol.
        """
elif False:
    ServiceV2StatusLoadbalancerIngressPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2StatusLoadbalancerIngressPortArgs:
    def __init__(__self__, *,
                 error: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error: The error.
        :param pulumi.Input[_builtins.int] port: The port.
        :param pulumi.Input[_builtins.str] protocol: The protocol.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The error.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


