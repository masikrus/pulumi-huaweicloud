# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AddonValues',
    'AutopilotClusterAuthentication',
    'AutopilotClusterConfigurationsOverride',
    'AutopilotClusterConfigurationsOverrideConfiguration',
    'AutopilotClusterContainerNetwork',
    'AutopilotClusterEniNetwork',
    'AutopilotClusterEniNetworkSubnet',
    'AutopilotClusterExtendParam',
    'AutopilotClusterHostNetwork',
    'AutopilotClusterServiceNetwork',
    'AutopilotClusterStatus',
    'AutopilotClusterStatusEndpoint',
    'ClusterCertificateCluster',
    'ClusterCertificateUser',
    'ClusterComponentConfiguration',
    'ClusterEncryptionConfig',
    'ClusterExtendParam',
    'ClusterLogConfigLogConfig',
    'ClusterMaster',
    'ClusterUpgradeAddon',
    'ClusterUpgradeAddonValues',
    'ClusterUpgradeStrategy',
    'ClusterUpgradeStrategyInPlaceRollingUpdate',
    'ClusterV3CertificateCluster',
    'ClusterV3CertificateUser',
    'ClusterV3ComponentConfiguration',
    'ClusterV3EncryptionConfig',
    'ClusterV3ExtendParam',
    'ClusterV3Master',
    'NodeAttachDataVolume',
    'NodeAttachExtensionNic',
    'NodeAttachHostnameConfig',
    'NodeAttachRootVolume',
    'NodeAttachStorage',
    'NodeAttachStorageGroup',
    'NodeAttachStorageGroupVirtualSpace',
    'NodeAttachStorageSelector',
    'NodeAttachTaint',
    'NodeDataVolume',
    'NodeExtendParams',
    'NodeExtensionNic',
    'NodeHostnameConfig',
    'NodePoolDataVolume',
    'NodePoolExtendParams',
    'NodePoolExtensionScaleGroup',
    'NodePoolExtensionScaleGroupMetadata',
    'NodePoolExtensionScaleGroupSpec',
    'NodePoolExtensionScaleGroupSpecAutoscaling',
    'NodePoolExtensionScaleGroupSpecCapacityReservationSpecification',
    'NodePoolHostnameConfig',
    'NodePoolNodesAddNodeList',
    'NodePoolRootVolume',
    'NodePoolStorage',
    'NodePoolStorageGroup',
    'NodePoolStorageGroupVirtualSpace',
    'NodePoolStorageSelector',
    'NodePoolTaint',
    'NodeRootVolume',
    'NodeStorage',
    'NodeStorageGroup',
    'NodeStorageGroupVirtualSpace',
    'NodeStorageSelector',
    'NodeTaint',
    'NodeV3DataVolume',
    'NodeV3ExtendParams',
    'NodeV3ExtensionNic',
    'NodeV3HostnameConfig',
    'NodeV3RootVolume',
    'NodeV3Storage',
    'NodeV3StorageGroup',
    'NodeV3StorageGroupVirtualSpace',
    'NodeV3StorageSelector',
    'NodeV3Taint',
    'NodesRemoveNode',
    'GetAddonTemplateSupportVersionResult',
    'GetAddonsItemResult',
    'GetAddonsItemMetadataResult',
    'GetAddonsItemSpecResult',
    'GetAddonsItemStatusResult',
    'GetAddonsItemStatusCurrentVersionResult',
    'GetAddonsItemStatusCurrentVersionSupportVersionResult',
    'GetAutopilotAddonTemplatesTemplateResult',
    'GetAutopilotAddonTemplatesTemplateVersionResult',
    'GetAutopilotAddonTemplatesTemplateVersionSupportVersionResult',
    'GetAutopilotClusterCertificateClusterResult',
    'GetAutopilotClusterCertificateClusterClusterResult',
    'GetAutopilotClusterCertificateContextResult',
    'GetAutopilotClusterCertificateContextContextResult',
    'GetAutopilotClusterCertificateUserResult',
    'GetAutopilotClusterCertificateUserUserResult',
    'GetAutopilotClustersClusterResult',
    'GetAutopilotClustersClusterAuthenticationResult',
    'GetAutopilotClustersClusterConfigurationsOverrideResult',
    'GetAutopilotClustersClusterConfigurationsOverrideConfigurationResult',
    'GetAutopilotClustersClusterContainerNetworkResult',
    'GetAutopilotClustersClusterEniNetworkResult',
    'GetAutopilotClustersClusterEniNetworkSubnetResult',
    'GetAutopilotClustersClusterExtendParamResult',
    'GetAutopilotClustersClusterHostNetworkResult',
    'GetAutopilotClustersClusterServiceNetworkResult',
    'GetAutopilotClustersClusterStatusResult',
    'GetAutopilotClustersClusterStatusEndpointResult',
    'GetChartsChartResult',
    'GetClusterCertificateClusterResult',
    'GetClusterCertificateUserResult',
    'GetClusterCertificatesClusterResult',
    'GetClusterCertificatesContextResult',
    'GetClusterCertificatesUserResult',
    'GetClusterEndpointResult',
    'GetClusterMasterResult',
    'GetClusterOpenidJwksKeyResult',
    'GetClusterUpgradeInfoMetadataResult',
    'GetClusterUpgradeInfoSpecResult',
    'GetClusterUpgradeInfoSpecLastUpgradeInfoResult',
    'GetClusterUpgradeInfoSpecUpgradeFeatureGateResult',
    'GetClusterUpgradeInfoSpecVersionInfoResult',
    'GetClusterUpgradeInfoStatusResult',
    'GetClusterV3CertificateClusterResult',
    'GetClusterV3CertificateUserResult',
    'GetClusterV3EndpointResult',
    'GetClusterV3MasterResult',
    'GetClustersClusterResult',
    'GetClustersClusterCertificateClusterResult',
    'GetClustersClusterCertificateUserResult',
    'GetClustersClusterEndpointResult',
    'GetClustersClusterMasterResult',
    'GetNodeDataVolumeResult',
    'GetNodeHostnameConfigResult',
    'GetNodePoolDataVolumeResult',
    'GetNodePoolHostnameConfigResult',
    'GetNodePoolRootVolumeResult',
    'GetNodeRootVolumeResult',
    'GetNodeV3DataVolumeResult',
    'GetNodeV3HostnameConfigResult',
    'GetNodeV3RootVolumeResult',
    'GetNodesNodeResult',
    'GetNodesNodeDataVolumeResult',
    'GetNodesNodeHostnameConfigResult',
    'GetNodesNodeRootVolumeResult',
]

@pulumi.output_type
class AddonValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicJson":
            suggest = "basic_json"
        elif key == "customJson":
            suggest = "custom_json"
        elif key == "flavorJson":
            suggest = "flavor_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddonValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddonValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddonValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic: Optional[Mapping[str, _builtins.str]] = None,
                 basic_json: Optional[_builtins.str] = None,
                 custom: Optional[Mapping[str, _builtins.str]] = None,
                 custom_json: Optional[_builtins.str] = None,
                 flavor: Optional[Mapping[str, _builtins.str]] = None,
                 flavor_json: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] basic: Specifies the key/value pairs vary depending on the add-on.
               Only supports non-nested structure and only supports string type elements.
               This is an alternative to `basic_json`, but it is not recommended.
        :param _builtins.str basic_json: Specifies the json string vary depending on the add-on.
        :param Mapping[str, _builtins.str] custom: Specifies the key/value pairs vary depending on the add-on.
               Only supports non-nested structure and only supports string type elements.
               This is an alternative to `custom_json`, but it is not recommended.
        :param _builtins.str custom_json: Specifies the json string vary depending on the add-on.
        :param Mapping[str, _builtins.str] flavor: Specifies the key/value pairs vary depending on the add-on.
               Only supports non-nested structure and only supports string type elements.
               This is an alternative to `flavor_json`, but it is not recommended.
        :param _builtins.str flavor_json: Specifies the json string vary depending on the add-on.
        """
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if basic_json is not None:
            pulumi.set(__self__, "basic_json", basic_json)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if custom_json is not None:
            pulumi.set(__self__, "custom_json", custom_json)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_json is not None:
            pulumi.set(__self__, "flavor_json", flavor_json)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `basic_json`, but it is not recommended.
        """
        return pulumi.get(self, "basic")

    @_builtins.property
    @pulumi.getter(name="basicJson")
    def basic_json(self) -> Optional[_builtins.str]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "basic_json")

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `custom_json`, but it is not recommended.
        """
        return pulumi.get(self, "custom")

    @_builtins.property
    @pulumi.getter(name="customJson")
    def custom_json(self) -> Optional[_builtins.str]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "custom_json")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `flavor_json`, but it is not recommended.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="flavorJson")
    def flavor_json(self) -> Optional[_builtins.str]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "flavor_json")


@pulumi.output_type
class AutopilotClusterAuthentication(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str mode: Specifies the cluster authentication mode.
               The default value is **rbac**.
               
               <a name="autopilot_cluster_extend_param"></a>
               The `extend_param` block supports:
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies the cluster authentication mode.
        The default value is **rbac**.

        <a name="autopilot_cluster_extend_param"></a>
        The `extend_param` block supports:
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutopilotClusterConfigurationsOverride(dict):
    def __init__(__self__, *,
                 configurations: Optional[Sequence['outputs.AutopilotClusterConfigurationsOverrideConfiguration']] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param Sequence['AutopilotClusterConfigurationsOverrideConfigurationArgs'] configurations: Specifies the component configuration items.
               The configurations structure is documented below.
               
               <a name="autopilot_cluster_configurations_override_configurations"></a>
               The `configurations` block supports:
        :param _builtins.str name: Specifies the component configuration item name.
        """
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.AutopilotClusterConfigurationsOverrideConfiguration']]:
        """
        Specifies the component configuration items.
        The configurations structure is documented below.

        <a name="autopilot_cluster_configurations_override_configurations"></a>
        The `configurations` block supports:
        """
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the component configuration item name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AutopilotClusterConfigurationsOverrideConfiguration(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the component configuration item name.
        :param _builtins.str value: Specifies the component configuration item value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the component configuration item name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the component configuration item value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AutopilotClusterContainerNetwork(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: Specifies the cluster authentication mode.
               The default value is **rbac**.
               
               <a name="autopilot_cluster_extend_param"></a>
               The `extend_param` block supports:
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Specifies the cluster authentication mode.
        The default value is **rbac**.

        <a name="autopilot_cluster_extend_param"></a>
        The `extend_param` block supports:
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class AutopilotClusterEniNetwork(dict):
    def __init__(__self__, *,
                 subnets: Sequence['outputs.AutopilotClusterEniNetworkSubnet']):
        """
        :param Sequence['AutopilotClusterEniNetworkSubnetArgs'] subnets: Specifies the list of ENI subnets.
               The subnets structure is documented below.
               
               <a name="autopilot_cluster_eni_network_subnets"></a>
               The `subnets` block supports:
        """
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.AutopilotClusterEniNetworkSubnet']:
        """
        Specifies the list of ENI subnets.
        The subnets structure is documented below.

        <a name="autopilot_cluster_eni_network_subnets"></a>
        The `subnets` block supports:
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class AutopilotClusterEniNetworkSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutopilotClusterEniNetworkSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutopilotClusterEniNetworkSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutopilotClusterEniNetworkSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str subnet_id: Specifies the IPv4 subnet ID of the subnet used to create control
               nodes and containers.
               
               <a name="autopilot_cluster_service_network"></a>
               The `service_network` block supports:
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Specifies the IPv4 subnet ID of the subnet used to create control
        nodes and containers.

        <a name="autopilot_cluster_service_network"></a>
        The `service_network` block supports:
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class AutopilotClusterExtendParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enterpriseProjectId":
            suggest = "enterprise_project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutopilotClusterExtendParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutopilotClusterExtendParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutopilotClusterExtendParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enterprise_project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str enterprise_project_id: Specifies the ID of the enterprise project to which the
               cluster belongs.
               
               <a name="autopilot_cluster_configurations_override"></a>
               The `configurations_override` block supports:
        """
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the enterprise project to which the
        cluster belongs.

        <a name="autopilot_cluster_configurations_override"></a>
        The `configurations_override` block supports:
        """
        return pulumi.get(self, "enterprise_project_id")


@pulumi.output_type
class AutopilotClusterHostNetwork(dict):
    def __init__(__self__, *,
                 subnet: _builtins.str,
                 vpc: _builtins.str):
        """
        :param _builtins.str subnet: Specifies ID of the subnet used to create a master node.
               
               <a name="autopilot_cluster_container_network"></a>
               The `container_network` block supports:
        :param _builtins.str vpc: Specifies the ID of the VPC used to create a master node.
        """
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        Specifies ID of the subnet used to create a master node.

        <a name="autopilot_cluster_container_network"></a>
        The `container_network` block supports:
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        """
        Specifies the ID of the VPC used to create a master node.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class AutopilotClusterServiceNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Cidr":
            suggest = "ipv4_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutopilotClusterServiceNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutopilotClusterServiceNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutopilotClusterServiceNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_cidr: Optional[_builtins.str] = None):
        """
        :param _builtins.str ipv4_cidr: Specifies the IPv4 CIDR of the service network.
               If not specified, the default value 10.247.0.0/16 will be used.
               
               <a name="autopilot_cluster_authentication"></a>
               The `authentication` block supports:
        """
        if ipv4_cidr is not None:
            pulumi.set(__self__, "ipv4_cidr", ipv4_cidr)

    @_builtins.property
    @pulumi.getter(name="ipv4Cidr")
    def ipv4_cidr(self) -> Optional[_builtins.str]:
        """
        Specifies the IPv4 CIDR of the service network.
        If not specified, the default value 10.247.0.0/16 will be used.

        <a name="autopilot_cluster_authentication"></a>
        The `authentication` block supports:
        """
        return pulumi.get(self, "ipv4_cidr")


@pulumi.output_type
class AutopilotClusterStatus(dict):
    def __init__(__self__, *,
                 endpoints: Optional[Sequence['outputs.AutopilotClusterStatusEndpoint']] = None,
                 phase: Optional[_builtins.str] = None):
        """
        :param Sequence['AutopilotClusterStatusEndpointArgs'] endpoints: The access address of kube-apiserver in the cluster.
               The endpoints structure is documented below.
        :param _builtins.str phase: The phase of the cluster.
        """
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AutopilotClusterStatusEndpoint']]:
        """
        The access address of kube-apiserver in the cluster.
        The endpoints structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        The phase of the cluster.
        """
        return pulumi.get(self, "phase")


@pulumi.output_type
class AutopilotClusterStatusEndpoint(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the master node architecture. The value can be:
               + **VirtualMachine**: Indicates the master node is an x86 server.
        :param _builtins.str url: The phase of the cluster.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the master node architecture. The value can be:
        + **VirtualMachine**: Indicates the master node is an x86 server.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The phase of the cluster.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ClusterCertificateCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthorityData":
            suggest = "certificate_authority_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCertificateCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCertificateCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCertificateCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority_data: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 server: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate_authority_data: The certificate data.
        :param _builtins.str name: Specifies the component name.
        :param _builtins.str server: The server IP address.
        """
        if certificate_authority_data is not None:
            pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> Optional[_builtins.str]:
        """
        The certificate data.
        """
        return pulumi.get(self, "certificate_authority_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the component name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[_builtins.str]:
        """
        The server IP address.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class ClusterCertificateUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificateData":
            suggest = "client_certificate_data"
        elif key == "clientKeyData":
            suggest = "client_key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCertificateUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCertificateUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCertificateUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate_data: Optional[_builtins.str] = None,
                 client_key_data: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_certificate_data: The client certificate data.
        :param _builtins.str client_key_data: The client key data.
        :param _builtins.str name: Specifies the component name.
        """
        if client_certificate_data is not None:
            pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        if client_key_data is not None:
            pulumi.set(__self__, "client_key_data", client_key_data)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> Optional[_builtins.str]:
        """
        The client certificate data.
        """
        return pulumi.get(self, "client_certificate_data")

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> Optional[_builtins.str]:
        """
        The client key data.
        """
        return pulumi.get(self, "client_key_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the component name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ClusterComponentConfiguration(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 configurations: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the component name.
        :param _builtins.str configurations: Specifies JSON string of the component configurations.
               
               <a name="cce_cluster_encryption_config"></a>
               The `encryption_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the component name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[_builtins.str]:
        """
        Specifies JSON string of the component configurations.

        <a name="cce_cluster_encryption_config"></a>
        The `encryption_config` block supports:
        """
        return pulumi.get(self, "configurations")


@pulumi.output_type
class ClusterEncryptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_id: Specifies KMS key ID, required if `mode` is set to **KMS**.
        :param _builtins.str mode: Specifies the encryption mode. The value can be: **Default** and **KMS**.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Specifies KMS key ID, required if `mode` is set to **KMS**.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies the encryption mode. The value can be: **Default** and **KMS**.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class ClusterExtendParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterAz":
            suggest = "cluster_az"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "decMasterFlavor":
            suggest = "dec_master_flavor"
        elif key == "dockerUmaskMode":
            suggest = "docker_umask_mode"
        elif key == "dssMasterVolumes":
            suggest = "dss_master_volumes"
        elif key == "fixPoolMask":
            suggest = "fix_pool_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterExtendParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterExtendParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterExtendParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_az: Optional[_builtins.str] = None,
                 cpu_manager_policy: Optional[_builtins.str] = None,
                 dec_master_flavor: Optional[_builtins.str] = None,
                 docker_umask_mode: Optional[_builtins.str] = None,
                 dss_master_volumes: Optional[_builtins.str] = None,
                 fix_pool_mask: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_az: Specifies the AZ of master nodes in the cluster. The value can be:
               + **multi_az**: The cluster will span across AZs. This field is configurable only for high-availability clusters.
               + **AZ of the dedicated cloud computing pool**: The cluster will be deployed in the AZ of Dedicated Cloud (DeC).
               This parameter is mandatory for dedicated CCE clusters.
               
               Changing this parameter will create a new cluster resource.
        :param _builtins.str cpu_manager_policy: Specifies the cluster CPU management policy.
               The value can be:
               + **none**: CPU cores will not be exclusively allocated to workload pods.
               Select this value if you want a large pool of shareable CPU cores.
               + **static**: CPU cores can be exclusively allocated to workload pods.
               Select this value if your workload is sensitive to latency in CPU cache and scheduling.In a CCE Turbo cluster,
               this setting is valid only for nodes where common containers, not Kata containers, run.
               
               Defaults to none.
               Changing this parameter will create a new cluster resource.
               
               <a name="cce_cluster_component_configurations"></a>
               The `component_configurations` block supports:
        :param _builtins.str dec_master_flavor: Specifies the specifications of the master node
               in the dedicated hybrid cluster.
               Changing this parameter will create a new cluster resource.
        :param _builtins.str docker_umask_mode: Specifies the default UmaskMode configuration of Docker in a
               cluster. The value can be **secure** or **normal**, defaults to normal.
               Changing this parameter will create a new cluster resource.
        :param _builtins.str dss_master_volumes: Specifies whether the system and data disks of a master node
               use dedicated distributed storage. If left unspecified, EVS disks are used by default.
               This parameter is mandatory for dedicated CCE clusters.
               It is in the following format:
               
               ```bash
               <rootVol.dssPoolID>.<rootVol.volType>;<dataVol.dssPoolID>.<dataVol.volType>
               ```
               
               Changing this parameter will create a new cluster resource.
        :param _builtins.str fix_pool_mask: Specifies the number of mask bits of the fixed IP address pool
               of the container network model. This field can only be used when `container_network_type` is set to **vpc-router**.
               Changing this parameter will create a new cluster resource.
        """
        if cluster_az is not None:
            pulumi.set(__self__, "cluster_az", cluster_az)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if dec_master_flavor is not None:
            pulumi.set(__self__, "dec_master_flavor", dec_master_flavor)
        if docker_umask_mode is not None:
            pulumi.set(__self__, "docker_umask_mode", docker_umask_mode)
        if dss_master_volumes is not None:
            pulumi.set(__self__, "dss_master_volumes", dss_master_volumes)
        if fix_pool_mask is not None:
            pulumi.set(__self__, "fix_pool_mask", fix_pool_mask)

    @_builtins.property
    @pulumi.getter(name="clusterAz")
    def cluster_az(self) -> Optional[_builtins.str]:
        """
        Specifies the AZ of master nodes in the cluster. The value can be:
        + **multi_az**: The cluster will span across AZs. This field is configurable only for high-availability clusters.
        + **AZ of the dedicated cloud computing pool**: The cluster will be deployed in the AZ of Dedicated Cloud (DeC).
        This parameter is mandatory for dedicated CCE clusters.

        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "cluster_az")

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the cluster CPU management policy.
        The value can be:
        + **none**: CPU cores will not be exclusively allocated to workload pods.
        Select this value if you want a large pool of shareable CPU cores.
        + **static**: CPU cores can be exclusively allocated to workload pods.
        Select this value if your workload is sensitive to latency in CPU cache and scheduling.In a CCE Turbo cluster,
        this setting is valid only for nodes where common containers, not Kata containers, run.

        Defaults to none.
        Changing this parameter will create a new cluster resource.

        <a name="cce_cluster_component_configurations"></a>
        The `component_configurations` block supports:
        """
        return pulumi.get(self, "cpu_manager_policy")

    @_builtins.property
    @pulumi.getter(name="decMasterFlavor")
    def dec_master_flavor(self) -> Optional[_builtins.str]:
        """
        Specifies the specifications of the master node
        in the dedicated hybrid cluster.
        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "dec_master_flavor")

    @_builtins.property
    @pulumi.getter(name="dockerUmaskMode")
    def docker_umask_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the default UmaskMode configuration of Docker in a
        cluster. The value can be **secure** or **normal**, defaults to normal.
        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "docker_umask_mode")

    @_builtins.property
    @pulumi.getter(name="dssMasterVolumes")
    def dss_master_volumes(self) -> Optional[_builtins.str]:
        """
        Specifies whether the system and data disks of a master node
        use dedicated distributed storage. If left unspecified, EVS disks are used by default.
        This parameter is mandatory for dedicated CCE clusters.
        It is in the following format:

        ```bash
        <rootVol.dssPoolID>.<rootVol.volType>;<dataVol.dssPoolID>.<dataVol.volType>
        ```

        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "dss_master_volumes")

    @_builtins.property
    @pulumi.getter(name="fixPoolMask")
    def fix_pool_mask(self) -> Optional[_builtins.str]:
        """
        Specifies the number of mask bits of the fixed IP address pool
        of the container network model. This field can only be used when `container_network_type` is set to **vpc-router**.
        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "fix_pool_mask")


@pulumi.output_type
class ClusterLogConfigLogConfig(dict):
    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enable: Specifies whether to collect the log.
        :param _builtins.str name: Specifies the log type.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to collect the log.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the log type.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ClusterMaster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMaster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMaster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMaster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_zone: Specifies the availability zone of the master node.
               Changing this parameter will create a new cluster resource.
               
               <a name="cce_cluster_extend_params"></a>
               The `extend_params` block supports:
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        Specifies the availability zone of the master node.
        Changing this parameter will create a new cluster resource.

        <a name="cce_cluster_extend_params"></a>
        The `extend_params` block supports:
        """
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class ClusterUpgradeAddon(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addonTemplateName":
            suggest = "addon_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpgradeAddon. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpgradeAddon.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpgradeAddon.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addon_template_name: _builtins.str,
                 operation: _builtins.str,
                 version: _builtins.str,
                 values: Optional['outputs.ClusterUpgradeAddonValues'] = None):
        """
        :param _builtins.str addon_template_name: Specifies the add-on name.
        :param _builtins.str operation: Specifies the execution action.
               For current upgrades, the value can be **patch**.
        :param _builtins.str version: Specifies the target add-on version.
               The target add-on version must match the target cluster version.
        :param 'ClusterUpgradeAddonValuesArgs' values: Specifies the add-on template installation parameters.
               These parameters vary depending on the add-on. The values is documented below.
               
               <a name="values"></a>
               The `values` block supports:
        """
        pulumi.set(__self__, "addon_template_name", addon_template_name)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "version", version)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="addonTemplateName")
    def addon_template_name(self) -> _builtins.str:
        """
        Specifies the add-on name.
        """
        return pulumi.get(self, "addon_template_name")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        Specifies the execution action.
        For current upgrades, the value can be **patch**.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Specifies the target add-on version.
        The target add-on version must match the target cluster version.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional['outputs.ClusterUpgradeAddonValues']:
        """
        Specifies the add-on template installation parameters.
        These parameters vary depending on the add-on. The values is documented below.

        <a name="values"></a>
        The `values` block supports:
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterUpgradeAddonValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicJson":
            suggest = "basic_json"
        elif key == "customJson":
            suggest = "custom_json"
        elif key == "flavorJson":
            suggest = "flavor_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpgradeAddonValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpgradeAddonValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpgradeAddonValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_json: Optional[_builtins.str] = None,
                 custom_json: Optional[_builtins.str] = None,
                 flavor_json: Optional[_builtins.str] = None):
        """
        :param _builtins.str basic_json: Specifies the json string vary depending on the add-on.
        :param _builtins.str custom_json: Specifies the json string vary depending on the add-on.
        :param _builtins.str flavor_json: Specifies the json string vary depending on the add-on.
               
               > Arguments which can be passed to the `basic_json`, `custom_json` and `flavor_json` add-on parameters depends on
               the add-on type and version. For more detailed description of add-ons
               see add-ons description
               
               <a name="strategy"></a>
               The `strategy` block supports:
        """
        if basic_json is not None:
            pulumi.set(__self__, "basic_json", basic_json)
        if custom_json is not None:
            pulumi.set(__self__, "custom_json", custom_json)
        if flavor_json is not None:
            pulumi.set(__self__, "flavor_json", flavor_json)

    @_builtins.property
    @pulumi.getter(name="basicJson")
    def basic_json(self) -> Optional[_builtins.str]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "basic_json")

    @_builtins.property
    @pulumi.getter(name="customJson")
    def custom_json(self) -> Optional[_builtins.str]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "custom_json")

    @_builtins.property
    @pulumi.getter(name="flavorJson")
    def flavor_json(self) -> Optional[_builtins.str]:
        """
        Specifies the json string vary depending on the add-on.

        > Arguments which can be passed to the `basic_json`, `custom_json` and `flavor_json` add-on parameters depends on
        the add-on type and version. For more detailed description of add-ons
        see add-ons description

        <a name="strategy"></a>
        The `strategy` block supports:
        """
        return pulumi.get(self, "flavor_json")


@pulumi.output_type
class ClusterUpgradeStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inPlaceRollingUpdate":
            suggest = "in_place_rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpgradeStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpgradeStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpgradeStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 in_place_rolling_update: Optional['outputs.ClusterUpgradeStrategyInPlaceRollingUpdate'] = None):
        """
        :param _builtins.str type: Specifies the upgrade strategy type.
               The value can be **inPlaceRollingUpdate**.
        :param 'ClusterUpgradeStrategyInPlaceRollingUpdateArgs' in_place_rolling_update: Specifies the in-place upgrade settings.
               It's mandatory when the `type` is set to **inPlaceRollingUpdate**.
               The in_place_rolling_update structure is documented below.
               
               <a name="in_place_rolling_update"></a>
               The `in_place_rolling_update` block supports:
        """
        pulumi.set(__self__, "type", type)
        if in_place_rolling_update is not None:
            pulumi.set(__self__, "in_place_rolling_update", in_place_rolling_update)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the upgrade strategy type.
        The value can be **inPlaceRollingUpdate**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="inPlaceRollingUpdate")
    def in_place_rolling_update(self) -> Optional['outputs.ClusterUpgradeStrategyInPlaceRollingUpdate']:
        """
        Specifies the in-place upgrade settings.
        It's mandatory when the `type` is set to **inPlaceRollingUpdate**.
        The in_place_rolling_update structure is documented below.

        <a name="in_place_rolling_update"></a>
        The `in_place_rolling_update` block supports:
        """
        return pulumi.get(self, "in_place_rolling_update")


@pulumi.output_type
class ClusterUpgradeStrategyInPlaceRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userDefinedStep":
            suggest = "user_defined_step"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterUpgradeStrategyInPlaceRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterUpgradeStrategyInPlaceRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterUpgradeStrategyInPlaceRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_defined_step: Optional[_builtins.int] = None):
        """
        :param _builtins.int user_defined_step: Specifies the node upgrade step.
               The value ranges from **1** to **40**. The recommended value is **20**.
        """
        if user_defined_step is not None:
            pulumi.set(__self__, "user_defined_step", user_defined_step)

    @_builtins.property
    @pulumi.getter(name="userDefinedStep")
    def user_defined_step(self) -> Optional[_builtins.int]:
        """
        Specifies the node upgrade step.
        The value ranges from **1** to **40**. The recommended value is **20**.
        """
        return pulumi.get(self, "user_defined_step")


@pulumi.output_type
class ClusterV3CertificateCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthorityData":
            suggest = "certificate_authority_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV3CertificateCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV3CertificateCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV3CertificateCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority_data: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 server: Optional[_builtins.str] = None):
        if certificate_authority_data is not None:
            pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "certificate_authority_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "server")


@pulumi.output_type
class ClusterV3CertificateUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificateData":
            suggest = "client_certificate_data"
        elif key == "clientKeyData":
            suggest = "client_key_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV3CertificateUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV3CertificateUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV3CertificateUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate_data: Optional[_builtins.str] = None,
                 client_key_data: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        if client_certificate_data is not None:
            pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        if client_key_data is not None:
            pulumi.set(__self__, "client_key_data", client_key_data)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_certificate_data")

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_key_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ClusterV3ComponentConfiguration(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 configurations: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "configurations")


@pulumi.output_type
class ClusterV3EncryptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV3EncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV3EncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV3EncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None):
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class ClusterV3ExtendParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterAz":
            suggest = "cluster_az"
        elif key == "cpuManagerPolicy":
            suggest = "cpu_manager_policy"
        elif key == "decMasterFlavor":
            suggest = "dec_master_flavor"
        elif key == "dockerUmaskMode":
            suggest = "docker_umask_mode"
        elif key == "dssMasterVolumes":
            suggest = "dss_master_volumes"
        elif key == "fixPoolMask":
            suggest = "fix_pool_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV3ExtendParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV3ExtendParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV3ExtendParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_az: Optional[_builtins.str] = None,
                 cpu_manager_policy: Optional[_builtins.str] = None,
                 dec_master_flavor: Optional[_builtins.str] = None,
                 docker_umask_mode: Optional[_builtins.str] = None,
                 dss_master_volumes: Optional[_builtins.str] = None,
                 fix_pool_mask: Optional[_builtins.str] = None):
        if cluster_az is not None:
            pulumi.set(__self__, "cluster_az", cluster_az)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if dec_master_flavor is not None:
            pulumi.set(__self__, "dec_master_flavor", dec_master_flavor)
        if docker_umask_mode is not None:
            pulumi.set(__self__, "docker_umask_mode", docker_umask_mode)
        if dss_master_volumes is not None:
            pulumi.set(__self__, "dss_master_volumes", dss_master_volumes)
        if fix_pool_mask is not None:
            pulumi.set(__self__, "fix_pool_mask", fix_pool_mask)

    @_builtins.property
    @pulumi.getter(name="clusterAz")
    def cluster_az(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_az")

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cpu_manager_policy")

    @_builtins.property
    @pulumi.getter(name="decMasterFlavor")
    def dec_master_flavor(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dec_master_flavor")

    @_builtins.property
    @pulumi.getter(name="dockerUmaskMode")
    def docker_umask_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "docker_umask_mode")

    @_builtins.property
    @pulumi.getter(name="dssMasterVolumes")
    def dss_master_volumes(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dss_master_volumes")

    @_builtins.property
    @pulumi.getter(name="fixPoolMask")
    def fix_pool_mask(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fix_pool_mask")


@pulumi.output_type
class ClusterV3Master(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV3Master. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV3Master.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV3Master.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class NodeAttachDataVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeAttachDataVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeAttachDataVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeAttachDataVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 throughput: Optional[_builtins.int] = None,
                 volumetype: Optional[_builtins.str] = None):
        """
        :param _builtins.str dss_pool_id: The DSS pool ID. This field is used only for dedicated storage.
        :param Mapping[str, _builtins.str] extend_params: The disk expansion parameters.
        :param _builtins.bool hw_passthrough: schema: Internal
        :param _builtins.int iops: The iops of the disk.
        :param _builtins.str kms_key_id: The ID of a KMS key. This is used to encrypt the volume.
        :param _builtins.int size: The disk size in GB.
        :param _builtins.int throughput: The throughput of the disk.
        :param _builtins.str volumetype: The disk type.
        """
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumetype is not None:
            pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        """
        The DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        The iops of the disk.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        The throughput of the disk.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> Optional[_builtins.str]:
        """
        The disk type.
        """
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class NodeAttachExtensionNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeAttachExtensionNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeAttachExtensionNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeAttachExtensionNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet_id: The ID of the subnet to which the NIC belongs.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet to which the NIC belongs.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class NodeAttachHostnameConfig(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class NodeAttachRootVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeAttachRootVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeAttachRootVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeAttachRootVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 throughput: Optional[_builtins.int] = None,
                 volumetype: Optional[_builtins.str] = None):
        """
        :param _builtins.str dss_pool_id: The DSS pool ID. This field is used only for dedicated storage.
        :param Mapping[str, _builtins.str] extend_params: The disk expansion parameters.
        :param _builtins.bool hw_passthrough: schema: Internal
        :param _builtins.int iops: The iops of the disk.
        :param _builtins.str kms_key_id: The ID of a KMS key. This is used to encrypt the volume.
        :param _builtins.int size: The disk size in GB.
        :param _builtins.int throughput: The throughput of the disk.
        :param _builtins.str volumetype: The disk type.
        """
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumetype is not None:
            pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        """
        The DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        The iops of the disk.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        The disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        The throughput of the disk.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> Optional[_builtins.str]:
        """
        The disk type.
        """
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class NodeAttachStorage(dict):
    def __init__(__self__, *,
                 groups: Sequence['outputs.NodeAttachStorageGroup'],
                 selectors: Sequence['outputs.NodeAttachStorageSelector']):
        """
        :param Sequence['NodeAttachStorageGroupArgs'] groups: Specifies the storage group consists of multiple storage devices.
               This is used to divide storage space. Structure is documented below.
               Changing this parameter will reset the node.
        :param Sequence['NodeAttachStorageSelectorArgs'] selectors: Specifies the disk selection.
               Matched disks are managed according to match labels and storage type. Structure is documented below.
               Changing this parameter will reset the node.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.NodeAttachStorageGroup']:
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Sequence['outputs.NodeAttachStorageSelector']:
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class NodeAttachStorageGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectorNames":
            suggest = "selector_names"
        elif key == "virtualSpaces":
            suggest = "virtual_spaces"
        elif key == "cceManaged":
            suggest = "cce_managed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeAttachStorageGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeAttachStorageGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeAttachStorageGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 selector_names: Sequence[_builtins.str],
                 virtual_spaces: Sequence['outputs.NodeAttachStorageGroupVirtualSpace'],
                 cce_managed: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Specifies the name of a virtual storage group. Each group name must be unique.
               Changing this parameter will reset the node.
        :param Sequence[_builtins.str] selector_names: Specifies the list of names of selectors to match.
               This parameter corresponds to name in `selectors`. A group can match multiple selectors,
               but a selector can match only one group. Changing this parameter will reset the node.
        :param Sequence['NodeAttachStorageGroupVirtualSpaceArgs'] virtual_spaces: Specifies the detailed management of space configuration in a group.
               Changing this parameter will reset the node.
        :param _builtins.bool cce_managed: Specifies the whether the storage space is for **kubernetes** and
               **runtime** components. Only one group can be set to true. The default value is **false**.
               Changing this parameter will reset the node.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of a virtual storage group. Each group name must be unique.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "selector_names")

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> Sequence['outputs.NodeAttachStorageGroupVirtualSpace']:
        """
        Specifies the detailed management of space configuration in a group.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "virtual_spaces")

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[_builtins.bool]:
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "cce_managed")


@pulumi.output_type
class NodeAttachStorageGroupVirtualSpace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvmLvType":
            suggest = "lvm_lv_type"
        elif key == "lvmPath":
            suggest = "lvm_path"
        elif key == "runtimeLvType":
            suggest = "runtime_lv_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeAttachStorageGroupVirtualSpace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeAttachStorageGroupVirtualSpace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeAttachStorageGroupVirtualSpace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 size: _builtins.str,
                 lvm_lv_type: Optional[_builtins.str] = None,
                 lvm_path: Optional[_builtins.str] = None,
                 runtime_lv_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
               and **user** are supported. Changing this parameter will reset the node.
        :param _builtins.str size: Specifies the size of a virtual space. Only an integer percentage is supported.
               Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
               Changing this parameter will reset the node.
        :param _builtins.str lvm_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
               a new resource.
        :param _builtins.str lvm_path: Specifies the absolute path to which the disk is attached.
               This parameter takes effect only in **user** configuration. Changing this parameter will reset the node.
        :param _builtins.str runtime_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **runtime** configuration. Changing this parameter will reset the node.
               
               <a name="hostname_config"></a>
               The `hostname_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[_builtins.str]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
        a new resource.
        """
        return pulumi.get(self, "lvm_lv_type")

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[_builtins.str]:
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "lvm_path")

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[_builtins.str]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration. Changing this parameter will reset the node.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
        return pulumi.get(self, "runtime_lv_type")


@pulumi.output_type
class NodeAttachStorageSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchLabelCount":
            suggest = "match_label_count"
        elif key == "matchLabelMetadataCmkid":
            suggest = "match_label_metadata_cmkid"
        elif key == "matchLabelMetadataEncrypted":
            suggest = "match_label_metadata_encrypted"
        elif key == "matchLabelSize":
            suggest = "match_label_size"
        elif key == "matchLabelVolumeType":
            suggest = "match_label_volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeAttachStorageSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeAttachStorageSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeAttachStorageSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 match_label_count: Optional[_builtins.str] = None,
                 match_label_metadata_cmkid: Optional[_builtins.str] = None,
                 match_label_metadata_encrypted: Optional[_builtins.str] = None,
                 match_label_size: Optional[_builtins.str] = None,
                 match_label_volume_type: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the selector name, used as the index of `selector_names` in storage group.
               The name of each selector must be unique. Changing this parameter will reset the node.
        :param _builtins.str match_label_count: Specifies the number of disks to be selected. If omitted,
               all disks of this type are selected. Changing this parameter will reset the node.
        :param _builtins.str match_label_metadata_cmkid: Specifies the customer master key ID of an encrypted
               disk. Changing this parameter will reset the node.
        :param _builtins.str match_label_metadata_encrypted: Specifies the disk encryption identifier.
               Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
               If omitted, whether the disk is encrypted is not limited. Changing this parameter will reset the node.
        :param _builtins.str match_label_size: Specifies the matched disk size. If omitted,
               the disk size is not limited. Example: 100. Changing this parameter will reset the node.
        :param _builtins.str match_label_volume_type: Specifies the EVS disk type. Currently,
               **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
               Changing this parameter will reset the node.
        :param _builtins.str type: Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
               The default value is **evs**. Changing this parameter will reset the node.
        """
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the selector name, used as the index of `selector_names` in storage group.
        The name of each selector must be unique. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[_builtins.str]:
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_count")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[_builtins.str]:
        """
        Specifies the customer master key ID of an encrypted
        disk. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_metadata_cmkid")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[_builtins.str]:
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_metadata_encrypted")

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[_builtins.str]:
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_size")

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[_builtins.str]:
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_volume_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NodeAttachTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: Available options are NoSchedule, PreferNoSchedule, and NoExecute.
               Changing this parameter will reset the node.
        :param _builtins.str key: A key must contain 1 to 63 characters starting with a letter or digit.
               Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
               as the prefix of a key. Changing this parameter will reset the node.
        :param _builtins.str value: A value must start with a letter or digit and can contain a maximum of 63
               characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
               reset the node.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key must contain 1 to 63 characters starting with a letter or digit.
        Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
        as the prefix of a key. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A value must start with a letter or digit and can contain a maximum of 63
        characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
        reset the node.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NodeDataVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeDataVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeDataVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeDataVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volumetype: _builtins.str,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        """
        :param _builtins.int size: Specifies the disk size in GB.
        :param _builtins.str volumetype: Specifies the disk type.
        :param _builtins.str dss_pool_id: Specifies the DSS pool ID. This field is used only for
        :param Mapping[str, _builtins.str] extend_params: Specifies the disk expansion parameters.
        :param _builtins.bool hw_passthrough: schema: Internal
        :param _builtins.int iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param _builtins.str kms_key_id: Specifies the ID of a KMS key. This is used to encrypt the volume.
        :param _builtins.int throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
               
               > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first
               time ever.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        """
        Specifies the DSS pool ID. This field is used only for
        """
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.

        > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first
        time ever.
        """
        return pulumi.get(self, "throughput")


@pulumi.output_type
class NodeExtendParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agencyName":
            suggest = "agency_name"
        elif key == "dockerBaseSize":
            suggest = "docker_base_size"
        elif key == "kubeReservedMem":
            suggest = "kube_reserved_mem"
        elif key == "marketType":
            suggest = "market_type"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "nicThreshold":
            suggest = "nic_threshold"
        elif key == "nodeImageId":
            suggest = "node_image_id"
        elif key == "nodeMultiQueue":
            suggest = "node_multi_queue"
        elif key == "securityReinforcementType":
            suggest = "security_reinforcement_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "systemReservedMem":
            suggest = "system_reserved_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeExtendParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeExtendParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeExtendParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agency_name: Optional[_builtins.str] = None,
                 docker_base_size: Optional[_builtins.int] = None,
                 kube_reserved_mem: Optional[_builtins.int] = None,
                 market_type: Optional[_builtins.str] = None,
                 max_pods: Optional[_builtins.int] = None,
                 nic_threshold: Optional[_builtins.str] = None,
                 node_image_id: Optional[_builtins.str] = None,
                 node_multi_queue: Optional[_builtins.str] = None,
                 postinstall: Optional[_builtins.str] = None,
                 preinstall: Optional[_builtins.str] = None,
                 security_reinforcement_type: Optional[_builtins.str] = None,
                 spot_price: Optional[_builtins.str] = None,
                 system_reserved_mem: Optional[_builtins.int] = None):
        """
        :param _builtins.str agency_name: Specifies the agency name.
        :param _builtins.int docker_base_size: Specifies the available disk space of a single container on a node,
               in GB.
        :param _builtins.int kube_reserved_mem: Specifies the reserved node memory, which is reserved for
               Kubernetes-related components.
        :param _builtins.int max_pods: Specifies the maximum number of instances a node is allowed to create.
        :param _builtins.str nic_threshold: Specifies the ENI pre-binding thresholds.
               Example setting: **"0.3:0.6"**.
        :param _builtins.str node_image_id: Specifies the image ID to create the node.
        :param _builtins.str node_multi_queue: Specifies the number of ENI queues.
               Example setting: **"[{\\"queue\\":4}]"**.
        :param _builtins.str postinstall: Specifies the script to be executed after installation.
               The input value can be a Base64 encoded string or not.
        :param _builtins.str preinstall: Specifies the script to be executed before installation.
               The input value can be a Base64 encoded string or not.
        :param _builtins.str security_reinforcement_type: Specifies the security reinforcement type.
               The value can be: **null** or **cybersecurity**.
        :param _builtins.int system_reserved_mem: Specifies the reserved node memory, which is reserved
               value for system components.
        """
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[_builtins.str]:
        """
        Specifies the agency name.
        """
        return pulumi.get(self, "agency_name")

    @_builtins.property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[_builtins.int]:
        """
        Specifies the available disk space of a single container on a node,
        in GB.
        """
        return pulumi.get(self, "docker_base_size")

    @_builtins.property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[_builtins.int]:
        """
        Specifies the reserved node memory, which is reserved for
        Kubernetes-related components.
        """
        return pulumi.get(self, "kube_reserved_mem")

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of instances a node is allowed to create.
        """
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[_builtins.str]:
        """
        Specifies the ENI pre-binding thresholds.
        Example setting: **"0.3:0.6"**.
        """
        return pulumi.get(self, "nic_threshold")

    @_builtins.property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[_builtins.str]:
        """
        Specifies the image ID to create the node.
        """
        return pulumi.get(self, "node_image_id")

    @_builtins.property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[_builtins.str]:
        """
        Specifies the number of ENI queues.
        Example setting: **"[{\\"queue\\":4}]"**.
        """
        return pulumi.get(self, "node_multi_queue")

    @_builtins.property
    @pulumi.getter
    def postinstall(self) -> Optional[_builtins.str]:
        """
        Specifies the script to be executed after installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "postinstall")

    @_builtins.property
    @pulumi.getter
    def preinstall(self) -> Optional[_builtins.str]:
        """
        Specifies the script to be executed before installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "preinstall")

    @_builtins.property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[_builtins.str]:
        """
        Specifies the security reinforcement type.
        The value can be: **null** or **cybersecurity**.
        """
        return pulumi.get(self, "security_reinforcement_type")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[_builtins.int]:
        """
        Specifies the reserved node memory, which is reserved
        value for system components.
        """
        return pulumi.get(self, "system_reserved_mem")


@pulumi.output_type
class NodeExtensionNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeExtensionNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeExtensionNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeExtensionNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str subnet_id: Specifies the ID of the subnet to which the NIC belongs.
               
               <a name="extend_params"></a>
               The `extend_params` block supports:
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Specifies the ID of the subnet to which the NIC belongs.

        <a name="extend_params"></a>
        The `extend_params` block supports:
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class NodeHostnameConfig(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class NodePoolDataVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolDataVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolDataVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolDataVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volumetype: _builtins.str,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        """
        :param _builtins.int size: Specifies the disk size in GB.
        :param _builtins.str volumetype: Specifies the disk type.
        :param _builtins.str dss_pool_id: Specifies the DSS pool ID. This field is used only for dedicated storage.
        :param Mapping[str, _builtins.str] extend_params: Specifies the disk expansion parameters.
        :param _builtins.bool hw_passthrough: schema: Internal
        :param _builtins.int iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param _builtins.str kms_key_id: Specifies the KMS key ID. This is used to encrypt the volume.
        :param _builtins.int throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
               
               > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first time ever.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        """
        Specifies the DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Specifies the KMS key ID. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.

        > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first time ever.
        """
        return pulumi.get(self, "throughput")


@pulumi.output_type
class NodePoolExtendParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agencyName":
            suggest = "agency_name"
        elif key == "dockerBaseSize":
            suggest = "docker_base_size"
        elif key == "kubeReservedMem":
            suggest = "kube_reserved_mem"
        elif key == "marketType":
            suggest = "market_type"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "nicThreshold":
            suggest = "nic_threshold"
        elif key == "nodeImageId":
            suggest = "node_image_id"
        elif key == "nodeMultiQueue":
            suggest = "node_multi_queue"
        elif key == "securityReinforcementType":
            suggest = "security_reinforcement_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "systemReservedMem":
            suggest = "system_reserved_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolExtendParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolExtendParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolExtendParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agency_name: Optional[_builtins.str] = None,
                 docker_base_size: Optional[_builtins.int] = None,
                 kube_reserved_mem: Optional[_builtins.int] = None,
                 market_type: Optional[_builtins.str] = None,
                 max_pods: Optional[_builtins.int] = None,
                 nic_threshold: Optional[_builtins.str] = None,
                 node_image_id: Optional[_builtins.str] = None,
                 node_multi_queue: Optional[_builtins.str] = None,
                 postinstall: Optional[_builtins.str] = None,
                 preinstall: Optional[_builtins.str] = None,
                 security_reinforcement_type: Optional[_builtins.str] = None,
                 spot_price: Optional[_builtins.str] = None,
                 system_reserved_mem: Optional[_builtins.int] = None):
        """
        :param _builtins.str agency_name: Specifies the agency name.
        :param _builtins.int docker_base_size: Specifies the available disk space of a single container on a node,
               in GB.
        :param _builtins.int kube_reserved_mem: Specifies the reserved node memory, which is reserved for
               Kubernetes-related components.
        :param _builtins.int max_pods: Specifies the maximum number of instances a node is allowed to create.
        :param _builtins.str nic_threshold: Specifies the ENI pre-binding thresholds.
               Example setting: **"0.3:0.6"**.
        :param _builtins.str node_image_id: Specifies the image ID to create the node.
        :param _builtins.str node_multi_queue: Specifies the number of ENI queues.
               Example setting: **"[{\\"queue\\":4}]"**.
        :param _builtins.str postinstall: Specifies the script to be executed after installation.
               The input value can be a Base64 encoded string or not.
        :param _builtins.str preinstall: Specifies the script to be executed before installation.
               The input value can be a Base64 encoded string or not.
        :param _builtins.str security_reinforcement_type: Specifies the security reinforcement type.
               The value can be: **null** or **cybersecurity**.
        :param _builtins.int system_reserved_mem: Specifies the reserved node memory, which is reserved
               value for system components.
        """
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[_builtins.str]:
        """
        Specifies the agency name.
        """
        return pulumi.get(self, "agency_name")

    @_builtins.property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[_builtins.int]:
        """
        Specifies the available disk space of a single container on a node,
        in GB.
        """
        return pulumi.get(self, "docker_base_size")

    @_builtins.property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[_builtins.int]:
        """
        Specifies the reserved node memory, which is reserved for
        Kubernetes-related components.
        """
        return pulumi.get(self, "kube_reserved_mem")

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of instances a node is allowed to create.
        """
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[_builtins.str]:
        """
        Specifies the ENI pre-binding thresholds.
        Example setting: **"0.3:0.6"**.
        """
        return pulumi.get(self, "nic_threshold")

    @_builtins.property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[_builtins.str]:
        """
        Specifies the image ID to create the node.
        """
        return pulumi.get(self, "node_image_id")

    @_builtins.property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[_builtins.str]:
        """
        Specifies the number of ENI queues.
        Example setting: **"[{\\"queue\\":4}]"**.
        """
        return pulumi.get(self, "node_multi_queue")

    @_builtins.property
    @pulumi.getter
    def postinstall(self) -> Optional[_builtins.str]:
        """
        Specifies the script to be executed after installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "postinstall")

    @_builtins.property
    @pulumi.getter
    def preinstall(self) -> Optional[_builtins.str]:
        """
        Specifies the script to be executed before installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "preinstall")

    @_builtins.property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[_builtins.str]:
        """
        Specifies the security reinforcement type.
        The value can be: **null** or **cybersecurity**.
        """
        return pulumi.get(self, "security_reinforcement_type")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[_builtins.int]:
        """
        Specifies the reserved node memory, which is reserved
        value for system components.
        """
        return pulumi.get(self, "system_reserved_mem")


@pulumi.output_type
class NodePoolExtensionScaleGroup(dict):
    def __init__(__self__, *,
                 metadata: Optional['outputs.NodePoolExtensionScaleGroupMetadata'] = None,
                 spec: Optional['outputs.NodePoolExtensionScaleGroupSpec'] = None):
        """
        :param 'NodePoolExtensionScaleGroupMetadataArgs' metadata: The basic information about the extended scaling group.
               The object structure is documented below.
        :param 'NodePoolExtensionScaleGroupSpecArgs' spec: Specifies the configurations of the extended scaling group,
               which carry different configurations from those of the default scaling group.
               The object structure is documented below.
               
               <a name="metadata"></a>
               The `metadata` block supports:
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.NodePoolExtensionScaleGroupMetadata']:
        """
        The basic information about the extended scaling group.
        The object structure is documented below.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.NodePoolExtensionScaleGroupSpec']:
        """
        Specifies the configurations of the extended scaling group,
        which carry different configurations from those of the default scaling group.
        The object structure is documented below.

        <a name="metadata"></a>
        The `metadata` block supports:
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class NodePoolExtensionScaleGroupMetadata(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the node pool name.
        :param _builtins.str uid: The ID of the extended scaling group.
        """
        pulumi.set(__self__, "name", name)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the node pool name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        The ID of the extended scaling group.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class NodePoolExtensionScaleGroupSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationSpecification":
            suggest = "capacity_reservation_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolExtensionScaleGroupSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolExtensionScaleGroupSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolExtensionScaleGroupSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: Optional['outputs.NodePoolExtensionScaleGroupSpecAutoscaling'] = None,
                 az: Optional[_builtins.str] = None,
                 capacity_reservation_specification: Optional['outputs.NodePoolExtensionScaleGroupSpecCapacityReservationSpecification'] = None,
                 flavor: Optional[_builtins.str] = None):
        """
        :param 'NodePoolExtensionScaleGroupSpecAutoscalingArgs' autoscaling: Specifies the auto scaling configurations of the extended scaling group.
               The object structure is documented below.
               
               <a name="capacity_reservation_specification"></a>
               The `capacity_reservation_specification` block supports:
        :param _builtins.str az: Specifies the availability zone of a node.
               If this parameter is not specified or left blank, the default scaling group configurations take effect.
        :param 'NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs' capacity_reservation_specification: Specifies the capacity reservation
               configurations of the extended scaling group.
               The object structure is documented below.
        :param _builtins.str flavor: Specifies the node flavor.
        """
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if az is not None:
            pulumi.set(__self__, "az", az)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.NodePoolExtensionScaleGroupSpecAutoscaling']:
        """
        Specifies the auto scaling configurations of the extended scaling group.
        The object structure is documented below.

        <a name="capacity_reservation_specification"></a>
        The `capacity_reservation_specification` block supports:
        """
        return pulumi.get(self, "autoscaling")

    @_builtins.property
    @pulumi.getter
    def az(self) -> Optional[_builtins.str]:
        """
        Specifies the availability zone of a node.
        If this parameter is not specified or left blank, the default scaling group configurations take effect.
        """
        return pulumi.get(self, "az")

    @_builtins.property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional['outputs.NodePoolExtensionScaleGroupSpecCapacityReservationSpecification']:
        """
        Specifies the capacity reservation
        configurations of the extended scaling group.
        The object structure is documented below.
        """
        return pulumi.get(self, "capacity_reservation_specification")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[_builtins.str]:
        """
        Specifies the node flavor.
        """
        return pulumi.get(self, "flavor")


@pulumi.output_type
class NodePoolExtensionScaleGroupSpecAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionPriority":
            suggest = "extension_priority"
        elif key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolExtensionScaleGroupSpecAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolExtensionScaleGroupSpecAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolExtensionScaleGroupSpecAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[_builtins.bool] = None,
                 extension_priority: Optional[_builtins.int] = None,
                 max_node_count: Optional[_builtins.int] = None,
                 min_node_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enable: Specifies whether to enable auto scaling for the scaling group, defaults to **false**.
        :param _builtins.int extension_priority: Specifies the priority of the scaling group, defaults to **0**.
               A higher value indicates a greater priority.
        :param _builtins.int max_node_count: Specifies the maximum number of nodes allowed if auto scaling is enabled.
        :param _builtins.int min_node_count: Specifies the minimum number of nodes allowed if auto scaling is enabled.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if extension_priority is not None:
            pulumi.set(__self__, "extension_priority", extension_priority)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable auto scaling for the scaling group, defaults to **false**.
        """
        return pulumi.get(self, "enable")

    @_builtins.property
    @pulumi.getter(name="extensionPriority")
    def extension_priority(self) -> Optional[_builtins.int]:
        """
        Specifies the priority of the scaling group, defaults to **0**.
        A higher value indicates a greater priority.
        """
        return pulumi.get(self, "extension_priority")

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of nodes allowed if auto scaling is enabled.
        """
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum number of nodes allowed if auto scaling is enabled.
        """
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class NodePoolExtensionScaleGroupSpecCapacityReservationSpecification(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 preference: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The resource ID in UUID format.
        :param _builtins.str preference: Specifies the capacity of a private storage pool. If the value is none,
               the capacity reservation is not specified. If the value is targeted, the capacity reservation is specified.
               In this case, the `id` cannot be left blank.
               
               <a name="autoscaling"></a>
               The `autoscaling` block supports:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The resource ID in UUID format.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[_builtins.str]:
        """
        Specifies the capacity of a private storage pool. If the value is none,
        the capacity reservation is not specified. If the value is targeted, the capacity reservation is specified.
        In this case, the `id` cannot be left blank.

        <a name="autoscaling"></a>
        The `autoscaling` block supports:
        """
        return pulumi.get(self, "preference")


@pulumi.output_type
class NodePoolHostnameConfig(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: Specifies the node pool type. Possible values are: **vm** and **ElasticBMS**.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the node pool type. Possible values are: **vm** and **ElasticBMS**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NodePoolNodesAddNodeList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverId":
            suggest = "server_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolNodesAddNodeList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolNodesAddNodeList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolNodesAddNodeList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_id: _builtins.str):
        """
        :param _builtins.str server_id: Specifies server ID.
        """
        pulumi.set(__self__, "server_id", server_id)

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> _builtins.str:
        """
        Specifies server ID.
        """
        return pulumi.get(self, "server_id")


@pulumi.output_type
class NodePoolRootVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolRootVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolRootVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolRootVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volumetype: _builtins.str,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        """
        :param _builtins.int size: Specifies the disk size in GB.
        :param _builtins.str volumetype: Specifies the disk type.
        :param _builtins.str dss_pool_id: Specifies the DSS pool ID. This field is used only for dedicated storage.
        :param Mapping[str, _builtins.str] extend_params: Specifies the disk expansion parameters.
        :param _builtins.bool hw_passthrough: schema: Internal
        :param _builtins.int iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param _builtins.str kms_key_id: Specifies the KMS key ID. This is used to encrypt the volume.
        :param _builtins.int throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        """
        Specifies the DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Specifies the KMS key ID. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.
        """
        return pulumi.get(self, "throughput")


@pulumi.output_type
class NodePoolStorage(dict):
    def __init__(__self__, *,
                 groups: Sequence['outputs.NodePoolStorageGroup'],
                 selectors: Sequence['outputs.NodePoolStorageSelector']):
        """
        :param Sequence['NodePoolStorageGroupArgs'] groups: Specifies the storage group consists of multiple storage devices.
               This is used to divide storage space. Structure is documented below.
        :param Sequence['NodePoolStorageSelectorArgs'] selectors: Specifies the disk selection.
               Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.NodePoolStorageGroup']:
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Sequence['outputs.NodePoolStorageSelector']:
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class NodePoolStorageGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectorNames":
            suggest = "selector_names"
        elif key == "virtualSpaces":
            suggest = "virtual_spaces"
        elif key == "cceManaged":
            suggest = "cce_managed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolStorageGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolStorageGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolStorageGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 selector_names: Sequence[_builtins.str],
                 virtual_spaces: Sequence['outputs.NodePoolStorageGroupVirtualSpace'],
                 cce_managed: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Specifies the name of an extended scaling group.
               The value cannot be default and can contain a maximum of 55 characters.
               Only digits, lowercase letters, and hyphens (-) are allowed.
               
               <a name="spec"></a>
               The `spec` block supports:
        :param Sequence[_builtins.str] selector_names: Specifies the list of names of selectors to match.
               This parameter corresponds to name in `selectors`. A group can match multiple selectors,
               but a selector can match only one group.
        :param Sequence['NodePoolStorageGroupVirtualSpaceArgs'] virtual_spaces: Specifies the detailed management of space configuration in a group.
        :param _builtins.bool cce_managed: Specifies the whether the storage space is for **kubernetes** and
               **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of an extended scaling group.
        The value cannot be default and can contain a maximum of 55 characters.
        Only digits, lowercase letters, and hyphens (-) are allowed.

        <a name="spec"></a>
        The `spec` block supports:
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group.
        """
        return pulumi.get(self, "selector_names")

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> Sequence['outputs.NodePoolStorageGroupVirtualSpace']:
        """
        Specifies the detailed management of space configuration in a group.
        """
        return pulumi.get(self, "virtual_spaces")

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[_builtins.bool]:
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        return pulumi.get(self, "cce_managed")


@pulumi.output_type
class NodePoolStorageGroupVirtualSpace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvmLvType":
            suggest = "lvm_lv_type"
        elif key == "lvmPath":
            suggest = "lvm_path"
        elif key == "runtimeLvType":
            suggest = "runtime_lv_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolStorageGroupVirtualSpace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolStorageGroupVirtualSpace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolStorageGroupVirtualSpace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 size: _builtins.str,
                 lvm_lv_type: Optional[_builtins.str] = None,
                 lvm_path: Optional[_builtins.str] = None,
                 runtime_lv_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
               and **user** are supported.
        :param _builtins.str size: Specifies the size of a virtual space. Only an integer percentage is supported.
               Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        :param _builtins.str lvm_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **kubernetes** and **user** configuration.
        :param _builtins.str lvm_path: Specifies the absolute path to which the disk is attached.
               This parameter takes effect only in **user** configuration.
        :param _builtins.str runtime_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **runtime** configuration.
               
               <a name="hostname_config"></a>
               The `hostname_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[_builtins.str]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration.
        """
        return pulumi.get(self, "lvm_lv_type")

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[_builtins.str]:
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration.
        """
        return pulumi.get(self, "lvm_path")

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[_builtins.str]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
        return pulumi.get(self, "runtime_lv_type")


@pulumi.output_type
class NodePoolStorageSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchLabelCount":
            suggest = "match_label_count"
        elif key == "matchLabelMetadataCmkid":
            suggest = "match_label_metadata_cmkid"
        elif key == "matchLabelMetadataEncrypted":
            suggest = "match_label_metadata_encrypted"
        elif key == "matchLabelSize":
            suggest = "match_label_size"
        elif key == "matchLabelVolumeType":
            suggest = "match_label_volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolStorageSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolStorageSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolStorageSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 match_label_count: Optional[_builtins.str] = None,
                 match_label_metadata_cmkid: Optional[_builtins.str] = None,
                 match_label_metadata_encrypted: Optional[_builtins.str] = None,
                 match_label_size: Optional[_builtins.str] = None,
                 match_label_volume_type: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the selector name, used as the index of `selector_names`
               in storage group. The name of each selector must be unique.
        :param _builtins.str match_label_count: Specifies the number of disks to be selected. If omitted,
               all disks of this type are selected.
        :param _builtins.str match_label_metadata_cmkid: Specifies the customer master key ID of an encrypted
               disk.
        :param _builtins.str match_label_metadata_encrypted: Specifies the disk encryption identifier.
               Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
               If omitted, whether the disk is encrypted is not limited.
        :param _builtins.str match_label_size: Specifies the matched disk size. If omitted,
               the disk size is not limited. Example: 100.
        :param _builtins.str match_label_volume_type: Specifies the EVS disk type. Currently,
               **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        :param _builtins.str type: Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
               The default value is **evs**.
        """
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the selector name, used as the index of `selector_names`
        in storage group. The name of each selector must be unique.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[_builtins.str]:
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected.
        """
        return pulumi.get(self, "match_label_count")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[_builtins.str]:
        """
        Specifies the customer master key ID of an encrypted
        disk.
        """
        return pulumi.get(self, "match_label_metadata_cmkid")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[_builtins.str]:
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited.
        """
        return pulumi.get(self, "match_label_metadata_encrypted")

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[_builtins.str]:
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100.
        """
        return pulumi.get(self, "match_label_size")

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[_builtins.str]:
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        """
        return pulumi.get(self, "match_label_volume_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: Available options are NoSchedule, PreferNoSchedule, and NoExecute.
               
               <a name="extend_params"></a>
               The `extend_params` block supports:
        :param _builtins.str key: A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
               digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
               prefix of a key.
        :param _builtins.str value: A value must start with a letter or digit and can contain a maximum of 63 characters,
               including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.

        <a name="extend_params"></a>
        The `extend_params` block supports:
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
        digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
        prefix of a key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        A value must start with a letter or digit and can contain a maximum of 63 characters,
        including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NodeRootVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeRootVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeRootVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeRootVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volumetype: _builtins.str,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        """
        :param _builtins.int size: Specifies the disk size in GB.
        :param _builtins.str volumetype: Specifies the disk type.
        :param _builtins.str dss_pool_id: Specifies the DSS pool ID. This field is used only for
        :param Mapping[str, _builtins.str] extend_params: Specifies the disk expansion parameters.
        :param _builtins.bool hw_passthrough: schema: Internal
        :param _builtins.int iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param _builtins.str kms_key_id: Specifies the ID of a KMS key. This is used to encrypt the volume.
        :param _builtins.int throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        """
        Specifies the DSS pool ID. This field is used only for
        """
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.
        """
        return pulumi.get(self, "throughput")


@pulumi.output_type
class NodeStorage(dict):
    def __init__(__self__, *,
                 groups: Sequence['outputs.NodeStorageGroup'],
                 selectors: Sequence['outputs.NodeStorageSelector']):
        """
        :param Sequence['NodeStorageGroupArgs'] groups: Specifies the storage group consists of multiple storage devices.
               This is used to divide storage space. Structure is documented below.
        :param Sequence['NodeStorageSelectorArgs'] selectors: Specifies the disk selection.
               Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.NodeStorageGroup']:
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Sequence['outputs.NodeStorageSelector']:
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        return pulumi.get(self, "selectors")


@pulumi.output_type
class NodeStorageGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectorNames":
            suggest = "selector_names"
        elif key == "virtualSpaces":
            suggest = "virtual_spaces"
        elif key == "cceManaged":
            suggest = "cce_managed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeStorageGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeStorageGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeStorageGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 selector_names: Sequence[_builtins.str],
                 virtual_spaces: Sequence['outputs.NodeStorageGroupVirtualSpace'],
                 cce_managed: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Specifies the name of a virtual storage group. Each group name must be unique.
        :param Sequence[_builtins.str] selector_names: Specifies the list of names of selectors to match.
               This parameter corresponds to name in `selectors`. A group can match multiple selectors,
               but a selector can match only one group.
        :param Sequence['NodeStorageGroupVirtualSpaceArgs'] virtual_spaces: Specifies the detailed management of space configuration in a group.
        :param _builtins.bool cce_managed: Specifies the whether the storage space is for **kubernetes** and
               **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of a virtual storage group. Each group name must be unique.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group.
        """
        return pulumi.get(self, "selector_names")

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> Sequence['outputs.NodeStorageGroupVirtualSpace']:
        """
        Specifies the detailed management of space configuration in a group.
        """
        return pulumi.get(self, "virtual_spaces")

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[_builtins.bool]:
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        return pulumi.get(self, "cce_managed")


@pulumi.output_type
class NodeStorageGroupVirtualSpace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvmLvType":
            suggest = "lvm_lv_type"
        elif key == "lvmPath":
            suggest = "lvm_path"
        elif key == "runtimeLvType":
            suggest = "runtime_lv_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeStorageGroupVirtualSpace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeStorageGroupVirtualSpace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeStorageGroupVirtualSpace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 size: _builtins.str,
                 lvm_lv_type: Optional[_builtins.str] = None,
                 lvm_path: Optional[_builtins.str] = None,
                 runtime_lv_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
               and **user** are supported.
        :param _builtins.str size: Specifies the size of a virtual space. Only an integer percentage is supported.
               Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        :param _builtins.str lvm_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **kubernetes** and **user** configuration.
        :param _builtins.str lvm_path: Specifies the absolute path to which the disk is attached.
               This parameter takes effect only in **user** configuration.
        :param _builtins.str runtime_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **runtime** configuration.
               
               <a name="hostname_config"></a>
               The `hostname_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[_builtins.str]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration.
        """
        return pulumi.get(self, "lvm_lv_type")

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[_builtins.str]:
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration.
        """
        return pulumi.get(self, "lvm_path")

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[_builtins.str]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
        return pulumi.get(self, "runtime_lv_type")


@pulumi.output_type
class NodeStorageSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchLabelCount":
            suggest = "match_label_count"
        elif key == "matchLabelMetadataCmkid":
            suggest = "match_label_metadata_cmkid"
        elif key == "matchLabelMetadataEncrypted":
            suggest = "match_label_metadata_encrypted"
        elif key == "matchLabelSize":
            suggest = "match_label_size"
        elif key == "matchLabelVolumeType":
            suggest = "match_label_volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeStorageSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeStorageSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeStorageSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 match_label_count: Optional[_builtins.str] = None,
                 match_label_metadata_cmkid: Optional[_builtins.str] = None,
                 match_label_metadata_encrypted: Optional[_builtins.str] = None,
                 match_label_size: Optional[_builtins.str] = None,
                 match_label_volume_type: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the selector name, used as the index of `selector_names`
               in storage group. The name of each selector must be unique.
        :param _builtins.str match_label_count: Specifies the number of disks to be selected. If omitted,
               all disks of this type are selected.
        :param _builtins.str match_label_metadata_cmkid: Specifies the customer master key ID of an encrypted
               disk.
        :param _builtins.str match_label_metadata_encrypted: Specifies the disk encryption identifier.
               Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
               If omitted, whether the disk is encrypted is not limited.
        :param _builtins.str match_label_size: Specifies the matched disk size. If omitted,
               the disk size is not limited. Example: 100.
        :param _builtins.str match_label_volume_type: Specifies the EVS disk type. Currently,
               **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        :param _builtins.str type: Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
               The default value is **evs**.
        """
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the selector name, used as the index of `selector_names`
        in storage group. The name of each selector must be unique.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[_builtins.str]:
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected.
        """
        return pulumi.get(self, "match_label_count")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[_builtins.str]:
        """
        Specifies the customer master key ID of an encrypted
        disk.
        """
        return pulumi.get(self, "match_label_metadata_cmkid")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[_builtins.str]:
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited.
        """
        return pulumi.get(self, "match_label_metadata_encrypted")

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[_builtins.str]:
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100.
        """
        return pulumi.get(self, "match_label_size")

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[_builtins.str]:
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        """
        return pulumi.get(self, "match_label_volume_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NodeTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        :param _builtins.str key: A key must contain 1 to 63 characters starting with a letter or digit.
               Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
               as the prefix of a key.
        :param _builtins.str value: A value must start with a letter or digit and can contain a maximum of 63
               characters, including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A key must contain 1 to 63 characters starting with a letter or digit.
        Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
        as the prefix of a key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        A value must start with a letter or digit and can contain a maximum of 63
        characters, including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NodeV3DataVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeV3DataVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeV3DataVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeV3DataVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volumetype: _builtins.str,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        """
        :param _builtins.bool hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        return pulumi.get(self, "volumetype")

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")


@pulumi.output_type
class NodeV3ExtendParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agencyName":
            suggest = "agency_name"
        elif key == "dockerBaseSize":
            suggest = "docker_base_size"
        elif key == "kubeReservedMem":
            suggest = "kube_reserved_mem"
        elif key == "marketType":
            suggest = "market_type"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "nicThreshold":
            suggest = "nic_threshold"
        elif key == "nodeImageId":
            suggest = "node_image_id"
        elif key == "nodeMultiQueue":
            suggest = "node_multi_queue"
        elif key == "securityReinforcementType":
            suggest = "security_reinforcement_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "systemReservedMem":
            suggest = "system_reserved_mem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeV3ExtendParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeV3ExtendParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeV3ExtendParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agency_name: Optional[_builtins.str] = None,
                 docker_base_size: Optional[_builtins.int] = None,
                 kube_reserved_mem: Optional[_builtins.int] = None,
                 market_type: Optional[_builtins.str] = None,
                 max_pods: Optional[_builtins.int] = None,
                 nic_threshold: Optional[_builtins.str] = None,
                 node_image_id: Optional[_builtins.str] = None,
                 node_multi_queue: Optional[_builtins.str] = None,
                 postinstall: Optional[_builtins.str] = None,
                 preinstall: Optional[_builtins.str] = None,
                 security_reinforcement_type: Optional[_builtins.str] = None,
                 spot_price: Optional[_builtins.str] = None,
                 system_reserved_mem: Optional[_builtins.int] = None):
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "agency_name")

    @_builtins.property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "docker_base_size")

    @_builtins.property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "kube_reserved_mem")

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "nic_threshold")

    @_builtins.property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_image_id")

    @_builtins.property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_multi_queue")

    @_builtins.property
    @pulumi.getter
    def postinstall(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "postinstall")

    @_builtins.property
    @pulumi.getter
    def preinstall(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "preinstall")

    @_builtins.property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_reinforcement_type")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "system_reserved_mem")


@pulumi.output_type
class NodeV3ExtensionNic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeV3ExtensionNic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeV3ExtensionNic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeV3ExtensionNic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str):
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class NodeV3HostnameConfig(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class NodeV3RootVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dssPoolId":
            suggest = "dss_pool_id"
        elif key == "extendParam":
            suggest = "extend_param"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "hwPassthrough":
            suggest = "hw_passthrough"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeV3RootVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeV3RootVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeV3RootVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volumetype: _builtins.str,
                 dss_pool_id: Optional[_builtins.str] = None,
                 extend_param: Optional[_builtins.str] = None,
                 extend_params: Optional[Mapping[str, _builtins.str]] = None,
                 hw_passthrough: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        """
        :param _builtins.bool hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        return pulumi.get(self, "volumetype")

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dss_pool_id")

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "extend_param")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[_builtins.bool]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")


@pulumi.output_type
class NodeV3Storage(dict):
    def __init__(__self__, *,
                 groups: Sequence['outputs.NodeV3StorageGroup'],
                 selectors: Sequence['outputs.NodeV3StorageSelector']):
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.NodeV3StorageGroup']:
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> Sequence['outputs.NodeV3StorageSelector']:
        return pulumi.get(self, "selectors")


@pulumi.output_type
class NodeV3StorageGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectorNames":
            suggest = "selector_names"
        elif key == "virtualSpaces":
            suggest = "virtual_spaces"
        elif key == "cceManaged":
            suggest = "cce_managed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeV3StorageGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeV3StorageGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeV3StorageGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 selector_names: Sequence[_builtins.str],
                 virtual_spaces: Sequence['outputs.NodeV3StorageGroupVirtualSpace'],
                 cce_managed: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "selector_names")

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> Sequence['outputs.NodeV3StorageGroupVirtualSpace']:
        return pulumi.get(self, "virtual_spaces")

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cce_managed")


@pulumi.output_type
class NodeV3StorageGroupVirtualSpace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvmLvType":
            suggest = "lvm_lv_type"
        elif key == "lvmPath":
            suggest = "lvm_path"
        elif key == "runtimeLvType":
            suggest = "runtime_lv_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeV3StorageGroupVirtualSpace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeV3StorageGroupVirtualSpace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeV3StorageGroupVirtualSpace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 size: _builtins.str,
                 lvm_lv_type: Optional[_builtins.str] = None,
                 lvm_path: Optional[_builtins.str] = None,
                 runtime_lv_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lvm_lv_type")

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lvm_path")

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_lv_type")


@pulumi.output_type
class NodeV3StorageSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchLabelCount":
            suggest = "match_label_count"
        elif key == "matchLabelMetadataCmkid":
            suggest = "match_label_metadata_cmkid"
        elif key == "matchLabelMetadataEncrypted":
            suggest = "match_label_metadata_encrypted"
        elif key == "matchLabelSize":
            suggest = "match_label_size"
        elif key == "matchLabelVolumeType":
            suggest = "match_label_volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeV3StorageSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeV3StorageSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeV3StorageSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 match_label_count: Optional[_builtins.str] = None,
                 match_label_metadata_cmkid: Optional[_builtins.str] = None,
                 match_label_metadata_encrypted: Optional[_builtins.str] = None,
                 match_label_size: Optional[_builtins.str] = None,
                 match_label_volume_type: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_label_count")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_label_metadata_cmkid")

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_label_metadata_encrypted")

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_label_size")

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_label_volume_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class NodeV3Taint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NodesRemoveNode(dict):
    def __init__(__self__, *,
                 uid: _builtins.str):
        """
        :param _builtins.str uid: Specifies the node ID.
        """
        pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        Specifies the node ID.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetAddonTemplateSupportVersionResult(dict):
    def __init__(__self__, *,
                 bare_metals: Sequence[_builtins.str],
                 virtual_machines: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] bare_metals: The cluster (Bare Metal) version that the add-on template supported.
        :param Sequence[_builtins.str] virtual_machines: The cluster (Virtual Machine) version that the add-on template supported.
        """
        pulumi.set(__self__, "bare_metals", bare_metals)
        pulumi.set(__self__, "virtual_machines", virtual_machines)

    @_builtins.property
    @pulumi.getter(name="bareMetals")
    def bare_metals(self) -> Sequence[_builtins.str]:
        """
        The cluster (Bare Metal) version that the add-on template supported.
        """
        return pulumi.get(self, "bare_metals")

    @_builtins.property
    @pulumi.getter(name="virtualMachines")
    def virtual_machines(self) -> Sequence[_builtins.str]:
        """
        The cluster (Virtual Machine) version that the add-on template supported.
        """
        return pulumi.get(self, "virtual_machines")


@pulumi.output_type
class GetAddonsItemResult(dict):
    def __init__(__self__, *,
                 metadatas: Sequence['outputs.GetAddonsItemMetadataResult'],
                 specs: Sequence['outputs.GetAddonsItemSpecResult'],
                 statuses: Sequence['outputs.GetAddonsItemStatusResult']):
        """
        :param Sequence['GetAddonsItemMetadataArgs'] metadatas: The metadata of the add-on instance.
        :param Sequence['GetAddonsItemSpecArgs'] specs: The detailed description of the add-on instance.
        :param Sequence['GetAddonsItemStatusArgs'] statuses: The statuses of add-on instances.
        """
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "specs", specs)
        pulumi.set(__self__, "statuses", statuses)

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetAddonsItemMetadataResult']:
        """
        The metadata of the add-on instance.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GetAddonsItemSpecResult']:
        """
        The detailed description of the add-on instance.
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter
    def statuses(self) -> Sequence['outputs.GetAddonsItemStatusResult']:
        """
        The statuses of add-on instances.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class GetAddonsItemMetadataResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 annotations: Mapping[str, _builtins.str],
                 creation_timestamp: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 uid: _builtins.str,
                 update_timestamp: _builtins.str):
        """
        :param _builtins.str alias: The add-on instance alias.
        :param Mapping[str, _builtins.str] annotations: The add-on annotations in the format of key/value pairs.
        :param _builtins.str creation_timestamp: The creation time.
        :param Mapping[str, _builtins.str] labels: The add-on labels in key/value pairs.
        :param _builtins.str name: The add-on instance name.
        :param _builtins.str uid: The add-on instance ID.
        :param _builtins.str update_timestamp: The update time.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "update_timestamp", update_timestamp)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        The add-on instance alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        The add-on annotations in the format of key/value pairs.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        The creation time.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        The add-on labels in key/value pairs.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The add-on instance name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        The add-on instance ID.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="updateTimestamp")
    def update_timestamp(self) -> _builtins.str:
        """
        The update time.
        """
        return pulumi.get(self, "update_timestamp")


@pulumi.output_type
class GetAddonsItemSpecResult(dict):
    def __init__(__self__, *,
                 addon_template_labels: Sequence[_builtins.str],
                 addon_template_logo: _builtins.str,
                 addon_template_name: _builtins.str,
                 addon_template_type: _builtins.str,
                 cluster_id: _builtins.str,
                 description: _builtins.str,
                 values: Sequence[_builtins.str],
                 version: _builtins.str):
        """
        :param Sequence[_builtins.str] addon_template_labels: The labels of the add-on template.
        :param _builtins.str addon_template_logo: The URL for obtaining the add-on template logo.
        :param _builtins.str addon_template_name: The add-on name.
        :param _builtins.str addon_template_type: The add-on type.
        :param _builtins.str cluster_id: Specifies the ID of the cluster to which the add-on instance belongs.
        :param _builtins.str description: The add-on description.
        :param Sequence[_builtins.str] values: The add-on installation parameters.
        :param _builtins.str version: The add-on version.
        """
        pulumi.set(__self__, "addon_template_labels", addon_template_labels)
        pulumi.set(__self__, "addon_template_logo", addon_template_logo)
        pulumi.set(__self__, "addon_template_name", addon_template_name)
        pulumi.set(__self__, "addon_template_type", addon_template_type)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="addonTemplateLabels")
    def addon_template_labels(self) -> Sequence[_builtins.str]:
        """
        The labels of the add-on template.
        """
        return pulumi.get(self, "addon_template_labels")

    @_builtins.property
    @pulumi.getter(name="addonTemplateLogo")
    def addon_template_logo(self) -> _builtins.str:
        """
        The URL for obtaining the add-on template logo.
        """
        return pulumi.get(self, "addon_template_logo")

    @_builtins.property
    @pulumi.getter(name="addonTemplateName")
    def addon_template_name(self) -> _builtins.str:
        """
        The add-on name.
        """
        return pulumi.get(self, "addon_template_name")

    @_builtins.property
    @pulumi.getter(name="addonTemplateType")
    def addon_template_type(self) -> _builtins.str:
        """
        The add-on type.
        """
        return pulumi.get(self, "addon_template_type")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        Specifies the ID of the cluster to which the add-on instance belongs.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The add-on description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The add-on installation parameters.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The add-on version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAddonsItemStatusResult(dict):
    def __init__(__self__, *,
                 _reason: _builtins.str,
                 current_versions: Sequence['outputs.GetAddonsItemStatusCurrentVersionResult'],
                 is_rollbackable: _builtins.bool,
                 message: _builtins.str,
                 previous_version: _builtins.str,
                 status: _builtins.str,
                 target_versions: Sequence[_builtins.str]):
        """
        :param _builtins.str _reason: The cause of the add-on installation failure.
        :param Sequence['GetAddonsItemStatusCurrentVersionArgs'] current_versions: The information about the current add-on version.
        :param _builtins.bool is_rollbackable: Whether the add-on version can be rolled back to the source version.
        :param _builtins.str message: The installation error details.
        :param _builtins.str previous_version: The add-on version before upgrade or rollback
        :param _builtins.str status: The statuses of add-on instances.
        :param Sequence[_builtins.str] target_versions: The versions to which the current add-on version can be upgraded.
        """
        pulumi.set(__self__, "_reason", _reason)
        pulumi.set(__self__, "current_versions", current_versions)
        pulumi.set(__self__, "is_rollbackable", is_rollbackable)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "previous_version", previous_version)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "target_versions", target_versions)

    @_builtins.property
    @pulumi.getter
    def _reason(self) -> _builtins.str:
        """
        The cause of the add-on installation failure.
        """
        return pulumi.get(self, "_reason")

    @_builtins.property
    @pulumi.getter(name="currentVersions")
    def current_versions(self) -> Sequence['outputs.GetAddonsItemStatusCurrentVersionResult']:
        """
        The information about the current add-on version.
        """
        return pulumi.get(self, "current_versions")

    @_builtins.property
    @pulumi.getter(name="isRollbackable")
    def is_rollbackable(self) -> _builtins.bool:
        """
        Whether the add-on version can be rolled back to the source version.
        """
        return pulumi.get(self, "is_rollbackable")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The installation error details.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="previousVersion")
    def previous_version(self) -> _builtins.str:
        """
        The add-on version before upgrade or rollback
        """
        return pulumi.get(self, "previous_version")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The statuses of add-on instances.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="targetVersions")
    def target_versions(self) -> Sequence[_builtins.str]:
        """
        The versions to which the current add-on version can be upgraded.
        """
        return pulumi.get(self, "target_versions")


@pulumi.output_type
class GetAddonsItemStatusCurrentVersionResult(dict):
    def __init__(__self__, *,
                 creation_timestamp: _builtins.str,
                 inputs: Sequence[_builtins.str],
                 stable: _builtins.bool,
                 support_versions: Sequence['outputs.GetAddonsItemStatusCurrentVersionSupportVersionResult'],
                 translates: Sequence[_builtins.str],
                 update_timestamp: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str creation_timestamp: The creation time.
        :param Sequence[_builtins.str] inputs: The add-on installation parameters.
        :param _builtins.bool stable: Whether the add-on version is a stable release.
        :param Sequence['GetAddonsItemStatusCurrentVersionSupportVersionArgs'] support_versions: The cluster versions that support the add-on.
        :param Sequence[_builtins.str] translates: The translation information used by the GUI.
        :param _builtins.str update_timestamp: The update time.
        :param _builtins.str version: The add-on version.
        """
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "stable", stable)
        pulumi.set(__self__, "support_versions", support_versions)
        pulumi.set(__self__, "translates", translates)
        pulumi.set(__self__, "update_timestamp", update_timestamp)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        The creation time.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Sequence[_builtins.str]:
        """
        The add-on installation parameters.
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def stable(self) -> _builtins.bool:
        """
        Whether the add-on version is a stable release.
        """
        return pulumi.get(self, "stable")

    @_builtins.property
    @pulumi.getter(name="supportVersions")
    def support_versions(self) -> Sequence['outputs.GetAddonsItemStatusCurrentVersionSupportVersionResult']:
        """
        The cluster versions that support the add-on.
        """
        return pulumi.get(self, "support_versions")

    @_builtins.property
    @pulumi.getter
    def translates(self) -> Sequence[_builtins.str]:
        """
        The translation information used by the GUI.
        """
        return pulumi.get(self, "translates")

    @_builtins.property
    @pulumi.getter(name="updateTimestamp")
    def update_timestamp(self) -> _builtins.str:
        """
        The update time.
        """
        return pulumi.get(self, "update_timestamp")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The add-on version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAddonsItemStatusCurrentVersionSupportVersionResult(dict):
    def __init__(__self__, *,
                 categories: Sequence[_builtins.str],
                 cluster_type: _builtins.str,
                 cluster_versions: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] categories: The current support version category.
        :param _builtins.str cluster_type: The cluster type that supports the add-on.
        :param Sequence[_builtins.str] cluster_versions: The cluster versions that support the add-on. The value is a regular expression.
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "cluster_versions", cluster_versions)

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Sequence[_builtins.str]:
        """
        The current support version category.
        """
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        The cluster type that supports the add-on.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="clusterVersions")
    def cluster_versions(self) -> Sequence[_builtins.str]:
        """
        The cluster versions that support the add-on. The value is a regular expression.
        """
        return pulumi.get(self, "cluster_versions")


@pulumi.output_type
class GetAutopilotAddonTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 annotations: Mapping[str, _builtins.str],
                 description: _builtins.str,
                 id: _builtins.str,
                 labels: Sequence[_builtins.str],
                 name: _builtins.str,
                 require: _builtins.bool,
                 type: _builtins.str,
                 versions: Sequence['outputs.GetAutopilotAddonTemplatesTemplateVersionResult']):
        """
        :param _builtins.str alias: The add-on alias.
        :param Mapping[str, _builtins.str] annotations: The add-on annotations in the format of key-value pairs.
        :param _builtins.str description: The description of the add-on.
        :param _builtins.str id: The ID of the add-on template.
        :param Sequence[_builtins.str] labels: The labels of the add-on.
        :param _builtins.str name: The name of the add-on.
        :param _builtins.bool require: Whether the add-on is required.
        :param _builtins.str type: The type of the add-on template.
        :param Sequence['GetAutopilotAddonTemplatesTemplateVersionArgs'] versions: The versions of the add-on.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "require", require)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        The add-on alias.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        The add-on annotations in the format of key-value pairs.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the add-on.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the add-on template.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence[_builtins.str]:
        """
        The labels of the add-on.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the add-on.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def require(self) -> _builtins.bool:
        """
        Whether the add-on is required.
        """
        return pulumi.get(self, "require")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the add-on template.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Sequence['outputs.GetAutopilotAddonTemplatesTemplateVersionResult']:
        """
        The versions of the add-on.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetAutopilotAddonTemplatesTemplateVersionResult(dict):
    def __init__(__self__, *,
                 input: _builtins.str,
                 stable: _builtins.bool,
                 support_versions: Sequence['outputs.GetAutopilotAddonTemplatesTemplateVersionSupportVersionResult'],
                 version: _builtins.str):
        """
        :param _builtins.str input: The install parameters of the add-on.
        :param _builtins.bool stable: Whether the version is stable.
        :param Sequence['GetAutopilotAddonTemplatesTemplateVersionSupportVersionArgs'] support_versions: The list of supported cluster versions.
        :param _builtins.str version: The add-on version.
        """
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "stable", stable)
        pulumi.set(__self__, "support_versions", support_versions)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def input(self) -> _builtins.str:
        """
        The install parameters of the add-on.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def stable(self) -> _builtins.bool:
        """
        Whether the version is stable.
        """
        return pulumi.get(self, "stable")

    @_builtins.property
    @pulumi.getter(name="supportVersions")
    def support_versions(self) -> Sequence['outputs.GetAutopilotAddonTemplatesTemplateVersionSupportVersionResult']:
        """
        The list of supported cluster versions.
        """
        return pulumi.get(self, "support_versions")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The add-on version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutopilotAddonTemplatesTemplateVersionSupportVersionResult(dict):
    def __init__(__self__, *,
                 cluster_type: _builtins.str,
                 cluster_versions: Sequence[_builtins.str]):
        """
        :param _builtins.str cluster_type: The supported cluster type.
        :param Sequence[_builtins.str] cluster_versions: The supported cluster version.
        """
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "cluster_versions", cluster_versions)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        The supported cluster type.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="clusterVersions")
    def cluster_versions(self) -> Sequence[_builtins.str]:
        """
        The supported cluster version.
        """
        return pulumi.get(self, "cluster_versions")


@pulumi.output_type
class GetAutopilotClusterCertificateClusterResult(dict):
    def __init__(__self__, *,
                 clusters: Sequence['outputs.GetAutopilotClusterCertificateClusterClusterResult'],
                 name: _builtins.str):
        """
        :param Sequence['GetAutopilotClusterCertificateClusterClusterArgs'] clusters: The context cluster of the cluster certificate.
        :param _builtins.str name: The context name of the cluster certificate.
        """
        pulumi.set(__self__, "clusters", clusters)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetAutopilotClusterCertificateClusterClusterResult']:
        """
        The context cluster of the cluster certificate.
        """
        return pulumi.get(self, "clusters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The context name of the cluster certificate.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutopilotClusterCertificateClusterClusterResult(dict):
    def __init__(__self__, *,
                 certificate_authority_data: _builtins.str,
                 insecure_skip_tls_verify: _builtins.bool,
                 server: _builtins.str):
        """
        :param _builtins.str certificate_authority_data: The certificate authority data of the cluster certificate.
        :param _builtins.bool insecure_skip_tls_verify: Whether insecure skip tls verify of the cluster certificate.
        :param _builtins.str server: The server address of the cluster certificate.
        """
        pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        pulumi.set(__self__, "insecure_skip_tls_verify", insecure_skip_tls_verify)
        pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> _builtins.str:
        """
        The certificate authority data of the cluster certificate.
        """
        return pulumi.get(self, "certificate_authority_data")

    @_builtins.property
    @pulumi.getter(name="insecureSkipTlsVerify")
    def insecure_skip_tls_verify(self) -> _builtins.bool:
        """
        Whether insecure skip tls verify of the cluster certificate.
        """
        return pulumi.get(self, "insecure_skip_tls_verify")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        The server address of the cluster certificate.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetAutopilotClusterCertificateContextResult(dict):
    def __init__(__self__, *,
                 contexts: Sequence['outputs.GetAutopilotClusterCertificateContextContextResult'],
                 name: _builtins.str):
        """
        :param Sequence['GetAutopilotClusterCertificateContextContextArgs'] contexts: The user information.
        :param _builtins.str name: The context name of the cluster certificate.
        """
        pulumi.set(__self__, "contexts", contexts)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def contexts(self) -> Sequence['outputs.GetAutopilotClusterCertificateContextContextResult']:
        """
        The user information.
        """
        return pulumi.get(self, "contexts")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The context name of the cluster certificate.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutopilotClusterCertificateContextContextResult(dict):
    def __init__(__self__, *,
                 cluster: _builtins.str,
                 user: _builtins.str):
        """
        :param _builtins.str cluster: The context cluster of the cluster certificate.
        :param _builtins.str user: The context user of the cluster certificate.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.str:
        """
        The context cluster of the cluster certificate.
        """
        return pulumi.get(self, "cluster")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        The context user of the cluster certificate.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetAutopilotClusterCertificateUserResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 users: Sequence['outputs.GetAutopilotClusterCertificateUserUserResult']):
        """
        :param _builtins.str name: The context name of the cluster certificate.
        :param Sequence['GetAutopilotClusterCertificateUserUserArgs'] users: The context user of the cluster certificate.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The context name of the cluster certificate.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetAutopilotClusterCertificateUserUserResult']:
        """
        The context user of the cluster certificate.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetAutopilotClusterCertificateUserUserResult(dict):
    def __init__(__self__, *,
                 client_certificate_data: _builtins.str,
                 client_key_data: _builtins.str):
        """
        :param _builtins.str client_certificate_data: The client certificate data of the cluster certificate.
        :param _builtins.str client_key_data: The client key data of the cluster certificate.
        """
        pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        pulumi.set(__self__, "client_key_data", client_key_data)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> _builtins.str:
        """
        The client certificate data of the cluster certificate.
        """
        return pulumi.get(self, "client_certificate_data")

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> _builtins.str:
        """
        The client key data of the cluster certificate.
        """
        return pulumi.get(self, "client_key_data")


@pulumi.output_type
class GetAutopilotClustersClusterResult(dict):
    def __init__(__self__, *,
                 alias: _builtins.str,
                 annotations: Mapping[str, _builtins.str],
                 authentications: Sequence['outputs.GetAutopilotClustersClusterAuthenticationResult'],
                 az: _builtins.str,
                 category: _builtins.str,
                 configurations_overrides: Sequence['outputs.GetAutopilotClustersClusterConfigurationsOverrideResult'],
                 container_networks: Sequence['outputs.GetAutopilotClustersClusterContainerNetworkResult'],
                 created_at: _builtins.str,
                 custom_sans: Sequence[_builtins.str],
                 description: _builtins.str,
                 enable_autopilot: _builtins.bool,
                 enable_snat: _builtins.bool,
                 enable_swr_image_access: _builtins.bool,
                 eni_networks: Sequence['outputs.GetAutopilotClustersClusterEniNetworkResult'],
                 extend_params: Sequence['outputs.GetAutopilotClustersClusterExtendParamResult'],
                 flavor: _builtins.str,
                 host_networks: Sequence['outputs.GetAutopilotClustersClusterHostNetworkResult'],
                 id: _builtins.str,
                 ipv6_enable: _builtins.bool,
                 kube_proxy_mode: _builtins.str,
                 name: _builtins.str,
                 platform_version: _builtins.str,
                 service_networks: Sequence['outputs.GetAutopilotClustersClusterServiceNetworkResult'],
                 statuses: Sequence['outputs.GetAutopilotClustersClusterStatusResult'],
                 tags: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 updated_at: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str alias: The alias of the cluster.
        :param Mapping[str, _builtins.str] annotations: The cluster annotations in the format of key-value pairs.
        :param Sequence['GetAutopilotClustersClusterAuthenticationArgs'] authentications: The configurations of the cluster authentication mode.
        :param _builtins.str az: The AZ of the cluster.
        :param _builtins.str category: The cluster type. Only **Turbo** is supported.
        :param Sequence['GetAutopilotClustersClusterConfigurationsOverrideArgs'] configurations_overrides: The parameter to override the default component configurations in the cluster.
        :param Sequence['GetAutopilotClustersClusterContainerNetworkArgs'] container_networks: The container network of the cluster.
        :param _builtins.str created_at: The time when the cluster was created.
        :param Sequence[_builtins.str] custom_sans: The custom SAN field in the API server certificate of the cluster.
        :param _builtins.str description: The description of the cluster.
        :param _builtins.bool enable_autopilot: Whether the cluster is an Autopilot cluster.
        :param _builtins.bool enable_snat: Whether SNAT is configured for the cluster.
               After this function is enabled, the cluster can access the Internet through a NAT gateway.
               By default, the existing NAT gateway in the selected VPC is used. Otherwise, the system
               automatically creates a NAT gateway of the default specifications, binds an EIP to the NAT
               gateway, and configures SNAT rules.
        :param _builtins.bool enable_swr_image_access: Whether the cluster is interconnected with SWR.
               To ensure that your cluster nodes can pull images from SWR, the existing SWR and OBS
               endpoints in the selected VPC are used by default. If not, new SWR and OBS endpoints
               will be automatically created.
        :param Sequence['GetAutopilotClustersClusterEniNetworkArgs'] eni_networks: The ENI network of the cluster.
        :param Sequence['GetAutopilotClustersClusterExtendParamArgs'] extend_params: The extend param of the cluster.
        :param _builtins.str flavor: The cluster flavor.
        :param Sequence['GetAutopilotClustersClusterHostNetworkArgs'] host_networks: The host network of the cluster.
        :param _builtins.str id: The ID of the cluster.
        :param _builtins.bool ipv6_enable: Whether the cluster uses the IPv6 mode.
        :param _builtins.str kube_proxy_mode: The kube proxy mode of the cluster.
        :param _builtins.str name: The component configuration item name.
        :param _builtins.str platform_version: The cluster platform version.
        :param Sequence['GetAutopilotClustersClusterServiceNetworkArgs'] service_networks: The service network of the cluster.
        :param Sequence['GetAutopilotClustersClusterStatusArgs'] statuses: Specifies the status of the cluster.
               The value can be: **Available**, **Unavailable**, **Creating**, **Deleting**, **Upgrading**,
               **RollingBack**, **RollbackFailed** and **Error**.
        :param Mapping[str, _builtins.str] tags: The cluster tags in the format of key-value pairs.
        :param _builtins.str type: Specifies the master node architecture.
               The value can be: **VirtualMachine**.
        :param _builtins.str updated_at: The time when the cluster was updated.
        :param _builtins.str version: Specifies the version of the cluster.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "authentications", authentications)
        pulumi.set(__self__, "az", az)
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "configurations_overrides", configurations_overrides)
        pulumi.set(__self__, "container_networks", container_networks)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_sans", custom_sans)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enable_autopilot", enable_autopilot)
        pulumi.set(__self__, "enable_snat", enable_snat)
        pulumi.set(__self__, "enable_swr_image_access", enable_swr_image_access)
        pulumi.set(__self__, "eni_networks", eni_networks)
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "host_networks", host_networks)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        pulumi.set(__self__, "kube_proxy_mode", kube_proxy_mode)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "platform_version", platform_version)
        pulumi.set(__self__, "service_networks", service_networks)
        pulumi.set(__self__, "statuses", statuses)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> _builtins.str:
        """
        The alias of the cluster.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        The cluster annotations in the format of key-value pairs.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def authentications(self) -> Sequence['outputs.GetAutopilotClustersClusterAuthenticationResult']:
        """
        The configurations of the cluster authentication mode.
        """
        return pulumi.get(self, "authentications")

    @_builtins.property
    @pulumi.getter
    def az(self) -> _builtins.str:
        """
        The AZ of the cluster.
        """
        return pulumi.get(self, "az")

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        The cluster type. Only **Turbo** is supported.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="configurationsOverrides")
    def configurations_overrides(self) -> Sequence['outputs.GetAutopilotClustersClusterConfigurationsOverrideResult']:
        """
        The parameter to override the default component configurations in the cluster.
        """
        return pulumi.get(self, "configurations_overrides")

    @_builtins.property
    @pulumi.getter(name="containerNetworks")
    def container_networks(self) -> Sequence['outputs.GetAutopilotClustersClusterContainerNetworkResult']:
        """
        The container network of the cluster.
        """
        return pulumi.get(self, "container_networks")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The time when the cluster was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="customSans")
    def custom_sans(self) -> Sequence[_builtins.str]:
        """
        The custom SAN field in the API server certificate of the cluster.
        """
        return pulumi.get(self, "custom_sans")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the cluster.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enableAutopilot")
    def enable_autopilot(self) -> _builtins.bool:
        """
        Whether the cluster is an Autopilot cluster.
        """
        return pulumi.get(self, "enable_autopilot")

    @_builtins.property
    @pulumi.getter(name="enableSnat")
    def enable_snat(self) -> _builtins.bool:
        """
        Whether SNAT is configured for the cluster.
        After this function is enabled, the cluster can access the Internet through a NAT gateway.
        By default, the existing NAT gateway in the selected VPC is used. Otherwise, the system
        automatically creates a NAT gateway of the default specifications, binds an EIP to the NAT
        gateway, and configures SNAT rules.
        """
        return pulumi.get(self, "enable_snat")

    @_builtins.property
    @pulumi.getter(name="enableSwrImageAccess")
    def enable_swr_image_access(self) -> _builtins.bool:
        """
        Whether the cluster is interconnected with SWR.
        To ensure that your cluster nodes can pull images from SWR, the existing SWR and OBS
        endpoints in the selected VPC are used by default. If not, new SWR and OBS endpoints
        will be automatically created.
        """
        return pulumi.get(self, "enable_swr_image_access")

    @_builtins.property
    @pulumi.getter(name="eniNetworks")
    def eni_networks(self) -> Sequence['outputs.GetAutopilotClustersClusterEniNetworkResult']:
        """
        The ENI network of the cluster.
        """
        return pulumi.get(self, "eni_networks")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Sequence['outputs.GetAutopilotClustersClusterExtendParamResult']:
        """
        The extend param of the cluster.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        The cluster flavor.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="hostNetworks")
    def host_networks(self) -> Sequence['outputs.GetAutopilotClustersClusterHostNetworkResult']:
        """
        The host network of the cluster.
        """
        return pulumi.get(self, "host_networks")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> _builtins.bool:
        """
        Whether the cluster uses the IPv6 mode.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="kubeProxyMode")
    def kube_proxy_mode(self) -> _builtins.str:
        """
        The kube proxy mode of the cluster.
        """
        return pulumi.get(self, "kube_proxy_mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The component configuration item name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> _builtins.str:
        """
        The cluster platform version.
        """
        return pulumi.get(self, "platform_version")

    @_builtins.property
    @pulumi.getter(name="serviceNetworks")
    def service_networks(self) -> Sequence['outputs.GetAutopilotClustersClusterServiceNetworkResult']:
        """
        The service network of the cluster.
        """
        return pulumi.get(self, "service_networks")

    @_builtins.property
    @pulumi.getter
    def statuses(self) -> Sequence['outputs.GetAutopilotClustersClusterStatusResult']:
        """
        Specifies the status of the cluster.
        The value can be: **Available**, **Unavailable**, **Creating**, **Deleting**, **Upgrading**,
        **RollingBack**, **RollbackFailed** and **Error**.
        """
        return pulumi.get(self, "statuses")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The cluster tags in the format of key-value pairs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the master node architecture.
        The value can be: **VirtualMachine**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The time when the cluster was updated.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Specifies the version of the cluster.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAutopilotClustersClusterAuthenticationResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: The cluster authentication mode.
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The cluster authentication mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetAutopilotClustersClusterConfigurationsOverrideResult(dict):
    def __init__(__self__, *,
                 configurations: Sequence['outputs.GetAutopilotClustersClusterConfigurationsOverrideConfigurationResult'],
                 name: _builtins.str):
        """
        :param Sequence['GetAutopilotClustersClusterConfigurationsOverrideConfigurationArgs'] configurations: The component configuration items.
        :param _builtins.str name: The component configuration item name.
        """
        pulumi.set(__self__, "configurations", configurations)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Sequence['outputs.GetAutopilotClustersClusterConfigurationsOverrideConfigurationResult']:
        """
        The component configuration items.
        """
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The component configuration item name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutopilotClustersClusterConfigurationsOverrideConfigurationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The component configuration item name.
        :param _builtins.str value: The component configuration item value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The component configuration item name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The component configuration item value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAutopilotClustersClusterContainerNetworkResult(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        """
        :param _builtins.str mode: The cluster authentication mode.
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The cluster authentication mode.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetAutopilotClustersClusterEniNetworkResult(dict):
    def __init__(__self__, *,
                 subnets: Sequence['outputs.GetAutopilotClustersClusterEniNetworkSubnetResult']):
        """
        :param Sequence['GetAutopilotClustersClusterEniNetworkSubnetArgs'] subnets: The list of ENI subnets.
        """
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetAutopilotClustersClusterEniNetworkSubnetResult']:
        """
        The list of ENI subnets.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetAutopilotClustersClusterEniNetworkSubnetResult(dict):
    def __init__(__self__, *,
                 subnet_id: _builtins.str):
        """
        :param _builtins.str subnet_id: The IPv4 subnet ID of the subnet used to create control nodes and containers.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The IPv4 subnet ID of the subnet used to create control nodes and containers.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetAutopilotClustersClusterExtendParamResult(dict):
    def __init__(__self__, *,
                 enterprise_project_id: _builtins.str):
        """
        :param _builtins.str enterprise_project_id: The ID of the enterprise project to which the cluster belongs.
        """
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        The ID of the enterprise project to which the cluster belongs.
        """
        return pulumi.get(self, "enterprise_project_id")


@pulumi.output_type
class GetAutopilotClustersClusterHostNetworkResult(dict):
    def __init__(__self__, *,
                 subnet: _builtins.str,
                 vpc: _builtins.str):
        """
        :param _builtins.str subnet: The ID of the subnet used to create a master node.
        :param _builtins.str vpc: The ID of the VPC used to create a master node.
        """
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The ID of the subnet used to create a master node.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        """
        The ID of the VPC used to create a master node.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class GetAutopilotClustersClusterServiceNetworkResult(dict):
    def __init__(__self__, *,
                 ipv4_cidr: _builtins.str):
        """
        :param _builtins.str ipv4_cidr: The IPv4 CIDR of the service network.
        """
        pulumi.set(__self__, "ipv4_cidr", ipv4_cidr)

    @_builtins.property
    @pulumi.getter(name="ipv4Cidr")
    def ipv4_cidr(self) -> _builtins.str:
        """
        The IPv4 CIDR of the service network.
        """
        return pulumi.get(self, "ipv4_cidr")


@pulumi.output_type
class GetAutopilotClustersClusterStatusResult(dict):
    def __init__(__self__, *,
                 endpoints: Sequence['outputs.GetAutopilotClustersClusterStatusEndpointResult'],
                 phase: _builtins.str):
        """
        :param Sequence['GetAutopilotClustersClusterStatusEndpointArgs'] endpoints: The access address of kube-apiserver in the cluster.
        :param _builtins.str phase: The phase of the cluster.
        """
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "phase", phase)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAutopilotClustersClusterStatusEndpointResult']:
        """
        The access address of kube-apiserver in the cluster.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        The phase of the cluster.
        """
        return pulumi.get(self, "phase")


@pulumi.output_type
class GetAutopilotClustersClusterStatusEndpointResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str type: Specifies the master node architecture.
               The value can be: **VirtualMachine**.
        :param _builtins.str url: The URL of the endpoint.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the master node architecture.
        The value can be: **VirtualMachine**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the endpoint.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetChartsChartResult(dict):
    def __init__(__self__, *,
                 chart_url: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 icon_url: _builtins.str,
                 id: _builtins.str,
                 instruction: _builtins.str,
                 name: _builtins.str,
                 public: _builtins.bool,
                 source: _builtins.str,
                 translate: _builtins.str,
                 updated_at: _builtins.str,
                 values: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str chart_url: The chart URL.
        :param _builtins.str created_at: The create time.
        :param _builtins.str description: The description of the chart.
        :param _builtins.str icon_url: The icon URL.
        :param _builtins.str id: The chart ID.
        :param _builtins.str instruction: The instruction of the chart.
        :param _builtins.str name: The chart name.
        :param _builtins.bool public: Whether the chart is public.
        :param _builtins.str source: The source of the chart.
        :param _builtins.str translate: The traslate source of the chart.
        :param _builtins.str updated_at: The update time.
        :param _builtins.str values: The values of the chart.
        :param _builtins.str version: The chart version.
        """
        pulumi.set(__self__, "chart_url", chart_url)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "icon_url", icon_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "translate", translate)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "values", values)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="chartUrl")
    def chart_url(self) -> _builtins.str:
        """
        The chart URL.
        """
        return pulumi.get(self, "chart_url")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the chart.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="iconUrl")
    def icon_url(self) -> _builtins.str:
        """
        The icon URL.
        """
        return pulumi.get(self, "icon_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The chart ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        The instruction of the chart.
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The chart name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def public(self) -> _builtins.bool:
        """
        Whether the chart is public.
        """
        return pulumi.get(self, "public")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the chart.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def translate(self) -> _builtins.str:
        """
        The traslate source of the chart.
        """
        return pulumi.get(self, "translate")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The update time.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def values(self) -> _builtins.str:
        """
        The values of the chart.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The chart version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterCertificateClusterResult(dict):
    def __init__(__self__, *,
                 certificate_authority_data: _builtins.str,
                 name: _builtins.str,
                 server: _builtins.str):
        """
        :param _builtins.str certificate_authority_data: The certificate data.
        :param _builtins.str name: Specifies the name of the cluster.
        :param _builtins.str server: The server IP address.
        """
        pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> _builtins.str:
        """
        The certificate data.
        """
        return pulumi.get(self, "certificate_authority_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        The server IP address.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetClusterCertificateUserResult(dict):
    def __init__(__self__, *,
                 client_certificate_data: _builtins.str,
                 client_key_data: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str client_certificate_data: The client certificate data.
        :param _builtins.str client_key_data: The client key data.
        :param _builtins.str name: Specifies the name of the cluster.
        """
        pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        pulumi.set(__self__, "client_key_data", client_key_data)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> _builtins.str:
        """
        The client certificate data.
        """
        return pulumi.get(self, "client_certificate_data")

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> _builtins.str:
        """
        The client key data.
        """
        return pulumi.get(self, "client_key_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the cluster.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetClusterCertificatesClusterResult(dict):
    def __init__(__self__, *,
                 certificate_authority_data: _builtins.str,
                 insecure_skip_tls_verify: _builtins.bool,
                 name: _builtins.str,
                 server: _builtins.str):
        """
        :param _builtins.str certificate_authority_data: The certificate authority data of the cluster certificate.
        :param _builtins.bool insecure_skip_tls_verify: Whether insecure skip tls verify of the cluster certificate.
        :param _builtins.str name: The context name of the cluster certificate.
        :param _builtins.str server: The server address of the cluster certificate.
        """
        pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        pulumi.set(__self__, "insecure_skip_tls_verify", insecure_skip_tls_verify)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> _builtins.str:
        """
        The certificate authority data of the cluster certificate.
        """
        return pulumi.get(self, "certificate_authority_data")

    @_builtins.property
    @pulumi.getter(name="insecureSkipTlsVerify")
    def insecure_skip_tls_verify(self) -> _builtins.bool:
        """
        Whether insecure skip tls verify of the cluster certificate.
        """
        return pulumi.get(self, "insecure_skip_tls_verify")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The context name of the cluster certificate.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        The server address of the cluster certificate.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetClusterCertificatesContextResult(dict):
    def __init__(__self__, *,
                 cluster: _builtins.str,
                 name: _builtins.str,
                 user: _builtins.str):
        """
        :param _builtins.str cluster: The context cluster of the cluster certificate.
        :param _builtins.str name: The context name of the cluster certificate.
        :param _builtins.str user: The context user of the cluster certificate.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.str:
        """
        The context cluster of the cluster certificate.
        """
        return pulumi.get(self, "cluster")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The context name of the cluster certificate.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        The context user of the cluster certificate.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetClusterCertificatesUserResult(dict):
    def __init__(__self__, *,
                 client_certificate_data: _builtins.str,
                 client_key_data: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str client_certificate_data: The client certificate data of the cluster certificate.
        :param _builtins.str client_key_data: The client key data of the cluster certificate.
        :param _builtins.str name: The context name of the cluster certificate.
        """
        pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        pulumi.set(__self__, "client_key_data", client_key_data)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> _builtins.str:
        """
        The client certificate data of the cluster certificate.
        """
        return pulumi.get(self, "client_certificate_data")

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> _builtins.str:
        """
        The client key data of the cluster certificate.
        """
        return pulumi.get(self, "client_key_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The context name of the cluster certificate.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetClusterEndpointResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str type: The type of the cluster access address.
               + **Internal**: The user's subnet access address.
               + **External**: The public network access address.
        :param _builtins.str url: The URL of the cluster access address.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the cluster access address.
        + **Internal**: The user's subnet access address.
        + **External**: The public network access address.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the cluster access address.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClusterMasterResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str):
        """
        :param _builtins.str availability_zone: The availability zone (AZ) of the master node.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        The availability zone (AZ) of the master node.
        """
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class GetClusterOpenidJwksKeyResult(dict):
    def __init__(__self__, *,
                 alg: _builtins.str,
                 e: _builtins.str,
                 kid: _builtins.str,
                 kty: _builtins.str,
                 n: _builtins.str,
                 use: _builtins.str):
        pulumi.set(__self__, "alg", alg)
        pulumi.set(__self__, "e", e)
        pulumi.set(__self__, "kid", kid)
        pulumi.set(__self__, "kty", kty)
        pulumi.set(__self__, "n", n)
        pulumi.set(__self__, "use", use)

    @_builtins.property
    @pulumi.getter
    def alg(self) -> _builtins.str:
        return pulumi.get(self, "alg")

    @_builtins.property
    @pulumi.getter
    def e(self) -> _builtins.str:
        return pulumi.get(self, "e")

    @_builtins.property
    @pulumi.getter
    def kid(self) -> _builtins.str:
        return pulumi.get(self, "kid")

    @_builtins.property
    @pulumi.getter
    def kty(self) -> _builtins.str:
        return pulumi.get(self, "kty")

    @_builtins.property
    @pulumi.getter
    def n(self) -> _builtins.str:
        return pulumi.get(self, "n")

    @_builtins.property
    @pulumi.getter
    def use(self) -> _builtins.str:
        return pulumi.get(self, "use")


@pulumi.output_type
class GetClusterUpgradeInfoMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, _builtins.str],
                 creation_timestamp: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 uid: _builtins.str,
                 update_timestamp: _builtins.str):
        """
        :param Mapping[str, _builtins.str] annotations: Resource annotations, composed of key/value pairs.
        :param _builtins.str creation_timestamp: Creation time.
        :param Mapping[str, _builtins.str] labels: Resource tags, in key/value pair format, reserved fields for the interface.
        :param _builtins.str name: Resource name.
        :param _builtins.str uid: Unique ID identifier.
        :param _builtins.str update_timestamp: Update time.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "update_timestamp", update_timestamp)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        Resource annotations, composed of key/value pairs.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        Creation time.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Resource tags, in key/value pair format, reserved fields for the interface.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        Unique ID identifier.
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="updateTimestamp")
    def update_timestamp(self) -> _builtins.str:
        """
        Update time.
        """
        return pulumi.get(self, "update_timestamp")


@pulumi.output_type
class GetClusterUpgradeInfoSpecResult(dict):
    def __init__(__self__, *,
                 last_upgrade_infos: Sequence['outputs.GetClusterUpgradeInfoSpecLastUpgradeInfoResult'],
                 upgrade_feature_gates: Sequence['outputs.GetClusterUpgradeInfoSpecUpgradeFeatureGateResult'],
                 version_infos: Sequence['outputs.GetClusterUpgradeInfoSpecVersionInfoResult']):
        """
        :param Sequence['GetClusterUpgradeInfoSpecLastUpgradeInfoArgs'] last_upgrade_infos: Last cluster upgrade information.
        :param Sequence['GetClusterUpgradeInfoSpecUpgradeFeatureGateArgs'] upgrade_feature_gates: Cluster upgrade feature flags.
        :param Sequence['GetClusterUpgradeInfoSpecVersionInfoArgs'] version_infos: Version information.
        """
        pulumi.set(__self__, "last_upgrade_infos", last_upgrade_infos)
        pulumi.set(__self__, "upgrade_feature_gates", upgrade_feature_gates)
        pulumi.set(__self__, "version_infos", version_infos)

    @_builtins.property
    @pulumi.getter(name="lastUpgradeInfos")
    def last_upgrade_infos(self) -> Sequence['outputs.GetClusterUpgradeInfoSpecLastUpgradeInfoResult']:
        """
        Last cluster upgrade information.
        """
        return pulumi.get(self, "last_upgrade_infos")

    @_builtins.property
    @pulumi.getter(name="upgradeFeatureGates")
    def upgrade_feature_gates(self) -> Sequence['outputs.GetClusterUpgradeInfoSpecUpgradeFeatureGateResult']:
        """
        Cluster upgrade feature flags.
        """
        return pulumi.get(self, "upgrade_feature_gates")

    @_builtins.property
    @pulumi.getter(name="versionInfos")
    def version_infos(self) -> Sequence['outputs.GetClusterUpgradeInfoSpecVersionInfoResult']:
        """
        Version information.
        """
        return pulumi.get(self, "version_infos")


@pulumi.output_type
class GetClusterUpgradeInfoSpecLastUpgradeInfoResult(dict):
    def __init__(__self__, *,
                 completion_time: _builtins.str,
                 phase: _builtins.str,
                 progress: _builtins.str):
        """
        :param _builtins.str completion_time: Upgrade task end time.
        :param _builtins.str phase: Upgrade task status. The value can be: **Init**, **Running**, **Pause**, **Success** and **Failed**.
        :param _builtins.str progress: Upgrade task progress.
        """
        pulumi.set(__self__, "completion_time", completion_time)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "progress", progress)

    @_builtins.property
    @pulumi.getter(name="completionTime")
    def completion_time(self) -> _builtins.str:
        """
        Upgrade task end time.
        """
        return pulumi.get(self, "completion_time")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        Upgrade task status. The value can be: **Init**, **Running**, **Pause**, **Success** and **Failed**.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> _builtins.str:
        """
        Upgrade task progress.
        """
        return pulumi.get(self, "progress")


@pulumi.output_type
class GetClusterUpgradeInfoSpecUpgradeFeatureGateResult(dict):
    def __init__(__self__, *,
                 support_upgrade_page_v4: _builtins.bool):
        """
        :param _builtins.bool support_upgrade_page_v4: Whether the cluster upgrade console supports V4 version, generally used by CCE Console.
        """
        pulumi.set(__self__, "support_upgrade_page_v4", support_upgrade_page_v4)

    @_builtins.property
    @pulumi.getter(name="supportUpgradePageV4")
    def support_upgrade_page_v4(self) -> _builtins.bool:
        """
        Whether the cluster upgrade console supports V4 version, generally used by CCE Console.
        """
        return pulumi.get(self, "support_upgrade_page_v4")


@pulumi.output_type
class GetClusterUpgradeInfoSpecVersionInfoResult(dict):
    def __init__(__self__, *,
                 patch: _builtins.str,
                 release: _builtins.str,
                 suggest_patch: _builtins.str,
                 target_versions: Sequence[_builtins.str]):
        """
        :param _builtins.str patch: Patch version number, e.g. **r0**.
        :param _builtins.str release: Formal version number, e.g. **v1.19.10**.
        :param _builtins.str suggest_patch: Recommended target patch version for upgrade, e.g. **r0**.
        :param Sequence[_builtins.str] target_versions: Target versions for upgrade.
        """
        pulumi.set(__self__, "patch", patch)
        pulumi.set(__self__, "release", release)
        pulumi.set(__self__, "suggest_patch", suggest_patch)
        pulumi.set(__self__, "target_versions", target_versions)

    @_builtins.property
    @pulumi.getter
    def patch(self) -> _builtins.str:
        """
        Patch version number, e.g. **r0**.
        """
        return pulumi.get(self, "patch")

    @_builtins.property
    @pulumi.getter
    def release(self) -> _builtins.str:
        """
        Formal version number, e.g. **v1.19.10**.
        """
        return pulumi.get(self, "release")

    @_builtins.property
    @pulumi.getter(name="suggestPatch")
    def suggest_patch(self) -> _builtins.str:
        """
        Recommended target patch version for upgrade, e.g. **r0**.
        """
        return pulumi.get(self, "suggest_patch")

    @_builtins.property
    @pulumi.getter(name="targetVersions")
    def target_versions(self) -> Sequence[_builtins.str]:
        """
        Target versions for upgrade.
        """
        return pulumi.get(self, "target_versions")


@pulumi.output_type
class GetClusterUpgradeInfoStatusResult(dict):
    def __init__(__self__, *,
                 completion_time: _builtins.str,
                 phase: _builtins.str,
                 progress: _builtins.str):
        """
        :param _builtins.str completion_time: Upgrade task end time.
        :param _builtins.str phase: Upgrade task status. The value can be: **Init**, **Running**, **Pause**, **Success** and **Failed**.
        :param _builtins.str progress: Upgrade task progress.
        """
        pulumi.set(__self__, "completion_time", completion_time)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "progress", progress)

    @_builtins.property
    @pulumi.getter(name="completionTime")
    def completion_time(self) -> _builtins.str:
        """
        Upgrade task end time.
        """
        return pulumi.get(self, "completion_time")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        Upgrade task status. The value can be: **Init**, **Running**, **Pause**, **Success** and **Failed**.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> _builtins.str:
        """
        Upgrade task progress.
        """
        return pulumi.get(self, "progress")


@pulumi.output_type
class GetClusterV3CertificateClusterResult(dict):
    def __init__(__self__, *,
                 certificate_authority_data: _builtins.str,
                 name: _builtins.str,
                 server: _builtins.str):
        pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> _builtins.str:
        return pulumi.get(self, "certificate_authority_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        return pulumi.get(self, "server")


@pulumi.output_type
class GetClusterV3CertificateUserResult(dict):
    def __init__(__self__, *,
                 client_certificate_data: _builtins.str,
                 client_key_data: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        pulumi.set(__self__, "client_key_data", client_key_data)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> _builtins.str:
        return pulumi.get(self, "client_certificate_data")

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> _builtins.str:
        return pulumi.get(self, "client_key_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetClusterV3EndpointResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 url: _builtins.str):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClusterV3MasterResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str):
        pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class GetClustersClusterResult(dict):
    def __init__(__self__, *,
                 authentication_mode: _builtins.str,
                 billing_mode: _builtins.int,
                 certificate_clusters: Sequence['outputs.GetClustersClusterCertificateClusterResult'],
                 certificate_users: Sequence['outputs.GetClustersClusterCertificateUserResult'],
                 cluster_type: _builtins.str,
                 cluster_version: _builtins.str,
                 container_network_cidr: _builtins.str,
                 container_network_type: _builtins.str,
                 description: _builtins.str,
                 endpoints: Sequence['outputs.GetClustersClusterEndpointResult'],
                 eni_subnet_cidr: _builtins.str,
                 eni_subnet_id: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 flavor_id: _builtins.str,
                 id: _builtins.str,
                 kube_config_raw: _builtins.str,
                 masters: Sequence['outputs.GetClustersClusterMasterResult'],
                 name: _builtins.str,
                 security_group_id: _builtins.str,
                 service_network_cidr: _builtins.str,
                 status: _builtins.str,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str authentication_mode: The authentication mode of the cluster, possible values are x509 and rbac. Defaults to **rbac**.
        :param _builtins.int billing_mode: The charging mode of the cluster.
        :param Sequence['GetClustersClusterCertificateClusterArgs'] certificate_clusters: The certificate clusters. Structure is documented below.
        :param Sequence['GetClustersClusterCertificateUserArgs'] certificate_users: The certificate users. Structure is documented below.
        :param _builtins.str cluster_type: Specifies the type of the cluster. Possible values: **VirtualMachine**, **BareMetal**.
        :param _builtins.str cluster_version: The version of the cluster.
        :param _builtins.str container_network_cidr: The container network segment.
        :param _builtins.str container_network_type: The container network type: **overlay_l2** , **underlay_ipvlan**, **vpc-router** or **eni**.
        :param _builtins.str description: The description of the cluster.
        :param Sequence['GetClustersClusterEndpointArgs'] endpoints: The access addresses of kube-apiserver in the cluster. Structure is documented below.
        :param _builtins.str eni_subnet_cidr: The ENI network segment.
        :param _builtins.str eni_subnet_id: The **IPv4 subnet ID** of the subnet where the ENI resides.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID of the cluster.
        :param _builtins.str flavor_id: The specification of the cluster.
        :param _builtins.str id: The ID of the cluster.
        :param _builtins.str kube_config_raw: The raw Kubernetes config to be used by kubectl and other compatible tools.
        :param Sequence['GetClustersClusterMasterArgs'] masters: The advanced configuration of master nodes. Structure is documented below.
        :param _builtins.str name: Specifies the name of the cluster.
        :param _builtins.str security_group_id: The security group ID of the cluster.
        :param _builtins.str service_network_cidr: The service network segment.
        :param _builtins.str status: Specifies the status of the cluster.
        :param _builtins.str subnet_id: The ID of the subnet used to create the node.
        :param _builtins.str vpc_id: Specifies the VPC ID to which the cluster belongs.
        """
        pulumi.set(__self__, "authentication_mode", authentication_mode)
        pulumi.set(__self__, "billing_mode", billing_mode)
        pulumi.set(__self__, "certificate_clusters", certificate_clusters)
        pulumi.set(__self__, "certificate_users", certificate_users)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "container_network_cidr", container_network_cidr)
        pulumi.set(__self__, "container_network_type", container_network_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "eni_subnet_cidr", eni_subnet_cidr)
        pulumi.set(__self__, "eni_subnet_id", eni_subnet_id)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "flavor_id", flavor_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "kube_config_raw", kube_config_raw)
        pulumi.set(__self__, "masters", masters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "service_network_cidr", service_network_cidr)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="authenticationMode")
    def authentication_mode(self) -> _builtins.str:
        """
        The authentication mode of the cluster, possible values are x509 and rbac. Defaults to **rbac**.
        """
        return pulumi.get(self, "authentication_mode")

    @_builtins.property
    @pulumi.getter(name="billingMode")
    def billing_mode(self) -> _builtins.int:
        """
        The charging mode of the cluster.
        """
        return pulumi.get(self, "billing_mode")

    @_builtins.property
    @pulumi.getter(name="certificateClusters")
    def certificate_clusters(self) -> Sequence['outputs.GetClustersClusterCertificateClusterResult']:
        """
        The certificate clusters. Structure is documented below.
        """
        return pulumi.get(self, "certificate_clusters")

    @_builtins.property
    @pulumi.getter(name="certificateUsers")
    def certificate_users(self) -> Sequence['outputs.GetClustersClusterCertificateUserResult']:
        """
        The certificate users. Structure is documented below.
        """
        return pulumi.get(self, "certificate_users")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        Specifies the type of the cluster. Possible values: **VirtualMachine**, **BareMetal**.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> _builtins.str:
        """
        The version of the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @_builtins.property
    @pulumi.getter(name="containerNetworkCidr")
    def container_network_cidr(self) -> _builtins.str:
        """
        The container network segment.
        """
        return pulumi.get(self, "container_network_cidr")

    @_builtins.property
    @pulumi.getter(name="containerNetworkType")
    def container_network_type(self) -> _builtins.str:
        """
        The container network type: **overlay_l2** , **underlay_ipvlan**, **vpc-router** or **eni**.
        """
        return pulumi.get(self, "container_network_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the cluster.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClustersClusterEndpointResult']:
        """
        The access addresses of kube-apiserver in the cluster. Structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter(name="eniSubnetCidr")
    def eni_subnet_cidr(self) -> _builtins.str:
        """
        The ENI network segment.
        """
        return pulumi.get(self, "eni_subnet_cidr")

    @_builtins.property
    @pulumi.getter(name="eniSubnetId")
    def eni_subnet_id(self) -> _builtins.str:
        """
        The **IPv4 subnet ID** of the subnet where the ENI resides.
        """
        return pulumi.get(self, "eni_subnet_id")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID of the cluster.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> _builtins.str:
        """
        The specification of the cluster.
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kubeConfigRaw")
    def kube_config_raw(self) -> _builtins.str:
        """
        The raw Kubernetes config to be used by kubectl and other compatible tools.
        """
        return pulumi.get(self, "kube_config_raw")

    @_builtins.property
    @pulumi.getter
    def masters(self) -> Sequence['outputs.GetClustersClusterMasterResult']:
        """
        The advanced configuration of master nodes. Structure is documented below.
        """
        return pulumi.get(self, "masters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        The security group ID of the cluster.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="serviceNetworkCidr")
    def service_network_cidr(self) -> _builtins.str:
        """
        The service network segment.
        """
        return pulumi.get(self, "service_network_cidr")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the cluster.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet used to create the node.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Specifies the VPC ID to which the cluster belongs.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetClustersClusterCertificateClusterResult(dict):
    def __init__(__self__, *,
                 certificate_authority_data: _builtins.str,
                 name: _builtins.str,
                 server: _builtins.str):
        """
        :param _builtins.str certificate_authority_data: The certificate data.
        :param _builtins.str name: Specifies the name of the cluster.
        :param _builtins.str server: The server IP address.
        """
        pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> _builtins.str:
        """
        The certificate data.
        """
        return pulumi.get(self, "certificate_authority_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        The server IP address.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetClustersClusterCertificateUserResult(dict):
    def __init__(__self__, *,
                 client_certificate_data: _builtins.str,
                 client_key_data: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str client_certificate_data: The client certificate data.
        :param _builtins.str client_key_data: The client key data.
        :param _builtins.str name: Specifies the name of the cluster.
        """
        pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        pulumi.set(__self__, "client_key_data", client_key_data)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> _builtins.str:
        """
        The client certificate data.
        """
        return pulumi.get(self, "client_certificate_data")

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> _builtins.str:
        """
        The client key data.
        """
        return pulumi.get(self, "client_key_data")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the cluster.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetClustersClusterEndpointResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str type: The type of the cluster access address.
               + **Internal**: The user's subnet access address.
               + **External**: The public network access address.
        :param _builtins.str url: The URL of the cluster access address.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the cluster access address.
        + **Internal**: The user's subnet access address.
        + **External**: The public network access address.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the cluster access address.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClustersClusterMasterResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str):
        """
        :param _builtins.str availability_zone: The availability zone (AZ) of the master node.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        The availability zone (AZ) of the master node.
        """
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class GetNodeDataVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        """
        :param Mapping[str, _builtins.str] extend_params: Disk expansion parameters.
        :param _builtins.int size: Disk size in GB.
        :param _builtins.str volumetype: Disk type.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        """
        Disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Disk type.
        """
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class GetNodeHostnameConfigResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The hostname type of the kubernetes node.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The hostname type of the kubernetes node.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNodePoolDataVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        """
        :param Mapping[str, _builtins.str] extend_params: Disk expansion parameters.
        :param _builtins.int size: Disk size in GB.
        :param _builtins.str volumetype: Disk type.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        """
        Disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Disk type.
        """
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class GetNodePoolHostnameConfigResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The hostname type of the kubernetes node.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The hostname type of the kubernetes node.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNodePoolRootVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        """
        :param Mapping[str, _builtins.str] extend_params: Disk expansion parameters.
        :param _builtins.int size: Disk size in GB.
        :param _builtins.str volumetype: Disk type.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        """
        Disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Disk type.
        """
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class GetNodeRootVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        """
        :param Mapping[str, _builtins.str] extend_params: Disk expansion parameters.
        :param _builtins.int size: Disk size in GB.
        :param _builtins.str volumetype: Disk type.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        """
        Disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Disk type.
        """
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class GetNodeV3DataVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class GetNodeV3HostnameConfigResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNodeV3RootVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class GetNodesNodeResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 billing_mode: _builtins.int,
                 data_volumes: Sequence['outputs.GetNodesNodeDataVolumeResult'],
                 ecs_group_id: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 flavor_id: _builtins.str,
                 hostname_configs: Sequence['outputs.GetNodesNodeHostnameConfigResult'],
                 id: _builtins.str,
                 key_pair: _builtins.str,
                 name: _builtins.str,
                 os: _builtins.str,
                 private_ip: _builtins.str,
                 public_ip: _builtins.str,
                 root_volumes: Sequence['outputs.GetNodesNodeRootVolumeResult'],
                 server_id: _builtins.str,
                 status: _builtins.str,
                 subnet_id: _builtins.str,
                 tags: Mapping[str, _builtins.str]):
        """
        :param _builtins.str availability_zone: The available partitions where the node is located.
        :param _builtins.int billing_mode: The node's billing mode: The value is 0 (on demand).
        :param Sequence['GetNodesNodeDataVolumeArgs'] data_volumes: The data related configuration. Structure is documented below.
        :param _builtins.str ecs_group_id: The ID of ECS group to which the node belongs.
        :param _builtins.str enterprise_project_id: The enterprise project ID of the node.
        :param _builtins.str flavor_id: The flavor ID to be used.
        :param Sequence['GetNodesNodeHostnameConfigArgs'] hostname_configs: The hostname config of the kubernetes node.
               The object structure is documented below.
        :param _builtins.str id: The ID of the node.
        :param _builtins.str key_pair: The key pair name when logging in to select the key pair mode.
        :param _builtins.str name: Specifies the of the node.
        :param _builtins.str os: The operating System of the node.
        :param _builtins.str private_ip: The private IP of the node.
        :param _builtins.str public_ip: The elastic IP parameters of the node.
        :param Sequence['GetNodesNodeRootVolumeArgs'] root_volumes: The system disk related configuration. Structure is documented below.
        :param _builtins.str server_id: The node's virtual machine ID in ECS.
        :param _builtins.str status: Specifies the status of the node.
        :param _builtins.str subnet_id: The ID of the subnet to which the NIC belongs.
        :param Mapping[str, _builtins.str] tags: The tags of a VM node, key/value pair format.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "billing_mode", billing_mode)
        pulumi.set(__self__, "data_volumes", data_volumes)
        pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "flavor_id", flavor_id)
        pulumi.set(__self__, "hostname_configs", hostname_configs)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key_pair", key_pair)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "root_volumes", root_volumes)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        The available partitions where the node is located.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="billingMode")
    def billing_mode(self) -> _builtins.int:
        """
        The node's billing mode: The value is 0 (on demand).
        """
        return pulumi.get(self, "billing_mode")

    @_builtins.property
    @pulumi.getter(name="dataVolumes")
    def data_volumes(self) -> Sequence['outputs.GetNodesNodeDataVolumeResult']:
        """
        The data related configuration. Structure is documented below.
        """
        return pulumi.get(self, "data_volumes")

    @_builtins.property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> _builtins.str:
        """
        The ID of ECS group to which the node belongs.
        """
        return pulumi.get(self, "ecs_group_id")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        The enterprise project ID of the node.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> _builtins.str:
        """
        The flavor ID to be used.
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter(name="hostnameConfigs")
    def hostname_configs(self) -> Sequence['outputs.GetNodesNodeHostnameConfigResult']:
        """
        The hostname config of the kubernetes node.
        The object structure is documented below.
        """
        return pulumi.get(self, "hostname_configs")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the node.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> _builtins.str:
        """
        The key pair name when logging in to select the key pair mode.
        """
        return pulumi.get(self, "key_pair")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the of the node.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def os(self) -> _builtins.str:
        """
        The operating System of the node.
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> _builtins.str:
        """
        The private IP of the node.
        """
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        """
        The elastic IP parameters of the node.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter(name="rootVolumes")
    def root_volumes(self) -> Sequence['outputs.GetNodesNodeRootVolumeResult']:
        """
        The system disk related configuration. Structure is documented below.
        """
        return pulumi.get(self, "root_volumes")

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> _builtins.str:
        """
        The node's virtual machine ID in ECS.
        """
        return pulumi.get(self, "server_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the node.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet to which the NIC belongs.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The tags of a VM node, key/value pair format.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetNodesNodeDataVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        """
        :param Mapping[str, _builtins.str] extend_params: Disk expansion parameters.
        :param _builtins.int size: Disk size in GB.
        :param _builtins.str volumetype: Disk type.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        """
        Disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Disk type.
        """
        return pulumi.get(self, "volumetype")


@pulumi.output_type
class GetNodesNodeHostnameConfigResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The hostname type of the kubernetes node.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The hostname type of the kubernetes node.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNodesNodeRootVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: Mapping[str, _builtins.str],
                 size: _builtins.int,
                 volumetype: _builtins.str):
        """
        :param Mapping[str, _builtins.str] extend_params: Disk expansion parameters.
        :param _builtins.int size: Disk size in GB.
        :param _builtins.str volumetype: Disk type.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Mapping[str, _builtins.str]:
        """
        Disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Disk size in GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> _builtins.str:
        """
        Disk type.
        """
        return pulumi.get(self, "volumetype")


