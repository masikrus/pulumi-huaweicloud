# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AddonValuesArgs',
    'AddonValuesArgsDict',
    'AutopilotClusterAuthenticationArgs',
    'AutopilotClusterAuthenticationArgsDict',
    'AutopilotClusterConfigurationsOverrideArgs',
    'AutopilotClusterConfigurationsOverrideArgsDict',
    'AutopilotClusterConfigurationsOverrideConfigurationArgs',
    'AutopilotClusterConfigurationsOverrideConfigurationArgsDict',
    'AutopilotClusterContainerNetworkArgs',
    'AutopilotClusterContainerNetworkArgsDict',
    'AutopilotClusterEniNetworkArgs',
    'AutopilotClusterEniNetworkArgsDict',
    'AutopilotClusterEniNetworkSubnetArgs',
    'AutopilotClusterEniNetworkSubnetArgsDict',
    'AutopilotClusterExtendParamArgs',
    'AutopilotClusterExtendParamArgsDict',
    'AutopilotClusterHostNetworkArgs',
    'AutopilotClusterHostNetworkArgsDict',
    'AutopilotClusterServiceNetworkArgs',
    'AutopilotClusterServiceNetworkArgsDict',
    'AutopilotClusterStatusArgs',
    'AutopilotClusterStatusArgsDict',
    'AutopilotClusterStatusEndpointArgs',
    'AutopilotClusterStatusEndpointArgsDict',
    'ClusterCertificateClusterArgs',
    'ClusterCertificateClusterArgsDict',
    'ClusterCertificateUserArgs',
    'ClusterCertificateUserArgsDict',
    'ClusterComponentConfigurationArgs',
    'ClusterComponentConfigurationArgsDict',
    'ClusterEncryptionConfigArgs',
    'ClusterEncryptionConfigArgsDict',
    'ClusterExtendParamArgs',
    'ClusterExtendParamArgsDict',
    'ClusterLogConfigLogConfigArgs',
    'ClusterLogConfigLogConfigArgsDict',
    'ClusterMasterArgs',
    'ClusterMasterArgsDict',
    'ClusterUpgradeAddonArgs',
    'ClusterUpgradeAddonArgsDict',
    'ClusterUpgradeAddonValuesArgs',
    'ClusterUpgradeAddonValuesArgsDict',
    'ClusterUpgradeStrategyArgs',
    'ClusterUpgradeStrategyArgsDict',
    'ClusterUpgradeStrategyInPlaceRollingUpdateArgs',
    'ClusterUpgradeStrategyInPlaceRollingUpdateArgsDict',
    'ClusterV3CertificateClusterArgs',
    'ClusterV3CertificateClusterArgsDict',
    'ClusterV3CertificateUserArgs',
    'ClusterV3CertificateUserArgsDict',
    'ClusterV3ComponentConfigurationArgs',
    'ClusterV3ComponentConfigurationArgsDict',
    'ClusterV3EncryptionConfigArgs',
    'ClusterV3EncryptionConfigArgsDict',
    'ClusterV3ExtendParamArgs',
    'ClusterV3ExtendParamArgsDict',
    'ClusterV3MasterArgs',
    'ClusterV3MasterArgsDict',
    'NodeAttachDataVolumeArgs',
    'NodeAttachDataVolumeArgsDict',
    'NodeAttachExtensionNicArgs',
    'NodeAttachExtensionNicArgsDict',
    'NodeAttachHostnameConfigArgs',
    'NodeAttachHostnameConfigArgsDict',
    'NodeAttachRootVolumeArgs',
    'NodeAttachRootVolumeArgsDict',
    'NodeAttachStorageArgs',
    'NodeAttachStorageArgsDict',
    'NodeAttachStorageGroupArgs',
    'NodeAttachStorageGroupArgsDict',
    'NodeAttachStorageGroupVirtualSpaceArgs',
    'NodeAttachStorageGroupVirtualSpaceArgsDict',
    'NodeAttachStorageSelectorArgs',
    'NodeAttachStorageSelectorArgsDict',
    'NodeAttachTaintArgs',
    'NodeAttachTaintArgsDict',
    'NodeDataVolumeArgs',
    'NodeDataVolumeArgsDict',
    'NodeExtendParamsArgs',
    'NodeExtendParamsArgsDict',
    'NodeExtensionNicArgs',
    'NodeExtensionNicArgsDict',
    'NodeHostnameConfigArgs',
    'NodeHostnameConfigArgsDict',
    'NodePoolDataVolumeArgs',
    'NodePoolDataVolumeArgsDict',
    'NodePoolExtendParamsArgs',
    'NodePoolExtendParamsArgsDict',
    'NodePoolExtensionScaleGroupArgs',
    'NodePoolExtensionScaleGroupArgsDict',
    'NodePoolExtensionScaleGroupMetadataArgs',
    'NodePoolExtensionScaleGroupMetadataArgsDict',
    'NodePoolExtensionScaleGroupSpecArgs',
    'NodePoolExtensionScaleGroupSpecArgsDict',
    'NodePoolExtensionScaleGroupSpecAutoscalingArgs',
    'NodePoolExtensionScaleGroupSpecAutoscalingArgsDict',
    'NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs',
    'NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict',
    'NodePoolHostnameConfigArgs',
    'NodePoolHostnameConfigArgsDict',
    'NodePoolNodesAddNodeListArgs',
    'NodePoolNodesAddNodeListArgsDict',
    'NodePoolRootVolumeArgs',
    'NodePoolRootVolumeArgsDict',
    'NodePoolStorageArgs',
    'NodePoolStorageArgsDict',
    'NodePoolStorageGroupArgs',
    'NodePoolStorageGroupArgsDict',
    'NodePoolStorageGroupVirtualSpaceArgs',
    'NodePoolStorageGroupVirtualSpaceArgsDict',
    'NodePoolStorageSelectorArgs',
    'NodePoolStorageSelectorArgsDict',
    'NodePoolTaintArgs',
    'NodePoolTaintArgsDict',
    'NodeRootVolumeArgs',
    'NodeRootVolumeArgsDict',
    'NodeStorageArgs',
    'NodeStorageArgsDict',
    'NodeStorageGroupArgs',
    'NodeStorageGroupArgsDict',
    'NodeStorageGroupVirtualSpaceArgs',
    'NodeStorageGroupVirtualSpaceArgsDict',
    'NodeStorageSelectorArgs',
    'NodeStorageSelectorArgsDict',
    'NodeTaintArgs',
    'NodeTaintArgsDict',
    'NodeV3DataVolumeArgs',
    'NodeV3DataVolumeArgsDict',
    'NodeV3ExtendParamsArgs',
    'NodeV3ExtendParamsArgsDict',
    'NodeV3ExtensionNicArgs',
    'NodeV3ExtensionNicArgsDict',
    'NodeV3HostnameConfigArgs',
    'NodeV3HostnameConfigArgsDict',
    'NodeV3RootVolumeArgs',
    'NodeV3RootVolumeArgsDict',
    'NodeV3StorageArgs',
    'NodeV3StorageArgsDict',
    'NodeV3StorageGroupArgs',
    'NodeV3StorageGroupArgsDict',
    'NodeV3StorageGroupVirtualSpaceArgs',
    'NodeV3StorageGroupVirtualSpaceArgsDict',
    'NodeV3StorageSelectorArgs',
    'NodeV3StorageSelectorArgsDict',
    'NodeV3TaintArgs',
    'NodeV3TaintArgsDict',
    'NodesRemoveNodeArgs',
    'NodesRemoveNodeArgsDict',
]

MYPY = False

if not MYPY:
    class AddonValuesArgsDict(TypedDict):
        basic: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `basic_json`, but it is not recommended.
        """
        basic_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the json string vary depending on the add-on.
        """
        custom: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `custom_json`, but it is not recommended.
        """
        custom_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the json string vary depending on the add-on.
        """
        flavor: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `flavor_json`, but it is not recommended.
        """
        flavor_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the json string vary depending on the add-on.
        """
elif False:
    AddonValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonValuesArgs:
    def __init__(__self__, *,
                 basic: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 basic_json: Optional[pulumi.Input[_builtins.str]] = None,
                 custom: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 custom_json: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 flavor_json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] basic: Specifies the key/value pairs vary depending on the add-on.
               Only supports non-nested structure and only supports string type elements.
               This is an alternative to `basic_json`, but it is not recommended.
        :param pulumi.Input[_builtins.str] basic_json: Specifies the json string vary depending on the add-on.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom: Specifies the key/value pairs vary depending on the add-on.
               Only supports non-nested structure and only supports string type elements.
               This is an alternative to `custom_json`, but it is not recommended.
        :param pulumi.Input[_builtins.str] custom_json: Specifies the json string vary depending on the add-on.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] flavor: Specifies the key/value pairs vary depending on the add-on.
               Only supports non-nested structure and only supports string type elements.
               This is an alternative to `flavor_json`, but it is not recommended.
        :param pulumi.Input[_builtins.str] flavor_json: Specifies the json string vary depending on the add-on.
        """
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if basic_json is not None:
            pulumi.set(__self__, "basic_json", basic_json)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if custom_json is not None:
            pulumi.set(__self__, "custom_json", custom_json)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_json is not None:
            pulumi.set(__self__, "flavor_json", flavor_json)

    @_builtins.property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `basic_json`, but it is not recommended.
        """
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "basic", value)

    @_builtins.property
    @pulumi.getter(name="basicJson")
    def basic_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "basic_json")

    @basic_json.setter
    def basic_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_json", value)

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `custom_json`, but it is not recommended.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom", value)

    @_builtins.property
    @pulumi.getter(name="customJson")
    def custom_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "custom_json")

    @custom_json.setter
    def custom_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_json", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the key/value pairs vary depending on the add-on.
        Only supports non-nested structure and only supports string type elements.
        This is an alternative to `flavor_json`, but it is not recommended.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="flavorJson")
    def flavor_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "flavor_json")

    @flavor_json.setter
    def flavor_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor_json", value)


if not MYPY:
    class AutopilotClusterAuthenticationArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cluster authentication mode.
        The default value is **rbac**.

        <a name="autopilot_cluster_extend_param"></a>
        The `extend_param` block supports:
        """
elif False:
    AutopilotClusterAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterAuthenticationArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: Specifies the cluster authentication mode.
               The default value is **rbac**.
               
               <a name="autopilot_cluster_extend_param"></a>
               The `extend_param` block supports:
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cluster authentication mode.
        The default value is **rbac**.

        <a name="autopilot_cluster_extend_param"></a>
        The `extend_param` block supports:
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class AutopilotClusterConfigurationsOverrideArgsDict(TypedDict):
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterConfigurationsOverrideConfigurationArgsDict']]]]
        """
        Specifies the component configuration items.
        The configurations structure is documented below.

        <a name="autopilot_cluster_configurations_override_configurations"></a>
        The `configurations` block supports:
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the component configuration item name.
        """
elif False:
    AutopilotClusterConfigurationsOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterConfigurationsOverrideArgs:
    def __init__(__self__, *,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterConfigurationsOverrideConfigurationArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutopilotClusterConfigurationsOverrideConfigurationArgs']]] configurations: Specifies the component configuration items.
               The configurations structure is documented below.
               
               <a name="autopilot_cluster_configurations_override_configurations"></a>
               The `configurations` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the component configuration item name.
        """
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterConfigurationsOverrideConfigurationArgs']]]]:
        """
        Specifies the component configuration items.
        The configurations structure is documented below.

        <a name="autopilot_cluster_configurations_override_configurations"></a>
        The `configurations` block supports:
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterConfigurationsOverrideConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the component configuration item name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AutopilotClusterConfigurationsOverrideConfigurationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the component configuration item name.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the component configuration item value.
        """
elif False:
    AutopilotClusterConfigurationsOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterConfigurationsOverrideConfigurationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the component configuration item name.
        :param pulumi.Input[_builtins.str] value: Specifies the component configuration item value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the component configuration item name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the component configuration item value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AutopilotClusterContainerNetworkArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        Specifies the cluster authentication mode.
        The default value is **rbac**.

        <a name="autopilot_cluster_extend_param"></a>
        The `extend_param` block supports:
        """
elif False:
    AutopilotClusterContainerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterContainerNetworkArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mode: Specifies the cluster authentication mode.
               The default value is **rbac**.
               
               <a name="autopilot_cluster_extend_param"></a>
               The `extend_param` block supports:
        """
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the cluster authentication mode.
        The default value is **rbac**.

        <a name="autopilot_cluster_extend_param"></a>
        The `extend_param` block supports:
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class AutopilotClusterEniNetworkArgsDict(TypedDict):
        subnets: pulumi.Input[Sequence[pulumi.Input['AutopilotClusterEniNetworkSubnetArgsDict']]]
        """
        Specifies the list of ENI subnets.
        The subnets structure is documented below.

        <a name="autopilot_cluster_eni_network_subnets"></a>
        The `subnets` block supports:
        """
elif False:
    AutopilotClusterEniNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterEniNetworkArgs:
    def __init__(__self__, *,
                 subnets: pulumi.Input[Sequence[pulumi.Input['AutopilotClusterEniNetworkSubnetArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutopilotClusterEniNetworkSubnetArgs']]] subnets: Specifies the list of ENI subnets.
               The subnets structure is documented below.
               
               <a name="autopilot_cluster_eni_network_subnets"></a>
               The `subnets` block supports:
        """
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input['AutopilotClusterEniNetworkSubnetArgs']]]:
        """
        Specifies the list of ENI subnets.
        The subnets structure is documented below.

        <a name="autopilot_cluster_eni_network_subnets"></a>
        The `subnets` block supports:
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input['AutopilotClusterEniNetworkSubnetArgs']]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class AutopilotClusterEniNetworkSubnetArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        Specifies the IPv4 subnet ID of the subnet used to create control
        nodes and containers.

        <a name="autopilot_cluster_service_network"></a>
        The `service_network` block supports:
        """
elif False:
    AutopilotClusterEniNetworkSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterEniNetworkSubnetArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Specifies the IPv4 subnet ID of the subnet used to create control
               nodes and containers.
               
               <a name="autopilot_cluster_service_network"></a>
               The `service_network` block supports:
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IPv4 subnet ID of the subnet used to create control
        nodes and containers.

        <a name="autopilot_cluster_service_network"></a>
        The `service_network` block supports:
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class AutopilotClusterExtendParamArgsDict(TypedDict):
        enterprise_project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the enterprise project to which the
        cluster belongs.

        <a name="autopilot_cluster_configurations_override"></a>
        The `configurations_override` block supports:
        """
elif False:
    AutopilotClusterExtendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterExtendParamArgs:
    def __init__(__self__, *,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the ID of the enterprise project to which the
               cluster belongs.
               
               <a name="autopilot_cluster_configurations_override"></a>
               The `configurations_override` block supports:
        """
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the enterprise project to which the
        cluster belongs.

        <a name="autopilot_cluster_configurations_override"></a>
        The `configurations_override` block supports:
        """
        return pulumi.get(self, "enterprise_project_id")

    @enterprise_project_id.setter
    def enterprise_project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enterprise_project_id", value)


if not MYPY:
    class AutopilotClusterHostNetworkArgsDict(TypedDict):
        subnet: pulumi.Input[_builtins.str]
        """
        Specifies ID of the subnet used to create a master node.

        <a name="autopilot_cluster_container_network"></a>
        The `container_network` block supports:
        """
        vpc: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the VPC used to create a master node.
        """
elif False:
    AutopilotClusterHostNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterHostNetworkArgs:
    def __init__(__self__, *,
                 subnet: pulumi.Input[_builtins.str],
                 vpc: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] subnet: Specifies ID of the subnet used to create a master node.
               
               <a name="autopilot_cluster_container_network"></a>
               The `container_network` block supports:
        :param pulumi.Input[_builtins.str] vpc: Specifies the ID of the VPC used to create a master node.
        """
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies ID of the subnet used to create a master node.

        <a name="autopilot_cluster_container_network"></a>
        The `container_network` block supports:
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet", value)

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the VPC used to create a master node.
        """
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc", value)


if not MYPY:
    class AutopilotClusterServiceNetworkArgsDict(TypedDict):
        ipv4_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IPv4 CIDR of the service network.
        If not specified, the default value 10.247.0.0/16 will be used.

        <a name="autopilot_cluster_authentication"></a>
        The `authentication` block supports:
        """
elif False:
    AutopilotClusterServiceNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterServiceNetworkArgs:
    def __init__(__self__, *,
                 ipv4_cidr: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4_cidr: Specifies the IPv4 CIDR of the service network.
               If not specified, the default value 10.247.0.0/16 will be used.
               
               <a name="autopilot_cluster_authentication"></a>
               The `authentication` block supports:
        """
        if ipv4_cidr is not None:
            pulumi.set(__self__, "ipv4_cidr", ipv4_cidr)

    @_builtins.property
    @pulumi.getter(name="ipv4Cidr")
    def ipv4_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IPv4 CIDR of the service network.
        If not specified, the default value 10.247.0.0/16 will be used.

        <a name="autopilot_cluster_authentication"></a>
        The `authentication` block supports:
        """
        return pulumi.get(self, "ipv4_cidr")

    @ipv4_cidr.setter
    def ipv4_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4_cidr", value)


if not MYPY:
    class AutopilotClusterStatusArgsDict(TypedDict):
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterStatusEndpointArgsDict']]]]
        """
        The access address of kube-apiserver in the cluster.
        The endpoints structure is documented below.
        """
        phase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The phase of the cluster.
        """
elif False:
    AutopilotClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterStatusArgs:
    def __init__(__self__, *,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterStatusEndpointArgs']]]] = None,
                 phase: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutopilotClusterStatusEndpointArgs']]] endpoints: The access address of kube-apiserver in the cluster.
               The endpoints structure is documented below.
        :param pulumi.Input[_builtins.str] phase: The phase of the cluster.
        """
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterStatusEndpointArgs']]]]:
        """
        The access address of kube-apiserver in the cluster.
        The endpoints structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutopilotClusterStatusEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The phase of the cluster.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase", value)


if not MYPY:
    class AutopilotClusterStatusEndpointArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the master node architecture. The value can be:
        + **VirtualMachine**: Indicates the master node is an x86 server.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The phase of the cluster.
        """
elif False:
    AutopilotClusterStatusEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutopilotClusterStatusEndpointArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the master node architecture. The value can be:
               + **VirtualMachine**: Indicates the master node is an x86 server.
        :param pulumi.Input[_builtins.str] url: The phase of the cluster.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the master node architecture. The value can be:
        + **VirtualMachine**: Indicates the master node is an x86 server.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The phase of the cluster.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClusterCertificateClusterArgsDict(TypedDict):
        certificate_authority_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate data.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the component name.
        """
        server: NotRequired[pulumi.Input[_builtins.str]]
        """
        The server IP address.
        """
elif False:
    ClusterCertificateClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCertificateClusterArgs:
    def __init__(__self__, *,
                 certificate_authority_data: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 server: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_authority_data: The certificate data.
        :param pulumi.Input[_builtins.str] name: Specifies the component name.
        :param pulumi.Input[_builtins.str] server: The server IP address.
        """
        if certificate_authority_data is not None:
            pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate data.
        """
        return pulumi.get(self, "certificate_authority_data")

    @certificate_authority_data.setter
    def certificate_authority_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority_data", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the component name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The server IP address.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server", value)


if not MYPY:
    class ClusterCertificateUserArgsDict(TypedDict):
        client_certificate_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate data.
        """
        client_key_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client key data.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the component name.
        """
elif False:
    ClusterCertificateUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCertificateUserArgs:
    def __init__(__self__, *,
                 client_certificate_data: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key_data: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_certificate_data: The client certificate data.
        :param pulumi.Input[_builtins.str] client_key_data: The client key data.
        :param pulumi.Input[_builtins.str] name: Specifies the component name.
        """
        if client_certificate_data is not None:
            pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        if client_key_data is not None:
            pulumi.set(__self__, "client_key_data", client_key_data)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate data.
        """
        return pulumi.get(self, "client_certificate_data")

    @client_certificate_data.setter
    def client_certificate_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate_data", value)

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client key data.
        """
        return pulumi.get(self, "client_key_data")

    @client_key_data.setter
    def client_key_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key_data", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the component name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterComponentConfigurationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the component name.
        """
        configurations: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies JSON string of the component configurations.

        <a name="cce_cluster_encryption_config"></a>
        The `encryption_config` block supports:
        """
elif False:
    ClusterComponentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterComponentConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 configurations: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the component name.
        :param pulumi.Input[_builtins.str] configurations: Specifies JSON string of the component configurations.
               
               <a name="cce_cluster_encryption_config"></a>
               The `encryption_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the component name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies JSON string of the component configurations.

        <a name="cce_cluster_encryption_config"></a>
        The `encryption_config` block supports:
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "configurations", value)


if not MYPY:
    class ClusterEncryptionConfigArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies KMS key ID, required if `mode` is set to **KMS**.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the encryption mode. The value can be: **Default** and **KMS**.
        """
elif False:
    ClusterEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kms_key_id: Specifies KMS key ID, required if `mode` is set to **KMS**.
        :param pulumi.Input[_builtins.str] mode: Specifies the encryption mode. The value can be: **Default** and **KMS**.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies KMS key ID, required if `mode` is set to **KMS**.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the encryption mode. The value can be: **Default** and **KMS**.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ClusterExtendParamArgsDict(TypedDict):
        cluster_az: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the AZ of master nodes in the cluster. The value can be:
        + **multi_az**: The cluster will span across AZs. This field is configurable only for high-availability clusters.
        + **AZ of the dedicated cloud computing pool**: The cluster will be deployed in the AZ of Dedicated Cloud (DeC).
        This parameter is mandatory for dedicated CCE clusters.

        Changing this parameter will create a new cluster resource.
        """
        cpu_manager_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cluster CPU management policy.
        The value can be:
        + **none**: CPU cores will not be exclusively allocated to workload pods.
        Select this value if you want a large pool of shareable CPU cores.
        + **static**: CPU cores can be exclusively allocated to workload pods.
        Select this value if your workload is sensitive to latency in CPU cache and scheduling.In a CCE Turbo cluster,
        this setting is valid only for nodes where common containers, not Kata containers, run.

        Defaults to none.
        Changing this parameter will create a new cluster resource.

        <a name="cce_cluster_component_configurations"></a>
        The `component_configurations` block supports:
        """
        dec_master_flavor: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the specifications of the master node
        in the dedicated hybrid cluster.
        Changing this parameter will create a new cluster resource.
        """
        docker_umask_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the default UmaskMode configuration of Docker in a
        cluster. The value can be **secure** or **normal**, defaults to normal.
        Changing this parameter will create a new cluster resource.
        """
        dss_master_volumes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether the system and data disks of a master node
        use dedicated distributed storage. If left unspecified, EVS disks are used by default.
        This parameter is mandatory for dedicated CCE clusters.
        It is in the following format:

        ```bash
        <rootVol.dssPoolID>.<rootVol.volType>;<dataVol.dssPoolID>.<dataVol.volType>
        ```

        Changing this parameter will create a new cluster resource.
        """
        fix_pool_mask: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of mask bits of the fixed IP address pool
        of the container network model. This field can only be used when `container_network_type` is set to **vpc-router**.
        Changing this parameter will create a new cluster resource.
        """
elif False:
    ClusterExtendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterExtendParamArgs:
    def __init__(__self__, *,
                 cluster_az: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_manager_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 dec_master_flavor: Optional[pulumi.Input[_builtins.str]] = None,
                 docker_umask_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 dss_master_volumes: Optional[pulumi.Input[_builtins.str]] = None,
                 fix_pool_mask: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_az: Specifies the AZ of master nodes in the cluster. The value can be:
               + **multi_az**: The cluster will span across AZs. This field is configurable only for high-availability clusters.
               + **AZ of the dedicated cloud computing pool**: The cluster will be deployed in the AZ of Dedicated Cloud (DeC).
               This parameter is mandatory for dedicated CCE clusters.
               
               Changing this parameter will create a new cluster resource.
        :param pulumi.Input[_builtins.str] cpu_manager_policy: Specifies the cluster CPU management policy.
               The value can be:
               + **none**: CPU cores will not be exclusively allocated to workload pods.
               Select this value if you want a large pool of shareable CPU cores.
               + **static**: CPU cores can be exclusively allocated to workload pods.
               Select this value if your workload is sensitive to latency in CPU cache and scheduling.In a CCE Turbo cluster,
               this setting is valid only for nodes where common containers, not Kata containers, run.
               
               Defaults to none.
               Changing this parameter will create a new cluster resource.
               
               <a name="cce_cluster_component_configurations"></a>
               The `component_configurations` block supports:
        :param pulumi.Input[_builtins.str] dec_master_flavor: Specifies the specifications of the master node
               in the dedicated hybrid cluster.
               Changing this parameter will create a new cluster resource.
        :param pulumi.Input[_builtins.str] docker_umask_mode: Specifies the default UmaskMode configuration of Docker in a
               cluster. The value can be **secure** or **normal**, defaults to normal.
               Changing this parameter will create a new cluster resource.
        :param pulumi.Input[_builtins.str] dss_master_volumes: Specifies whether the system and data disks of a master node
               use dedicated distributed storage. If left unspecified, EVS disks are used by default.
               This parameter is mandatory for dedicated CCE clusters.
               It is in the following format:
               
               ```bash
               <rootVol.dssPoolID>.<rootVol.volType>;<dataVol.dssPoolID>.<dataVol.volType>
               ```
               
               Changing this parameter will create a new cluster resource.
        :param pulumi.Input[_builtins.str] fix_pool_mask: Specifies the number of mask bits of the fixed IP address pool
               of the container network model. This field can only be used when `container_network_type` is set to **vpc-router**.
               Changing this parameter will create a new cluster resource.
        """
        if cluster_az is not None:
            pulumi.set(__self__, "cluster_az", cluster_az)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if dec_master_flavor is not None:
            pulumi.set(__self__, "dec_master_flavor", dec_master_flavor)
        if docker_umask_mode is not None:
            pulumi.set(__self__, "docker_umask_mode", docker_umask_mode)
        if dss_master_volumes is not None:
            pulumi.set(__self__, "dss_master_volumes", dss_master_volumes)
        if fix_pool_mask is not None:
            pulumi.set(__self__, "fix_pool_mask", fix_pool_mask)

    @_builtins.property
    @pulumi.getter(name="clusterAz")
    def cluster_az(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the AZ of master nodes in the cluster. The value can be:
        + **multi_az**: The cluster will span across AZs. This field is configurable only for high-availability clusters.
        + **AZ of the dedicated cloud computing pool**: The cluster will be deployed in the AZ of Dedicated Cloud (DeC).
        This parameter is mandatory for dedicated CCE clusters.

        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "cluster_az")

    @cluster_az.setter
    def cluster_az(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_az", value)

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cluster CPU management policy.
        The value can be:
        + **none**: CPU cores will not be exclusively allocated to workload pods.
        Select this value if you want a large pool of shareable CPU cores.
        + **static**: CPU cores can be exclusively allocated to workload pods.
        Select this value if your workload is sensitive to latency in CPU cache and scheduling.In a CCE Turbo cluster,
        this setting is valid only for nodes where common containers, not Kata containers, run.

        Defaults to none.
        Changing this parameter will create a new cluster resource.

        <a name="cce_cluster_component_configurations"></a>
        The `component_configurations` block supports:
        """
        return pulumi.get(self, "cpu_manager_policy")

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_manager_policy", value)

    @_builtins.property
    @pulumi.getter(name="decMasterFlavor")
    def dec_master_flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the specifications of the master node
        in the dedicated hybrid cluster.
        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "dec_master_flavor")

    @dec_master_flavor.setter
    def dec_master_flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dec_master_flavor", value)

    @_builtins.property
    @pulumi.getter(name="dockerUmaskMode")
    def docker_umask_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the default UmaskMode configuration of Docker in a
        cluster. The value can be **secure** or **normal**, defaults to normal.
        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "docker_umask_mode")

    @docker_umask_mode.setter
    def docker_umask_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "docker_umask_mode", value)

    @_builtins.property
    @pulumi.getter(name="dssMasterVolumes")
    def dss_master_volumes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether the system and data disks of a master node
        use dedicated distributed storage. If left unspecified, EVS disks are used by default.
        This parameter is mandatory for dedicated CCE clusters.
        It is in the following format:

        ```bash
        <rootVol.dssPoolID>.<rootVol.volType>;<dataVol.dssPoolID>.<dataVol.volType>
        ```

        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "dss_master_volumes")

    @dss_master_volumes.setter
    def dss_master_volumes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_master_volumes", value)

    @_builtins.property
    @pulumi.getter(name="fixPoolMask")
    def fix_pool_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of mask bits of the fixed IP address pool
        of the container network model. This field can only be used when `container_network_type` is set to **vpc-router**.
        Changing this parameter will create a new cluster resource.
        """
        return pulumi.get(self, "fix_pool_mask")

    @fix_pool_mask.setter
    def fix_pool_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fix_pool_mask", value)


if not MYPY:
    class ClusterLogConfigLogConfigArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to collect the log.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the log type.
        """
elif False:
    ClusterLogConfigLogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLogConfigLogConfigArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Specifies whether to collect the log.
        :param pulumi.Input[_builtins.str] name: Specifies the log type.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to collect the log.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the log type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterMasterArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the availability zone of the master node.
        Changing this parameter will create a new cluster resource.

        <a name="cce_cluster_extend_params"></a>
        The `extend_params` block supports:
        """
elif False:
    ClusterMasterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: Specifies the availability zone of the master node.
               Changing this parameter will create a new cluster resource.
               
               <a name="cce_cluster_extend_params"></a>
               The `extend_params` block supports:
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the availability zone of the master node.
        Changing this parameter will create a new cluster resource.

        <a name="cce_cluster_extend_params"></a>
        The `extend_params` block supports:
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)


if not MYPY:
    class ClusterUpgradeAddonArgsDict(TypedDict):
        addon_template_name: pulumi.Input[_builtins.str]
        """
        Specifies the add-on name.
        """
        operation: pulumi.Input[_builtins.str]
        """
        Specifies the execution action.
        For current upgrades, the value can be **patch**.
        """
        version: pulumi.Input[_builtins.str]
        """
        Specifies the target add-on version.
        The target add-on version must match the target cluster version.
        """
        values: NotRequired[pulumi.Input['ClusterUpgradeAddonValuesArgsDict']]
        """
        Specifies the add-on template installation parameters.
        These parameters vary depending on the add-on. The values is documented below.

        <a name="values"></a>
        The `values` block supports:
        """
elif False:
    ClusterUpgradeAddonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterUpgradeAddonArgs:
    def __init__(__self__, *,
                 addon_template_name: pulumi.Input[_builtins.str],
                 operation: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str],
                 values: Optional[pulumi.Input['ClusterUpgradeAddonValuesArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] addon_template_name: Specifies the add-on name.
        :param pulumi.Input[_builtins.str] operation: Specifies the execution action.
               For current upgrades, the value can be **patch**.
        :param pulumi.Input[_builtins.str] version: Specifies the target add-on version.
               The target add-on version must match the target cluster version.
        :param pulumi.Input['ClusterUpgradeAddonValuesArgs'] values: Specifies the add-on template installation parameters.
               These parameters vary depending on the add-on. The values is documented below.
               
               <a name="values"></a>
               The `values` block supports:
        """
        pulumi.set(__self__, "addon_template_name", addon_template_name)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "version", version)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="addonTemplateName")
    def addon_template_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the add-on name.
        """
        return pulumi.get(self, "addon_template_name")

    @addon_template_name.setter
    def addon_template_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "addon_template_name", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the execution action.
        For current upgrades, the value can be **patch**.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the target add-on version.
        The target add-on version must match the target cluster version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input['ClusterUpgradeAddonValuesArgs']]:
        """
        Specifies the add-on template installation parameters.
        These parameters vary depending on the add-on. The values is documented below.

        <a name="values"></a>
        The `values` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input['ClusterUpgradeAddonValuesArgs']]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ClusterUpgradeAddonValuesArgsDict(TypedDict):
        basic_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the json string vary depending on the add-on.
        """
        custom_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the json string vary depending on the add-on.
        """
        flavor_json: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the json string vary depending on the add-on.

        > Arguments which can be passed to the `basic_json`, `custom_json` and `flavor_json` add-on parameters depends on
        the add-on type and version. For more detailed description of add-ons
        see add-ons description

        <a name="strategy"></a>
        The `strategy` block supports:
        """
elif False:
    ClusterUpgradeAddonValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterUpgradeAddonValuesArgs:
    def __init__(__self__, *,
                 basic_json: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_json: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor_json: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] basic_json: Specifies the json string vary depending on the add-on.
        :param pulumi.Input[_builtins.str] custom_json: Specifies the json string vary depending on the add-on.
        :param pulumi.Input[_builtins.str] flavor_json: Specifies the json string vary depending on the add-on.
               
               > Arguments which can be passed to the `basic_json`, `custom_json` and `flavor_json` add-on parameters depends on
               the add-on type and version. For more detailed description of add-ons
               see add-ons description
               
               <a name="strategy"></a>
               The `strategy` block supports:
        """
        if basic_json is not None:
            pulumi.set(__self__, "basic_json", basic_json)
        if custom_json is not None:
            pulumi.set(__self__, "custom_json", custom_json)
        if flavor_json is not None:
            pulumi.set(__self__, "flavor_json", flavor_json)

    @_builtins.property
    @pulumi.getter(name="basicJson")
    def basic_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "basic_json")

    @basic_json.setter
    def basic_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_json", value)

    @_builtins.property
    @pulumi.getter(name="customJson")
    def custom_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the json string vary depending on the add-on.
        """
        return pulumi.get(self, "custom_json")

    @custom_json.setter
    def custom_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_json", value)

    @_builtins.property
    @pulumi.getter(name="flavorJson")
    def flavor_json(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the json string vary depending on the add-on.

        > Arguments which can be passed to the `basic_json`, `custom_json` and `flavor_json` add-on parameters depends on
        the add-on type and version. For more detailed description of add-ons
        see add-ons description

        <a name="strategy"></a>
        The `strategy` block supports:
        """
        return pulumi.get(self, "flavor_json")

    @flavor_json.setter
    def flavor_json(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor_json", value)


if not MYPY:
    class ClusterUpgradeStrategyArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the upgrade strategy type.
        The value can be **inPlaceRollingUpdate**.
        """
        in_place_rolling_update: NotRequired[pulumi.Input['ClusterUpgradeStrategyInPlaceRollingUpdateArgsDict']]
        """
        Specifies the in-place upgrade settings.
        It's mandatory when the `type` is set to **inPlaceRollingUpdate**.
        The in_place_rolling_update structure is documented below.

        <a name="in_place_rolling_update"></a>
        The `in_place_rolling_update` block supports:
        """
elif False:
    ClusterUpgradeStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterUpgradeStrategyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 in_place_rolling_update: Optional[pulumi.Input['ClusterUpgradeStrategyInPlaceRollingUpdateArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the upgrade strategy type.
               The value can be **inPlaceRollingUpdate**.
        :param pulumi.Input['ClusterUpgradeStrategyInPlaceRollingUpdateArgs'] in_place_rolling_update: Specifies the in-place upgrade settings.
               It's mandatory when the `type` is set to **inPlaceRollingUpdate**.
               The in_place_rolling_update structure is documented below.
               
               <a name="in_place_rolling_update"></a>
               The `in_place_rolling_update` block supports:
        """
        pulumi.set(__self__, "type", type)
        if in_place_rolling_update is not None:
            pulumi.set(__self__, "in_place_rolling_update", in_place_rolling_update)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the upgrade strategy type.
        The value can be **inPlaceRollingUpdate**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="inPlaceRollingUpdate")
    def in_place_rolling_update(self) -> Optional[pulumi.Input['ClusterUpgradeStrategyInPlaceRollingUpdateArgs']]:
        """
        Specifies the in-place upgrade settings.
        It's mandatory when the `type` is set to **inPlaceRollingUpdate**.
        The in_place_rolling_update structure is documented below.

        <a name="in_place_rolling_update"></a>
        The `in_place_rolling_update` block supports:
        """
        return pulumi.get(self, "in_place_rolling_update")

    @in_place_rolling_update.setter
    def in_place_rolling_update(self, value: Optional[pulumi.Input['ClusterUpgradeStrategyInPlaceRollingUpdateArgs']]):
        pulumi.set(self, "in_place_rolling_update", value)


if not MYPY:
    class ClusterUpgradeStrategyInPlaceRollingUpdateArgsDict(TypedDict):
        user_defined_step: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the node upgrade step.
        The value ranges from **1** to **40**. The recommended value is **20**.
        """
elif False:
    ClusterUpgradeStrategyInPlaceRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterUpgradeStrategyInPlaceRollingUpdateArgs:
    def __init__(__self__, *,
                 user_defined_step: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] user_defined_step: Specifies the node upgrade step.
               The value ranges from **1** to **40**. The recommended value is **20**.
        """
        if user_defined_step is not None:
            pulumi.set(__self__, "user_defined_step", user_defined_step)

    @_builtins.property
    @pulumi.getter(name="userDefinedStep")
    def user_defined_step(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the node upgrade step.
        The value ranges from **1** to **40**. The recommended value is **20**.
        """
        return pulumi.get(self, "user_defined_step")

    @user_defined_step.setter
    def user_defined_step(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "user_defined_step", value)


if not MYPY:
    class ClusterV3CertificateClusterArgsDict(TypedDict):
        certificate_authority_data: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        server: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV3CertificateClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV3CertificateClusterArgs:
    def __init__(__self__, *,
                 certificate_authority_data: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 server: Optional[pulumi.Input[_builtins.str]] = None):
        if certificate_authority_data is not None:
            pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "certificate_authority_data")

    @certificate_authority_data.setter
    def certificate_authority_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_authority_data", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server", value)


if not MYPY:
    class ClusterV3CertificateUserArgsDict(TypedDict):
        client_certificate_data: NotRequired[pulumi.Input[_builtins.str]]
        client_key_data: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV3CertificateUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV3CertificateUserArgs:
    def __init__(__self__, *,
                 client_certificate_data: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key_data: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        if client_certificate_data is not None:
            pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        if client_key_data is not None:
            pulumi.set(__self__, "client_key_data", client_key_data)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_certificate_data")

    @client_certificate_data.setter
    def client_certificate_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate_data", value)

    @_builtins.property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_key_data")

    @client_key_data.setter
    def client_key_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key_data", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterV3ComponentConfigurationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        configurations: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV3ComponentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV3ComponentConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 configurations: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "configurations", value)


if not MYPY:
    class ClusterV3EncryptionConfigArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        mode: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV3EncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV3EncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None):
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ClusterV3ExtendParamArgsDict(TypedDict):
        cluster_az: NotRequired[pulumi.Input[_builtins.str]]
        cpu_manager_policy: NotRequired[pulumi.Input[_builtins.str]]
        dec_master_flavor: NotRequired[pulumi.Input[_builtins.str]]
        docker_umask_mode: NotRequired[pulumi.Input[_builtins.str]]
        dss_master_volumes: NotRequired[pulumi.Input[_builtins.str]]
        fix_pool_mask: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV3ExtendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV3ExtendParamArgs:
    def __init__(__self__, *,
                 cluster_az: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_manager_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 dec_master_flavor: Optional[pulumi.Input[_builtins.str]] = None,
                 docker_umask_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 dss_master_volumes: Optional[pulumi.Input[_builtins.str]] = None,
                 fix_pool_mask: Optional[pulumi.Input[_builtins.str]] = None):
        if cluster_az is not None:
            pulumi.set(__self__, "cluster_az", cluster_az)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if dec_master_flavor is not None:
            pulumi.set(__self__, "dec_master_flavor", dec_master_flavor)
        if docker_umask_mode is not None:
            pulumi.set(__self__, "docker_umask_mode", docker_umask_mode)
        if dss_master_volumes is not None:
            pulumi.set(__self__, "dss_master_volumes", dss_master_volumes)
        if fix_pool_mask is not None:
            pulumi.set(__self__, "fix_pool_mask", fix_pool_mask)

    @_builtins.property
    @pulumi.getter(name="clusterAz")
    def cluster_az(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cluster_az")

    @cluster_az.setter
    def cluster_az(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_az", value)

    @_builtins.property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cpu_manager_policy")

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_manager_policy", value)

    @_builtins.property
    @pulumi.getter(name="decMasterFlavor")
    def dec_master_flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dec_master_flavor")

    @dec_master_flavor.setter
    def dec_master_flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dec_master_flavor", value)

    @_builtins.property
    @pulumi.getter(name="dockerUmaskMode")
    def docker_umask_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "docker_umask_mode")

    @docker_umask_mode.setter
    def docker_umask_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "docker_umask_mode", value)

    @_builtins.property
    @pulumi.getter(name="dssMasterVolumes")
    def dss_master_volumes(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dss_master_volumes")

    @dss_master_volumes.setter
    def dss_master_volumes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_master_volumes", value)

    @_builtins.property
    @pulumi.getter(name="fixPoolMask")
    def fix_pool_mask(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fix_pool_mask")

    @fix_pool_mask.setter
    def fix_pool_mask(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fix_pool_mask", value)


if not MYPY:
    class ClusterV3MasterArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV3MasterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV3MasterArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)


if not MYPY:
    class NodeAttachDataVolumeArgsDict(TypedDict):
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DSS pool ID. This field is used only for dedicated storage.
        """
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The disk expansion parameters.
        """
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The iops of the disk.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of a KMS key. This is used to encrypt the volume.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The disk size in GB.
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        The throughput of the disk.
        """
        volumetype: NotRequired[pulumi.Input[_builtins.str]]
        """
        The disk type.
        """
elif False:
    NodeAttachDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachDataVolumeArgs:
    def __init__(__self__, *,
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None,
                 volumetype: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dss_pool_id: The DSS pool ID. This field is used only for dedicated storage.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend_params: The disk expansion parameters.
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        :param pulumi.Input[_builtins.int] iops: The iops of the disk.
        :param pulumi.Input[_builtins.str] kms_key_id: The ID of a KMS key. This is used to encrypt the volume.
        :param pulumi.Input[_builtins.int] size: The disk size in GB.
        :param pulumi.Input[_builtins.int] throughput: The throughput of the disk.
        :param pulumi.Input[_builtins.str] volumetype: The disk type.
        """
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumetype is not None:
            pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The iops of the disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The disk size in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The throughput of the disk.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The disk type.
        """
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volumetype", value)


if not MYPY:
    class NodeAttachExtensionNicArgsDict(TypedDict):
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the subnet to which the NIC belongs.
        """
elif False:
    NodeAttachExtensionNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachExtensionNicArgs:
    def __init__(__self__, *,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the subnet to which the NIC belongs.
        """
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the subnet to which the NIC belongs.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class NodeAttachHostnameConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
elif False:
    NodeAttachHostnameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachHostnameConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodeAttachRootVolumeArgsDict(TypedDict):
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DSS pool ID. This field is used only for dedicated storage.
        """
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The disk expansion parameters.
        """
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The iops of the disk.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of a KMS key. This is used to encrypt the volume.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The disk size in GB.
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        The throughput of the disk.
        """
        volumetype: NotRequired[pulumi.Input[_builtins.str]]
        """
        The disk type.
        """
elif False:
    NodeAttachRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachRootVolumeArgs:
    def __init__(__self__, *,
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None,
                 volumetype: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dss_pool_id: The DSS pool ID. This field is used only for dedicated storage.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend_params: The disk expansion parameters.
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        :param pulumi.Input[_builtins.int] iops: The iops of the disk.
        :param pulumi.Input[_builtins.str] kms_key_id: The ID of a KMS key. This is used to encrypt the volume.
        :param pulumi.Input[_builtins.int] size: The disk size in GB.
        :param pulumi.Input[_builtins.int] throughput: The throughput of the disk.
        :param pulumi.Input[_builtins.str] volumetype: The disk type.
        """
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumetype is not None:
            pulumi.set(__self__, "volumetype", volumetype)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The iops of the disk.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The disk size in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The throughput of the disk.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The disk type.
        """
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volumetype", value)


if not MYPY:
    class NodeAttachStorageArgsDict(TypedDict):
        groups: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupArgsDict']]]
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        Changing this parameter will reset the node.
        """
        selectors: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageSelectorArgsDict']]]
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        Changing this parameter will reset the node.
        """
elif False:
    NodeAttachStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachStorageArgs:
    def __init__(__self__, *,
                 groups: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupArgs']]],
                 selectors: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageSelectorArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupArgs']]] groups: Specifies the storage group consists of multiple storage devices.
               This is used to divide storage space. Structure is documented below.
               Changing this parameter will reset the node.
        :param pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageSelectorArgs']]] selectors: Specifies the disk selection.
               Matched disks are managed according to match labels and storage type. Structure is documented below.
               Changing this parameter will reset the node.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupArgs']]]:
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageSelectorArgs']]]:
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageSelectorArgs']]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class NodeAttachStorageGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of a virtual storage group. Each group name must be unique.
        Changing this parameter will reset the node.
        """
        selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group. Changing this parameter will reset the node.
        """
        virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupVirtualSpaceArgsDict']]]
        """
        Specifies the detailed management of space configuration in a group.
        Changing this parameter will reset the node.
        """
        cce_managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        Changing this parameter will reset the node.
        """
elif False:
    NodeAttachStorageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachStorageGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupVirtualSpaceArgs']]],
                 cce_managed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of a virtual storage group. Each group name must be unique.
               Changing this parameter will reset the node.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selector_names: Specifies the list of names of selectors to match.
               This parameter corresponds to name in `selectors`. A group can match multiple selectors,
               but a selector can match only one group. Changing this parameter will reset the node.
        :param pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupVirtualSpaceArgs']]] virtual_spaces: Specifies the detailed management of space configuration in a group.
               Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.bool] cce_managed: Specifies the whether the storage space is for **kubernetes** and
               **runtime** components. Only one group can be set to true. The default value is **false**.
               Changing this parameter will reset the node.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of a virtual storage group. Each group name must be unique.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "selector_names")

    @selector_names.setter
    def selector_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "selector_names", value)

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupVirtualSpaceArgs']]]:
        """
        Specifies the detailed management of space configuration in a group.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "virtual_spaces")

    @virtual_spaces.setter
    def virtual_spaces(self, value: pulumi.Input[Sequence[pulumi.Input['NodeAttachStorageGroupVirtualSpaceArgs']]]):
        pulumi.set(self, "virtual_spaces", value)

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "cce_managed")

    @cce_managed.setter
    def cce_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cce_managed", value)


if not MYPY:
    class NodeAttachStorageGroupVirtualSpaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported. Changing this parameter will reset the node.
        """
        size: pulumi.Input[_builtins.str]
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        Changing this parameter will reset the node.
        """
        lvm_lv_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
        a new resource.
        """
        lvm_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration. Changing this parameter will reset the node.
        """
        runtime_lv_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration. Changing this parameter will reset the node.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
elif False:
    NodeAttachStorageGroupVirtualSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachStorageGroupVirtualSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.str],
                 lvm_lv_type: Optional[pulumi.Input[_builtins.str]] = None,
                 lvm_path: Optional[pulumi.Input[_builtins.str]] = None,
                 runtime_lv_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
               and **user** are supported. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] size: Specifies the size of a virtual space. Only an integer percentage is supported.
               Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
               Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] lvm_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
               a new resource.
        :param pulumi.Input[_builtins.str] lvm_path: Specifies the absolute path to which the disk is attached.
               This parameter takes effect only in **user** configuration. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] runtime_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **runtime** configuration. Changing this parameter will reset the node.
               
               <a name="hostname_config"></a>
               The `hostname_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration. Changing this parameter will create
        a new resource.
        """
        return pulumi.get(self, "lvm_lv_type")

    @lvm_lv_type.setter
    def lvm_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_lv_type", value)

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "lvm_path")

    @lvm_path.setter
    def lvm_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_path", value)

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration. Changing this parameter will reset the node.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
        return pulumi.get(self, "runtime_lv_type")

    @runtime_lv_type.setter
    def runtime_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_lv_type", value)


if not MYPY:
    class NodeAttachStorageSelectorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the selector name, used as the index of `selector_names` in storage group.
        The name of each selector must be unique. Changing this parameter will reset the node.
        """
        match_label_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected. Changing this parameter will reset the node.
        """
        match_label_metadata_cmkid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the customer master key ID of an encrypted
        disk. Changing this parameter will reset the node.
        """
        match_label_metadata_encrypted: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited. Changing this parameter will reset the node.
        """
        match_label_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100. Changing this parameter will reset the node.
        """
        match_label_volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        Changing this parameter will reset the node.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**. Changing this parameter will reset the node.
        """
elif False:
    NodeAttachStorageSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachStorageSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 match_label_count: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_cmkid: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_encrypted: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_size: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_volume_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the selector name, used as the index of `selector_names` in storage group.
               The name of each selector must be unique. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] match_label_count: Specifies the number of disks to be selected. If omitted,
               all disks of this type are selected. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] match_label_metadata_cmkid: Specifies the customer master key ID of an encrypted
               disk. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] match_label_metadata_encrypted: Specifies the disk encryption identifier.
               Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
               If omitted, whether the disk is encrypted is not limited. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] match_label_size: Specifies the matched disk size. If omitted,
               the disk size is not limited. Example: 100. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] match_label_volume_type: Specifies the EVS disk type. Currently,
               **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
               Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] type: Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
               The default value is **evs**. Changing this parameter will reset the node.
        """
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the selector name, used as the index of `selector_names` in storage group.
        The name of each selector must be unique. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_count")

    @match_label_count.setter
    def match_label_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_count", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the customer master key ID of an encrypted
        disk. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_metadata_cmkid")

    @match_label_metadata_cmkid.setter
    def match_label_metadata_cmkid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_cmkid", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_metadata_encrypted")

    @match_label_metadata_encrypted.setter
    def match_label_metadata_encrypted(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_encrypted", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_size")

    @match_label_size.setter
    def match_label_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_size", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "match_label_volume_type")

    @match_label_volume_type.setter
    def match_label_volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_volume_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodeAttachTaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        Changing this parameter will reset the node.
        """
        key: pulumi.Input[_builtins.str]
        """
        A key must contain 1 to 63 characters starting with a letter or digit.
        Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
        as the prefix of a key. Changing this parameter will reset the node.
        """
        value: pulumi.Input[_builtins.str]
        """
        A value must start with a letter or digit and can contain a maximum of 63
        characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
        reset the node.
        """
elif False:
    NodeAttachTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeAttachTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] effect: Available options are NoSchedule, PreferNoSchedule, and NoExecute.
               Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] key: A key must contain 1 to 63 characters starting with a letter or digit.
               Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
               as the prefix of a key. Changing this parameter will reset the node.
        :param pulumi.Input[_builtins.str] value: A value must start with a letter or digit and can contain a maximum of 63
               characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
               reset the node.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        Changing this parameter will reset the node.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        A key must contain 1 to 63 characters starting with a letter or digit.
        Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
        as the prefix of a key. Changing this parameter will reset the node.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        A value must start with a letter or digit and can contain a maximum of 63
        characters, including letters, digits, hyphens (-), underscores (_), and periods (.). Changing this parameter will
        reset the node.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodeDataVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the disk size in GB.
        """
        volumetype: pulumi.Input[_builtins.str]
        """
        Specifies the disk type.
        """
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the DSS pool ID. This field is used only for
        """
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the disk expansion parameters.
        """
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of a KMS key. This is used to encrypt the volume.
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.

        > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first
        time ever.
        """
elif False:
    NodeDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeDataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volumetype: pulumi.Input[_builtins.str],
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the disk size in GB.
        :param pulumi.Input[_builtins.str] volumetype: Specifies the disk type.
        :param pulumi.Input[_builtins.str] dss_pool_id: Specifies the DSS pool ID. This field is used only for
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend_params: Specifies the disk expansion parameters.
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        :param pulumi.Input[_builtins.int] iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param pulumi.Input[_builtins.str] kms_key_id: Specifies the ID of a KMS key. This is used to encrypt the volume.
        :param pulumi.Input[_builtins.int] throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
               
               > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first
               time ever.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volumetype", value)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the DSS pool ID. This field is used only for
        """
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.

        > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first
        time ever.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class NodeExtendParamsArgsDict(TypedDict):
        agency_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the agency name.
        """
        docker_base_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the available disk space of a single container on a node,
        in GB.
        """
        kube_reserved_mem: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the reserved node memory, which is reserved for
        Kubernetes-related components.
        """
        market_type: NotRequired[pulumi.Input[_builtins.str]]
        max_pods: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of instances a node is allowed to create.
        """
        nic_threshold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ENI pre-binding thresholds.
        Example setting: **"0.3:0.6"**.
        """
        node_image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image ID to create the node.
        """
        node_multi_queue: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of ENI queues.
        Example setting: **"[{\\"queue\\":4}]"**.
        """
        postinstall: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the script to be executed after installation.
        The input value can be a Base64 encoded string or not.
        """
        preinstall: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the script to be executed before installation.
        The input value can be a Base64 encoded string or not.
        """
        security_reinforcement_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the security reinforcement type.
        The value can be: **null** or **cybersecurity**.
        """
        spot_price: NotRequired[pulumi.Input[_builtins.str]]
        system_reserved_mem: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the reserved node memory, which is reserved
        value for system components.
        """
elif False:
    NodeExtendParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeExtendParamsArgs:
    def __init__(__self__, *,
                 agency_name: Optional[pulumi.Input[_builtins.str]] = None,
                 docker_base_size: Optional[pulumi.Input[_builtins.int]] = None,
                 kube_reserved_mem: Optional[pulumi.Input[_builtins.int]] = None,
                 market_type: Optional[pulumi.Input[_builtins.str]] = None,
                 max_pods: Optional[pulumi.Input[_builtins.int]] = None,
                 nic_threshold: Optional[pulumi.Input[_builtins.str]] = None,
                 node_image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 node_multi_queue: Optional[pulumi.Input[_builtins.str]] = None,
                 postinstall: Optional[pulumi.Input[_builtins.str]] = None,
                 preinstall: Optional[pulumi.Input[_builtins.str]] = None,
                 security_reinforcement_type: Optional[pulumi.Input[_builtins.str]] = None,
                 spot_price: Optional[pulumi.Input[_builtins.str]] = None,
                 system_reserved_mem: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] agency_name: Specifies the agency name.
        :param pulumi.Input[_builtins.int] docker_base_size: Specifies the available disk space of a single container on a node,
               in GB.
        :param pulumi.Input[_builtins.int] kube_reserved_mem: Specifies the reserved node memory, which is reserved for
               Kubernetes-related components.
        :param pulumi.Input[_builtins.int] max_pods: Specifies the maximum number of instances a node is allowed to create.
        :param pulumi.Input[_builtins.str] nic_threshold: Specifies the ENI pre-binding thresholds.
               Example setting: **"0.3:0.6"**.
        :param pulumi.Input[_builtins.str] node_image_id: Specifies the image ID to create the node.
        :param pulumi.Input[_builtins.str] node_multi_queue: Specifies the number of ENI queues.
               Example setting: **"[{\\"queue\\":4}]"**.
        :param pulumi.Input[_builtins.str] postinstall: Specifies the script to be executed after installation.
               The input value can be a Base64 encoded string or not.
        :param pulumi.Input[_builtins.str] preinstall: Specifies the script to be executed before installation.
               The input value can be a Base64 encoded string or not.
        :param pulumi.Input[_builtins.str] security_reinforcement_type: Specifies the security reinforcement type.
               The value can be: **null** or **cybersecurity**.
        :param pulumi.Input[_builtins.int] system_reserved_mem: Specifies the reserved node memory, which is reserved
               value for system components.
        """
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the agency name.
        """
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agency_name", value)

    @_builtins.property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the available disk space of a single container on a node,
        in GB.
        """
        return pulumi.get(self, "docker_base_size")

    @docker_base_size.setter
    def docker_base_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "docker_base_size", value)

    @_builtins.property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the reserved node memory, which is reserved for
        Kubernetes-related components.
        """
        return pulumi.get(self, "kube_reserved_mem")

    @kube_reserved_mem.setter
    def kube_reserved_mem(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kube_reserved_mem", value)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "market_type", value)

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of instances a node is allowed to create.
        """
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_pods", value)

    @_builtins.property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ENI pre-binding thresholds.
        Example setting: **"0.3:0.6"**.
        """
        return pulumi.get(self, "nic_threshold")

    @nic_threshold.setter
    def nic_threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nic_threshold", value)

    @_builtins.property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image ID to create the node.
        """
        return pulumi.get(self, "node_image_id")

    @node_image_id.setter
    def node_image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_image_id", value)

    @_builtins.property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of ENI queues.
        Example setting: **"[{\\"queue\\":4}]"**.
        """
        return pulumi.get(self, "node_multi_queue")

    @node_multi_queue.setter
    def node_multi_queue(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_multi_queue", value)

    @_builtins.property
    @pulumi.getter
    def postinstall(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the script to be executed after installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "postinstall")

    @postinstall.setter
    def postinstall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postinstall", value)

    @_builtins.property
    @pulumi.getter
    def preinstall(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the script to be executed before installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "preinstall")

    @preinstall.setter
    def preinstall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preinstall", value)

    @_builtins.property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the security reinforcement type.
        The value can be: **null** or **cybersecurity**.
        """
        return pulumi.get(self, "security_reinforcement_type")

    @security_reinforcement_type.setter
    def security_reinforcement_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_reinforcement_type", value)

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @_builtins.property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the reserved node memory, which is reserved
        value for system components.
        """
        return pulumi.get(self, "system_reserved_mem")

    @system_reserved_mem.setter
    def system_reserved_mem(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "system_reserved_mem", value)


if not MYPY:
    class NodeExtensionNicArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the subnet to which the NIC belongs.

        <a name="extend_params"></a>
        The `extend_params` block supports:
        """
elif False:
    NodeExtensionNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeExtensionNicArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Specifies the ID of the subnet to which the NIC belongs.
               
               <a name="extend_params"></a>
               The `extend_params` block supports:
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the subnet to which the NIC belongs.

        <a name="extend_params"></a>
        The `extend_params` block supports:
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class NodeHostnameConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
elif False:
    NodeHostnameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeHostnameConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodePoolDataVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the disk size in GB.
        """
        volumetype: pulumi.Input[_builtins.str]
        """
        Specifies the disk type.
        """
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the DSS pool ID. This field is used only for dedicated storage.
        """
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the disk expansion parameters.
        """
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the KMS key ID. This is used to encrypt the volume.
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.

        > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first time ever.
        """
elif False:
    NodePoolDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolDataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volumetype: pulumi.Input[_builtins.str],
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the disk size in GB.
        :param pulumi.Input[_builtins.str] volumetype: Specifies the disk type.
        :param pulumi.Input[_builtins.str] dss_pool_id: Specifies the DSS pool ID. This field is used only for dedicated storage.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend_params: Specifies the disk expansion parameters.
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        :param pulumi.Input[_builtins.int] iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param pulumi.Input[_builtins.str] kms_key_id: Specifies the KMS key ID. This is used to encrypt the volume.
        :param pulumi.Input[_builtins.int] throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
               
               > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first time ever.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volumetype", value)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the KMS key ID. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.

        > You need to create an agency (EVSAccessKMS) when disk encryption is used in the current project for the first time ever.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class NodePoolExtendParamsArgsDict(TypedDict):
        agency_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the agency name.
        """
        docker_base_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the available disk space of a single container on a node,
        in GB.
        """
        kube_reserved_mem: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the reserved node memory, which is reserved for
        Kubernetes-related components.
        """
        market_type: NotRequired[pulumi.Input[_builtins.str]]
        max_pods: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of instances a node is allowed to create.
        """
        nic_threshold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ENI pre-binding thresholds.
        Example setting: **"0.3:0.6"**.
        """
        node_image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image ID to create the node.
        """
        node_multi_queue: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of ENI queues.
        Example setting: **"[{\\"queue\\":4}]"**.
        """
        postinstall: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the script to be executed after installation.
        The input value can be a Base64 encoded string or not.
        """
        preinstall: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the script to be executed before installation.
        The input value can be a Base64 encoded string or not.
        """
        security_reinforcement_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the security reinforcement type.
        The value can be: **null** or **cybersecurity**.
        """
        spot_price: NotRequired[pulumi.Input[_builtins.str]]
        system_reserved_mem: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the reserved node memory, which is reserved
        value for system components.
        """
elif False:
    NodePoolExtendParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolExtendParamsArgs:
    def __init__(__self__, *,
                 agency_name: Optional[pulumi.Input[_builtins.str]] = None,
                 docker_base_size: Optional[pulumi.Input[_builtins.int]] = None,
                 kube_reserved_mem: Optional[pulumi.Input[_builtins.int]] = None,
                 market_type: Optional[pulumi.Input[_builtins.str]] = None,
                 max_pods: Optional[pulumi.Input[_builtins.int]] = None,
                 nic_threshold: Optional[pulumi.Input[_builtins.str]] = None,
                 node_image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 node_multi_queue: Optional[pulumi.Input[_builtins.str]] = None,
                 postinstall: Optional[pulumi.Input[_builtins.str]] = None,
                 preinstall: Optional[pulumi.Input[_builtins.str]] = None,
                 security_reinforcement_type: Optional[pulumi.Input[_builtins.str]] = None,
                 spot_price: Optional[pulumi.Input[_builtins.str]] = None,
                 system_reserved_mem: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] agency_name: Specifies the agency name.
        :param pulumi.Input[_builtins.int] docker_base_size: Specifies the available disk space of a single container on a node,
               in GB.
        :param pulumi.Input[_builtins.int] kube_reserved_mem: Specifies the reserved node memory, which is reserved for
               Kubernetes-related components.
        :param pulumi.Input[_builtins.int] max_pods: Specifies the maximum number of instances a node is allowed to create.
        :param pulumi.Input[_builtins.str] nic_threshold: Specifies the ENI pre-binding thresholds.
               Example setting: **"0.3:0.6"**.
        :param pulumi.Input[_builtins.str] node_image_id: Specifies the image ID to create the node.
        :param pulumi.Input[_builtins.str] node_multi_queue: Specifies the number of ENI queues.
               Example setting: **"[{\\"queue\\":4}]"**.
        :param pulumi.Input[_builtins.str] postinstall: Specifies the script to be executed after installation.
               The input value can be a Base64 encoded string or not.
        :param pulumi.Input[_builtins.str] preinstall: Specifies the script to be executed before installation.
               The input value can be a Base64 encoded string or not.
        :param pulumi.Input[_builtins.str] security_reinforcement_type: Specifies the security reinforcement type.
               The value can be: **null** or **cybersecurity**.
        :param pulumi.Input[_builtins.int] system_reserved_mem: Specifies the reserved node memory, which is reserved
               value for system components.
        """
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the agency name.
        """
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agency_name", value)

    @_builtins.property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the available disk space of a single container on a node,
        in GB.
        """
        return pulumi.get(self, "docker_base_size")

    @docker_base_size.setter
    def docker_base_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "docker_base_size", value)

    @_builtins.property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the reserved node memory, which is reserved for
        Kubernetes-related components.
        """
        return pulumi.get(self, "kube_reserved_mem")

    @kube_reserved_mem.setter
    def kube_reserved_mem(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kube_reserved_mem", value)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "market_type", value)

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of instances a node is allowed to create.
        """
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_pods", value)

    @_builtins.property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ENI pre-binding thresholds.
        Example setting: **"0.3:0.6"**.
        """
        return pulumi.get(self, "nic_threshold")

    @nic_threshold.setter
    def nic_threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nic_threshold", value)

    @_builtins.property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image ID to create the node.
        """
        return pulumi.get(self, "node_image_id")

    @node_image_id.setter
    def node_image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_image_id", value)

    @_builtins.property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of ENI queues.
        Example setting: **"[{\\"queue\\":4}]"**.
        """
        return pulumi.get(self, "node_multi_queue")

    @node_multi_queue.setter
    def node_multi_queue(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_multi_queue", value)

    @_builtins.property
    @pulumi.getter
    def postinstall(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the script to be executed after installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "postinstall")

    @postinstall.setter
    def postinstall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postinstall", value)

    @_builtins.property
    @pulumi.getter
    def preinstall(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the script to be executed before installation.
        The input value can be a Base64 encoded string or not.
        """
        return pulumi.get(self, "preinstall")

    @preinstall.setter
    def preinstall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preinstall", value)

    @_builtins.property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the security reinforcement type.
        The value can be: **null** or **cybersecurity**.
        """
        return pulumi.get(self, "security_reinforcement_type")

    @security_reinforcement_type.setter
    def security_reinforcement_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_reinforcement_type", value)

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @_builtins.property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the reserved node memory, which is reserved
        value for system components.
        """
        return pulumi.get(self, "system_reserved_mem")

    @system_reserved_mem.setter
    def system_reserved_mem(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "system_reserved_mem", value)


if not MYPY:
    class NodePoolExtensionScaleGroupArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input['NodePoolExtensionScaleGroupMetadataArgsDict']]
        """
        The basic information about the extended scaling group.
        The object structure is documented below.
        """
        spec: NotRequired[pulumi.Input['NodePoolExtensionScaleGroupSpecArgsDict']]
        """
        Specifies the configurations of the extended scaling group,
        which carry different configurations from those of the default scaling group.
        The object structure is documented below.

        <a name="metadata"></a>
        The `metadata` block supports:
        """
elif False:
    NodePoolExtensionScaleGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolExtensionScaleGroupArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['NodePoolExtensionScaleGroupMetadataArgs']] = None,
                 spec: Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecArgs']] = None):
        """
        :param pulumi.Input['NodePoolExtensionScaleGroupMetadataArgs'] metadata: The basic information about the extended scaling group.
               The object structure is documented below.
        :param pulumi.Input['NodePoolExtensionScaleGroupSpecArgs'] spec: Specifies the configurations of the extended scaling group,
               which carry different configurations from those of the default scaling group.
               The object structure is documented below.
               
               <a name="metadata"></a>
               The `metadata` block supports:
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['NodePoolExtensionScaleGroupMetadataArgs']]:
        """
        The basic information about the extended scaling group.
        The object structure is documented below.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['NodePoolExtensionScaleGroupMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecArgs']]:
        """
        Specifies the configurations of the extended scaling group,
        which carry different configurations from those of the default scaling group.
        The object structure is documented below.

        <a name="metadata"></a>
        The `metadata` block supports:
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecArgs']]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class NodePoolExtensionScaleGroupMetadataArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the node pool name.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the extended scaling group.
        """
elif False:
    NodePoolExtensionScaleGroupMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolExtensionScaleGroupMetadataArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the node pool name.
        :param pulumi.Input[_builtins.str] uid: The ID of the extended scaling group.
        """
        pulumi.set(__self__, "name", name)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the node pool name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the extended scaling group.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class NodePoolExtensionScaleGroupSpecArgsDict(TypedDict):
        autoscaling: NotRequired[pulumi.Input['NodePoolExtensionScaleGroupSpecAutoscalingArgsDict']]
        """
        Specifies the auto scaling configurations of the extended scaling group.
        The object structure is documented below.

        <a name="capacity_reservation_specification"></a>
        The `capacity_reservation_specification` block supports:
        """
        az: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the availability zone of a node.
        If this parameter is not specified or left blank, the default scaling group configurations take effect.
        """
        capacity_reservation_specification: NotRequired[pulumi.Input['NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict']]
        """
        Specifies the capacity reservation
        configurations of the extended scaling group.
        The object structure is documented below.
        """
        flavor: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the node flavor.
        """
elif False:
    NodePoolExtensionScaleGroupSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolExtensionScaleGroupSpecArgs:
    def __init__(__self__, *,
                 autoscaling: Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecAutoscalingArgs']] = None,
                 az: Optional[pulumi.Input[_builtins.str]] = None,
                 capacity_reservation_specification: Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs']] = None,
                 flavor: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['NodePoolExtensionScaleGroupSpecAutoscalingArgs'] autoscaling: Specifies the auto scaling configurations of the extended scaling group.
               The object structure is documented below.
               
               <a name="capacity_reservation_specification"></a>
               The `capacity_reservation_specification` block supports:
        :param pulumi.Input[_builtins.str] az: Specifies the availability zone of a node.
               If this parameter is not specified or left blank, the default scaling group configurations take effect.
        :param pulumi.Input['NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs'] capacity_reservation_specification: Specifies the capacity reservation
               configurations of the extended scaling group.
               The object structure is documented below.
        :param pulumi.Input[_builtins.str] flavor: Specifies the node flavor.
        """
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if az is not None:
            pulumi.set(__self__, "az", az)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecAutoscalingArgs']]:
        """
        Specifies the auto scaling configurations of the extended scaling group.
        The object structure is documented below.

        <a name="capacity_reservation_specification"></a>
        The `capacity_reservation_specification` block supports:
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @_builtins.property
    @pulumi.getter
    def az(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the availability zone of a node.
        If this parameter is not specified or left blank, the default scaling group configurations take effect.
        """
        return pulumi.get(self, "az")

    @az.setter
    def az(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "az", value)

    @_builtins.property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs']]:
        """
        Specifies the capacity reservation
        configurations of the extended scaling group.
        The object structure is documented below.
        """
        return pulumi.get(self, "capacity_reservation_specification")

    @capacity_reservation_specification.setter
    def capacity_reservation_specification(self, value: Optional[pulumi.Input['NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs']]):
        pulumi.set(self, "capacity_reservation_specification", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the node flavor.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor", value)


if not MYPY:
    class NodePoolExtensionScaleGroupSpecAutoscalingArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable auto scaling for the scaling group, defaults to **false**.
        """
        extension_priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the priority of the scaling group, defaults to **0**.
        A higher value indicates a greater priority.
        """
        max_node_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of nodes allowed if auto scaling is enabled.
        """
        min_node_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum number of nodes allowed if auto scaling is enabled.
        """
elif False:
    NodePoolExtensionScaleGroupSpecAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolExtensionScaleGroupSpecAutoscalingArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 extension_priority: Optional[pulumi.Input[_builtins.int]] = None,
                 max_node_count: Optional[pulumi.Input[_builtins.int]] = None,
                 min_node_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Specifies whether to enable auto scaling for the scaling group, defaults to **false**.
        :param pulumi.Input[_builtins.int] extension_priority: Specifies the priority of the scaling group, defaults to **0**.
               A higher value indicates a greater priority.
        :param pulumi.Input[_builtins.int] max_node_count: Specifies the maximum number of nodes allowed if auto scaling is enabled.
        :param pulumi.Input[_builtins.int] min_node_count: Specifies the minimum number of nodes allowed if auto scaling is enabled.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if extension_priority is not None:
            pulumi.set(__self__, "extension_priority", extension_priority)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable auto scaling for the scaling group, defaults to **false**.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="extensionPriority")
    def extension_priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the priority of the scaling group, defaults to **0**.
        A higher value indicates a greater priority.
        """
        return pulumi.get(self, "extension_priority")

    @extension_priority.setter
    def extension_priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "extension_priority", value)

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of nodes allowed if auto scaling is enabled.
        """
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_node_count", value)

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum number of nodes allowed if auto scaling is enabled.
        """
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_node_count", value)


if not MYPY:
    class NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID in UUID format.
        """
        preference: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the capacity of a private storage pool. If the value is none,
        the capacity reservation is not specified. If the value is targeted, the capacity reservation is specified.
        In this case, the `id` cannot be left blank.

        <a name="autoscaling"></a>
        The `autoscaling` block supports:
        """
elif False:
    NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 preference: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The resource ID in UUID format.
        :param pulumi.Input[_builtins.str] preference: Specifies the capacity of a private storage pool. If the value is none,
               the capacity reservation is not specified. If the value is targeted, the capacity reservation is specified.
               In this case, the `id` cannot be left blank.
               
               <a name="autoscaling"></a>
               The `autoscaling` block supports:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID in UUID format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the capacity of a private storage pool. If the value is none,
        the capacity reservation is not specified. If the value is targeted, the capacity reservation is specified.
        In this case, the `id` cannot be left blank.

        <a name="autoscaling"></a>
        The `autoscaling` block supports:
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class NodePoolHostnameConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the node pool type. Possible values are: **vm** and **ElasticBMS**.
        """
elif False:
    NodePoolHostnameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolHostnameConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the node pool type. Possible values are: **vm** and **ElasticBMS**.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the node pool type. Possible values are: **vm** and **ElasticBMS**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodePoolNodesAddNodeListArgsDict(TypedDict):
        server_id: pulumi.Input[_builtins.str]
        """
        Specifies server ID.
        """
elif False:
    NodePoolNodesAddNodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolNodesAddNodeListArgs:
    def __init__(__self__, *,
                 server_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] server_id: Specifies server ID.
        """
        pulumi.set(__self__, "server_id", server_id)

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies server ID.
        """
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_id", value)


if not MYPY:
    class NodePoolRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the disk size in GB.
        """
        volumetype: pulumi.Input[_builtins.str]
        """
        Specifies the disk type.
        """
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the DSS pool ID. This field is used only for dedicated storage.
        """
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the disk expansion parameters.
        """
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the KMS key ID. This is used to encrypt the volume.
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.
        """
elif False:
    NodePoolRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volumetype: pulumi.Input[_builtins.str],
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the disk size in GB.
        :param pulumi.Input[_builtins.str] volumetype: Specifies the disk type.
        :param pulumi.Input[_builtins.str] dss_pool_id: Specifies the DSS pool ID. This field is used only for dedicated storage.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend_params: Specifies the disk expansion parameters.
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        :param pulumi.Input[_builtins.int] iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param pulumi.Input[_builtins.str] kms_key_id: Specifies the KMS key ID. This is used to encrypt the volume.
        :param pulumi.Input[_builtins.int] throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volumetype", value)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the DSS pool ID. This field is used only for dedicated storage.
        """
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the KMS key ID. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class NodePoolStorageArgsDict(TypedDict):
        groups: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupArgsDict']]]
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        """
        selectors: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageSelectorArgsDict']]]
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
elif False:
    NodePoolStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolStorageArgs:
    def __init__(__self__, *,
                 groups: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupArgs']]],
                 selectors: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageSelectorArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupArgs']]] groups: Specifies the storage group consists of multiple storage devices.
               This is used to divide storage space. Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['NodePoolStorageSelectorArgs']]] selectors: Specifies the disk selection.
               Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupArgs']]]:
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['NodePoolStorageSelectorArgs']]]:
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageSelectorArgs']]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class NodePoolStorageGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of an extended scaling group.
        The value cannot be default and can contain a maximum of 55 characters.
        Only digits, lowercase letters, and hyphens (-) are allowed.

        <a name="spec"></a>
        The `spec` block supports:
        """
        selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group.
        """
        virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupVirtualSpaceArgsDict']]]
        """
        Specifies the detailed management of space configuration in a group.
        """
        cce_managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        """
elif False:
    NodePoolStorageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolStorageGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupVirtualSpaceArgs']]],
                 cce_managed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of an extended scaling group.
               The value cannot be default and can contain a maximum of 55 characters.
               Only digits, lowercase letters, and hyphens (-) are allowed.
               
               <a name="spec"></a>
               The `spec` block supports:
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selector_names: Specifies the list of names of selectors to match.
               This parameter corresponds to name in `selectors`. A group can match multiple selectors,
               but a selector can match only one group.
        :param pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupVirtualSpaceArgs']]] virtual_spaces: Specifies the detailed management of space configuration in a group.
        :param pulumi.Input[_builtins.bool] cce_managed: Specifies the whether the storage space is for **kubernetes** and
               **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of an extended scaling group.
        The value cannot be default and can contain a maximum of 55 characters.
        Only digits, lowercase letters, and hyphens (-) are allowed.

        <a name="spec"></a>
        The `spec` block supports:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group.
        """
        return pulumi.get(self, "selector_names")

    @selector_names.setter
    def selector_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "selector_names", value)

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupVirtualSpaceArgs']]]:
        """
        Specifies the detailed management of space configuration in a group.
        """
        return pulumi.get(self, "virtual_spaces")

    @virtual_spaces.setter
    def virtual_spaces(self, value: pulumi.Input[Sequence[pulumi.Input['NodePoolStorageGroupVirtualSpaceArgs']]]):
        pulumi.set(self, "virtual_spaces", value)

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        return pulumi.get(self, "cce_managed")

    @cce_managed.setter
    def cce_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cce_managed", value)


if not MYPY:
    class NodePoolStorageGroupVirtualSpaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported.
        """
        size: pulumi.Input[_builtins.str]
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        """
        lvm_lv_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration.
        """
        lvm_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration.
        """
        runtime_lv_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
elif False:
    NodePoolStorageGroupVirtualSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolStorageGroupVirtualSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.str],
                 lvm_lv_type: Optional[pulumi.Input[_builtins.str]] = None,
                 lvm_path: Optional[pulumi.Input[_builtins.str]] = None,
                 runtime_lv_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
               and **user** are supported.
        :param pulumi.Input[_builtins.str] size: Specifies the size of a virtual space. Only an integer percentage is supported.
               Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        :param pulumi.Input[_builtins.str] lvm_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **kubernetes** and **user** configuration.
        :param pulumi.Input[_builtins.str] lvm_path: Specifies the absolute path to which the disk is attached.
               This parameter takes effect only in **user** configuration.
        :param pulumi.Input[_builtins.str] runtime_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **runtime** configuration.
               
               <a name="hostname_config"></a>
               The `hostname_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration.
        """
        return pulumi.get(self, "lvm_lv_type")

    @lvm_lv_type.setter
    def lvm_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_lv_type", value)

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration.
        """
        return pulumi.get(self, "lvm_path")

    @lvm_path.setter
    def lvm_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_path", value)

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
        return pulumi.get(self, "runtime_lv_type")

    @runtime_lv_type.setter
    def runtime_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_lv_type", value)


if not MYPY:
    class NodePoolStorageSelectorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the selector name, used as the index of `selector_names`
        in storage group. The name of each selector must be unique.
        """
        match_label_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected.
        """
        match_label_metadata_cmkid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the customer master key ID of an encrypted
        disk.
        """
        match_label_metadata_encrypted: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited.
        """
        match_label_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100.
        """
        match_label_volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**.
        """
elif False:
    NodePoolStorageSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolStorageSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 match_label_count: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_cmkid: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_encrypted: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_size: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_volume_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the selector name, used as the index of `selector_names`
               in storage group. The name of each selector must be unique.
        :param pulumi.Input[_builtins.str] match_label_count: Specifies the number of disks to be selected. If omitted,
               all disks of this type are selected.
        :param pulumi.Input[_builtins.str] match_label_metadata_cmkid: Specifies the customer master key ID of an encrypted
               disk.
        :param pulumi.Input[_builtins.str] match_label_metadata_encrypted: Specifies the disk encryption identifier.
               Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
               If omitted, whether the disk is encrypted is not limited.
        :param pulumi.Input[_builtins.str] match_label_size: Specifies the matched disk size. If omitted,
               the disk size is not limited. Example: 100.
        :param pulumi.Input[_builtins.str] match_label_volume_type: Specifies the EVS disk type. Currently,
               **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        :param pulumi.Input[_builtins.str] type: Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
               The default value is **evs**.
        """
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the selector name, used as the index of `selector_names`
        in storage group. The name of each selector must be unique.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected.
        """
        return pulumi.get(self, "match_label_count")

    @match_label_count.setter
    def match_label_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_count", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the customer master key ID of an encrypted
        disk.
        """
        return pulumi.get(self, "match_label_metadata_cmkid")

    @match_label_metadata_cmkid.setter
    def match_label_metadata_cmkid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_cmkid", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited.
        """
        return pulumi.get(self, "match_label_metadata_encrypted")

    @match_label_metadata_encrypted.setter
    def match_label_metadata_encrypted(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_encrypted", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100.
        """
        return pulumi.get(self, "match_label_size")

    @match_label_size.setter
    def match_label_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_size", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        """
        return pulumi.get(self, "match_label_volume_type")

    @match_label_volume_type.setter
    def match_label_volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_volume_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodePoolTaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.

        <a name="extend_params"></a>
        The `extend_params` block supports:
        """
        key: pulumi.Input[_builtins.str]
        """
        A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
        digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
        prefix of a key.
        """
        value: pulumi.Input[_builtins.str]
        """
        A value must start with a letter or digit and can contain a maximum of 63 characters,
        including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
elif False:
    NodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] effect: Available options are NoSchedule, PreferNoSchedule, and NoExecute.
               
               <a name="extend_params"></a>
               The `extend_params` block supports:
        :param pulumi.Input[_builtins.str] key: A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
               digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
               prefix of a key.
        :param pulumi.Input[_builtins.str] value: A value must start with a letter or digit and can contain a maximum of 63 characters,
               including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.

        <a name="extend_params"></a>
        The `extend_params` block supports:
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        A key must contain 1 to 63 characters starting with a letter or digit. Only letters,
        digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used as the
        prefix of a key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        A value must start with a letter or digit and can contain a maximum of 63 characters,
        including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodeRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the disk size in GB.
        """
        volumetype: pulumi.Input[_builtins.str]
        """
        Specifies the disk type.
        """
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the DSS pool ID. This field is used only for
        """
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the disk expansion parameters.
        """
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of a KMS key. This is used to encrypt the volume.
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.
        """
elif False:
    NodeRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volumetype: pulumi.Input[_builtins.str],
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the disk size in GB.
        :param pulumi.Input[_builtins.str] volumetype: Specifies the disk type.
        :param pulumi.Input[_builtins.str] dss_pool_id: Specifies the DSS pool ID. This field is used only for
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend_params: Specifies the disk expansion parameters.
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        :param pulumi.Input[_builtins.int] iops: Specifies the iops of the disk,
               required when `volumetype` is **GPSSD2** or **ESSD2**.
        :param pulumi.Input[_builtins.str] kms_key_id: Specifies the ID of a KMS key. This is used to encrypt the volume.
        :param pulumi.Input[_builtins.int] throughput: Specifies the throughput of the disk in MiB/s,
               required when `volumetype` is **GPSSD2**.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the disk size in GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type.
        """
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volumetype", value)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the DSS pool ID. This field is used only for
        """
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the disk expansion parameters.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the iops of the disk,
        required when `volumetype` is **GPSSD2** or **ESSD2**.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of a KMS key. This is used to encrypt the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the throughput of the disk in MiB/s,
        required when `volumetype` is **GPSSD2**.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class NodeStorageArgsDict(TypedDict):
        groups: pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupArgsDict']]]
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        """
        selectors: pulumi.Input[Sequence[pulumi.Input['NodeStorageSelectorArgsDict']]]
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
elif False:
    NodeStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeStorageArgs:
    def __init__(__self__, *,
                 groups: pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupArgs']]],
                 selectors: pulumi.Input[Sequence[pulumi.Input['NodeStorageSelectorArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupArgs']]] groups: Specifies the storage group consists of multiple storage devices.
               This is used to divide storage space. Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['NodeStorageSelectorArgs']]] selectors: Specifies the disk selection.
               Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupArgs']]]:
        """
        Specifies the storage group consists of multiple storage devices.
        This is used to divide storage space. Structure is documented below.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['NodeStorageSelectorArgs']]]:
        """
        Specifies the disk selection.
        Matched disks are managed according to match labels and storage type. Structure is documented below.
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['NodeStorageSelectorArgs']]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class NodeStorageGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of a virtual storage group. Each group name must be unique.
        """
        selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group.
        """
        virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupVirtualSpaceArgsDict']]]
        """
        Specifies the detailed management of space configuration in a group.
        """
        cce_managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        """
elif False:
    NodeStorageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeStorageGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupVirtualSpaceArgs']]],
                 cce_managed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of a virtual storage group. Each group name must be unique.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selector_names: Specifies the list of names of selectors to match.
               This parameter corresponds to name in `selectors`. A group can match multiple selectors,
               but a selector can match only one group.
        :param pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupVirtualSpaceArgs']]] virtual_spaces: Specifies the detailed management of space configuration in a group.
        :param pulumi.Input[_builtins.bool] cce_managed: Specifies the whether the storage space is for **kubernetes** and
               **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of a virtual storage group. Each group name must be unique.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of names of selectors to match.
        This parameter corresponds to name in `selectors`. A group can match multiple selectors,
        but a selector can match only one group.
        """
        return pulumi.get(self, "selector_names")

    @selector_names.setter
    def selector_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "selector_names", value)

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupVirtualSpaceArgs']]]:
        """
        Specifies the detailed management of space configuration in a group.
        """
        return pulumi.get(self, "virtual_spaces")

    @virtual_spaces.setter
    def virtual_spaces(self, value: pulumi.Input[Sequence[pulumi.Input['NodeStorageGroupVirtualSpaceArgs']]]):
        pulumi.set(self, "virtual_spaces", value)

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the whether the storage space is for **kubernetes** and
        **runtime** components. Only one group can be set to true. The default value is **false**.
        """
        return pulumi.get(self, "cce_managed")

    @cce_managed.setter
    def cce_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cce_managed", value)


if not MYPY:
    class NodeStorageGroupVirtualSpaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported.
        """
        size: pulumi.Input[_builtins.str]
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        """
        lvm_lv_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration.
        """
        lvm_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration.
        """
        runtime_lv_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
elif False:
    NodeStorageGroupVirtualSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeStorageGroupVirtualSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.str],
                 lvm_lv_type: Optional[pulumi.Input[_builtins.str]] = None,
                 lvm_path: Optional[pulumi.Input[_builtins.str]] = None,
                 runtime_lv_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
               and **user** are supported.
        :param pulumi.Input[_builtins.str] size: Specifies the size of a virtual space. Only an integer percentage is supported.
               Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        :param pulumi.Input[_builtins.str] lvm_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **kubernetes** and **user** configuration.
        :param pulumi.Input[_builtins.str] lvm_path: Specifies the absolute path to which the disk is attached.
               This parameter takes effect only in **user** configuration.
        :param pulumi.Input[_builtins.str] runtime_lv_type: Specifies the LVM write mode, values can be **linear** and **striped**.
               This parameter takes effect only in **runtime** configuration.
               
               <a name="hostname_config"></a>
               The `hostname_config` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the virtual space name. Currently, only **kubernetes**, **runtime**,
        and **user** are supported.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the size of a virtual space. Only an integer percentage is supported.
        Example: 90%. Note that the total percentage of all virtual spaces in a group cannot exceed 100%.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **kubernetes** and **user** configuration.
        """
        return pulumi.get(self, "lvm_lv_type")

    @lvm_lv_type.setter
    def lvm_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_lv_type", value)

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the absolute path to which the disk is attached.
        This parameter takes effect only in **user** configuration.
        """
        return pulumi.get(self, "lvm_path")

    @lvm_path.setter
    def lvm_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_path", value)

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the LVM write mode, values can be **linear** and **striped**.
        This parameter takes effect only in **runtime** configuration.

        <a name="hostname_config"></a>
        The `hostname_config` block supports:
        """
        return pulumi.get(self, "runtime_lv_type")

    @runtime_lv_type.setter
    def runtime_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_lv_type", value)


if not MYPY:
    class NodeStorageSelectorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the selector name, used as the index of `selector_names`
        in storage group. The name of each selector must be unique.
        """
        match_label_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected.
        """
        match_label_metadata_cmkid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the customer master key ID of an encrypted
        disk.
        """
        match_label_metadata_encrypted: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited.
        """
        match_label_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100.
        """
        match_label_volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**.
        """
elif False:
    NodeStorageSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeStorageSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 match_label_count: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_cmkid: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_encrypted: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_size: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_volume_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the selector name, used as the index of `selector_names`
               in storage group. The name of each selector must be unique.
        :param pulumi.Input[_builtins.str] match_label_count: Specifies the number of disks to be selected. If omitted,
               all disks of this type are selected.
        :param pulumi.Input[_builtins.str] match_label_metadata_cmkid: Specifies the customer master key ID of an encrypted
               disk.
        :param pulumi.Input[_builtins.str] match_label_metadata_encrypted: Specifies the disk encryption identifier.
               Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
               If omitted, whether the disk is encrypted is not limited.
        :param pulumi.Input[_builtins.str] match_label_size: Specifies the matched disk size. If omitted,
               the disk size is not limited. Example: 100.
        :param pulumi.Input[_builtins.str] match_label_volume_type: Specifies the EVS disk type. Currently,
               **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        :param pulumi.Input[_builtins.str] type: Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
               The default value is **evs**.
        """
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the selector name, used as the index of `selector_names`
        in storage group. The name of each selector must be unique.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the number of disks to be selected. If omitted,
        all disks of this type are selected.
        """
        return pulumi.get(self, "match_label_count")

    @match_label_count.setter
    def match_label_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_count", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the customer master key ID of an encrypted
        disk.
        """
        return pulumi.get(self, "match_label_metadata_cmkid")

    @match_label_metadata_cmkid.setter
    def match_label_metadata_cmkid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_cmkid", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the disk encryption identifier.
        Values can be: **0** indicates that the disk is not encrypted and **1** indicates that the disk is encrypted.
        If omitted, whether the disk is encrypted is not limited.
        """
        return pulumi.get(self, "match_label_metadata_encrypted")

    @match_label_metadata_encrypted.setter
    def match_label_metadata_encrypted(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_encrypted", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the matched disk size. If omitted,
        the disk size is not limited. Example: 100.
        """
        return pulumi.get(self, "match_label_size")

    @match_label_size.setter
    def match_label_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_size", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the EVS disk type. Currently,
        **SSD**, **GPSSD**, and **SAS** are supported. If omitted, the disk type is not limited.
        """
        return pulumi.get(self, "match_label_volume_type")

    @match_label_volume_type.setter
    def match_label_volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_volume_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the storage type. Currently, only **evs (EVS volumes)** is supported.
        The default value is **evs**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodeTaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        """
        key: pulumi.Input[_builtins.str]
        """
        A key must contain 1 to 63 characters starting with a letter or digit.
        Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
        as the prefix of a key.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        A value must start with a letter or digit and can contain a maximum of 63
        characters, including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
elif False:
    NodeTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        :param pulumi.Input[_builtins.str] key: A key must contain 1 to 63 characters starting with a letter or digit.
               Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
               as the prefix of a key.
        :param pulumi.Input[_builtins.str] value: A value must start with a letter or digit and can contain a maximum of 63
               characters, including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Available options are NoSchedule, PreferNoSchedule, and NoExecute.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        A key must contain 1 to 63 characters starting with a letter or digit.
        Only letters, digits, hyphens (-), underscores (_), and periods (.) are allowed. A DNS subdomain name can be used
        as the prefix of a key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A value must start with a letter or digit and can contain a maximum of 63
        characters, including letters, digits, hyphens (-), underscores (_), and periods (.).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodeV3DataVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        volumetype: pulumi.Input[_builtins.str]
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    NodeV3DataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3DataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volumetype: pulumi.Input[_builtins.str],
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volumetype", value)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class NodeV3ExtendParamsArgsDict(TypedDict):
        agency_name: NotRequired[pulumi.Input[_builtins.str]]
        docker_base_size: NotRequired[pulumi.Input[_builtins.int]]
        kube_reserved_mem: NotRequired[pulumi.Input[_builtins.int]]
        market_type: NotRequired[pulumi.Input[_builtins.str]]
        max_pods: NotRequired[pulumi.Input[_builtins.int]]
        nic_threshold: NotRequired[pulumi.Input[_builtins.str]]
        node_image_id: NotRequired[pulumi.Input[_builtins.str]]
        node_multi_queue: NotRequired[pulumi.Input[_builtins.str]]
        postinstall: NotRequired[pulumi.Input[_builtins.str]]
        preinstall: NotRequired[pulumi.Input[_builtins.str]]
        security_reinforcement_type: NotRequired[pulumi.Input[_builtins.str]]
        spot_price: NotRequired[pulumi.Input[_builtins.str]]
        system_reserved_mem: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    NodeV3ExtendParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3ExtendParamsArgs:
    def __init__(__self__, *,
                 agency_name: Optional[pulumi.Input[_builtins.str]] = None,
                 docker_base_size: Optional[pulumi.Input[_builtins.int]] = None,
                 kube_reserved_mem: Optional[pulumi.Input[_builtins.int]] = None,
                 market_type: Optional[pulumi.Input[_builtins.str]] = None,
                 max_pods: Optional[pulumi.Input[_builtins.int]] = None,
                 nic_threshold: Optional[pulumi.Input[_builtins.str]] = None,
                 node_image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 node_multi_queue: Optional[pulumi.Input[_builtins.str]] = None,
                 postinstall: Optional[pulumi.Input[_builtins.str]] = None,
                 preinstall: Optional[pulumi.Input[_builtins.str]] = None,
                 security_reinforcement_type: Optional[pulumi.Input[_builtins.str]] = None,
                 spot_price: Optional[pulumi.Input[_builtins.str]] = None,
                 system_reserved_mem: Optional[pulumi.Input[_builtins.int]] = None):
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @_builtins.property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agency_name", value)

    @_builtins.property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "docker_base_size")

    @docker_base_size.setter
    def docker_base_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "docker_base_size", value)

    @_builtins.property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "kube_reserved_mem")

    @kube_reserved_mem.setter
    def kube_reserved_mem(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "kube_reserved_mem", value)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "market_type", value)

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_pods", value)

    @_builtins.property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "nic_threshold")

    @nic_threshold.setter
    def nic_threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nic_threshold", value)

    @_builtins.property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_image_id")

    @node_image_id.setter
    def node_image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_image_id", value)

    @_builtins.property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "node_multi_queue")

    @node_multi_queue.setter
    def node_multi_queue(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_multi_queue", value)

    @_builtins.property
    @pulumi.getter
    def postinstall(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "postinstall")

    @postinstall.setter
    def postinstall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "postinstall", value)

    @_builtins.property
    @pulumi.getter
    def preinstall(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "preinstall")

    @preinstall.setter
    def preinstall(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "preinstall", value)

    @_builtins.property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "security_reinforcement_type")

    @security_reinforcement_type.setter
    def security_reinforcement_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_reinforcement_type", value)

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @_builtins.property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "system_reserved_mem")

    @system_reserved_mem.setter
    def system_reserved_mem(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "system_reserved_mem", value)


if not MYPY:
    class NodeV3ExtensionNicArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
elif False:
    NodeV3ExtensionNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3ExtensionNicArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class NodeV3HostnameConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
elif False:
    NodeV3HostnameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3HostnameConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodeV3RootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        volumetype: pulumi.Input[_builtins.str]
        dss_pool_id: NotRequired[pulumi.Input[_builtins.str]]
        extend_param: NotRequired[pulumi.Input[_builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    NodeV3RootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3RootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volumetype: pulumi.Input[_builtins.str],
                 dss_pool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[_builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volumetype", value)

    @_builtins.property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @_builtins.property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class NodeV3StorageArgsDict(TypedDict):
        groups: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupArgsDict']]]
        selectors: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageSelectorArgsDict']]]
elif False:
    NodeV3StorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3StorageArgs:
    def __init__(__self__, *,
                 groups: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupArgs']]],
                 selectors: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageSelectorArgs']]]):
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupArgs']]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['NodeV3StorageSelectorArgs']]]:
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageSelectorArgs']]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class NodeV3StorageGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupVirtualSpaceArgsDict']]]
        cce_managed: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    NodeV3StorageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3StorageGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 virtual_spaces: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupVirtualSpaceArgs']]],
                 cce_managed: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "selector_names")

    @selector_names.setter
    def selector_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "selector_names", value)

    @_builtins.property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupVirtualSpaceArgs']]]:
        return pulumi.get(self, "virtual_spaces")

    @virtual_spaces.setter
    def virtual_spaces(self, value: pulumi.Input[Sequence[pulumi.Input['NodeV3StorageGroupVirtualSpaceArgs']]]):
        pulumi.set(self, "virtual_spaces", value)

    @_builtins.property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "cce_managed")

    @cce_managed.setter
    def cce_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cce_managed", value)


if not MYPY:
    class NodeV3StorageGroupVirtualSpaceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.str]
        lvm_lv_type: NotRequired[pulumi.Input[_builtins.str]]
        lvm_path: NotRequired[pulumi.Input[_builtins.str]]
        runtime_lv_type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeV3StorageGroupVirtualSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3StorageGroupVirtualSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.str],
                 lvm_lv_type: Optional[pulumi.Input[_builtins.str]] = None,
                 lvm_path: Optional[pulumi.Input[_builtins.str]] = None,
                 runtime_lv_type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lvm_lv_type")

    @lvm_lv_type.setter
    def lvm_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_lv_type", value)

    @_builtins.property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "lvm_path")

    @lvm_path.setter
    def lvm_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lvm_path", value)

    @_builtins.property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "runtime_lv_type")

    @runtime_lv_type.setter
    def runtime_lv_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_lv_type", value)


if not MYPY:
    class NodeV3StorageSelectorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        match_label_count: NotRequired[pulumi.Input[_builtins.str]]
        match_label_metadata_cmkid: NotRequired[pulumi.Input[_builtins.str]]
        match_label_metadata_encrypted: NotRequired[pulumi.Input[_builtins.str]]
        match_label_size: NotRequired[pulumi.Input[_builtins.str]]
        match_label_volume_type: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeV3StorageSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3StorageSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 match_label_count: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_cmkid: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_metadata_encrypted: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_size: Optional[pulumi.Input[_builtins.str]] = None,
                 match_label_volume_type: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_label_count")

    @match_label_count.setter
    def match_label_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_count", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_label_metadata_cmkid")

    @match_label_metadata_cmkid.setter
    def match_label_metadata_cmkid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_cmkid", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_label_metadata_encrypted")

    @match_label_metadata_encrypted.setter
    def match_label_metadata_encrypted(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_metadata_encrypted", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_label_size")

    @match_label_size.setter
    def match_label_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_size", value)

    @_builtins.property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_label_volume_type")

    @match_label_volume_type.setter
    def match_label_volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_label_volume_type", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NodeV3TaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    NodeV3TaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeV3TaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NodesRemoveNodeArgsDict(TypedDict):
        uid: pulumi.Input[_builtins.str]
        """
        Specifies the node ID.
        """
elif False:
    NodesRemoveNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodesRemoveNodeArgs:
    def __init__(__self__, *,
                 uid: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] uid: Specifies the node ID.
        """
        pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the node ID.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uid", value)


