# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AddressGroupRule',
    'CloudInstanceBandwidthExpackProduct',
    'CloudInstanceDomainExpackProduct',
    'CloudInstanceRuleExpackProduct',
    'DedicatedDomainBlockPage',
    'DedicatedDomainBlockPageCustomPage',
    'DedicatedDomainConnectionProtection',
    'DedicatedDomainCustomPage',
    'DedicatedDomainFlag',
    'DedicatedDomainServer',
    'DedicatedDomainTimeoutSettings',
    'DedicatedDomainTrafficMark',
    'DomainCustomPage',
    'DomainServer',
    'DomainTimeoutSettings',
    'DomainTrafficMark',
    'PolicyBindHost',
    'PolicyOption',
    'RuleAntiCrawlerCondition',
    'RuleCcProtectionCondition',
    'RuleGlobalProtectionWhitelistCondition',
    'RulePreciseProtectionCondition',
    'GetAddressGroupsGroupResult',
    'GetAddressGroupsGroupRuleResult',
    'GetAlarmNotificationsItemResult',
    'GetAllDomainsItemResult',
    'GetAllDomainsItemAccessProgressResult',
    'GetAllDomainsItemFlagResult',
    'GetAllDomainsItemPremiumWafInstanceResult',
    'GetAllDomainsItemServerResult',
    'GetCertificatesCertificateResult',
    'GetCertificatesCertificateBindHostResult',
    'GetDedicatedDomainsDomainResult',
    'GetDedicatedInstanceTagsTagResult',
    'GetDedicatedInstancesInstanceResult',
    'GetDomainsDomainResult',
    'GetInstanceGroupsGroupResult',
    'GetInstanceGroupsGroupDedicatedInstanceResult',
    'GetInstanceGroupsGroupDomainNameResult',
    'GetOverviewsAbnormalItemResult',
    'GetOverviewsAttackTopDomainsItemResult',
    'GetOverviewsBandwidthTimelineBandwidthResult',
    'GetOverviewsBandwidthTimelineBandwidthTimelineResult',
    'GetOverviewsClassificationAttackTypeResult',
    'GetOverviewsClassificationAttackTypeItemResult',
    'GetOverviewsClassificationDomainResult',
    'GetOverviewsClassificationDomainItemResult',
    'GetOverviewsClassificationGeoResult',
    'GetOverviewsClassificationGeoItemResult',
    'GetOverviewsClassificationIpResult',
    'GetOverviewsClassificationIpItemResult',
    'GetOverviewsClassificationUrlResult',
    'GetOverviewsClassificationUrlItemResult',
    'GetOverviewsQpsTimelineQpResult',
    'GetOverviewsQpsTimelineQpTimelineResult',
    'GetOverviewsRequestTimelineRequestResult',
    'GetOverviewsRequestTimelineRequestTimelineResult',
    'GetOverviewsStatisticsStatisticResult',
    'GetPoliciesPolicyResult',
    'GetPoliciesPolicyBindHostResult',
    'GetPoliciesPolicyOptionResult',
    'GetReferenceTablesTableResult',
    'GetRulesAntiCrawlerRuleResult',
    'GetRulesAntiCrawlerRuleConditionResult',
    'GetRulesBlacklistRuleResult',
    'GetRulesBlacklistRuleAddressGroupResult',
    'GetRulesCcProtectionRuleResult',
    'GetRulesCcProtectionRuleActionResult',
    'GetRulesCcProtectionRuleActionDetailResult',
    'GetRulesCcProtectionRuleConditionResult',
    'GetRulesDataMaskingRuleResult',
    'GetRulesGeolocationAccessControlRuleResult',
    'GetRulesGlobalProtectionWhitelistRuleResult',
    'GetRulesGlobalProtectionWhitelistRuleConditionResult',
    'GetRulesInformationLeakagePreventionRuleResult',
    'GetRulesKnownAttackSourceRuleResult',
    'GetRulesPreciseProtectionRuleResult',
    'GetRulesPreciseProtectionRuleConditionResult',
    'GetRulesWebTamperProtectionRuleResult',
    'GetSecurityReportSubscriptionsItemResult',
    'GetSourceIpsSourceIpResult',
]

@pulumi.output_type
class AddressGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyId":
            suggest = "policy_id"
        elif key == "policyName":
            suggest = "policy_name"
        elif key == "ruleId":
            suggest = "rule_id"
        elif key == "ruleName":
            suggest = "rule_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AddressGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AddressGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AddressGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_id: Optional[_builtins.str] = None,
                 policy_name: Optional[_builtins.str] = None,
                 rule_id: Optional[_builtins.str] = None,
                 rule_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str policy_id: The ID of policy.
        :param _builtins.str policy_name: The name of policy.
        :param _builtins.str rule_id: The ID of rule.
        :param _builtins.str rule_name: The name of rule.
        """
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        """
        The ID of policy.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[_builtins.str]:
        """
        The name of policy.
        """
        return pulumi.get(self, "policy_name")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[_builtins.str]:
        """
        The ID of rule.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        The name of rule.
        """
        return pulumi.get(self, "rule_name")


@pulumi.output_type
class CloudInstanceBandwidthExpackProduct(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceSize":
            suggest = "resource_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudInstanceBandwidthExpackProduct. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudInstanceBandwidthExpackProduct.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudInstanceBandwidthExpackProduct.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int resource_size: Specifies the number of extended packages.
               + For bandwidth extended packages, each package will support `1,000` QPS or `20` Mbits/s (outside HUAWEI Cloud) and
               `50` Mbits/s (inside HUAWEI Cloud) bandwidth.
               + For domain extended packages, each package will support `10` domain names (only one level-1 domain is supported).
               + For rule extended packages, each package will support `10` protection rules (only IP black/white list is supported).
               
               > The `resource_size` cannot be reduced below `1`.
        """
        if resource_size is not None:
            pulumi.set(__self__, "resource_size", resource_size)

    @_builtins.property
    @pulumi.getter(name="resourceSize")
    def resource_size(self) -> Optional[_builtins.int]:
        """
        Specifies the number of extended packages.
        + For bandwidth extended packages, each package will support `1,000` QPS or `20` Mbits/s (outside HUAWEI Cloud) and
        `50` Mbits/s (inside HUAWEI Cloud) bandwidth.
        + For domain extended packages, each package will support `10` domain names (only one level-1 domain is supported).
        + For rule extended packages, each package will support `10` protection rules (only IP black/white list is supported).

        > The `resource_size` cannot be reduced below `1`.
        """
        return pulumi.get(self, "resource_size")


@pulumi.output_type
class CloudInstanceDomainExpackProduct(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceSize":
            suggest = "resource_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudInstanceDomainExpackProduct. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudInstanceDomainExpackProduct.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudInstanceDomainExpackProduct.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int resource_size: Specifies the number of extended packages.
               + For bandwidth extended packages, each package will support `1,000` QPS or `20` Mbits/s (outside HUAWEI Cloud) and
               `50` Mbits/s (inside HUAWEI Cloud) bandwidth.
               + For domain extended packages, each package will support `10` domain names (only one level-1 domain is supported).
               + For rule extended packages, each package will support `10` protection rules (only IP black/white list is supported).
               
               > The `resource_size` cannot be reduced below `1`.
        """
        if resource_size is not None:
            pulumi.set(__self__, "resource_size", resource_size)

    @_builtins.property
    @pulumi.getter(name="resourceSize")
    def resource_size(self) -> Optional[_builtins.int]:
        """
        Specifies the number of extended packages.
        + For bandwidth extended packages, each package will support `1,000` QPS or `20` Mbits/s (outside HUAWEI Cloud) and
        `50` Mbits/s (inside HUAWEI Cloud) bandwidth.
        + For domain extended packages, each package will support `10` domain names (only one level-1 domain is supported).
        + For rule extended packages, each package will support `10` protection rules (only IP black/white list is supported).

        > The `resource_size` cannot be reduced below `1`.
        """
        return pulumi.get(self, "resource_size")


@pulumi.output_type
class CloudInstanceRuleExpackProduct(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceSize":
            suggest = "resource_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudInstanceRuleExpackProduct. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudInstanceRuleExpackProduct.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudInstanceRuleExpackProduct.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int resource_size: Specifies the number of extended packages.
               + For bandwidth extended packages, each package will support `1,000` QPS or `20` Mbits/s (outside HUAWEI Cloud) and
               `50` Mbits/s (inside HUAWEI Cloud) bandwidth.
               + For domain extended packages, each package will support `10` domain names (only one level-1 domain is supported).
               + For rule extended packages, each package will support `10` protection rules (only IP black/white list is supported).
               
               > The `resource_size` cannot be reduced below `1`.
        """
        if resource_size is not None:
            pulumi.set(__self__, "resource_size", resource_size)

    @_builtins.property
    @pulumi.getter(name="resourceSize")
    def resource_size(self) -> Optional[_builtins.int]:
        """
        Specifies the number of extended packages.
        + For bandwidth extended packages, each package will support `1,000` QPS or `20` Mbits/s (outside HUAWEI Cloud) and
        `50` Mbits/s (inside HUAWEI Cloud) bandwidth.
        + For domain extended packages, each package will support `10` domain names (only one level-1 domain is supported).
        + For rule extended packages, each package will support `10` protection rules (only IP black/white list is supported).

        > The `resource_size` cannot be reduced below `1`.
        """
        return pulumi.get(self, "resource_size")


@pulumi.output_type
class DedicatedDomainBlockPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customPages":
            suggest = "custom_pages"
        elif key == "redirectUrl":
            suggest = "redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainBlockPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainBlockPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainBlockPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_pages: Optional[Sequence['outputs.DedicatedDomainBlockPageCustomPage']] = None,
                 redirect_url: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param Sequence['DedicatedDomainBlockPageCustomPageArgs'] custom_pages: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param _builtins.str redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param _builtins.str template: Template name. Enter **default** for the default page. Enter **custom** for the customized alarm page.
               Enter **redirect** for the redirection page.
        """
        if custom_pages is not None:
            pulumi.set(__self__, "custom_pages", custom_pages)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter(name="customPages")
    def custom_pages(self) -> Optional[Sequence['outputs.DedicatedDomainBlockPageCustomPage']]:
        """
        Specifies the custom page. Only supports one custom alarm page.
        The custom_page structure is documented below.
        """
        return pulumi.get(self, "custom_pages")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[_builtins.str]:
        """
        Specifies the URL of the redirected page. The root domain name of the redirection
        address must be the name of the currently protected domain (including a wildcard domain name).
        The available **${http_host}** can be used to indicate the currently protected domain name and port.
        For example: **${http_host}/error.html**.

        > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        Template name. Enter **default** for the default page. Enter **custom** for the customized alarm page.
        Enter **redirect** for the redirection page.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class DedicatedDomainBlockPageCustomPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainBlockPageCustomPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainBlockPageCustomPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainBlockPageCustomPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None,
                 content_type: Optional[_builtins.str] = None,
                 status_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: The page content based on the selected page type.
        :param _builtins.str content_type: The content type of the custom alarm page. The value can be **text/html**, **text/xml** or **application/json**.
        :param _builtins.str status_code: The status code.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        The page content based on the selected page type.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        The content type of the custom alarm page. The value can be **text/html**, **text/xml** or **application/json**.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[_builtins.str]:
        """
        The status code.
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class DedicatedDomainConnectionProtection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorPercentage":
            suggest = "error_percentage"
        elif key == "errorThreshold":
            suggest = "error_threshold"
        elif key == "initialDowntime":
            suggest = "initial_downtime"
        elif key == "multiplierForConsecutiveBreakdowns":
            suggest = "multiplier_for_consecutive_breakdowns"
        elif key == "pendingUrlRequestThreshold":
            suggest = "pending_url_request_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainConnectionProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainConnectionProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainConnectionProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[_builtins.int] = None,
                 error_percentage: Optional[_builtins.float] = None,
                 error_threshold: Optional[_builtins.int] = None,
                 initial_downtime: Optional[_builtins.int] = None,
                 multiplier_for_consecutive_breakdowns: Optional[_builtins.int] = None,
                 pending_url_request_threshold: Optional[_builtins.int] = None,
                 status: Optional[_builtins.bool] = None):
        """
        :param _builtins.int duration: Specifies the protection duration (s) for connection protection. During this period, WAF
               stops forwarding website requests. Valid value ranges from `0` to `2,147,483,647`.
        :param _builtins.float error_percentage: Specifies the `502`/`504` error percentage. A breakdown protection is triggered
               when the `502`/`504` error threshold and percentage threshold have been reached. Valid value ranges from `0` to `99`.
        :param _builtins.int error_threshold: Specifies the `502`/`504` error threshold for every 30 seconds. Valid value ranges
               from `0` to `2,147,483,647`.
        :param _builtins.int initial_downtime: Specifies the breakdown duration (s) when the breakdown is triggered for the first
               time. Valid value ranges from `0` to `2,147,483,647`.
        :param _builtins.int multiplier_for_consecutive_breakdowns: Specifies the maximum multiplier for consecutive breakdowns
               that occur within an hour. Valid value ranges from `0` to `2,147,483,647`.
               For example: Assume that you set the initial downtime to `180s` and the maximum multiplier to `3`. If the breakdown
               protection is triggered for the second time, the website downtime is 360s (180s X 2).
               If the breakdown protection is triggered for the third or fourth time, the website downtime is 540s (180s x 3).
               The breakdowns are calculated every one hour.
        :param _builtins.int pending_url_request_threshold: Specifies the pending URL request threshold. Connection protection
               is triggered when the number of read URL requests reaches the threshold you configure. Valid value ranges from `0` to
               `2,147,483,647`.
        :param _builtins.bool status: Specifies whether to enable connection protection. Defaults to **false**.
               
               <a name="DedicatedDomain_timeout_settings"></a>
               The `timeout_settings` block supports:
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if error_percentage is not None:
            pulumi.set(__self__, "error_percentage", error_percentage)
        if error_threshold is not None:
            pulumi.set(__self__, "error_threshold", error_threshold)
        if initial_downtime is not None:
            pulumi.set(__self__, "initial_downtime", initial_downtime)
        if multiplier_for_consecutive_breakdowns is not None:
            pulumi.set(__self__, "multiplier_for_consecutive_breakdowns", multiplier_for_consecutive_breakdowns)
        if pending_url_request_threshold is not None:
            pulumi.set(__self__, "pending_url_request_threshold", pending_url_request_threshold)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        Specifies the protection duration (s) for connection protection. During this period, WAF
        stops forwarding website requests. Valid value ranges from `0` to `2,147,483,647`.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="errorPercentage")
    def error_percentage(self) -> Optional[_builtins.float]:
        """
        Specifies the `502`/`504` error percentage. A breakdown protection is triggered
        when the `502`/`504` error threshold and percentage threshold have been reached. Valid value ranges from `0` to `99`.
        """
        return pulumi.get(self, "error_percentage")

    @_builtins.property
    @pulumi.getter(name="errorThreshold")
    def error_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the `502`/`504` error threshold for every 30 seconds. Valid value ranges
        from `0` to `2,147,483,647`.
        """
        return pulumi.get(self, "error_threshold")

    @_builtins.property
    @pulumi.getter(name="initialDowntime")
    def initial_downtime(self) -> Optional[_builtins.int]:
        """
        Specifies the breakdown duration (s) when the breakdown is triggered for the first
        time. Valid value ranges from `0` to `2,147,483,647`.
        """
        return pulumi.get(self, "initial_downtime")

    @_builtins.property
    @pulumi.getter(name="multiplierForConsecutiveBreakdowns")
    def multiplier_for_consecutive_breakdowns(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum multiplier for consecutive breakdowns
        that occur within an hour. Valid value ranges from `0` to `2,147,483,647`.
        For example: Assume that you set the initial downtime to `180s` and the maximum multiplier to `3`. If the breakdown
        protection is triggered for the second time, the website downtime is 360s (180s X 2).
        If the breakdown protection is triggered for the third or fourth time, the website downtime is 540s (180s x 3).
        The breakdowns are calculated every one hour.
        """
        return pulumi.get(self, "multiplier_for_consecutive_breakdowns")

    @_builtins.property
    @pulumi.getter(name="pendingUrlRequestThreshold")
    def pending_url_request_threshold(self) -> Optional[_builtins.int]:
        """
        Specifies the pending URL request threshold. Connection protection
        is triggered when the number of read URL requests reaches the threshold you configure. Valid value ranges from `0` to
        `2,147,483,647`.
        """
        return pulumi.get(self, "pending_url_request_threshold")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable connection protection. Defaults to **false**.

        <a name="DedicatedDomain_timeout_settings"></a>
        The `timeout_settings` block supports:
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class DedicatedDomainCustomPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockPageType":
            suggest = "block_page_type"
        elif key == "httpReturnCode":
            suggest = "http_return_code"
        elif key == "pageContent":
            suggest = "page_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainCustomPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainCustomPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainCustomPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_page_type: _builtins.str,
                 http_return_code: _builtins.str,
                 page_content: _builtins.str):
        """
        :param _builtins.str block_page_type: Specifies the content type of the custom alarm page.
               The value can be **text/html**, **text/xml** or **application/json**.
        :param _builtins.str http_return_code: Specifies the HTTP return code.
               The value can be a positive integer in the range of `200`-`599` except `408`, `444` and `499`.
        :param _builtins.str page_content: Specifies the page content. The page content based on the selected page type.
               The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
               can be available.
               
               <a name="DedicatedDomain_connection_protection"></a>
               The `connection_protection` block supports:
        """
        pulumi.set(__self__, "block_page_type", block_page_type)
        pulumi.set(__self__, "http_return_code", http_return_code)
        pulumi.set(__self__, "page_content", page_content)

    @_builtins.property
    @pulumi.getter(name="blockPageType")
    def block_page_type(self) -> _builtins.str:
        """
        Specifies the content type of the custom alarm page.
        The value can be **text/html**, **text/xml** or **application/json**.
        """
        return pulumi.get(self, "block_page_type")

    @_builtins.property
    @pulumi.getter(name="httpReturnCode")
    def http_return_code(self) -> _builtins.str:
        """
        Specifies the HTTP return code.
        The value can be a positive integer in the range of `200`-`599` except `408`, `444` and `499`.
        """
        return pulumi.get(self, "http_return_code")

    @_builtins.property
    @pulumi.getter(name="pageContent")
    def page_content(self) -> _builtins.str:
        """
        Specifies the page content. The page content based on the selected page type.
        The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
        can be available.

        <a name="DedicatedDomain_connection_protection"></a>
        The `connection_protection` block supports:
        """
        return pulumi.get(self, "page_content")


@pulumi.output_type
class DedicatedDomainFlag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDualAz":
            suggest = "is_dual_az"
        elif key == "pciDss":
            suggest = "pci_dss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainFlag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainFlag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainFlag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cname: Optional[_builtins.str] = None,
                 ipv6: Optional[_builtins.str] = None,
                 is_dual_az: Optional[_builtins.str] = None,
                 pci3ds: Optional[_builtins.str] = None,
                 pci_dss: Optional[_builtins.str] = None):
        """
        :param _builtins.str cname: The CNAME record being used. Valid values are **old** and **new**.
        :param _builtins.str ipv6: Whether IPv6 protection is supported. Valid values are **true** and **false**.
        :param _builtins.str is_dual_az: Whether WAF support Multi-AZ DR. Valid values are **true** and **false**.
        :param _builtins.str pci3ds: Specifies the status of the PCI 3DS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
        :param _builtins.str pci_dss: Specifies the status of the PCI DSS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        """
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if is_dual_az is not None:
            pulumi.set(__self__, "is_dual_az", is_dual_az)
        if pci3ds is not None:
            pulumi.set(__self__, "pci3ds", pci3ds)
        if pci_dss is not None:
            pulumi.set(__self__, "pci_dss", pci_dss)

    @_builtins.property
    @pulumi.getter
    def cname(self) -> Optional[_builtins.str]:
        """
        The CNAME record being used. Valid values are **old** and **new**.
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.str]:
        """
        Whether IPv6 protection is supported. Valid values are **true** and **false**.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="isDualAz")
    def is_dual_az(self) -> Optional[_builtins.str]:
        """
        Whether WAF support Multi-AZ DR. Valid values are **true** and **false**.
        """
        return pulumi.get(self, "is_dual_az")

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> Optional[_builtins.str]:
        """
        Specifies the status of the PCI 3DS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
        check cannot be disabled after being enabled.
        """
        return pulumi.get(self, "pci3ds")

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> Optional[_builtins.str]:
        """
        Specifies the status of the PCI DSS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        """
        return pulumi.get(self, "pci_dss")


@pulumi.output_type
class DedicatedDomainServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProtocol":
            suggest = "client_protocol"
        elif key == "serverProtocol":
            suggest = "server_protocol"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 client_protocol: _builtins.str,
                 port: _builtins.int,
                 server_protocol: _builtins.str,
                 type: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str address: Specifies the IP address or domain name of the web server accessed by the
               client. For example, `192.168.1.1` or `www.example.com`.
        :param _builtins.str client_protocol: Specifies the protocol type of the client. The options include **HTTP**
               and **HTTPS**.
        :param _builtins.int port: Specifies the port number used by the web server. The value ranges from `0` to `65,535`.
               
               <a name="DedicatedDomain_custom_page"></a>
               The `custom_page` block supports:
        :param _builtins.str server_protocol: Specifies the protocol used by WAF to forward client requests to the
               server. The valid values are **HTTP** and **HTTPS**.
        :param _builtins.str type: Specifies the server network type, IPv4 or IPv6.
               Valid values are **ipv4** and **ipv6**.
        :param _builtins.str vpc_id: Specifies the ID of the VPC used by the server.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "client_protocol", client_protocol)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server_protocol", server_protocol)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Specifies the IP address or domain name of the web server accessed by the
        client. For example, `192.168.1.1` or `www.example.com`.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="clientProtocol")
    def client_protocol(self) -> _builtins.str:
        """
        Specifies the protocol type of the client. The options include **HTTP**
        and **HTTPS**.
        """
        return pulumi.get(self, "client_protocol")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Specifies the port number used by the web server. The value ranges from `0` to `65,535`.

        <a name="DedicatedDomain_custom_page"></a>
        The `custom_page` block supports:
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="serverProtocol")
    def server_protocol(self) -> _builtins.str:
        """
        Specifies the protocol used by WAF to forward client requests to the
        server. The valid values are **HTTP** and **HTTPS**.
        """
        return pulumi.get(self, "server_protocol")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the server network type, IPv4 or IPv6.
        Valid values are **ipv4** and **ipv6**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Specifies the ID of the VPC used by the server.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class DedicatedDomainTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "writeTimeout":
            suggest = "write_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_timeout: Optional[_builtins.int] = None,
                 read_timeout: Optional[_builtins.int] = None,
                 write_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int connection_timeout: Specifies the timeout for WAF to connect to the origin server. The unit is second.
               Valid value ranges from `0` to `180`.
        :param _builtins.int read_timeout: Specifies the timeout for WAF to receive responses from the origin server.
               The unit is second. Valid value ranges from `0` to `3,600`.
        :param _builtins.int write_timeout: Specifies the timeout for WAF to send requests to the origin server. The unit is second.
               Valid value ranges from `0` to `3,600`.
               
               <a name="DedicatedDomain_traffic_mark"></a>
               The `traffic_mark` block supports:
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if write_timeout is not None:
            pulumi.set(__self__, "write_timeout", write_timeout)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the timeout for WAF to connect to the origin server. The unit is second.
        Valid value ranges from `0` to `180`.
        """
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the timeout for WAF to receive responses from the origin server.
        The unit is second. Valid value ranges from `0` to `3,600`.
        """
        return pulumi.get(self, "read_timeout")

    @_builtins.property
    @pulumi.getter(name="writeTimeout")
    def write_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the timeout for WAF to send requests to the origin server. The unit is second.
        Valid value ranges from `0` to `3,600`.

        <a name="DedicatedDomain_traffic_mark"></a>
        The `traffic_mark` block supports:
        """
        return pulumi.get(self, "write_timeout")


@pulumi.output_type
class DedicatedDomainTrafficMark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipTags":
            suggest = "ip_tags"
        elif key == "sessionTag":
            suggest = "session_tag"
        elif key == "userTag":
            suggest = "user_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DedicatedDomainTrafficMark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DedicatedDomainTrafficMark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DedicatedDomainTrafficMark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_tags: Optional[Sequence[_builtins.str]] = None,
                 session_tag: Optional[_builtins.str] = None,
                 user_tag: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] ip_tags: Specifies the IP tags. HTTP request header field of the original client IP address.
               This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
               configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
               address list in order. Note:
               + If you want to use a TCP connection IP address as the client IP address, set IP Tag to `$remote_addr`.
               + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the `cdn-src-ip`,
               `x-real-ip`, `x-forwarded-for` and `$remote_addr` fields in sequence to read the client IP address.
        :param _builtins.str session_tag: Specifies the session tag. This tag is used by known attack source rules to block
               malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
               requests based on cookie attributes.
        :param _builtins.str user_tag: Specifies the user tag. This tag is used by known attack source rules to block malicious
               attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if session_tag is not None:
            pulumi.set(__self__, "session_tag", session_tag)
        if user_tag is not None:
            pulumi.set(__self__, "user_tag", user_tag)

    @_builtins.property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the IP tags. HTTP request header field of the original client IP address.
        This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
        configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
        address list in order. Note:
        + If you want to use a TCP connection IP address as the client IP address, set IP Tag to `$remote_addr`.
        + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the `cdn-src-ip`,
        `x-real-ip`, `x-forwarded-for` and `$remote_addr` fields in sequence to read the client IP address.
        """
        return pulumi.get(self, "ip_tags")

    @_builtins.property
    @pulumi.getter(name="sessionTag")
    def session_tag(self) -> Optional[_builtins.str]:
        """
        Specifies the session tag. This tag is used by known attack source rules to block
        malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
        requests based on cookie attributes.
        """
        return pulumi.get(self, "session_tag")

    @_builtins.property
    @pulumi.getter(name="userTag")
    def user_tag(self) -> Optional[_builtins.str]:
        """
        Specifies the user tag. This tag is used by known attack source rules to block malicious
        attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        return pulumi.get(self, "user_tag")


@pulumi.output_type
class DomainCustomPage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockPageType":
            suggest = "block_page_type"
        elif key == "httpReturnCode":
            suggest = "http_return_code"
        elif key == "pageContent":
            suggest = "page_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainCustomPage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainCustomPage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainCustomPage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_page_type: _builtins.str,
                 http_return_code: _builtins.str,
                 page_content: _builtins.str):
        """
        :param _builtins.str block_page_type: Specifies the content type of the custom alarm page.
               The value can be **text/html**, **text/xml** or **application/json**.
        :param _builtins.str http_return_code: Specifies the HTTP return code.
               The value can be a positive integer in the range of `200` to `599` except `408`, `444` and `499`.
        :param _builtins.str page_content: Specifies the page content. The page content based on the selected page type.
               The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
               can be available.
               
               <a name="Domain_timeout_settings"></a>
               The `timeout_settings` block supports:
        """
        pulumi.set(__self__, "block_page_type", block_page_type)
        pulumi.set(__self__, "http_return_code", http_return_code)
        pulumi.set(__self__, "page_content", page_content)

    @_builtins.property
    @pulumi.getter(name="blockPageType")
    def block_page_type(self) -> _builtins.str:
        """
        Specifies the content type of the custom alarm page.
        The value can be **text/html**, **text/xml** or **application/json**.
        """
        return pulumi.get(self, "block_page_type")

    @_builtins.property
    @pulumi.getter(name="httpReturnCode")
    def http_return_code(self) -> _builtins.str:
        """
        Specifies the HTTP return code.
        The value can be a positive integer in the range of `200` to `599` except `408`, `444` and `499`.
        """
        return pulumi.get(self, "http_return_code")

    @_builtins.property
    @pulumi.getter(name="pageContent")
    def page_content(self) -> _builtins.str:
        """
        Specifies the page content. The page content based on the selected page type.
        The available **${waf_event_id}** in the page content indicates an event ID, and only one **${waf_event_id}** variable
        can be available.

        <a name="Domain_timeout_settings"></a>
        The `timeout_settings` block supports:
        """
        return pulumi.get(self, "page_content")


@pulumi.output_type
class DomainServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProtocol":
            suggest = "client_protocol"
        elif key == "serverProtocol":
            suggest = "server_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 client_protocol: _builtins.str,
                 port: _builtins.int,
                 server_protocol: _builtins.str,
                 type: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str address: Specifies the IP address or domain name of the web server that the client accesses.
        :param _builtins.str client_protocol: Specifies the protocol type of the client. The options include **HTTP** and **HTTPS**.
        :param _builtins.int port: Specifies the port number used by the web server. The value ranges from `0` to `65,535`,
               for example, `8,080`.
        :param _builtins.str server_protocol: Specifies the protocol used by WAF to forward client requests to the server.
               The options include **HTTP** and **HTTPS**.
        :param _builtins.str type: Specifies the server network type. Valid values are: **ipv4** and **ipv6**.
               + When this field is set to **ipv4**, `address` must be set to an IPv4 address.
               + When this field is set to **ipv6**, `address` must be set to an IPv6 address.
        :param _builtins.int weight: Specifies the load balancing algorithm will assign requests to the origin
               site according to this weight.
               Defaults to `1`.
               
               <a name="Domain_custom_page"></a>
               The `custom_page` block supports:
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "client_protocol", client_protocol)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server_protocol", server_protocol)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Specifies the IP address or domain name of the web server that the client accesses.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="clientProtocol")
    def client_protocol(self) -> _builtins.str:
        """
        Specifies the protocol type of the client. The options include **HTTP** and **HTTPS**.
        """
        return pulumi.get(self, "client_protocol")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Specifies the port number used by the web server. The value ranges from `0` to `65,535`,
        for example, `8,080`.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="serverProtocol")
    def server_protocol(self) -> _builtins.str:
        """
        Specifies the protocol used by WAF to forward client requests to the server.
        The options include **HTTP** and **HTTPS**.
        """
        return pulumi.get(self, "server_protocol")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the server network type. Valid values are: **ipv4** and **ipv6**.
        + When this field is set to **ipv4**, `address` must be set to an IPv4 address.
        + When this field is set to **ipv6**, `address` must be set to an IPv6 address.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Specifies the load balancing algorithm will assign requests to the origin
        site according to this weight.
        Defaults to `1`.

        <a name="Domain_custom_page"></a>
        The `custom_page` block supports:
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DomainTimeoutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTimeout":
            suggest = "connection_timeout"
        elif key == "readTimeout":
            suggest = "read_timeout"
        elif key == "writeTimeout":
            suggest = "write_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainTimeoutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainTimeoutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainTimeoutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_timeout: Optional[_builtins.int] = None,
                 read_timeout: Optional[_builtins.int] = None,
                 write_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int connection_timeout: Specifies the timeout for WAF to connect to the origin server. The unit is second.
               Valid value ranges from `0` to `180`.
        :param _builtins.int read_timeout: Specifies the timeout for WAF to receive responses from the origin server.
               The unit is second. Valid value ranges from `0` to `3,600`.
        :param _builtins.int write_timeout: Specifies the timeout for WAF to send requests to the origin server. The unit is second.
               Valid value ranges from `0` to `3,600`.
               
               <a name="Domain_traffic_mark"></a>
               The `traffic_mark` block supports:
        """
        if connection_timeout is not None:
            pulumi.set(__self__, "connection_timeout", connection_timeout)
        if read_timeout is not None:
            pulumi.set(__self__, "read_timeout", read_timeout)
        if write_timeout is not None:
            pulumi.set(__self__, "write_timeout", write_timeout)

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the timeout for WAF to connect to the origin server. The unit is second.
        Valid value ranges from `0` to `180`.
        """
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the timeout for WAF to receive responses from the origin server.
        The unit is second. Valid value ranges from `0` to `3,600`.
        """
        return pulumi.get(self, "read_timeout")

    @_builtins.property
    @pulumi.getter(name="writeTimeout")
    def write_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the timeout for WAF to send requests to the origin server. The unit is second.
        Valid value ranges from `0` to `3,600`.

        <a name="Domain_traffic_mark"></a>
        The `traffic_mark` block supports:
        """
        return pulumi.get(self, "write_timeout")


@pulumi.output_type
class DomainTrafficMark(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipTags":
            suggest = "ip_tags"
        elif key == "sessionTag":
            suggest = "session_tag"
        elif key == "userTag":
            suggest = "user_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainTrafficMark. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainTrafficMark.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainTrafficMark.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_tags: Optional[Sequence[_builtins.str]] = None,
                 session_tag: Optional[_builtins.str] = None,
                 user_tag: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] ip_tags: Specifies the IP tags. HTTP request header field of the original client IP address.
               This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
               configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
               address list in order. Note:
               + If you want to use a TCP connection IP address as the client IP address, set IP Tag to **$remote_addr**.
               + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the **cdn-src-ip**,
               **x-real-ip**, **x-forwarded-for** and **$remote_addr** fields in sequence to read the client IP address.
               + When the website setting `proxy` is configured as **false**, this field does not take effect,
               and the client IP is only obtained through the `$remote_addr` field.
        :param _builtins.str session_tag: Specifies the session tag. This tag is used by known attack source rules to block
               malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
               requests based on cookie attributes.
        :param _builtins.str user_tag: Specifies the user tag. This tag is used by known attack source rules to block malicious
               attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        if ip_tags is not None:
            pulumi.set(__self__, "ip_tags", ip_tags)
        if session_tag is not None:
            pulumi.set(__self__, "session_tag", session_tag)
        if user_tag is not None:
            pulumi.set(__self__, "user_tag", user_tag)

    @_builtins.property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the IP tags. HTTP request header field of the original client IP address.
        This field is used to store the real IP address of the client. After the configuration, WAF preferentially reads the
        configured field to obtain the real IP address of the client. If multiple fields are configured, WAF reads the IP
        address list in order. Note:
        + If you want to use a TCP connection IP address as the client IP address, set IP Tag to **$remote_addr**.
        + If WAF does not obtain the real IP address of a client from fields you configure, WAF reads the **cdn-src-ip**,
        **x-real-ip**, **x-forwarded-for** and **$remote_addr** fields in sequence to read the client IP address.
        + When the website setting `proxy` is configured as **false**, this field does not take effect,
        and the client IP is only obtained through the `$remote_addr` field.
        """
        return pulumi.get(self, "ip_tags")

    @_builtins.property
    @pulumi.getter(name="sessionTag")
    def session_tag(self) -> Optional[_builtins.str]:
        """
        Specifies the session tag. This tag is used by known attack source rules to block
        malicious attacks based on cookie attributes. This parameter must be configured in known attack source rules to block
        requests based on cookie attributes.
        """
        return pulumi.get(self, "session_tag")

    @_builtins.property
    @pulumi.getter(name="userTag")
    def user_tag(self) -> Optional[_builtins.str]:
        """
        Specifies the user tag. This tag is used by known attack source rules to block malicious
        attacks based on params attributes. This parameter must be configured to block requests based on the params attributes.
        """
        return pulumi.get(self, "user_tag")


@pulumi.output_type
class PolicyBindHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wafType":
            suggest = "waf_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyBindHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyBindHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyBindHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 waf_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: The domain name.
        :param _builtins.str id: The domain name ID.
        :param _builtins.str mode: The special domain name mode. This attribute is only valid for dedicated mode.
        :param _builtins.str waf_type: The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
               cloud WAF or **premium** for dedicated WAF instances.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if waf_type is not None:
            pulumi.set(__self__, "waf_type", waf_type)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The domain name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The domain name ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The special domain name mode. This attribute is only valid for dedicated mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="wafType")
    def waf_type(self) -> Optional[_builtins.str]:
        """
        The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
        cloud WAF or **premium** for dedicated WAF instances.
        """
        return pulumi.get(self, "waf_type")


@pulumi.output_type
class PolicyOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "antiCrawler":
            suggest = "anti_crawler"
        elif key == "basicWebProtection":
            suggest = "basic_web_protection"
        elif key == "botEnable":
            suggest = "bot_enable"
        elif key == "ccAttackProtection":
            suggest = "cc_attack_protection"
        elif key == "crawlerEngine":
            suggest = "crawler_engine"
        elif key == "crawlerOther":
            suggest = "crawler_other"
        elif key == "crawlerScanner":
            suggest = "crawler_scanner"
        elif key == "crawlerScript":
            suggest = "crawler_script"
        elif key == "dataMasking":
            suggest = "data_masking"
        elif key == "falseAlarmMasking":
            suggest = "false_alarm_masking"
        elif key == "generalCheck":
            suggest = "general_check"
        elif key == "geolocationAccessControl":
            suggest = "geolocation_access_control"
        elif key == "informationLeakagePrevention":
            suggest = "information_leakage_prevention"
        elif key == "knownAttackSource":
            suggest = "known_attack_source"
        elif key == "preciseProtection":
            suggest = "precise_protection"
        elif key == "webTamperProtection":
            suggest = "web_tamper_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anti_crawler: Optional[_builtins.bool] = None,
                 basic_web_protection: Optional[_builtins.bool] = None,
                 blacklist: Optional[_builtins.bool] = None,
                 bot_enable: Optional[_builtins.bool] = None,
                 cc_attack_protection: Optional[_builtins.bool] = None,
                 crawler: Optional[_builtins.bool] = None,
                 crawler_engine: Optional[_builtins.bool] = None,
                 crawler_other: Optional[_builtins.bool] = None,
                 crawler_scanner: Optional[_builtins.bool] = None,
                 crawler_script: Optional[_builtins.bool] = None,
                 data_masking: Optional[_builtins.bool] = None,
                 false_alarm_masking: Optional[_builtins.bool] = None,
                 general_check: Optional[_builtins.bool] = None,
                 geolocation_access_control: Optional[_builtins.bool] = None,
                 information_leakage_prevention: Optional[_builtins.bool] = None,
                 known_attack_source: Optional[_builtins.bool] = None,
                 precise_protection: Optional[_builtins.bool] = None,
                 web_tamper_protection: Optional[_builtins.bool] = None,
                 webshell: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool anti_crawler: Specifies whether the javascript anti-crawler is enabled. Defaults to **false**.
        :param _builtins.bool basic_web_protection: Specifies whether basic web protection is enabled. Defaults to **false**.
        :param _builtins.bool blacklist: Specifies whether the blacklist and whitelist protection is enabled.
               Defaults to **false**.
        :param _builtins.bool bot_enable: Specifies whether the anti-crawler protection is enabled. Defaults to **false**.
        :param _builtins.bool cc_attack_protection: Specifies whether the cc attack protection rules are enabled.
               Defaults to **false**.
        :param _builtins.bool crawler: schema: Deprecated
        :param _builtins.bool crawler_engine: Specifies whether the search engine is enabled. Defaults to **false**.
        :param _builtins.bool crawler_other: Specifies whether other crawler check is enabled. Defaults to **false**.
        :param _builtins.bool crawler_scanner: Specifies whether the anti-crawler detection is enabled. Defaults to **false**.
        :param _builtins.bool crawler_script: Specifies whether the script tool is enabled. Defaults to **false**.
        :param _builtins.bool data_masking: Specifies whether data masking is enabled. Defaults to **false**.
        :param _builtins.bool false_alarm_masking: Specifies whether false alarm masking is enabled. Defaults to **false**.
        :param _builtins.bool general_check: Specifies whether the general check in basic web protection is enabled.
               Defaults to **false**.
        :param _builtins.bool geolocation_access_control: Specifies whether the geolocation access control is enabled.
               Defaults to **false**.
        :param _builtins.bool information_leakage_prevention: Specifies whether the information leakage prevention is enabled.
               Defaults to **false**.
        :param _builtins.bool known_attack_source: Specifies whether the known attack source is enabled. Defaults to **false**.
        :param _builtins.bool precise_protection: Specifies whether the precise protection is enabled. Defaults to **false**.
        :param _builtins.bool web_tamper_protection: Specifies whether the web tamper protection is enabled.
               Defaults to **false**.
        :param _builtins.bool webshell: Specifies whether the web shell detection in basic web protection is enabled.
               Defaults to **false**.
        """
        if anti_crawler is not None:
            pulumi.set(__self__, "anti_crawler", anti_crawler)
        if basic_web_protection is not None:
            pulumi.set(__self__, "basic_web_protection", basic_web_protection)
        if blacklist is not None:
            pulumi.set(__self__, "blacklist", blacklist)
        if bot_enable is not None:
            pulumi.set(__self__, "bot_enable", bot_enable)
        if cc_attack_protection is not None:
            pulumi.set(__self__, "cc_attack_protection", cc_attack_protection)
        if crawler is not None:
            pulumi.set(__self__, "crawler", crawler)
        if crawler_engine is not None:
            pulumi.set(__self__, "crawler_engine", crawler_engine)
        if crawler_other is not None:
            pulumi.set(__self__, "crawler_other", crawler_other)
        if crawler_scanner is not None:
            pulumi.set(__self__, "crawler_scanner", crawler_scanner)
        if crawler_script is not None:
            pulumi.set(__self__, "crawler_script", crawler_script)
        if data_masking is not None:
            pulumi.set(__self__, "data_masking", data_masking)
        if false_alarm_masking is not None:
            pulumi.set(__self__, "false_alarm_masking", false_alarm_masking)
        if general_check is not None:
            pulumi.set(__self__, "general_check", general_check)
        if geolocation_access_control is not None:
            pulumi.set(__self__, "geolocation_access_control", geolocation_access_control)
        if information_leakage_prevention is not None:
            pulumi.set(__self__, "information_leakage_prevention", information_leakage_prevention)
        if known_attack_source is not None:
            pulumi.set(__self__, "known_attack_source", known_attack_source)
        if precise_protection is not None:
            pulumi.set(__self__, "precise_protection", precise_protection)
        if web_tamper_protection is not None:
            pulumi.set(__self__, "web_tamper_protection", web_tamper_protection)
        if webshell is not None:
            pulumi.set(__self__, "webshell", webshell)

    @_builtins.property
    @pulumi.getter(name="antiCrawler")
    def anti_crawler(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the javascript anti-crawler is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "anti_crawler")

    @_builtins.property
    @pulumi.getter(name="basicWebProtection")
    def basic_web_protection(self) -> Optional[_builtins.bool]:
        """
        Specifies whether basic web protection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "basic_web_protection")

    @_builtins.property
    @pulumi.getter
    def blacklist(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the blacklist and whitelist protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "blacklist")

    @_builtins.property
    @pulumi.getter(name="botEnable")
    def bot_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the anti-crawler protection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "bot_enable")

    @_builtins.property
    @pulumi.getter(name="ccAttackProtection")
    def cc_attack_protection(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the cc attack protection rules are enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "cc_attack_protection")

    @_builtins.property
    @pulumi.getter
    def crawler(self) -> Optional[_builtins.bool]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "crawler")

    @_builtins.property
    @pulumi.getter(name="crawlerEngine")
    def crawler_engine(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the search engine is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_engine")

    @_builtins.property
    @pulumi.getter(name="crawlerOther")
    def crawler_other(self) -> Optional[_builtins.bool]:
        """
        Specifies whether other crawler check is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_other")

    @_builtins.property
    @pulumi.getter(name="crawlerScanner")
    def crawler_scanner(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the anti-crawler detection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_scanner")

    @_builtins.property
    @pulumi.getter(name="crawlerScript")
    def crawler_script(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the script tool is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "crawler_script")

    @_builtins.property
    @pulumi.getter(name="dataMasking")
    def data_masking(self) -> Optional[_builtins.bool]:
        """
        Specifies whether data masking is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "data_masking")

    @_builtins.property
    @pulumi.getter(name="falseAlarmMasking")
    def false_alarm_masking(self) -> Optional[_builtins.bool]:
        """
        Specifies whether false alarm masking is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "false_alarm_masking")

    @_builtins.property
    @pulumi.getter(name="generalCheck")
    def general_check(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the general check in basic web protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "general_check")

    @_builtins.property
    @pulumi.getter(name="geolocationAccessControl")
    def geolocation_access_control(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the geolocation access control is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "geolocation_access_control")

    @_builtins.property
    @pulumi.getter(name="informationLeakagePrevention")
    def information_leakage_prevention(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the information leakage prevention is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "information_leakage_prevention")

    @_builtins.property
    @pulumi.getter(name="knownAttackSource")
    def known_attack_source(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the known attack source is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "known_attack_source")

    @_builtins.property
    @pulumi.getter(name="preciseProtection")
    def precise_protection(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the precise protection is enabled. Defaults to **false**.
        """
        return pulumi.get(self, "precise_protection")

    @_builtins.property
    @pulumi.getter(name="webTamperProtection")
    def web_tamper_protection(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the web tamper protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "web_tamper_protection")

    @_builtins.property
    @pulumi.getter
    def webshell(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the web shell detection in basic web protection is enabled.
        Defaults to **false**.
        """
        return pulumi.get(self, "webshell")


@pulumi.output_type
class RuleAntiCrawlerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceTableId":
            suggest = "reference_table_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleAntiCrawlerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleAntiCrawlerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleAntiCrawlerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: _builtins.str,
                 logic: _builtins.str,
                 content: Optional[_builtins.str] = None,
                 reference_table_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Specifies the field type. The valid values are **url** and **user-agent**.
        :param _builtins.str logic: Specifies the logic for matching the condition. The valid values are **contain**,
               **not_contain**, **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
               **not_contain_all**, **equal_any**, **not_equal_all**, **prefix_any**, **not_prefix_all**, **suffix_any** and
               **not_suffix_all**.
        :param _builtins.str content: Specifies the content of the condition.
               It is valid and required when the `logic` does not end with `any` or `all`.
        :param _builtins.str reference_table_id: Specifies the reference table ID.
               It is valid and required when the `logic` end with `any` or `all`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if reference_table_id is not None:
            pulumi.set(__self__, "reference_table_id", reference_table_id)

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Specifies the field type. The valid values are **url** and **user-agent**.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        Specifies the logic for matching the condition. The valid values are **contain**,
        **not_contain**, **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
        **not_contain_all**, **equal_any**, **not_equal_all**, **prefix_any**, **not_prefix_all**, **suffix_any** and
        **not_suffix_all**.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Specifies the content of the condition.
        It is valid and required when the `logic` does not end with `any` or `all`.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="referenceTableId")
    def reference_table_id(self) -> Optional[_builtins.str]:
        """
        Specifies the reference table ID.
        It is valid and required when the `logic` end with `any` or `all`.
        """
        return pulumi.get(self, "reference_table_id")


@pulumi.output_type
class RuleCcProtectionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceTableId":
            suggest = "reference_table_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleCcProtectionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleCcProtectionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleCcProtectionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: _builtins.str,
                 logic: _builtins.str,
                 content: Optional[_builtins.str] = None,
                 reference_table_id: Optional[_builtins.str] = None,
                 subfield: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Specifies the field type.
               The value can be **url**, **ip**, **ipv6**, **params**, **cookie**, **header** or **response_code**.
        :param _builtins.str logic: Specifies the condition matching logic.
               
               + If `field` is set to **url**: Valid values are **contain**, **not_contain**, **equal**, **not_equal**, **prefix**,
               **not_prefix**, **suffix**, **not_suffix**, **contain_any**, **not_contain_all**, **equal_any**, **not_equal_all**,
               **equal_any**, **not_equal_all**, **prefix_any**, **not_prefix_all**, **suffix_any**, **not_suffix_all**,
               **len_greater**, **len_less**, **len_equal** and **len_not_equal**.
               
               + If `field` is set to **ip** or **ipv6**: Valid values are **equal**, **not_equal**, **equal_any** and
               **not_equal_all**.
               
               + If `field` is set to **response_code**: Valid values are **equal** and **not_equal**.
               
               + If `field` is set to **params**, **cookie** or **header**: Valid values are **contain**, **not_contain**,
               **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
               **not_contain_all**, **equal_any**, **not_equal_all**, **equal_any**, **not_equal_all**, **prefix_any**,
               **not_prefix_all**, **suffix_any**, **not_suffix_all**, **len_greater**, **len_less**, **len_equal**,
               **len_not_equal**, **num_greater**, **num_less**, **num_equal**, **num_not_equal**, **exist** and **not_exist**.
        :param _builtins.str content: Specifies the content of the match condition.
               It is required when the `logic` does not end with **any** or **all**.
        :param _builtins.str reference_table_id: Specifies the reference table ID.
               It is required when the `logic` end with **any** or **all**.
        :param _builtins.str subfield: Specifies the subfield of the condition.
               It is required when `field` is set to **params**, **header** or **cookie**.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if reference_table_id is not None:
            pulumi.set(__self__, "reference_table_id", reference_table_id)
        if subfield is not None:
            pulumi.set(__self__, "subfield", subfield)

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Specifies the field type.
        The value can be **url**, **ip**, **ipv6**, **params**, **cookie**, **header** or **response_code**.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        Specifies the condition matching logic.

        + If `field` is set to **url**: Valid values are **contain**, **not_contain**, **equal**, **not_equal**, **prefix**,
        **not_prefix**, **suffix**, **not_suffix**, **contain_any**, **not_contain_all**, **equal_any**, **not_equal_all**,
        **equal_any**, **not_equal_all**, **prefix_any**, **not_prefix_all**, **suffix_any**, **not_suffix_all**,
        **len_greater**, **len_less**, **len_equal** and **len_not_equal**.

        + If `field` is set to **ip** or **ipv6**: Valid values are **equal**, **not_equal**, **equal_any** and
        **not_equal_all**.

        + If `field` is set to **response_code**: Valid values are **equal** and **not_equal**.

        + If `field` is set to **params**, **cookie** or **header**: Valid values are **contain**, **not_contain**,
        **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
        **not_contain_all**, **equal_any**, **not_equal_all**, **equal_any**, **not_equal_all**, **prefix_any**,
        **not_prefix_all**, **suffix_any**, **not_suffix_all**, **len_greater**, **len_less**, **len_equal**,
        **len_not_equal**, **num_greater**, **num_less**, **num_equal**, **num_not_equal**, **exist** and **not_exist**.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Specifies the content of the match condition.
        It is required when the `logic` does not end with **any** or **all**.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="referenceTableId")
    def reference_table_id(self) -> Optional[_builtins.str]:
        """
        Specifies the reference table ID.
        It is required when the `logic` end with **any** or **all**.
        """
        return pulumi.get(self, "reference_table_id")

    @_builtins.property
    @pulumi.getter
    def subfield(self) -> Optional[_builtins.str]:
        """
        Specifies the subfield of the condition.
        It is required when `field` is set to **params**, **header** or **cookie**.
        """
        return pulumi.get(self, "subfield")


@pulumi.output_type
class RuleGlobalProtectionWhitelistCondition(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 field: _builtins.str,
                 logic: _builtins.str,
                 subfield: Optional[_builtins.str] = None):
        """
        :param _builtins.str content: Specifies the content of the match condition.
               
               + If `field` is set to **ip**, the value must be an IP address or IP address range.
               
               + If `field` is set to **url**, the value must be in the standard URL format.
               
               + If `field` is set to **params** or **cookie** or **header**, the content format is not limited.
        :param _builtins.str field: Specifies the field type. The value can be **ip**, **url**, **params**, **cookie**
               or **header**.
        :param _builtins.str logic: Specifies the condition matching logic.
               
               + If `field` is set to **ip**: Valid values are **equal** and **not_equal**.
               
               + If `field` is set to **url** or **header** or **params** or **cookie**: Valid values are **equal**, **not_equal**,
               **contain**, **not_contain**, **prefix**, **not_prefix**, **suffix** and **not_suffix**.
        :param _builtins.str subfield: Specifies the subfield of the condition.
               
               + If `field` is set to **ip** and the subfield is the client IP address, the parameter is not required.
               
               + If `field` is set to **ip** and the subfield is X-Forwarded-For, the parameter is required and the value should be
               **x-forwarded-for**.
               
               + If `field` is set to **params**, **header** or **cookie**, the parameter is required and the value is user-defined.
               
               + If `field` is set to **url**, the parameter cannot be specified.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        if subfield is not None:
            pulumi.set(__self__, "subfield", subfield)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Specifies the content of the match condition.

        + If `field` is set to **ip**, the value must be an IP address or IP address range.

        + If `field` is set to **url**, the value must be in the standard URL format.

        + If `field` is set to **params** or **cookie** or **header**, the content format is not limited.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Specifies the field type. The value can be **ip**, **url**, **params**, **cookie**
        or **header**.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        Specifies the condition matching logic.

        + If `field` is set to **ip**: Valid values are **equal** and **not_equal**.

        + If `field` is set to **url** or **header** or **params** or **cookie**: Valid values are **equal**, **not_equal**,
        **contain**, **not_contain**, **prefix**, **not_prefix**, **suffix** and **not_suffix**.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter
    def subfield(self) -> Optional[_builtins.str]:
        """
        Specifies the subfield of the condition.

        + If `field` is set to **ip** and the subfield is the client IP address, the parameter is not required.

        + If `field` is set to **ip** and the subfield is X-Forwarded-For, the parameter is required and the value should be
        **x-forwarded-for**.

        + If `field` is set to **params**, **header** or **cookie**, the parameter is required and the value is user-defined.

        + If `field` is set to **url**, the parameter cannot be specified.
        """
        return pulumi.get(self, "subfield")


@pulumi.output_type
class RulePreciseProtectionCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceTableId":
            suggest = "reference_table_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulePreciseProtectionCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulePreciseProtectionCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulePreciseProtectionCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: _builtins.str,
                 logic: _builtins.str,
                 content: Optional[_builtins.str] = None,
                 reference_table_id: Optional[_builtins.str] = None,
                 subfield: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Specifies the field of the condition. Valid values are **url**, **user-agent**,
               **referer**, **ip**, **method**, **request_line**, **request**, **params**, **cookie**, **header**.
        :param _builtins.str logic: Specifies the condition matching logic.
               
               + If `field` is set to **url** or **user-agent** or **referer**: Valid values are **contain**, **not_contain**,
               **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
               **not_contain_all**, **equal_any**, **not_equal_all**, **equal_any**, **not_equal_all**, **prefix_any**,
               **not_prefix_all**, **suffix_any**, **not_suffix_all**, **len_greater**, **len_less**, **len_equal**,
               **len_not_equal**.
               
               + If `field` is set to **ip**: Valid values are **equal**, **not_equal**, **equal_any**, **not_equal_all**.
               
               + If `field` is set to **method**: Valid values are **equal**, **not_equal**.
               
               + If `field` is set to **request_line** or **request**: Valid values are **len_greater**, **len_less**, **len_equal**,
               **len_not_equal**.
               
               + If `field` is set to **params** or **cookie** or **header**: Valid values are **contain**, **not_contain**,
               **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
               **not_contain_all**, **equal_any**, **not_equal_all**, **equal_any**, **not_equal_all**, **prefix_any**,
               **not_prefix_all**, **suffix_any**, **not_suffix_all**, **len_greater**, **len_less**, **len_equal**,
               **len_not_equal**, **num_greater**, **num_less**, **num_equal**, **num_not_equal**, **exist**, **not_exist**.
        :param _builtins.str content: Specifies the content of the match condition. It is required when the `logic`
               does not end with **any** or **all**.
        :param _builtins.str reference_table_id: Specifies the reference table id. It is required when the `logic`
               end with **any** or **all**. The type of reference table should be consistent with the type of `field`.
        :param _builtins.str subfield: Specifies the subfield of the condition. The parameter is required when `field`
               is set to **params**, **header** and **cookie**.
               
               + If `field` is set to **cookie**: The parameter indicates cookie name.
               
               + If `field` is set to **params**: The parameter indicates param name.
               
               + If `field` is set to **header**: The parameter indicates an option in the header.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if reference_table_id is not None:
            pulumi.set(__self__, "reference_table_id", reference_table_id)
        if subfield is not None:
            pulumi.set(__self__, "subfield", subfield)

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Specifies the field of the condition. Valid values are **url**, **user-agent**,
        **referer**, **ip**, **method**, **request_line**, **request**, **params**, **cookie**, **header**.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        Specifies the condition matching logic.

        + If `field` is set to **url** or **user-agent** or **referer**: Valid values are **contain**, **not_contain**,
        **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
        **not_contain_all**, **equal_any**, **not_equal_all**, **equal_any**, **not_equal_all**, **prefix_any**,
        **not_prefix_all**, **suffix_any**, **not_suffix_all**, **len_greater**, **len_less**, **len_equal**,
        **len_not_equal**.

        + If `field` is set to **ip**: Valid values are **equal**, **not_equal**, **equal_any**, **not_equal_all**.

        + If `field` is set to **method**: Valid values are **equal**, **not_equal**.

        + If `field` is set to **request_line** or **request**: Valid values are **len_greater**, **len_less**, **len_equal**,
        **len_not_equal**.

        + If `field` is set to **params** or **cookie** or **header**: Valid values are **contain**, **not_contain**,
        **equal**, **not_equal**, **prefix**, **not_prefix**, **suffix**, **not_suffix**, **contain_any**,
        **not_contain_all**, **equal_any**, **not_equal_all**, **equal_any**, **not_equal_all**, **prefix_any**,
        **not_prefix_all**, **suffix_any**, **not_suffix_all**, **len_greater**, **len_less**, **len_equal**,
        **len_not_equal**, **num_greater**, **num_less**, **num_equal**, **num_not_equal**, **exist**, **not_exist**.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        Specifies the content of the match condition. It is required when the `logic`
        does not end with **any** or **all**.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="referenceTableId")
    def reference_table_id(self) -> Optional[_builtins.str]:
        """
        Specifies the reference table id. It is required when the `logic`
        end with **any** or **all**. The type of reference table should be consistent with the type of `field`.
        """
        return pulumi.get(self, "reference_table_id")

    @_builtins.property
    @pulumi.getter
    def subfield(self) -> Optional[_builtins.str]:
        """
        Specifies the subfield of the condition. The parameter is required when `field`
        is set to **params**, **header** and **cookie**.

        + If `field` is set to **cookie**: The parameter indicates cookie name.

        + If `field` is set to **params**: The parameter indicates param name.

        + If `field` is set to **header**: The parameter indicates an option in the header.
        """
        return pulumi.get(self, "subfield")


@pulumi.output_type
class GetAddressGroupsGroupResult(dict):
    def __init__(__self__, *,
                 accept_count: _builtins.int,
                 description: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 ip_addresses: _builtins.str,
                 name: _builtins.str,
                 process_status: _builtins.int,
                 rules: Sequence['outputs.GetAddressGroupsGroupRuleResult'],
                 share_count: _builtins.int):
        """
        :param _builtins.int accept_count: The number of the users accept the sharing.
        :param _builtins.str description: The description of the address group.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID.
               For enterprise users, if omitted, default enterprise project will be used.
        :param _builtins.str id: The WAF address group ID.
        :param _builtins.str ip_addresses: The IP addresses or IP address ranges.
        :param _builtins.str name: Specifies the name of the address group. Fuzzy search is supported.
        :param _builtins.int process_status: The status of processing.
        :param Sequence['GetAddressGroupsGroupRuleArgs'] rules: The list of rules that use the IP address group.
        :param _builtins.int share_count: The total number of the users share the address group.
        """
        pulumi.set(__self__, "accept_count", accept_count)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "process_status", process_status)
        pulumi.set(__self__, "rules", rules)
        pulumi.set(__self__, "share_count", share_count)

    @_builtins.property
    @pulumi.getter(name="acceptCount")
    def accept_count(self) -> _builtins.int:
        """
        The number of the users accept the sharing.
        """
        return pulumi.get(self, "accept_count")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the address group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID.
        For enterprise users, if omitted, default enterprise project will be used.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The WAF address group ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> _builtins.str:
        """
        The IP addresses or IP address ranges.
        """
        return pulumi.get(self, "ip_addresses")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the address group. Fuzzy search is supported.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="processStatus")
    def process_status(self) -> _builtins.int:
        """
        The status of processing.
        """
        return pulumi.get(self, "process_status")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetAddressGroupsGroupRuleResult']:
        """
        The list of rules that use the IP address group.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter(name="shareCount")
    def share_count(self) -> _builtins.int:
        """
        The total number of the users share the address group.
        """
        return pulumi.get(self, "share_count")


@pulumi.output_type
class GetAddressGroupsGroupRuleResult(dict):
    def __init__(__self__, *,
                 policy_id: _builtins.str,
                 policy_name: _builtins.str,
                 rule_id: _builtins.str,
                 rule_name: _builtins.str):
        """
        :param _builtins.str policy_id: The ID of policy.
        :param _builtins.str policy_name: The name of policy.
        :param _builtins.str rule_id: The ID of rule.
        :param _builtins.str rule_name: The name of rule.
        """
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_name", policy_name)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "rule_name", rule_name)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        The ID of policy.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> _builtins.str:
        """
        The name of policy.
        """
        return pulumi.get(self, "policy_name")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.str:
        """
        The ID of rule.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> _builtins.str:
        """
        The name of rule.
        """
        return pulumi.get(self, "rule_name")


@pulumi.output_type
class GetAlarmNotificationsItemResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 is_all_enterprise_project: _builtins.bool,
                 locale: _builtins.str,
                 name: _builtins.str,
                 nearly_expired_time: _builtins.str,
                 notice_class: _builtins.str,
                 sendfreq: _builtins.int,
                 threats: Sequence[_builtins.str],
                 times: _builtins.int,
                 topic_urn: _builtins.str,
                 update_time: _builtins.int):
        """
        :param _builtins.bool enabled: Whether to enable the  alarm notification.
               The value can be **true** or  **false**.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID to which the alarm notification
               belongs.
        :param _builtins.str id: The ID of the alarm notification.
        :param _builtins.bool is_all_enterprise_project: Whether all enterprise projects are involved.
        :param _builtins.str locale: The language type.
        :param _builtins.str name: The name of the alarm notification.
        :param _builtins.str nearly_expired_time: The advance notification days.
        :param _builtins.str notice_class: The type of the  alarm notification.
        :param _builtins.int sendfreq: The alarm frequency of the alarm notification, in minutes.
        :param Sequence[_builtins.str] threats: The type of the event which triggered the alarm.
        :param _builtins.int times: The alarm times of the notification alarm.
        :param _builtins.str topic_urn: The theme URN of the SMN associated with the alarm notification.
        :param _builtins.int update_time: The latest update time of the alarm notification.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_all_enterprise_project", is_all_enterprise_project)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nearly_expired_time", nearly_expired_time)
        pulumi.set(__self__, "notice_class", notice_class)
        pulumi.set(__self__, "sendfreq", sendfreq)
        pulumi.set(__self__, "threats", threats)
        pulumi.set(__self__, "times", times)
        pulumi.set(__self__, "topic_urn", topic_urn)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable the  alarm notification.
        The value can be **true** or  **false**.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID to which the alarm notification
        belongs.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the alarm notification.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isAllEnterpriseProject")
    def is_all_enterprise_project(self) -> _builtins.bool:
        """
        Whether all enterprise projects are involved.
        """
        return pulumi.get(self, "is_all_enterprise_project")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> _builtins.str:
        """
        The language type.
        """
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the alarm notification.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nearlyExpiredTime")
    def nearly_expired_time(self) -> _builtins.str:
        """
        The advance notification days.
        """
        return pulumi.get(self, "nearly_expired_time")

    @_builtins.property
    @pulumi.getter(name="noticeClass")
    def notice_class(self) -> _builtins.str:
        """
        The type of the  alarm notification.
        """
        return pulumi.get(self, "notice_class")

    @_builtins.property
    @pulumi.getter
    def sendfreq(self) -> _builtins.int:
        """
        The alarm frequency of the alarm notification, in minutes.
        """
        return pulumi.get(self, "sendfreq")

    @_builtins.property
    @pulumi.getter
    def threats(self) -> Sequence[_builtins.str]:
        """
        The type of the event which triggered the alarm.
        """
        return pulumi.get(self, "threats")

    @_builtins.property
    @pulumi.getter
    def times(self) -> _builtins.int:
        """
        The alarm times of the notification alarm.
        """
        return pulumi.get(self, "times")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        The theme URN of the SMN associated with the alarm notification.
        """
        return pulumi.get(self, "topic_urn")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.int:
        """
        The latest update time of the alarm notification.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetAllDomainsItemResult(dict):
    def __init__(__self__, *,
                 access_code: _builtins.str,
                 access_progresses: Sequence['outputs.GetAllDomainsItemAccessProgressResult'],
                 access_status: _builtins.int,
                 description: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 flags: Sequence['outputs.GetAllDomainsItemFlagResult'],
                 hostname: _builtins.str,
                 id: _builtins.str,
                 paid_type: _builtins.str,
                 policyid: _builtins.str,
                 premium_waf_instances: Sequence['outputs.GetAllDomainsItemPremiumWafInstanceResult'],
                 protect_status: _builtins.int,
                 proxy: _builtins.bool,
                 region: _builtins.str,
                 servers: Sequence['outputs.GetAllDomainsItemServerResult'],
                 timestamp: _builtins.int,
                 waf_type: _builtins.str,
                 web_tag: _builtins.str):
        """
        :param _builtins.str access_code: The cname prefix.
        :param Sequence['GetAllDomainsItemAccessProgressArgs'] access_progresses: The access progress.
        :param _builtins.int access_status: The domain name access status.
               The valid values are as follows:
        :param _builtins.str description: The description of the domain.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID.
               If you want to query resources under all enterprise projects, set this parameter to **all_granted_eps**.
               Defaults to **0**.
        :param Sequence['GetAllDomainsItemFlagArgs'] flags: The special identifier, which is used on the console.
        :param _builtins.str hostname: Specifies the name of the domain.
        :param _builtins.str id: The ID of the dedicated WAF instance.
        :param _builtins.str paid_type: The package billing mode. The value can be prePaid or postPaid.
               The valid values are as follows:
               + **prePaid**: Indicates yearly/monthly billing.
               + **postPaid**: Indicates pay-per-use billing.
        :param _builtins.str policyid: The ID of the policy.
        :param Sequence['GetAllDomainsItemPremiumWafInstanceArgs'] premium_waf_instances: The list of dedicated WAF instances.
        :param _builtins.int protect_status: Specifies the protection status of the domain.
               The valid values are as follows:
               + `-1`: The WAF protection is bypassed. Requests of the domain are directly sent to the backend server and do not
               pass through WAF.
        :param _builtins.bool proxy: Whether a proxy is used for the domain.
               The valid values are as follows:
               + **false**: No proxy is used.
               + **true**: A proxy is used.
        :param _builtins.str region: Specifies the region in which to query the resource.
               If omitted, the provider-level region will be used.
        :param Sequence['GetAllDomainsItemServerArgs'] servers: The origin server settings of the domain.
        :param _builtins.int timestamp: The creation time of the domain.
        :param _builtins.str waf_type: Specifies the WAF mode of the domain.
               The valid values are as follows:
               + **cloud**: The cloud WAF is used to protect the domain.
               + **premium**: The dedicated WAF instance is used to protect the domain.
        :param _builtins.str web_tag: The website name.
        """
        pulumi.set(__self__, "access_code", access_code)
        pulumi.set(__self__, "access_progresses", access_progresses)
        pulumi.set(__self__, "access_status", access_status)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "paid_type", paid_type)
        pulumi.set(__self__, "policyid", policyid)
        pulumi.set(__self__, "premium_waf_instances", premium_waf_instances)
        pulumi.set(__self__, "protect_status", protect_status)
        pulumi.set(__self__, "proxy", proxy)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "servers", servers)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "waf_type", waf_type)
        pulumi.set(__self__, "web_tag", web_tag)

    @_builtins.property
    @pulumi.getter(name="accessCode")
    def access_code(self) -> _builtins.str:
        """
        The cname prefix.
        """
        return pulumi.get(self, "access_code")

    @_builtins.property
    @pulumi.getter(name="accessProgresses")
    def access_progresses(self) -> Sequence['outputs.GetAllDomainsItemAccessProgressResult']:
        """
        The access progress.
        """
        return pulumi.get(self, "access_progresses")

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> _builtins.int:
        """
        The domain name access status.
        The valid values are as follows:
        """
        return pulumi.get(self, "access_status")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the domain.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID.
        If you want to query resources under all enterprise projects, set this parameter to **all_granted_eps**.
        Defaults to **0**.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def flags(self) -> Sequence['outputs.GetAllDomainsItemFlagResult']:
        """
        The special identifier, which is used on the console.
        """
        return pulumi.get(self, "flags")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Specifies the name of the domain.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dedicated WAF instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="paidType")
    def paid_type(self) -> _builtins.str:
        """
        The package billing mode. The value can be prePaid or postPaid.
        The valid values are as follows:
        + **prePaid**: Indicates yearly/monthly billing.
        + **postPaid**: Indicates pay-per-use billing.
        """
        return pulumi.get(self, "paid_type")

    @_builtins.property
    @pulumi.getter
    def policyid(self) -> _builtins.str:
        """
        The ID of the policy.
        """
        return pulumi.get(self, "policyid")

    @_builtins.property
    @pulumi.getter(name="premiumWafInstances")
    def premium_waf_instances(self) -> Sequence['outputs.GetAllDomainsItemPremiumWafInstanceResult']:
        """
        The list of dedicated WAF instances.
        """
        return pulumi.get(self, "premium_waf_instances")

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> _builtins.int:
        """
        Specifies the protection status of the domain.
        The valid values are as follows:
        + `-1`: The WAF protection is bypassed. Requests of the domain are directly sent to the backend server and do not
        pass through WAF.
        """
        return pulumi.get(self, "protect_status")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> _builtins.bool:
        """
        Whether a proxy is used for the domain.
        The valid values are as follows:
        + **false**: No proxy is used.
        + **true**: A proxy is used.
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region in which to query the resource.
        If omitted, the provider-level region will be used.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence['outputs.GetAllDomainsItemServerResult']:
        """
        The origin server settings of the domain.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.int:
        """
        The creation time of the domain.
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="wafType")
    def waf_type(self) -> _builtins.str:
        """
        Specifies the WAF mode of the domain.
        The valid values are as follows:
        + **cloud**: The cloud WAF is used to protect the domain.
        + **premium**: The dedicated WAF instance is used to protect the domain.
        """
        return pulumi.get(self, "waf_type")

    @_builtins.property
    @pulumi.getter(name="webTag")
    def web_tag(self) -> _builtins.str:
        """
        The website name.
        """
        return pulumi.get(self, "web_tag")


@pulumi.output_type
class GetAllDomainsItemAccessProgressResult(dict):
    def __init__(__self__, *,
                 status: _builtins.int,
                 step: _builtins.int):
        """
        :param _builtins.int status: The status of the access. The value can be **0** or **1**.
        :param _builtins.int step: The procedure.
               The valid values are as follows.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "step", step)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        The status of the access. The value can be **0** or **1**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        The procedure.
        The valid values are as follows.
        """
        return pulumi.get(self, "step")


@pulumi.output_type
class GetAllDomainsItemFlagResult(dict):
    def __init__(__self__, *,
                 cname: _builtins.str,
                 ipv6: _builtins.str,
                 is_dual_az: _builtins.str,
                 pci3ds: _builtins.str,
                 pci_dss: _builtins.str):
        """
        :param _builtins.str cname: The cname record being used.
               The valid values are as follows:
               + **old**: The old cname record is used.
               + **new**: The new cname record is used.
        :param _builtins.str ipv6: Whether IPv6 protection is supported.
        :param _builtins.str is_dual_az: Whether WAF support Multi-AZ mode.
        :param _builtins.str pci3ds: Whether the website passes the PCI 3DS certification check.
        :param _builtins.str pci_dss: Whether the website passed the PCI DSS certification check.
        """
        pulumi.set(__self__, "cname", cname)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "is_dual_az", is_dual_az)
        pulumi.set(__self__, "pci3ds", pci3ds)
        pulumi.set(__self__, "pci_dss", pci_dss)

    @_builtins.property
    @pulumi.getter
    def cname(self) -> _builtins.str:
        """
        The cname record being used.
        The valid values are as follows:
        + **old**: The old cname record is used.
        + **new**: The new cname record is used.
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.str:
        """
        Whether IPv6 protection is supported.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="isDualAz")
    def is_dual_az(self) -> _builtins.str:
        """
        Whether WAF support Multi-AZ mode.
        """
        return pulumi.get(self, "is_dual_az")

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> _builtins.str:
        """
        Whether the website passes the PCI 3DS certification check.
        """
        return pulumi.get(self, "pci3ds")

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> _builtins.str:
        """
        Whether the website passed the PCI DSS certification check.
        """
        return pulumi.get(self, "pci_dss")


@pulumi.output_type
class GetAllDomainsItemPremiumWafInstanceResult(dict):
    def __init__(__self__, *,
                 accessed: _builtins.bool,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.bool accessed: Whether the domain name is added to the dedicated WAF instance.
        :param _builtins.str id: The ID of the dedicated WAF instance.
        :param _builtins.str name: The name of the dedicated WAF instance.
        """
        pulumi.set(__self__, "accessed", accessed)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def accessed(self) -> _builtins.bool:
        """
        Whether the domain name is added to the dedicated WAF instance.
        """
        return pulumi.get(self, "accessed")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dedicated WAF instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the dedicated WAF instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAllDomainsItemServerResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 back_protocol: _builtins.str,
                 front_protocol: _builtins.str,
                 port: _builtins.int,
                 type: _builtins.str,
                 vpc_id: _builtins.str,
                 weight: _builtins.int):
        """
        :param _builtins.str address: The IP address of origin server requested by the client.
        :param _builtins.str back_protocol: The protocol used by WAF to forward client requests it received to origin servers.
        :param _builtins.str front_protocol: The protocol used by the client to request access to the origin server.
        :param _builtins.int port: The port used by WAF to forward client requests to the origin server.
        :param _builtins.str type: The origin server type.
               The value can be **IPv4** or **IPv6**.
        :param _builtins.str vpc_id: The VPC ID.
               The value is returned only for domain protected with dedicated instances.
        :param _builtins.int weight: The weight of the origin server.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "back_protocol", back_protocol)
        pulumi.set(__self__, "front_protocol", front_protocol)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The IP address of origin server requested by the client.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="backProtocol")
    def back_protocol(self) -> _builtins.str:
        """
        The protocol used by WAF to forward client requests it received to origin servers.
        """
        return pulumi.get(self, "back_protocol")

    @_builtins.property
    @pulumi.getter(name="frontProtocol")
    def front_protocol(self) -> _builtins.str:
        """
        The protocol used by the client to request access to the origin server.
        """
        return pulumi.get(self, "front_protocol")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port used by WAF to forward client requests to the origin server.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The origin server type.
        The value can be **IPv4** or **IPv6**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The VPC ID.
        The value is returned only for domain protected with dedicated instances.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight of the origin server.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetCertificatesCertificateResult(dict):
    def __init__(__self__, *,
                 bind_hosts: Sequence['outputs.GetCertificatesCertificateBindHostResult'],
                 created_at: _builtins.str,
                 expiration_status: _builtins.str,
                 expired_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param Sequence['GetCertificatesCertificateBindHostArgs'] bind_hosts: The domain information bound to the certificate.
               The bind_host structure is documented below.
        :param _builtins.str created_at: The time when the certificate was uploaded, in RFC3339 format.
        :param _builtins.str expiration_status: Specifies the certificate expiration status. The options are as follows:
        :param _builtins.str expired_at: The time when the certificate expires, in RFC3339 format.
        :param _builtins.str id: The domain ID.
        :param _builtins.str name: Specifies the name of certificate. The value is case-sensitive and supports fuzzy matching.
        """
        pulumi.set(__self__, "bind_hosts", bind_hosts)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expiration_status", expiration_status)
        pulumi.set(__self__, "expired_at", expired_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="bindHosts")
    def bind_hosts(self) -> Sequence['outputs.GetCertificatesCertificateBindHostResult']:
        """
        The domain information bound to the certificate.
        The bind_host structure is documented below.
        """
        return pulumi.get(self, "bind_hosts")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The time when the certificate was uploaded, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expirationStatus")
    def expiration_status(self) -> _builtins.str:
        """
        Specifies the certificate expiration status. The options are as follows:
        """
        return pulumi.get(self, "expiration_status")

    @_builtins.property
    @pulumi.getter(name="expiredAt")
    def expired_at(self) -> _builtins.str:
        """
        The time when the certificate expires, in RFC3339 format.
        """
        return pulumi.get(self, "expired_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The domain ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of certificate. The value is case-sensitive and supports fuzzy matching.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCertificatesCertificateBindHostResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str,
                 id: _builtins.str,
                 mode: _builtins.str,
                 waf_type: _builtins.str):
        """
        :param _builtins.str domain: The domain name.
        :param _builtins.str id: The domain ID.
        :param _builtins.str mode: The special domain pattern.
        :param _builtins.str waf_type: The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
               cloud WAF or **premium** for dedicated WAF instances.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "waf_type", waf_type)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The domain ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The special domain pattern.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="wafType")
    def waf_type(self) -> _builtins.str:
        """
        The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
        cloud WAF or **premium** for dedicated WAF instances.
        """
        return pulumi.get(self, "waf_type")


@pulumi.output_type
class GetDedicatedDomainsDomainResult(dict):
    def __init__(__self__, *,
                 access_status: _builtins.int,
                 description: _builtins.str,
                 domain: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 ipv6_enable: _builtins.bool,
                 is_dual_az: _builtins.bool,
                 pci3ds: _builtins.bool,
                 pci_dds: _builtins.bool,
                 policy_id: _builtins.str,
                 protect_status: _builtins.int,
                 website_name: _builtins.str):
        """
        :param _builtins.int access_status: Whether a domain name is connected to WAF. Valid values are:
        :param _builtins.str description: The description of WAF dedicated domain.
        :param _builtins.str domain: Specifies the protected domain name or IP address (port allowed).
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID.
               For enterprise users, if omitted, default enterprise project will be used.
        :param _builtins.str id: The ID of WAF dedicated domain.
        :param _builtins.bool ipv6_enable: Whether to support IPv6.
        :param _builtins.bool is_dual_az: The status of the WAF support dual AZ mode.
        :param _builtins.bool pci3ds: The status of the PCI 3DS compliance certification check.
        :param _builtins.bool pci_dds: The status of the PCI DSS compliance certification check.
        :param _builtins.str policy_id: The policy ID associated with the domain.
        :param _builtins.int protect_status: Specifies the protection status of domain. Valid values are:
        :param _builtins.str website_name: The website name.
        """
        pulumi.set(__self__, "access_status", access_status)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        pulumi.set(__self__, "is_dual_az", is_dual_az)
        pulumi.set(__self__, "pci3ds", pci3ds)
        pulumi.set(__self__, "pci_dds", pci_dds)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "protect_status", protect_status)
        pulumi.set(__self__, "website_name", website_name)

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> _builtins.int:
        """
        Whether a domain name is connected to WAF. Valid values are:
        """
        return pulumi.get(self, "access_status")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of WAF dedicated domain.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Specifies the protected domain name or IP address (port allowed).
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID.
        For enterprise users, if omitted, default enterprise project will be used.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of WAF dedicated domain.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> _builtins.bool:
        """
        Whether to support IPv6.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="isDualAz")
    def is_dual_az(self) -> _builtins.bool:
        """
        The status of the WAF support dual AZ mode.
        """
        return pulumi.get(self, "is_dual_az")

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> _builtins.bool:
        """
        The status of the PCI 3DS compliance certification check.
        """
        return pulumi.get(self, "pci3ds")

    @_builtins.property
    @pulumi.getter(name="pciDds")
    def pci_dds(self) -> _builtins.bool:
        """
        The status of the PCI DSS compliance certification check.
        """
        return pulumi.get(self, "pci_dds")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        The policy ID associated with the domain.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> _builtins.int:
        """
        Specifies the protection status of domain. Valid values are:
        """
        return pulumi.get(self, "protect_status")

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> _builtins.str:
        """
        The website name.
        """
        return pulumi.get(self, "website_name")


@pulumi.output_type
class GetDedicatedInstanceTagsTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The tag key.
        :param Sequence[_builtins.str] values: The tag values list.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The tag values list.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetDedicatedInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 access_status: _builtins.int,
                 available_zone: _builtins.str,
                 cpu_architecture: _builtins.str,
                 ecs_flavor: _builtins.str,
                 group_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 run_status: _builtins.int,
                 security_groups: Sequence[_builtins.str],
                 server_id: _builtins.str,
                 service_ip: _builtins.str,
                 subnet_id: _builtins.str,
                 upgradable: _builtins.int,
                 vpc_id: _builtins.str):
        """
        :param _builtins.int access_status: The access status of the instance. `0`: inaccessible, `1`: accessible.
        :param _builtins.str available_zone: The available zone name of the WAF dedicated instance.
        :param _builtins.str cpu_architecture: The ECS CPU architecture of WAF dedicated instance.
        :param _builtins.str ecs_flavor: The flavor of the ECS used by the WAF instance.
        :param _builtins.str group_id: schema: Deprecated;
        :param _builtins.str id: Specifies the ID of WAF dedicated instance.
        :param _builtins.str name: Specifies the name of WAF dedicated instance.
        :param _builtins.int run_status: The running status of the instance. Values are:
        :param Sequence[_builtins.str] security_groups: The security group of the instance. This is an array of security group IDs.
        :param _builtins.str server_id: The ID of the ECS hosting the dedicated engine.
        :param _builtins.str service_ip: The service plane IP address of the dedicated WAF instance.
        :param _builtins.str subnet_id: The subnet ID of WAF dedicated instance VPC.
        :param _builtins.int upgradable: Whether the dedicated WAF instance can be upgraded. `0`: Cannot be upgraded; `1`: Can be upgraded.
        :param _builtins.str vpc_id: The VPC ID of WAF dedicated instance.
        """
        pulumi.set(__self__, "access_status", access_status)
        pulumi.set(__self__, "available_zone", available_zone)
        pulumi.set(__self__, "cpu_architecture", cpu_architecture)
        pulumi.set(__self__, "ecs_flavor", ecs_flavor)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "run_status", run_status)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "server_id", server_id)
        pulumi.set(__self__, "service_ip", service_ip)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "upgradable", upgradable)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> _builtins.int:
        """
        The access status of the instance. `0`: inaccessible, `1`: accessible.
        """
        return pulumi.get(self, "access_status")

    @_builtins.property
    @pulumi.getter(name="availableZone")
    def available_zone(self) -> _builtins.str:
        """
        The available zone name of the WAF dedicated instance.
        """
        return pulumi.get(self, "available_zone")

    @_builtins.property
    @pulumi.getter(name="cpuArchitecture")
    def cpu_architecture(self) -> _builtins.str:
        """
        The ECS CPU architecture of WAF dedicated instance.
        """
        return pulumi.get(self, "cpu_architecture")

    @_builtins.property
    @pulumi.getter(name="ecsFlavor")
    def ecs_flavor(self) -> _builtins.str:
        """
        The flavor of the ECS used by the WAF instance.
        """
        return pulumi.get(self, "ecs_flavor")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        schema: Deprecated;
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Specifies the ID of WAF dedicated instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of WAF dedicated instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="runStatus")
    def run_status(self) -> _builtins.int:
        """
        The running status of the instance. Values are:
        """
        return pulumi.get(self, "run_status")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        """
        The security group of the instance. This is an array of security group IDs.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> _builtins.str:
        """
        The ID of the ECS hosting the dedicated engine.
        """
        return pulumi.get(self, "server_id")

    @_builtins.property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> _builtins.str:
        """
        The service plane IP address of the dedicated WAF instance.
        """
        return pulumi.get(self, "service_ip")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The subnet ID of WAF dedicated instance VPC.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def upgradable(self) -> _builtins.int:
        """
        Whether the dedicated WAF instance can be upgraded. `0`: Cannot be upgraded; `1`: Can be upgraded.
        """
        return pulumi.get(self, "upgradable")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The VPC ID of WAF dedicated instance.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetDomainsDomainResult(dict):
    def __init__(__self__, *,
                 access_code: _builtins.str,
                 access_status: _builtins.int,
                 charging_mode: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 domain: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 ipv6_enable: _builtins.bool,
                 pci3ds: _builtins.bool,
                 pci_dss: _builtins.bool,
                 policy_id: _builtins.str,
                 protect_status: _builtins.int,
                 proxy: _builtins.bool,
                 proxy_layer: _builtins.int,
                 website_name: _builtins.str):
        """
        :param _builtins.str access_code: The CNAME prefix. The CNAME suffix is `.vip1.huaweicloudwaf.com`.
        :param _builtins.int access_status: Whether a domain name is connected to WAF. Valid values are:
        :param _builtins.str charging_mode: The charging mode of the domain.
               Valid values are **prePaid** and **postPaid**.
        :param _builtins.str created_at: The creation time of domain.
        :param _builtins.str description: The description of WAF domain.
        :param _builtins.str domain: Specifies the protected domain name or IP address (port allowed).
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID.
               For enterprise users, if omitted, default enterprise project will be used.
        :param _builtins.str id: The ID of WAF domain.
        :param _builtins.bool ipv6_enable: Whether to support IPv6.
        :param _builtins.bool pci3ds: The status of the PCI 3DS compliance certification check.
        :param _builtins.bool pci_dss: The status of the PCI DSS compliance certification check.
        :param _builtins.str policy_id: The policy ID associated with the domain.
        :param _builtins.int protect_status: The protection status of domain, `0`: suspended, `1`: enabled.
        :param _builtins.bool proxy: Whether the protected domain name uses a proxy.
               Valid values are **true** and **false**.
        :param _builtins.int proxy_layer: Type of front-end proxy. Valid values are:
        :param _builtins.str website_name: The website name.
        """
        pulumi.set(__self__, "access_code", access_code)
        pulumi.set(__self__, "access_status", access_status)
        pulumi.set(__self__, "charging_mode", charging_mode)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        pulumi.set(__self__, "pci3ds", pci3ds)
        pulumi.set(__self__, "pci_dss", pci_dss)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "protect_status", protect_status)
        pulumi.set(__self__, "proxy", proxy)
        pulumi.set(__self__, "proxy_layer", proxy_layer)
        pulumi.set(__self__, "website_name", website_name)

    @_builtins.property
    @pulumi.getter(name="accessCode")
    def access_code(self) -> _builtins.str:
        """
        The CNAME prefix. The CNAME suffix is `.vip1.huaweicloudwaf.com`.
        """
        return pulumi.get(self, "access_code")

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> _builtins.int:
        """
        Whether a domain name is connected to WAF. Valid values are:
        """
        return pulumi.get(self, "access_status")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> _builtins.str:
        """
        The charging mode of the domain.
        Valid values are **prePaid** and **postPaid**.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of domain.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of WAF domain.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Specifies the protected domain name or IP address (port allowed).
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID.
        For enterprise users, if omitted, default enterprise project will be used.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of WAF domain.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> _builtins.bool:
        """
        Whether to support IPv6.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> _builtins.bool:
        """
        The status of the PCI 3DS compliance certification check.
        """
        return pulumi.get(self, "pci3ds")

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> _builtins.bool:
        """
        The status of the PCI DSS compliance certification check.
        """
        return pulumi.get(self, "pci_dss")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        The policy ID associated with the domain.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> _builtins.int:
        """
        The protection status of domain, `0`: suspended, `1`: enabled.
        """
        return pulumi.get(self, "protect_status")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> _builtins.bool:
        """
        Whether the protected domain name uses a proxy.
        Valid values are **true** and **false**.
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter(name="proxyLayer")
    def proxy_layer(self) -> _builtins.int:
        """
        Type of front-end proxy. Valid values are:
        """
        return pulumi.get(self, "proxy_layer")

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> _builtins.str:
        """
        The website name.
        """
        return pulumi.get(self, "website_name")


@pulumi.output_type
class GetInstanceGroupsGroupResult(dict):
    def __init__(__self__, *,
                 body_limit: _builtins.int,
                 connection_timeout: _builtins.int,
                 dedicated_instances: Sequence['outputs.GetInstanceGroupsGroupDedicatedInstanceResult'],
                 description: _builtins.str,
                 domain_names: Sequence['outputs.GetInstanceGroupsGroupDomainNameResult'],
                 header_limit: _builtins.int,
                 load_balancers: Sequence[_builtins.str],
                 name: _builtins.str,
                 read_timeout: _builtins.int,
                 region: _builtins.str,
                 vpc_id: _builtins.str,
                 write_timeout: _builtins.int):
        """
        :param Sequence['GetInstanceGroupsGroupDedicatedInstanceArgs'] dedicated_instances: schema: Internal; check it later
        :param Sequence['GetInstanceGroupsGroupDomainNameArgs'] domain_names: schema: Internal; check it later
        """
        pulumi.set(__self__, "body_limit", body_limit)
        pulumi.set(__self__, "connection_timeout", connection_timeout)
        pulumi.set(__self__, "dedicated_instances", dedicated_instances)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain_names", domain_names)
        pulumi.set(__self__, "header_limit", header_limit)
        pulumi.set(__self__, "load_balancers", load_balancers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "read_timeout", read_timeout)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "write_timeout", write_timeout)

    @_builtins.property
    @pulumi.getter(name="bodyLimit")
    def body_limit(self) -> _builtins.int:
        return pulumi.get(self, "body_limit")

    @_builtins.property
    @pulumi.getter(name="connectionTimeout")
    def connection_timeout(self) -> _builtins.int:
        return pulumi.get(self, "connection_timeout")

    @_builtins.property
    @pulumi.getter(name="dedicatedInstances")
    def dedicated_instances(self) -> Sequence['outputs.GetInstanceGroupsGroupDedicatedInstanceResult']:
        """
        schema: Internal; check it later
        """
        return pulumi.get(self, "dedicated_instances")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence['outputs.GetInstanceGroupsGroupDomainNameResult']:
        """
        schema: Internal; check it later
        """
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter(name="headerLimit")
    def header_limit(self) -> _builtins.int:
        return pulumi.get(self, "header_limit")

    @_builtins.property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "load_balancers")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="readTimeout")
    def read_timeout(self) -> _builtins.int:
        return pulumi.get(self, "read_timeout")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="writeTimeout")
    def write_timeout(self) -> _builtins.int:
        return pulumi.get(self, "write_timeout")


@pulumi.output_type
class GetInstanceGroupsGroupDedicatedInstanceResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstanceGroupsGroupDomainNameResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetOverviewsAbnormalItemResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 key: _builtins.str,
                 num: _builtins.int):
        """
        :param _builtins.str host: The protected domain.
        :param _builtins.str key: The attack type.
        :param _builtins.int num: The attack count.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The protected domain.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The attack type.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The attack count.
        """
        return pulumi.get(self, "num")


@pulumi.output_type
class GetOverviewsAttackTopDomainsItemResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 num: _builtins.int):
        """
        :param _builtins.str key: The Domain ID.
        :param _builtins.int num: The domain attacked count.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The Domain ID.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The domain attacked count.
        """
        return pulumi.get(self, "num")


@pulumi.output_type
class GetOverviewsBandwidthTimelineBandwidthResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 timelines: Sequence['outputs.GetOverviewsBandwidthTimelineBandwidthTimelineResult']):
        """
        :param _builtins.str key: The key type.
               The options are **BANDWIDTH**, **IN_BANDWIDTH** and **OUT_BANDWIDTH**.
        :param Sequence['GetOverviewsBandwidthTimelineBandwidthTimelineArgs'] timelines: The statistics data over time for the corresponding key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "timelines", timelines)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key type.
        The options are **BANDWIDTH**, **IN_BANDWIDTH** and **OUT_BANDWIDTH**.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def timelines(self) -> Sequence['outputs.GetOverviewsBandwidthTimelineBandwidthTimelineResult']:
        """
        The statistics data over time for the corresponding key.
        """
        return pulumi.get(self, "timelines")


@pulumi.output_type
class GetOverviewsBandwidthTimelineBandwidthTimelineResult(dict):
    def __init__(__self__, *,
                 num: _builtins.int,
                 time: _builtins.int):
        """
        :param _builtins.int num: The statistics data for the time range from the previous time point to the point specified by `time`.
        :param _builtins.int time: The time point.
        """
        pulumi.set(__self__, "num", num)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The statistics data for the time range from the previous time point to the point specified by `time`.
        """
        return pulumi.get(self, "num")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.int:
        """
        The time point.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetOverviewsClassificationAttackTypeResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOverviewsClassificationAttackTypeItemResult']):
        """
        :param Sequence['GetOverviewsClassificationAttackTypeItemArgs'] items: The source region details.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOverviewsClassificationAttackTypeItemResult']:
        """
        The source region details.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetOverviewsClassificationAttackTypeItemResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 num: _builtins.int):
        """
        :param _builtins.str key: The source region.
        :param _builtins.int num: The number of the attacking source region.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The source region.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The number of the attacking source region.
        """
        return pulumi.get(self, "num")


@pulumi.output_type
class GetOverviewsClassificationDomainResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOverviewsClassificationDomainItemResult']):
        """
        :param Sequence['GetOverviewsClassificationDomainItemArgs'] items: The source region details.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOverviewsClassificationDomainItemResult']:
        """
        The source region details.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetOverviewsClassificationDomainItemResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 num: _builtins.int,
                 web_tag: _builtins.str):
        """
        :param _builtins.str key: The source region.
        :param _builtins.int num: The number of the attacking source region.
        :param _builtins.str web_tag: The website name.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)
        pulumi.set(__self__, "web_tag", web_tag)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The source region.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The number of the attacking source region.
        """
        return pulumi.get(self, "num")

    @_builtins.property
    @pulumi.getter(name="webTag")
    def web_tag(self) -> _builtins.str:
        """
        The website name.
        """
        return pulumi.get(self, "web_tag")


@pulumi.output_type
class GetOverviewsClassificationGeoResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOverviewsClassificationGeoItemResult']):
        """
        :param Sequence['GetOverviewsClassificationGeoItemArgs'] items: The source region details.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOverviewsClassificationGeoItemResult']:
        """
        The source region details.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetOverviewsClassificationGeoItemResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 num: _builtins.int):
        """
        :param _builtins.str key: The source region.
        :param _builtins.int num: The number of the attacking source region.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The source region.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The number of the attacking source region.
        """
        return pulumi.get(self, "num")


@pulumi.output_type
class GetOverviewsClassificationIpResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOverviewsClassificationIpItemResult']):
        """
        :param Sequence['GetOverviewsClassificationIpItemArgs'] items: The source region details.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOverviewsClassificationIpItemResult']:
        """
        The source region details.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetOverviewsClassificationIpItemResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 num: _builtins.int):
        """
        :param _builtins.str key: The source region.
        :param _builtins.int num: The number of the attacking source region.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The source region.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The number of the attacking source region.
        """
        return pulumi.get(self, "num")


@pulumi.output_type
class GetOverviewsClassificationUrlResult(dict):
    def __init__(__self__, *,
                 items: Sequence['outputs.GetOverviewsClassificationUrlItemResult']):
        """
        :param Sequence['GetOverviewsClassificationUrlItemArgs'] items: The source region details.
        """
        pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Sequence['outputs.GetOverviewsClassificationUrlItemResult']:
        """
        The source region details.
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetOverviewsClassificationUrlItemResult(dict):
    def __init__(__self__, *,
                 host: _builtins.str,
                 key: _builtins.str,
                 num: _builtins.int):
        """
        :param _builtins.str host: The domain name.
        :param _builtins.str key: The source region.
        :param _builtins.int num: The number of the attacking source region.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The domain name.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The source region.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The number of the attacking source region.
        """
        return pulumi.get(self, "num")


@pulumi.output_type
class GetOverviewsQpsTimelineQpResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 timelines: Sequence['outputs.GetOverviewsQpsTimelineQpTimelineResult']):
        """
        :param _builtins.str key: The key type.
               The options are **ACCESS** for total requests, **CRAWLER** for bot mitigation, **ATTACK** for total attacks,
               **WEB_ATTACK** for basic web protection, **PRECISE** for precise protection, and **CC** for CC attack protection.
        :param Sequence['GetOverviewsQpsTimelineQpTimelineArgs'] timelines: The statistics data over time for the corresponding key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "timelines", timelines)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key type.
        The options are **ACCESS** for total requests, **CRAWLER** for bot mitigation, **ATTACK** for total attacks,
        **WEB_ATTACK** for basic web protection, **PRECISE** for precise protection, and **CC** for CC attack protection.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def timelines(self) -> Sequence['outputs.GetOverviewsQpsTimelineQpTimelineResult']:
        """
        The statistics data over time for the corresponding key.
        """
        return pulumi.get(self, "timelines")


@pulumi.output_type
class GetOverviewsQpsTimelineQpTimelineResult(dict):
    def __init__(__self__, *,
                 num: _builtins.int,
                 time: _builtins.int):
        """
        :param _builtins.int num: The statistics data for the time range from the previous time point to the point specified by `time`.
        :param _builtins.int time: The time point.
        """
        pulumi.set(__self__, "num", num)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The statistics data for the time range from the previous time point to the point specified by `time`.
        """
        return pulumi.get(self, "num")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.int:
        """
        The time point.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetOverviewsRequestTimelineRequestResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 timelines: Sequence['outputs.GetOverviewsRequestTimelineRequestTimelineResult']):
        """
        :param _builtins.str key: The key type.
               The options are **ACCESS** for total requests, **CRAWLER** for bot mitigation, **ATTACK** for total attacks,
               **WEB_ATTACK** for basic web protection, **PRECISE** for precise protection, and **CC** for CC attack protection.
        :param Sequence['GetOverviewsRequestTimelineRequestTimelineArgs'] timelines: The statistics data over time for the corresponding key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "timelines", timelines)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key type.
        The options are **ACCESS** for total requests, **CRAWLER** for bot mitigation, **ATTACK** for total attacks,
        **WEB_ATTACK** for basic web protection, **PRECISE** for precise protection, and **CC** for CC attack protection.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def timelines(self) -> Sequence['outputs.GetOverviewsRequestTimelineRequestTimelineResult']:
        """
        The statistics data over time for the corresponding key.
        """
        return pulumi.get(self, "timelines")


@pulumi.output_type
class GetOverviewsRequestTimelineRequestTimelineResult(dict):
    def __init__(__self__, *,
                 num: _builtins.int,
                 time: _builtins.int):
        """
        :param _builtins.int num: The statistics data for the time range from the previous time point to the point specified by `time`.
        :param _builtins.int time: The time point.
        """
        pulumi.set(__self__, "num", num)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The statistics data for the time range from the previous time point to the point specified by `time`.
        """
        return pulumi.get(self, "num")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.int:
        """
        The time point.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetOverviewsStatisticsStatisticResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 num: _builtins.int):
        """
        :param _builtins.str key: The type of requests or attacks.
               The options are **ACCESS** for total requests, **CRAWLER** for bot mitigation, **ATTACK** for total attacks,
               **WEB_ATTACK** for basic web protection, **PRECISE** for precise protection, and **CC** for CC attack protection.
        :param _builtins.int num: The number of times requests or attacks.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "num", num)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The type of requests or attacks.
        The options are **ACCESS** for total requests, **CRAWLER** for bot mitigation, **ATTACK** for total attacks,
        **WEB_ATTACK** for basic web protection, **PRECISE** for precise protection, and **CC** for CC attack protection.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def num(self) -> _builtins.int:
        """
        The number of times requests or attacks.
        """
        return pulumi.get(self, "num")


@pulumi.output_type
class GetPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 bind_hosts: Sequence['outputs.GetPoliciesPolicyBindHostResult'],
                 deep_inspection: _builtins.bool,
                 full_detection: _builtins.bool,
                 header_inspection: _builtins.bool,
                 id: _builtins.str,
                 level: _builtins.int,
                 name: _builtins.str,
                 options: Sequence['outputs.GetPoliciesPolicyOptionResult'],
                 protection_mode: _builtins.str,
                 robot_action: _builtins.str,
                 shiro_decryption_check: _builtins.bool):
        """
        :param Sequence['GetPoliciesPolicyBindHostArgs'] bind_hosts: The protection switches. The object structure is documented below.
        :param _builtins.bool deep_inspection: The deep inspection in basic web protection.
        :param _builtins.bool full_detection: The detection mode in precise protection.
               + **false**: Instant detection. When a request hits the blocking conditions in precise protection, WAF terminates
               checks and blocks the request immediately.
               + **true**: Full detection. If a request hits the blocking conditions in precise protection, WAF does not block the
               request immediately. Instead, it blocks the requests until other checks are finished.
        :param _builtins.bool header_inspection: The header inspection in basic web protection.
        :param _builtins.str id: The domain name ID.
        :param _builtins.int level: The protection level. Valid values are:
               + **1**: Low. At this protection level, WAF blocks only requests with obvious attack features. If a large number of
               false alarms have been reported, this value is recommended.
               + **2**: Medium. This protection level meets web protection requirements in most scenarios.
               + **3**: High. At this protection level, WAF provides the finest granular protection and can intercept attacks with
               complex bypass features, such as Jolokia cyberattacks, common gateway interface (CGI) vulnerability detection,
               and Druid SQL injection attacks.
        :param _builtins.str name: Specifies the policy name used for matching. The value is case-sensitive and supports
               fuzzy matching.
        :param Sequence['GetPoliciesPolicyOptionArgs'] options: The protection switches. The options object structure is documented below.
        :param _builtins.str protection_mode: The protective action after a rule is matched. Valid values are:
               + **block**: WAF blocks and logs detected attacks.
               + **log**: WAF logs detected attacks only.
        :param _builtins.str robot_action: The protective actions for each rule in anti-crawler protection. Valid values are:
               + **block**: WAF blocks discovered attacks.
               + **log**: WAF only logs discovered attacks.
        :param _builtins.bool shiro_decryption_check: The shiro decryption check in basic web protection.
        """
        pulumi.set(__self__, "bind_hosts", bind_hosts)
        pulumi.set(__self__, "deep_inspection", deep_inspection)
        pulumi.set(__self__, "full_detection", full_detection)
        pulumi.set(__self__, "header_inspection", header_inspection)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "robot_action", robot_action)
        pulumi.set(__self__, "shiro_decryption_check", shiro_decryption_check)

    @_builtins.property
    @pulumi.getter(name="bindHosts")
    def bind_hosts(self) -> Sequence['outputs.GetPoliciesPolicyBindHostResult']:
        """
        The protection switches. The object structure is documented below.
        """
        return pulumi.get(self, "bind_hosts")

    @_builtins.property
    @pulumi.getter(name="deepInspection")
    def deep_inspection(self) -> _builtins.bool:
        """
        The deep inspection in basic web protection.
        """
        return pulumi.get(self, "deep_inspection")

    @_builtins.property
    @pulumi.getter(name="fullDetection")
    def full_detection(self) -> _builtins.bool:
        """
        The detection mode in precise protection.
        + **false**: Instant detection. When a request hits the blocking conditions in precise protection, WAF terminates
        checks and blocks the request immediately.
        + **true**: Full detection. If a request hits the blocking conditions in precise protection, WAF does not block the
        request immediately. Instead, it blocks the requests until other checks are finished.
        """
        return pulumi.get(self, "full_detection")

    @_builtins.property
    @pulumi.getter(name="headerInspection")
    def header_inspection(self) -> _builtins.bool:
        """
        The header inspection in basic web protection.
        """
        return pulumi.get(self, "header_inspection")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The domain name ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.int:
        """
        The protection level. Valid values are:
        + **1**: Low. At this protection level, WAF blocks only requests with obvious attack features. If a large number of
        false alarms have been reported, this value is recommended.
        + **2**: Medium. This protection level meets web protection requirements in most scenarios.
        + **3**: High. At this protection level, WAF provides the finest granular protection and can intercept attacks with
        complex bypass features, such as Jolokia cyberattacks, common gateway interface (CGI) vulnerability detection,
        and Druid SQL injection attacks.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the policy name used for matching. The value is case-sensitive and supports
        fuzzy matching.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Sequence['outputs.GetPoliciesPolicyOptionResult']:
        """
        The protection switches. The options object structure is documented below.
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        The protective action after a rule is matched. Valid values are:
        + **block**: WAF blocks and logs detected attacks.
        + **log**: WAF logs detected attacks only.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter(name="robotAction")
    def robot_action(self) -> _builtins.str:
        """
        The protective actions for each rule in anti-crawler protection. Valid values are:
        + **block**: WAF blocks discovered attacks.
        + **log**: WAF only logs discovered attacks.
        """
        return pulumi.get(self, "robot_action")

    @_builtins.property
    @pulumi.getter(name="shiroDecryptionCheck")
    def shiro_decryption_check(self) -> _builtins.bool:
        """
        The shiro decryption check in basic web protection.
        """
        return pulumi.get(self, "shiro_decryption_check")


@pulumi.output_type
class GetPoliciesPolicyBindHostResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 id: _builtins.str,
                 mode: _builtins.str,
                 waf_type: _builtins.str):
        """
        :param _builtins.str hostname: The domain name.
        :param _builtins.str id: The domain name ID.
        :param _builtins.str mode: The special domain name mode. This attribute is only valid for dedicated mode.
        :param _builtins.str waf_type: The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
               cloud WAF or **premium** for dedicated WAF instances.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "waf_type", waf_type)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        The domain name.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The domain name ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The special domain name mode. This attribute is only valid for dedicated mode.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="wafType")
    def waf_type(self) -> _builtins.str:
        """
        The deployment mode of WAF instance that is used for the domain name. The value can be **cloud** for
        cloud WAF or **premium** for dedicated WAF instances.
        """
        return pulumi.get(self, "waf_type")


@pulumi.output_type
class GetPoliciesPolicyOptionResult(dict):
    def __init__(__self__, *,
                 anti_crawler: _builtins.bool,
                 basic_web_protection: _builtins.bool,
                 blacklist: _builtins.bool,
                 bot_enable: _builtins.bool,
                 cc_attack_protection: _builtins.bool,
                 crawler: _builtins.bool,
                 crawler_engine: _builtins.bool,
                 crawler_other: _builtins.bool,
                 crawler_scanner: _builtins.bool,
                 crawler_script: _builtins.bool,
                 data_masking: _builtins.bool,
                 false_alarm_masking: _builtins.bool,
                 general_check: _builtins.bool,
                 geolocation_access_control: _builtins.bool,
                 information_leakage_prevention: _builtins.bool,
                 known_attack_source: _builtins.bool,
                 precise_protection: _builtins.bool,
                 web_tamper_protection: _builtins.bool,
                 webshell: _builtins.bool):
        """
        :param _builtins.bool anti_crawler: Indicates whether the javascript anti-crawler is enabled.
        :param _builtins.bool basic_web_protection: Indicates whether Basic Web Protection is enabled.
        :param _builtins.bool blacklist: Indicates whether the blacklist and whitelist protection is enabled.
        :param _builtins.bool bot_enable: Indicates whether the anti-crawler protection is enabled.
        :param _builtins.bool cc_attack_protection: Indicates whether the cc attack protection rules are enabled.
        :param _builtins.bool crawler: schema: Deprecated
        :param _builtins.bool crawler_engine: Indicates whether the search engine is enabled.
        :param _builtins.bool crawler_other: Indicates whether other crawler check is enabled.
        :param _builtins.bool crawler_scanner: Indicates whether the anti-crawler detection is enabled.
        :param _builtins.bool crawler_script: Indicates whether the script tool is enabled.
        :param _builtins.bool data_masking: Indicates whether data masking is enabled.
        :param _builtins.bool false_alarm_masking: Indicates whether false alarm masking is enabled.
        :param _builtins.bool general_check: Indicates whether General Check in Basic Web Protection is enabled.
        :param _builtins.bool geolocation_access_control: Indicates whether the geolocation access control is enabled.
        :param _builtins.bool information_leakage_prevention: Indicates whether the information leakage prevention is enabled.
        :param _builtins.bool known_attack_source: Indicates whether the known attack source is enabled.
        :param _builtins.bool precise_protection: Indicates whether the precise protection is enabled.
        :param _builtins.bool web_tamper_protection: Indicates whether the web tamper protection is enabled.
        :param _builtins.bool webshell: Indicates whether the web shell detection in basic web protection is enabled.
        """
        pulumi.set(__self__, "anti_crawler", anti_crawler)
        pulumi.set(__self__, "basic_web_protection", basic_web_protection)
        pulumi.set(__self__, "blacklist", blacklist)
        pulumi.set(__self__, "bot_enable", bot_enable)
        pulumi.set(__self__, "cc_attack_protection", cc_attack_protection)
        pulumi.set(__self__, "crawler", crawler)
        pulumi.set(__self__, "crawler_engine", crawler_engine)
        pulumi.set(__self__, "crawler_other", crawler_other)
        pulumi.set(__self__, "crawler_scanner", crawler_scanner)
        pulumi.set(__self__, "crawler_script", crawler_script)
        pulumi.set(__self__, "data_masking", data_masking)
        pulumi.set(__self__, "false_alarm_masking", false_alarm_masking)
        pulumi.set(__self__, "general_check", general_check)
        pulumi.set(__self__, "geolocation_access_control", geolocation_access_control)
        pulumi.set(__self__, "information_leakage_prevention", information_leakage_prevention)
        pulumi.set(__self__, "known_attack_source", known_attack_source)
        pulumi.set(__self__, "precise_protection", precise_protection)
        pulumi.set(__self__, "web_tamper_protection", web_tamper_protection)
        pulumi.set(__self__, "webshell", webshell)

    @_builtins.property
    @pulumi.getter(name="antiCrawler")
    def anti_crawler(self) -> _builtins.bool:
        """
        Indicates whether the javascript anti-crawler is enabled.
        """
        return pulumi.get(self, "anti_crawler")

    @_builtins.property
    @pulumi.getter(name="basicWebProtection")
    def basic_web_protection(self) -> _builtins.bool:
        """
        Indicates whether Basic Web Protection is enabled.
        """
        return pulumi.get(self, "basic_web_protection")

    @_builtins.property
    @pulumi.getter
    def blacklist(self) -> _builtins.bool:
        """
        Indicates whether the blacklist and whitelist protection is enabled.
        """
        return pulumi.get(self, "blacklist")

    @_builtins.property
    @pulumi.getter(name="botEnable")
    def bot_enable(self) -> _builtins.bool:
        """
        Indicates whether the anti-crawler protection is enabled.
        """
        return pulumi.get(self, "bot_enable")

    @_builtins.property
    @pulumi.getter(name="ccAttackProtection")
    def cc_attack_protection(self) -> _builtins.bool:
        """
        Indicates whether the cc attack protection rules are enabled.
        """
        return pulumi.get(self, "cc_attack_protection")

    @_builtins.property
    @pulumi.getter
    def crawler(self) -> _builtins.bool:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "crawler")

    @_builtins.property
    @pulumi.getter(name="crawlerEngine")
    def crawler_engine(self) -> _builtins.bool:
        """
        Indicates whether the search engine is enabled.
        """
        return pulumi.get(self, "crawler_engine")

    @_builtins.property
    @pulumi.getter(name="crawlerOther")
    def crawler_other(self) -> _builtins.bool:
        """
        Indicates whether other crawler check is enabled.
        """
        return pulumi.get(self, "crawler_other")

    @_builtins.property
    @pulumi.getter(name="crawlerScanner")
    def crawler_scanner(self) -> _builtins.bool:
        """
        Indicates whether the anti-crawler detection is enabled.
        """
        return pulumi.get(self, "crawler_scanner")

    @_builtins.property
    @pulumi.getter(name="crawlerScript")
    def crawler_script(self) -> _builtins.bool:
        """
        Indicates whether the script tool is enabled.
        """
        return pulumi.get(self, "crawler_script")

    @_builtins.property
    @pulumi.getter(name="dataMasking")
    def data_masking(self) -> _builtins.bool:
        """
        Indicates whether data masking is enabled.
        """
        return pulumi.get(self, "data_masking")

    @_builtins.property
    @pulumi.getter(name="falseAlarmMasking")
    def false_alarm_masking(self) -> _builtins.bool:
        """
        Indicates whether false alarm masking is enabled.
        """
        return pulumi.get(self, "false_alarm_masking")

    @_builtins.property
    @pulumi.getter(name="generalCheck")
    def general_check(self) -> _builtins.bool:
        """
        Indicates whether General Check in Basic Web Protection is enabled.
        """
        return pulumi.get(self, "general_check")

    @_builtins.property
    @pulumi.getter(name="geolocationAccessControl")
    def geolocation_access_control(self) -> _builtins.bool:
        """
        Indicates whether the geolocation access control is enabled.
        """
        return pulumi.get(self, "geolocation_access_control")

    @_builtins.property
    @pulumi.getter(name="informationLeakagePrevention")
    def information_leakage_prevention(self) -> _builtins.bool:
        """
        Indicates whether the information leakage prevention is enabled.
        """
        return pulumi.get(self, "information_leakage_prevention")

    @_builtins.property
    @pulumi.getter(name="knownAttackSource")
    def known_attack_source(self) -> _builtins.bool:
        """
        Indicates whether the known attack source is enabled.
        """
        return pulumi.get(self, "known_attack_source")

    @_builtins.property
    @pulumi.getter(name="preciseProtection")
    def precise_protection(self) -> _builtins.bool:
        """
        Indicates whether the precise protection is enabled.
        """
        return pulumi.get(self, "precise_protection")

    @_builtins.property
    @pulumi.getter(name="webTamperProtection")
    def web_tamper_protection(self) -> _builtins.bool:
        """
        Indicates whether the web tamper protection is enabled.
        """
        return pulumi.get(self, "web_tamper_protection")

    @_builtins.property
    @pulumi.getter
    def webshell(self) -> _builtins.bool:
        """
        Indicates whether the web shell detection in basic web protection is enabled.
        """
        return pulumi.get(self, "webshell")


@pulumi.output_type
class GetReferenceTablesTableResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence[_builtins.str],
                 creation_time: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] conditions: The conditions of the reference table.
        :param _builtins.str creation_time: The server time when reference table was created.
        :param _builtins.str description: The description of the reference table.
        :param _builtins.str id: The ID of the reference table.
        :param _builtins.str name: Specifies the name of the reference table. The value is case-sensitive and matches exactly.
        :param _builtins.str type: The type of the reference table, The options are: `url`, `user-agent`, `ip`, `params`, `cookie`, `referer`
               and `header`.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence[_builtins.str]:
        """
        The conditions of the reference table.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> _builtins.str:
        """
        The server time when reference table was created.
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the reference table.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the reference table.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the reference table. The value is case-sensitive and matches exactly.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the reference table, The options are: `url`, `user-agent`, `ip`, `params`, `cookie`, `referer`
        and `header`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRulesAntiCrawlerRuleResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetRulesAntiCrawlerRuleConditionResult'],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 policy_id: _builtins.str,
                 priority: _builtins.int,
                 protection_mode: _builtins.str,
                 status: _builtins.int):
        """
        :param Sequence['GetRulesAntiCrawlerRuleConditionArgs'] conditions: The matching condition list of the anti crawler rule.
        :param _builtins.str created_at: The creation time of the anti crawler rule.
        :param _builtins.str description: The description of the anti crawler rule.
        :param _builtins.str id: The ID of the anti crawler rule.
        :param _builtins.str name: Specifies the name of the anti crawler rule.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the anti crawler rules belong.
        :param _builtins.int priority: The priority of the anti crawler rule.
        :param _builtins.str protection_mode: Specifies the protection mode of the anti crawler rule.
               The valid values are as follows:
               + **anticrawler_except_url**: All paths are protected except the one specified in the queried anti crawler rules.
               + **anticrawler_specific_url**: The specified path is protected in the queried anti crawler rules.
               
               > If omitted, the API default query the anti crawler rules in **anticrawler_except_url** protection mode.
        :param _builtins.int status: Specifies the status of the anti crawler rule.
               The valid values are as follows:
               + **0**: The anti crawler rule is disabled.
               + **1**: The anti crawler rule is active.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "protection_mode", protection_mode)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetRulesAntiCrawlerRuleConditionResult']:
        """
        The matching condition list of the anti crawler rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the anti crawler rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the anti crawler rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the anti crawler rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the anti crawler rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the anti crawler rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of the anti crawler rule.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> _builtins.str:
        """
        Specifies the protection mode of the anti crawler rule.
        The valid values are as follows:
        + **anticrawler_except_url**: All paths are protected except the one specified in the queried anti crawler rules.
        + **anticrawler_specific_url**: The specified path is protected in the queried anti crawler rules.

        > If omitted, the API default query the anti crawler rules in **anticrawler_except_url** protection mode.
        """
        return pulumi.get(self, "protection_mode")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the anti crawler rule.
        The valid values are as follows:
        + **0**: The anti crawler rule is disabled.
        + **1**: The anti crawler rule is active.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesAntiCrawlerRuleConditionResult(dict):
    def __init__(__self__, *,
                 contents: Sequence[_builtins.str],
                 field: _builtins.str,
                 logic: _builtins.str,
                 reference_table_id: _builtins.str):
        """
        :param Sequence[_builtins.str] contents: The content of the match condition.
        :param _builtins.str field: The field type of the condition.
        :param _builtins.str logic: The condition matching logic.
        :param _builtins.str reference_table_id: The reference table ID.
        """
        pulumi.set(__self__, "contents", contents)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        pulumi.set(__self__, "reference_table_id", reference_table_id)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Sequence[_builtins.str]:
        """
        The content of the match condition.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        The field type of the condition.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        The condition matching logic.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter(name="referenceTableId")
    def reference_table_id(self) -> _builtins.str:
        """
        The reference table ID.
        """
        return pulumi.get(self, "reference_table_id")


@pulumi.output_type
class GetRulesBlacklistRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.int,
                 address_groups: Sequence['outputs.GetRulesBlacklistRuleAddressGroupResult'],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 ip_address: _builtins.str,
                 name: _builtins.str,
                 policy_id: _builtins.str,
                 status: _builtins.int):
        """
        :param _builtins.int action: Specifies the protective action of the blacklist and whitelist rule.
               The valid values are as follows:
               + **0**: Intercept the request.
               + **1**: Release the request.
               + **2**: Record the request only.
        :param Sequence['GetRulesBlacklistRuleAddressGroupArgs'] address_groups: The IP address group included in the blacklist and whitelist rule.
        :param _builtins.str created_at: The creation time of the blacklist and whitelist rule.
        :param _builtins.str description: The description of the blacklist or whitelist rule.
        :param _builtins.str id: The ID of the IP address group.
        :param _builtins.str ip_address: The IP address included in the blacklist and whitelist rule.
        :param _builtins.str name: Specifies the name of the blacklist or whitelist rule.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the blacklist and whitelist rules belong.
        :param _builtins.int status: Specifies the status of the blacklist or whitelist rule.
               The valid values are as follows:
               + **0**: The blacklist and whitelist rule is active.
               + **1**: The blacklist and whitelist rule is disabled.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "address_groups", address_groups)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.int:
        """
        Specifies the protective action of the blacklist and whitelist rule.
        The valid values are as follows:
        + **0**: Intercept the request.
        + **1**: Release the request.
        + **2**: Record the request only.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="addressGroups")
    def address_groups(self) -> Sequence['outputs.GetRulesBlacklistRuleAddressGroupResult']:
        """
        The IP address group included in the blacklist and whitelist rule.
        """
        return pulumi.get(self, "address_groups")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the blacklist and whitelist rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the blacklist or whitelist rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the IP address group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        The IP address included in the blacklist and whitelist rule.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the blacklist or whitelist rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the blacklist and whitelist rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the blacklist or whitelist rule.
        The valid values are as follows:
        + **0**: The blacklist and whitelist rule is active.
        + **1**: The blacklist and whitelist rule is disabled.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesBlacklistRuleAddressGroupResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.int):
        """
        :param _builtins.str id: The ID of the IP address group.
        :param _builtins.str name: Specifies the name of the blacklist or whitelist rule.
        :param _builtins.int size: The number of IP addresses or IP address ranges in the IP address group.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the IP address group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the blacklist or whitelist rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The number of IP addresses or IP address ranges in the IP address group.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetRulesCcProtectionRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetRulesCcProtectionRuleActionResult'],
                 all_waf_instances: _builtins.bool,
                 conditions: Sequence['outputs.GetRulesCcProtectionRuleConditionResult'],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 limit_num: _builtins.int,
                 limit_period: _builtins.int,
                 lock_time: _builtins.int,
                 name: _builtins.str,
                 other_user_identifiers: Sequence[_builtins.str],
                 policy_id: _builtins.str,
                 rate_limit_mode: _builtins.str,
                 request_aggregation: _builtins.bool,
                 status: _builtins.int,
                 unlock_num: _builtins.int,
                 user_identifier: _builtins.str):
        """
        :param Sequence['GetRulesCcProtectionRuleActionArgs'] actions: The protective action taken when the number of requests reaches the upper limit.
        :param _builtins.bool all_waf_instances: Whether to enable global counting.
        :param Sequence['GetRulesCcProtectionRuleConditionArgs'] conditions: The matching condition list of the cc protection rule.
        :param _builtins.str created_at: The creation time of the cc protection rule.
        :param _builtins.str description: The description of the cc protection rule.
        :param _builtins.str id: The ID of the cc protection rule.
        :param _builtins.int limit_num: The number of requests allowed from a web visitor in a rate limiting period.
        :param _builtins.int limit_period: The rate limiting period.
        :param _builtins.int lock_time: The lock time for resuming normal page access after blocking can be set.
        :param _builtins.str name: Specifies the name of the cc protection rule.
        :param Sequence[_builtins.str] other_user_identifiers: The other user identifier.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the cc protection rules belong.
        :param _builtins.str rate_limit_mode: The rate limit mode.
        :param _builtins.bool request_aggregation: Whether to enable domain aggregation statistics.
        :param _builtins.int status: Specifies the status of the cc protection rule.
               The valid values are as follows:
               + **0**: The cc protection rule is disabled.
               + **1**: The cc protection  rule is active.
        :param _builtins.int unlock_num: The allowable frequency.
        :param _builtins.str user_identifier: The user identifier.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "all_waf_instances", all_waf_instances)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "limit_num", limit_num)
        pulumi.set(__self__, "limit_period", limit_period)
        pulumi.set(__self__, "lock_time", lock_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "other_user_identifiers", other_user_identifiers)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "rate_limit_mode", rate_limit_mode)
        pulumi.set(__self__, "request_aggregation", request_aggregation)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "unlock_num", unlock_num)
        pulumi.set(__self__, "user_identifier", user_identifier)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetRulesCcProtectionRuleActionResult']:
        """
        The protective action taken when the number of requests reaches the upper limit.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="allWafInstances")
    def all_waf_instances(self) -> _builtins.bool:
        """
        Whether to enable global counting.
        """
        return pulumi.get(self, "all_waf_instances")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetRulesCcProtectionRuleConditionResult']:
        """
        The matching condition list of the cc protection rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the cc protection rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the cc protection rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the cc protection rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="limitNum")
    def limit_num(self) -> _builtins.int:
        """
        The number of requests allowed from a web visitor in a rate limiting period.
        """
        return pulumi.get(self, "limit_num")

    @_builtins.property
    @pulumi.getter(name="limitPeriod")
    def limit_period(self) -> _builtins.int:
        """
        The rate limiting period.
        """
        return pulumi.get(self, "limit_period")

    @_builtins.property
    @pulumi.getter(name="lockTime")
    def lock_time(self) -> _builtins.int:
        """
        The lock time for resuming normal page access after blocking can be set.
        """
        return pulumi.get(self, "lock_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the cc protection rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="otherUserIdentifiers")
    def other_user_identifiers(self) -> Sequence[_builtins.str]:
        """
        The other user identifier.
        """
        return pulumi.get(self, "other_user_identifiers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the cc protection rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="rateLimitMode")
    def rate_limit_mode(self) -> _builtins.str:
        """
        The rate limit mode.
        """
        return pulumi.get(self, "rate_limit_mode")

    @_builtins.property
    @pulumi.getter(name="requestAggregation")
    def request_aggregation(self) -> _builtins.bool:
        """
        Whether to enable domain aggregation statistics.
        """
        return pulumi.get(self, "request_aggregation")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the cc protection rule.
        The valid values are as follows:
        + **0**: The cc protection rule is disabled.
        + **1**: The cc protection  rule is active.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="unlockNum")
    def unlock_num(self) -> _builtins.int:
        """
        The allowable frequency.
        """
        return pulumi.get(self, "unlock_num")

    @_builtins.property
    @pulumi.getter(name="userIdentifier")
    def user_identifier(self) -> _builtins.str:
        """
        The user identifier.
        """
        return pulumi.get(self, "user_identifier")


@pulumi.output_type
class GetRulesCcProtectionRuleActionResult(dict):
    def __init__(__self__, *,
                 details: Sequence['outputs.GetRulesCcProtectionRuleActionDetailResult'],
                 protective_action: _builtins.str):
        """
        :param Sequence['GetRulesCcProtectionRuleActionDetailArgs'] details: The block page detail information.
        :param _builtins.str protective_action: The protective action type.
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "protective_action", protective_action)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Sequence['outputs.GetRulesCcProtectionRuleActionDetailResult']:
        """
        The block page detail information.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="protectiveAction")
    def protective_action(self) -> _builtins.str:
        """
        The protective action type.
        """
        return pulumi.get(self, "protective_action")


@pulumi.output_type
class GetRulesCcProtectionRuleActionDetailResult(dict):
    def __init__(__self__, *,
                 block_page_type: _builtins.str,
                 page_content: _builtins.str):
        """
        :param _builtins.str block_page_type: The type of the returned page.
        :param _builtins.str page_content: The content of the returned page.
        """
        pulumi.set(__self__, "block_page_type", block_page_type)
        pulumi.set(__self__, "page_content", page_content)

    @_builtins.property
    @pulumi.getter(name="blockPageType")
    def block_page_type(self) -> _builtins.str:
        """
        The type of the returned page.
        """
        return pulumi.get(self, "block_page_type")

    @_builtins.property
    @pulumi.getter(name="pageContent")
    def page_content(self) -> _builtins.str:
        """
        The content of the returned page.
        """
        return pulumi.get(self, "page_content")


@pulumi.output_type
class GetRulesCcProtectionRuleConditionResult(dict):
    def __init__(__self__, *,
                 contents: Sequence[_builtins.str],
                 field: _builtins.str,
                 logic: _builtins.str,
                 reference_table_id: _builtins.str,
                 subfield: _builtins.str):
        """
        :param Sequence[_builtins.str] contents: The content of the match condition.
        :param _builtins.str field: The field of the condition.
        :param _builtins.str logic: The condition matching logic.
        :param _builtins.str reference_table_id: The reference table ID.
        :param _builtins.str subfield: The subfield of the condition.
        """
        pulumi.set(__self__, "contents", contents)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        pulumi.set(__self__, "reference_table_id", reference_table_id)
        pulumi.set(__self__, "subfield", subfield)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Sequence[_builtins.str]:
        """
        The content of the match condition.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        The field of the condition.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        The condition matching logic.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter(name="referenceTableId")
    def reference_table_id(self) -> _builtins.str:
        """
        The reference table ID.
        """
        return pulumi.get(self, "reference_table_id")

    @_builtins.property
    @pulumi.getter
    def subfield(self) -> _builtins.str:
        """
        The subfield of the condition.
        """
        return pulumi.get(self, "subfield")


@pulumi.output_type
class GetRulesDataMaskingRuleResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 field: _builtins.str,
                 id: _builtins.str,
                 path: _builtins.str,
                 policy_id: _builtins.str,
                 status: _builtins.int,
                 subfield: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the data masking rule.
        :param _builtins.str description: The description of the data masking rule.
        :param _builtins.str field: The position where the masked field stored
        :param _builtins.str id: The ID of the data masking rule.
        :param _builtins.str path: The URL protected by the data masking rule.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the data masking rules belong.
        :param _builtins.int status: Specifies the status of the data masking rule.
               The value can be **0** or **1**.
               + **0**: The rule is disabled.
               + **1**: The rule is enabled.
        :param _builtins.str subfield: The name of the masked field.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subfield", subfield)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the data masking rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the data masking rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        The position where the masked field stored
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the data masking rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The URL protected by the data masking rule.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the data masking rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the data masking rule.
        The value can be **0** or **1**.
        + **0**: The rule is disabled.
        + **1**: The rule is enabled.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def subfield(self) -> _builtins.str:
        """
        The name of the masked field.
        """
        return pulumi.get(self, "subfield")


@pulumi.output_type
class GetRulesGeolocationAccessControlRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.int,
                 created_at: _builtins.str,
                 geolocation: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 policy_id: _builtins.str,
                 status: _builtins.int):
        """
        :param _builtins.int action: Specifies the protective action of the geolocation access control rule.
               The valid values are as follows:
               + **0**: Intercept the request.
               + **1**: Release the request.
               + **2**: Record the request only.
        :param _builtins.str created_at: The creation time of the geolocation access control rule.
        :param _builtins.str geolocation: The locations that can be configured in the geolocation access control rule.
        :param _builtins.str id: The ID of the geolocation access control rule.
        :param _builtins.str name: Specifies the name of the geolocation access control rule.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the the geolocation access control rules belong.
        :param _builtins.int status: Specifies the status of the geolocation access control rule.
               The valid values are as follows:
               + **0**: The geolocation access control rule is disabled.
               + **1**: The geolocation access control rule is active.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "geolocation", geolocation)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.int:
        """
        Specifies the protective action of the geolocation access control rule.
        The valid values are as follows:
        + **0**: Intercept the request.
        + **1**: Release the request.
        + **2**: Record the request only.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the geolocation access control rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def geolocation(self) -> _builtins.str:
        """
        The locations that can be configured in the geolocation access control rule.
        """
        return pulumi.get(self, "geolocation")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the geolocation access control rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the geolocation access control rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the the geolocation access control rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the geolocation access control rule.
        The valid values are as follows:
        + **0**: The geolocation access control rule is disabled.
        + **1**: The geolocation access control rule is active.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesGlobalProtectionWhitelistRuleResult(dict):
    def __init__(__self__, *,
                 advanced_contents: Sequence[_builtins.str],
                 advanced_field: _builtins.str,
                 conditions: Sequence['outputs.GetRulesGlobalProtectionWhitelistRuleConditionResult'],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 domains: Sequence[_builtins.str],
                 id: _builtins.str,
                 ignore_waf_protection: _builtins.str,
                 policy_id: _builtins.str,
                 status: _builtins.int):
        """
        :param Sequence[_builtins.str] advanced_contents: The subfiled of the advanced configuration.
        :param _builtins.str advanced_field: The filed type of the advanced configuration.
        :param Sequence['GetRulesGlobalProtectionWhitelistRuleConditionArgs'] conditions: The matching condition list of the global protection whitelist rule.
        :param _builtins.str created_at: The creation time of the global protection whitelist rule.
        :param _builtins.str description: The description of the global protection whitelist rule.
        :param Sequence[_builtins.str] domains: The protected domain name or website bound with the policy.
        :param _builtins.str id: The ID of the global protection whitelist rule.
        :param _builtins.str ignore_waf_protection: The rules that need to be ignored.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the global protection whitelist rules belong.
        :param _builtins.int status: Specifies the status of the global protection whitelist rule.
               The valid values are as follows:
               + **0**: The global protection whitelist rule is disabled.
               + **1**: The global protection whitelist rule is active.
        """
        pulumi.set(__self__, "advanced_contents", advanced_contents)
        pulumi.set(__self__, "advanced_field", advanced_field)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ignore_waf_protection", ignore_waf_protection)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="advancedContents")
    def advanced_contents(self) -> Sequence[_builtins.str]:
        """
        The subfiled of the advanced configuration.
        """
        return pulumi.get(self, "advanced_contents")

    @_builtins.property
    @pulumi.getter(name="advancedField")
    def advanced_field(self) -> _builtins.str:
        """
        The filed type of the advanced configuration.
        """
        return pulumi.get(self, "advanced_field")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetRulesGlobalProtectionWhitelistRuleConditionResult']:
        """
        The matching condition list of the global protection whitelist rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the global protection whitelist rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the global protection whitelist rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Sequence[_builtins.str]:
        """
        The protected domain name or website bound with the policy.
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the global protection whitelist rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ignoreWafProtection")
    def ignore_waf_protection(self) -> _builtins.str:
        """
        The rules that need to be ignored.
        """
        return pulumi.get(self, "ignore_waf_protection")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the global protection whitelist rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the global protection whitelist rule.
        The valid values are as follows:
        + **0**: The global protection whitelist rule is disabled.
        + **1**: The global protection whitelist rule is active.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetRulesGlobalProtectionWhitelistRuleConditionResult(dict):
    def __init__(__self__, *,
                 contents: Sequence[_builtins.str],
                 field: _builtins.str,
                 logic: _builtins.str,
                 subfield: _builtins.str):
        """
        :param Sequence[_builtins.str] contents: The content of the match condition.
        :param _builtins.str field: The field type of the condition.
        :param _builtins.str logic: The condition matching logic.
        :param _builtins.str subfield: The subfield of the condition.
        """
        pulumi.set(__self__, "contents", contents)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        pulumi.set(__self__, "subfield", subfield)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Sequence[_builtins.str]:
        """
        The content of the match condition.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        The field type of the condition.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        The condition matching logic.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter
    def subfield(self) -> _builtins.str:
        """
        The subfield of the condition.
        """
        return pulumi.get(self, "subfield")


@pulumi.output_type
class GetRulesInformationLeakagePreventionRuleResult(dict):
    def __init__(__self__, *,
                 contents: Sequence[_builtins.str],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 path: _builtins.str,
                 policy_id: _builtins.str,
                 protection_action: _builtins.str,
                 status: _builtins.int,
                 type: _builtins.str):
        """
        :param Sequence[_builtins.str] contents: The contents of the information leakage prevention rule.
        :param _builtins.str created_at: The creation time of the information leakage prevention rule.
        :param _builtins.str description: The description of the information leakage prevention rule.
        :param _builtins.str id: The ID of the information leakage prevention rule.
        :param _builtins.str path: The path to which the information leakage prevention rule applies.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the information leakage prevention rules belong.
        :param _builtins.str protection_action: The protection action of the information leakage prevention rule.
        :param _builtins.int status: Specifies the status of the information leakage prevention rule.
               The value can be **0** or **1**.
               + **0**: The rule is disabled.
               + **1**: The rule is enabled.
        :param _builtins.str type: Specifies the type of the information leakage prevention rule.
               The value can be **code** for response code or **sensitive** for sensitive information.
        """
        pulumi.set(__self__, "contents", contents)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "protection_action", protection_action)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Sequence[_builtins.str]:
        """
        The contents of the information leakage prevention rule.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the information leakage prevention rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the information leakage prevention rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the information leakage prevention rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to which the information leakage prevention rule applies.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the information leakage prevention rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="protectionAction")
    def protection_action(self) -> _builtins.str:
        """
        The protection action of the information leakage prevention rule.
        """
        return pulumi.get(self, "protection_action")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the information leakage prevention rule.
        The value can be **0** or **1**.
        + **0**: The rule is disabled.
        + **1**: The rule is enabled.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the information leakage prevention rule.
        The value can be **code** for response code or **sensitive** for sensitive information.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRulesKnownAttackSourceRuleResult(dict):
    def __init__(__self__, *,
                 block_time: _builtins.int,
                 block_type: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 policy_id: _builtins.str):
        """
        :param _builtins.int block_time: The block time of the known attack source rule.
        :param _builtins.str block_type: Specifies the block type of  the known attack source rule.
               The value can be **long_ip_block**, **long_cookie_block**, **long_params_block**, **short_ip_block**,
               **short_cookie_block** or **short_params_block**.
        :param _builtins.str created_at: The creation time of the known attack source rule.
        :param _builtins.str description: The description of the known attack source rule.
        :param _builtins.str id: The ID of the known attack source rule.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the known attack source rules belong.
        """
        pulumi.set(__self__, "block_time", block_time)
        pulumi.set(__self__, "block_type", block_type)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_id", policy_id)

    @_builtins.property
    @pulumi.getter(name="blockTime")
    def block_time(self) -> _builtins.int:
        """
        The block time of the known attack source rule.
        """
        return pulumi.get(self, "block_time")

    @_builtins.property
    @pulumi.getter(name="blockType")
    def block_type(self) -> _builtins.str:
        """
        Specifies the block type of  the known attack source rule.
        The value can be **long_ip_block**, **long_cookie_block**, **long_params_block**, **short_ip_block**,
        **short_cookie_block** or **short_params_block**.
        """
        return pulumi.get(self, "block_type")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the known attack source rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the known attack source rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the known attack source rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the known attack source rules belong.
        """
        return pulumi.get(self, "policy_id")


@pulumi.output_type
class GetRulesPreciseProtectionRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 conditions: Sequence['outputs.GetRulesPreciseProtectionRuleConditionResult'],
                 created_at: _builtins.str,
                 description: _builtins.str,
                 end_time: _builtins.str,
                 id: _builtins.str,
                 known_attack_source_id: _builtins.str,
                 name: _builtins.str,
                 policy_id: _builtins.str,
                 priority: _builtins.int,
                 start_time: _builtins.str,
                 status: _builtins.int,
                 time: _builtins.bool):
        """
        :param _builtins.str action: The protective action of the precise protection rule.
        :param Sequence['GetRulesPreciseProtectionRuleConditionArgs'] conditions: The matching condition list of the precision protection rule.
        :param _builtins.str created_at: The creation time of the precise protection rule.
        :param _builtins.str description: The description of the precise protection rule.
        :param _builtins.str end_time: The end time for the implementation of precision protection rule.
               This parameter will only be returned when the `time` value is **true**.
        :param _builtins.str id: The ID of the precise protection rule.
        :param _builtins.str known_attack_source_id: The known attack source ID.
        :param _builtins.str name: Specifies the name of the precise protection rule.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the precise protection rules belong.
        :param _builtins.int priority: The priority of the precise protection rule.
        :param _builtins.str start_time: The start time for the implementation of precision protection rule.
               This parameter will only be returned when the `time` value is **true**.
        :param _builtins.int status: Specifies the status of the precise protection rule.
        :param _builtins.bool time: The effective time of the precision protection rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "known_attack_source_id", known_attack_source_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The protective action of the precise protection rule.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetRulesPreciseProtectionRuleConditionResult']:
        """
        The matching condition list of the precision protection rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the precise protection rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the precise protection rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time for the implementation of precision protection rule.
        This parameter will only be returned when the `time` value is **true**.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the precise protection rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="knownAttackSourceId")
    def known_attack_source_id(self) -> _builtins.str:
        """
        The known attack source ID.
        """
        return pulumi.get(self, "known_attack_source_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the precise protection rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the precise protection rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of the precise protection rule.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time for the implementation of precision protection rule.
        This parameter will only be returned when the `time` value is **true**.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the precise protection rule.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def time(self) -> _builtins.bool:
        """
        The effective time of the precision protection rule.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GetRulesPreciseProtectionRuleConditionResult(dict):
    def __init__(__self__, *,
                 contents: Sequence[_builtins.str],
                 field: _builtins.str,
                 logic: _builtins.str,
                 reference_table_id: _builtins.str,
                 subfield: _builtins.str):
        """
        :param Sequence[_builtins.str] contents: The content of the match condition.
        :param _builtins.str field: The field of the condition.
        :param _builtins.str logic: The condition matching logic.
        :param _builtins.str reference_table_id: The reference table id.
        :param _builtins.str subfield: The subfield of the condition.
        """
        pulumi.set(__self__, "contents", contents)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "logic", logic)
        pulumi.set(__self__, "reference_table_id", reference_table_id)
        pulumi.set(__self__, "subfield", subfield)

    @_builtins.property
    @pulumi.getter
    def contents(self) -> Sequence[_builtins.str]:
        """
        The content of the match condition.
        """
        return pulumi.get(self, "contents")

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        The field of the condition.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def logic(self) -> _builtins.str:
        """
        The condition matching logic.
        """
        return pulumi.get(self, "logic")

    @_builtins.property
    @pulumi.getter(name="referenceTableId")
    def reference_table_id(self) -> _builtins.str:
        """
        The reference table id.
        """
        return pulumi.get(self, "reference_table_id")

    @_builtins.property
    @pulumi.getter
    def subfield(self) -> _builtins.str:
        """
        The subfield of the condition.
        """
        return pulumi.get(self, "subfield")


@pulumi.output_type
class GetRulesWebTamperProtectionRuleResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 domain: _builtins.str,
                 id: _builtins.str,
                 path: _builtins.str,
                 policy_id: _builtins.str,
                 status: _builtins.int):
        """
        :param _builtins.str created_at: The creation time of the web tamper protection rule.
        :param _builtins.str description: The description of the web tamper protection rule.
        :param _builtins.str domain: The domain name protected by the web tamper protection rule.
        :param _builtins.str id: The ID of the web tamper protection rule.
        :param _builtins.str path: The URL protected by the web tamper protection rule.
        :param _builtins.str policy_id: Specifies the ID of the policy to which the web tamper protection rules belong.
        :param _builtins.int status: Specifies the status of the web tamper protection rule.
               The value can be **0** or **1**.
               + **0**: The rule is disabled.
               + **1**: The rule is enabled.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the web tamper protection rule.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the web tamper protection rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name protected by the web tamper protection rule.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the web tamper protection rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The URL protected by the web tamper protection rule.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        Specifies the ID of the policy to which the web tamper protection rules belong.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the status of the web tamper protection rule.
        The value can be **0** or **1**.
        + **0**: The rule is disabled.
        + **1**: The rule is enabled.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetSecurityReportSubscriptionsItemResult(dict):
    def __init__(__self__, *,
                 enterprise_project_id: _builtins.str,
                 is_all_enterprise_project: _builtins.bool,
                 is_report_created: _builtins.bool,
                 latest_create_time: _builtins.int,
                 report_category: _builtins.str,
                 report_id: _builtins.str,
                 report_name: _builtins.str,
                 report_status: _builtins.str,
                 sending_period: _builtins.str,
                 subscription_id: _builtins.str,
                 template_eps_id: _builtins.str):
        """
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID.
               This parameter is valid only when the enterprise project is enabled.
               The default value is **0**, indicating the default enterprise project.
               If you need to query data for all enterprise projects, the value is **all_granted_eps**.
        :param _builtins.bool is_all_enterprise_project: Whether the security report belongs to all enterprise project.
        :param _builtins.bool is_report_created: The security report generation status.
        :param _builtins.int latest_create_time: The security report generation time.
        :param _builtins.str report_category: Specifies the security report type.
               The valid values are as follows:
               + **daily_report**Indicates security daily report.
               + **weekly_report**Indicates security weekly report.
               + **monthly_report**Indicates security monthly report.
               + **custom_report**: Indicates custom security report.
        :param _builtins.str report_id: The security report ID.
        :param _builtins.str report_name: Specifies the security report template name.
        :param _builtins.str report_status: Specifies the security report status.
               The valid values are as follows:
               + **opened**
               + **closed**
        :param _builtins.str sending_period: The send time period.
               The valid values are as follows:
               + **morning** (00:00~06:00)
               + **noon** (06:00~12:00)
               + **afternoon** (12:00~18:00)
               + **evening** (18:00~24:00)
        :param _builtins.str subscription_id: The subscription ID.
        :param _builtins.str template_eps_id: The enterprise project ID to which the security report belongs.
        """
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "is_all_enterprise_project", is_all_enterprise_project)
        pulumi.set(__self__, "is_report_created", is_report_created)
        pulumi.set(__self__, "latest_create_time", latest_create_time)
        pulumi.set(__self__, "report_category", report_category)
        pulumi.set(__self__, "report_id", report_id)
        pulumi.set(__self__, "report_name", report_name)
        pulumi.set(__self__, "report_status", report_status)
        pulumi.set(__self__, "sending_period", sending_period)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "template_eps_id", template_eps_id)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID.
        This parameter is valid only when the enterprise project is enabled.
        The default value is **0**, indicating the default enterprise project.
        If you need to query data for all enterprise projects, the value is **all_granted_eps**.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="isAllEnterpriseProject")
    def is_all_enterprise_project(self) -> _builtins.bool:
        """
        Whether the security report belongs to all enterprise project.
        """
        return pulumi.get(self, "is_all_enterprise_project")

    @_builtins.property
    @pulumi.getter(name="isReportCreated")
    def is_report_created(self) -> _builtins.bool:
        """
        The security report generation status.
        """
        return pulumi.get(self, "is_report_created")

    @_builtins.property
    @pulumi.getter(name="latestCreateTime")
    def latest_create_time(self) -> _builtins.int:
        """
        The security report generation time.
        """
        return pulumi.get(self, "latest_create_time")

    @_builtins.property
    @pulumi.getter(name="reportCategory")
    def report_category(self) -> _builtins.str:
        """
        Specifies the security report type.
        The valid values are as follows:
        + **daily_report**Indicates security daily report.
        + **weekly_report**Indicates security weekly report.
        + **monthly_report**Indicates security monthly report.
        + **custom_report**: Indicates custom security report.
        """
        return pulumi.get(self, "report_category")

    @_builtins.property
    @pulumi.getter(name="reportId")
    def report_id(self) -> _builtins.str:
        """
        The security report ID.
        """
        return pulumi.get(self, "report_id")

    @_builtins.property
    @pulumi.getter(name="reportName")
    def report_name(self) -> _builtins.str:
        """
        Specifies the security report template name.
        """
        return pulumi.get(self, "report_name")

    @_builtins.property
    @pulumi.getter(name="reportStatus")
    def report_status(self) -> _builtins.str:
        """
        Specifies the security report status.
        The valid values are as follows:
        + **opened**
        + **closed**
        """
        return pulumi.get(self, "report_status")

    @_builtins.property
    @pulumi.getter(name="sendingPeriod")
    def sending_period(self) -> _builtins.str:
        """
        The send time period.
        The valid values are as follows:
        + **morning** (00:00~06:00)
        + **noon** (06:00~12:00)
        + **afternoon** (12:00~18:00)
        + **evening** (18:00~24:00)
        """
        return pulumi.get(self, "sending_period")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="templateEpsId")
    def template_eps_id(self) -> _builtins.str:
        """
        The enterprise project ID to which the security report belongs.
        """
        return pulumi.get(self, "template_eps_id")


@pulumi.output_type
class GetSourceIpsSourceIpResult(dict):
    def __init__(__self__, *,
                 ips: Sequence[_builtins.str],
                 update_time: _builtins.str):
        """
        :param Sequence[_builtins.str] ips: WAF retrieval IP addresses.
        :param _builtins.str update_time: Time the WAF IP addresses are updated, in RFC3339 format.
        """
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Sequence[_builtins.str]:
        """
        WAF retrieval IP addresses.
        """
        return pulumi.get(self, "ips")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        Time the WAF IP addresses are updated, in RFC3339 format.
        """
        return pulumi.get(self, "update_time")


