# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['DomainArgs', 'Domain']

@pulumi.input_type
class DomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str],
                 servers: pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]],
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_page: Optional[pulumi.Input['DomainCustomPageArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 http2_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 lb_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_settings: Optional[pulumi.Input['DomainTimeoutSettingsArgs']] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_mark: Optional[pulumi.Input['DomainTrafficMarkArgs']] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a Domain resource.
        :param pulumi.Input[_builtins.str] domain: Specifies the domain name to be protected. For example, `www.example.com` or
               `*.example.com`. Changing this creates a new domain.
        :param pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]] servers: Specifies an array of origin web servers.
               The server structure is documented below.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] certificate_name: Specifies the certificate name. This parameter is mandatory
               when `client_protocol` is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] charging_mode: Specifies the charging mode of the domain. Valid values are **prePaid**
               and **postPaid**, defaults to **prePaid**. Changing this creates a new instance.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain.
               The options include **cipher_1**, **cipher_2**,**cipher_3**, **cipher_4**, **cipher_default**.
        :param pulumi.Input['DomainCustomPageArgs'] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF domain.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF domain.
               For enterprise users, if omitted, default enterprise project will be used.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] http2_enable: Specifies whether to use the http2 protocol.
               This field is only used for communication between clients and WAF.
               Defaults to **false**.
               Things to note when using this field are as follows:
               + There must be at least one server configuration with client protocol set to **HTTPS**, or this configuration is unable
               to work.
               + This field cannot not work if the client supports **TLS 1.3**.
               + This field can work only when the client supports **TLS 1.2** or earlier versions.
               + If you want to use HTTP/2 forwarding, use a dedicated WAF instance.
        :param pulumi.Input[_builtins.bool] ipv6_enable: Specifies whether IPv6 protection is enabled.
               Enable IPv6 protection if the domain name is accessible using an IPv6 address.
               After you enable it, WAF assigns an IPv6 address to the domain name.
               This field must be set to **true** when `server` contains a value of type **ipv6**.
               Defaults to false.
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] lb_algorithm: Specifies the load balancing algorithms used to
               distribute requests across origin servers.
               Only the professional edition (original enterprise edition) and platinum edition
               (original ultimate edition) support configuring the load balancing algorithm.
               The options of value are as follows:
               + **ip_hash** : Requests from the same IP address are routed to the same backend server.
               + **round_robin** : Requests are distributed across backend servers in turn based on the
               weight you assign to each server.
               + **session_hash** : Direct requests with the same session ID to the same origin server.
               Before using this configuration, please make sure to configure the traffic identifier for
               attack punishment after adding the domain name, otherwise the session hash configuration will not take effect.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
               The field `pci_3ds` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**.
               The field `pci_dss` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new
               policy will be created automatically.
        :param pulumi.Input[_builtins.int] protect_status: The protection status of domain. Valid values are:
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the WAF domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new certificate.
        :param pulumi.Input['DomainTimeoutSettingsArgs'] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
               
               <a name="Domain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The options include **TLS v1.0**, **TLS v1.1**,
               **TLS v1.2**.
        :param pulumi.Input['DomainTrafficMarkArgs'] traffic_mark: Specifies the traffic identifier.
               WAF uses the configurations to identify the malicious client IP address (proxy mode) in the header,
               session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name.
               This website name must start with a letter and only letters, digits, underscores (_),
               hyphens (-), colons (:) and periods (.) are allowed.
               The value contains `1` to `128` characters.
               The website name must be unique within this account.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "servers", servers)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if custom_page is not None:
            pulumi.set(__self__, "custom_page", custom_page)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        if forward_header_map is not None:
            pulumi.set(__self__, "forward_header_map", forward_header_map)
        if http2_enable is not None:
            pulumi.set(__self__, "http2_enable", http2_enable)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if keep_policy is not None:
            pulumi.set(__self__, "keep_policy", keep_policy)
        if lb_algorithm is not None:
            pulumi.set(__self__, "lb_algorithm", lb_algorithm)
        if pci3ds is not None:
            pulumi.set(__self__, "pci3ds", pci3ds)
        if pci_dss is not None:
            pulumi.set(__self__, "pci_dss", pci_dss)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if protect_status is not None:
            pulumi.set(__self__, "protect_status", protect_status)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if traffic_mark is not None:
            pulumi.set(__self__, "traffic_mark", traffic_mark)
        if website_name is not None:
            pulumi.set(__self__, "website_name", website_name)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the domain name to be protected. For example, `www.example.com` or
        `*.example.com`. Changing this creates a new domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]]:
        """
        Specifies an array of origin web servers.
        The server structure is documented below.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]]):
        pulumi.set(self, "servers", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate ID. This parameter is mandatory when `client_protocol`
        is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate name. This parameter is mandatory
        when `client_protocol` is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the charging mode of the domain. Valid values are **prePaid**
        and **postPaid**, defaults to **prePaid**. Changing this creates a new instance.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cipher suite of domain.
        The options include **cipher_1**, **cipher_2**,**cipher_3**, **cipher_4**, **cipher_default**.
        """
        return pulumi.get(self, "cipher")

    @cipher.setter
    def cipher(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cipher", value)

    @_builtins.property
    @pulumi.getter(name="customPage")
    def custom_page(self) -> Optional[pulumi.Input['DomainCustomPageArgs']]:
        """
        Specifies the custom page. Only supports one custom alarm page.
        The custom_page structure is documented below.
        """
        return pulumi.get(self, "custom_page")

    @custom_page.setter
    def custom_page(self, value: Optional[pulumi.Input['DomainCustomPageArgs']]):
        pulumi.set(self, "custom_page", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the WAF domain.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the enterprise project ID of WAF domain.
        For enterprise users, if omitted, default enterprise project will be used.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "enterprise_project_id")

    @enterprise_project_id.setter
    def enterprise_project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enterprise_project_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardHeaderMap")
    def forward_header_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the field forwarding configuration. WAF inserts the added fields into
        the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
        The options of value are as follows:
        + **$time_local**
        + **$request_id**
        + **$connection_requests**
        + **$tenant_id**
        + **$project_id**
        + **$remote_addr**
        + **$remote_port**
        + **$scheme**
        + **$request_method**
        + **$http_host**
        + **$origin_uri**
        + **$request_length**
        + **$ssl_server_name**
        + **$ssl_protocol**
        + **$ssl_curves**
        + **$ssl_session_reused**
        """
        return pulumi.get(self, "forward_header_map")

    @forward_header_map.setter
    def forward_header_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "forward_header_map", value)

    @_builtins.property
    @pulumi.getter(name="http2Enable")
    def http2_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to use the http2 protocol.
        This field is only used for communication between clients and WAF.
        Defaults to **false**.
        Things to note when using this field are as follows:
        + There must be at least one server configuration with client protocol set to **HTTPS**, or this configuration is unable
        to work.
        + This field cannot not work if the client supports **TLS 1.3**.
        + This field can work only when the client supports **TLS 1.2** or earlier versions.
        + If you want to use HTTP/2 forwarding, use a dedicated WAF instance.
        """
        return pulumi.get(self, "http2_enable")

    @http2_enable.setter
    def http2_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_enable", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether IPv6 protection is enabled.
        Enable IPv6 protection if the domain name is accessible using an IPv6 address.
        After you enable it, WAF assigns an IPv6 address to the domain name.
        This field must be set to **true** when `server` contains a value of type **ipv6**.
        Defaults to false.
        """
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @_builtins.property
    @pulumi.getter(name="keepPolicy")
    def keep_policy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to retain the policy when deleting a domain name.
        Defaults to **true**.
        """
        return pulumi.get(self, "keep_policy")

    @keep_policy.setter
    def keep_policy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keep_policy", value)

    @_builtins.property
    @pulumi.getter(name="lbAlgorithm")
    def lb_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the load balancing algorithms used to
        distribute requests across origin servers.
        Only the professional edition (original enterprise edition) and platinum edition
        (original ultimate edition) support configuring the load balancing algorithm.
        The options of value are as follows:
        + **ip_hash** : Requests from the same IP address are routed to the same backend server.
        + **round_robin** : Requests are distributed across backend servers in turn based on the
        weight you assign to each server.
        + **session_hash** : Direct requests with the same session ID to the same origin server.
        Before using this configuration, please make sure to configure the traffic identifier for
        attack punishment after adding the domain name, otherwise the session hash configuration will not take effect.
        """
        return pulumi.get(self, "lb_algorithm")

    @lb_algorithm.setter
    def lb_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lb_algorithm", value)

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI 3DS compliance certification check.
        This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**. The PCI 3DS compliance certification
        check cannot be disabled after being enabled.
        The field `pci_3ds` is meaningful only if `certificate_id` is specified.
        """
        return pulumi.get(self, "pci3ds")

    @pci3ds.setter
    def pci3ds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci3ds", value)

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI DSS compliance certification check.
        This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**.
        The field `pci_dss` is meaningful only if `certificate_id` is specified.
        """
        return pulumi.get(self, "pci_dss")

    @pci_dss.setter
    def pci_dss(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci_dss", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the policy ID associated with the domain. If not specified, a new
        policy will be created automatically.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The protection status of domain. Valid values are:
        """
        return pulumi.get(self, "protect_status")

    @protect_status.setter
    def protect_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protect_status", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether a proxy is configured.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL of the redirected page. The root domain name of the redirection
        address must be the name of the currently protected domain (including a wildcard domain name).
        The available **${http_host}** can be used to indicate the currently protected domain name and port.
        For example: **${http_host}/error.html**.

        > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the WAF domain resource.
        If omitted, the provider-level region will be used. Changing this setting will push a new certificate.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional[pulumi.Input['DomainTimeoutSettingsArgs']]:
        """
        Specifies the timeout setting. Only supports one timeout setting.
        The timeout_settings structure is documented below.

        <a name="Domain_server"></a>
        The `server` block supports:
        """
        return pulumi.get(self, "timeout_settings")

    @timeout_settings.setter
    def timeout_settings(self, value: Optional[pulumi.Input['DomainTimeoutSettingsArgs']]):
        pulumi.set(self, "timeout_settings", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the minimum required TLS version. The options include **TLS v1.0**, **TLS v1.1**,
        **TLS v1.2**.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter(name="trafficMark")
    def traffic_mark(self) -> Optional[pulumi.Input['DomainTrafficMarkArgs']]:
        """
        Specifies the traffic identifier.
        WAF uses the configurations to identify the malicious client IP address (proxy mode) in the header,
        session in the cookie, and user attribute in the parameter,
        and then triggers the corresponding known attack source rules to block attack sources.
        Only supports one traffic identifier.
        The traffic_mark structure is documented below.
        """
        return pulumi.get(self, "traffic_mark")

    @traffic_mark.setter
    def traffic_mark(self, value: Optional[pulumi.Input['DomainTrafficMarkArgs']]):
        pulumi.set(self, "traffic_mark", value)

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the website name.
        This website name must start with a letter and only letters, digits, underscores (_),
        hyphens (-), colons (:) and periods (.) are allowed.
        The value contains `1` to `128` characters.
        The website name must be unique within this account.
        """
        return pulumi.get(self, "website_name")

    @website_name.setter
    def website_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "website_name", value)


@pulumi.input_type
class _DomainState:
    def __init__(__self__, *,
                 access_code: Optional[pulumi.Input[_builtins.str]] = None,
                 access_status: Optional[pulumi.Input[_builtins.int]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_page: Optional[pulumi.Input['DomainCustomPageArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 http2_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 lb_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]]] = None,
                 timeout_settings: Optional[pulumi.Input['DomainTimeoutSettingsArgs']] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_mark: Optional[pulumi.Input['DomainTrafficMarkArgs']] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering Domain resources.
        :param pulumi.Input[_builtins.str] access_code: The CNAME prefix. The CNAME suffix is `.vip1.huaweicloudwaf.com`.
        :param pulumi.Input[_builtins.int] access_status: Whether a domain name is connected to WAF. 0: The domain name is not connected to WAF, 1: The domain
               name is connected to WAF.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] certificate_name: Specifies the certificate name. This parameter is mandatory
               when `client_protocol` is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] charging_mode: Specifies the charging mode of the domain. Valid values are **prePaid**
               and **postPaid**, defaults to **prePaid**. Changing this creates a new instance.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain.
               The options include **cipher_1**, **cipher_2**,**cipher_3**, **cipher_4**, **cipher_default**.
        :param pulumi.Input['DomainCustomPageArgs'] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF domain.
        :param pulumi.Input[_builtins.str] domain: Specifies the domain name to be protected. For example, `www.example.com` or
               `*.example.com`. Changing this creates a new domain.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF domain.
               For enterprise users, if omitted, default enterprise project will be used.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] http2_enable: Specifies whether to use the http2 protocol.
               This field is only used for communication between clients and WAF.
               Defaults to **false**.
               Things to note when using this field are as follows:
               + There must be at least one server configuration with client protocol set to **HTTPS**, or this configuration is unable
               to work.
               + This field cannot not work if the client supports **TLS 1.3**.
               + This field can work only when the client supports **TLS 1.2** or earlier versions.
               + If you want to use HTTP/2 forwarding, use a dedicated WAF instance.
        :param pulumi.Input[_builtins.bool] ipv6_enable: Specifies whether IPv6 protection is enabled.
               Enable IPv6 protection if the domain name is accessible using an IPv6 address.
               After you enable it, WAF assigns an IPv6 address to the domain name.
               This field must be set to **true** when `server` contains a value of type **ipv6**.
               Defaults to false.
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] lb_algorithm: Specifies the load balancing algorithms used to
               distribute requests across origin servers.
               Only the professional edition (original enterprise edition) and platinum edition
               (original ultimate edition) support configuring the load balancing algorithm.
               The options of value are as follows:
               + **ip_hash** : Requests from the same IP address are routed to the same backend server.
               + **round_robin** : Requests are distributed across backend servers in turn based on the
               weight you assign to each server.
               + **session_hash** : Direct requests with the same session ID to the same origin server.
               Before using this configuration, please make sure to configure the traffic identifier for
               attack punishment after adding the domain name, otherwise the session hash configuration will not take effect.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
               The field `pci_3ds` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**.
               The field `pci_dss` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new
               policy will be created automatically.
        :param pulumi.Input[_builtins.int] protect_status: The protection status of domain. Valid values are:
        :param pulumi.Input[_builtins.str] protocol: The protocol type of the client. The options are HTTP, HTTPS, and HTTP&HTTPS.
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the WAF domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new certificate.
        :param pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]] servers: Specifies an array of origin web servers.
               The server structure is documented below.
        :param pulumi.Input['DomainTimeoutSettingsArgs'] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
               
               <a name="Domain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The options include **TLS v1.0**, **TLS v1.1**,
               **TLS v1.2**.
        :param pulumi.Input['DomainTrafficMarkArgs'] traffic_mark: Specifies the traffic identifier.
               WAF uses the configurations to identify the malicious client IP address (proxy mode) in the header,
               session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name.
               This website name must start with a letter and only letters, digits, underscores (_),
               hyphens (-), colons (:) and periods (.) are allowed.
               The value contains `1` to `128` characters.
               The website name must be unique within this account.
        """
        if access_code is not None:
            pulumi.set(__self__, "access_code", access_code)
        if access_status is not None:
            pulumi.set(__self__, "access_status", access_status)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if custom_page is not None:
            pulumi.set(__self__, "custom_page", custom_page)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        if forward_header_map is not None:
            pulumi.set(__self__, "forward_header_map", forward_header_map)
        if http2_enable is not None:
            pulumi.set(__self__, "http2_enable", http2_enable)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if keep_policy is not None:
            pulumi.set(__self__, "keep_policy", keep_policy)
        if lb_algorithm is not None:
            pulumi.set(__self__, "lb_algorithm", lb_algorithm)
        if pci3ds is not None:
            pulumi.set(__self__, "pci3ds", pci3ds)
        if pci_dss is not None:
            pulumi.set(__self__, "pci_dss", pci_dss)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if protect_status is not None:
            pulumi.set(__self__, "protect_status", protect_status)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if traffic_mark is not None:
            pulumi.set(__self__, "traffic_mark", traffic_mark)
        if website_name is not None:
            pulumi.set(__self__, "website_name", website_name)

    @_builtins.property
    @pulumi.getter(name="accessCode")
    def access_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CNAME prefix. The CNAME suffix is `.vip1.huaweicloudwaf.com`.
        """
        return pulumi.get(self, "access_code")

    @access_code.setter
    def access_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_code", value)

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether a domain name is connected to WAF. 0: The domain name is not connected to WAF, 1: The domain
        name is connected to WAF.
        """
        return pulumi.get(self, "access_status")

    @access_status.setter
    def access_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "access_status", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate ID. This parameter is mandatory when `client_protocol`
        is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate name. This parameter is mandatory
        when `client_protocol` is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the charging mode of the domain. Valid values are **prePaid**
        and **postPaid**, defaults to **prePaid**. Changing this creates a new instance.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cipher suite of domain.
        The options include **cipher_1**, **cipher_2**,**cipher_3**, **cipher_4**, **cipher_default**.
        """
        return pulumi.get(self, "cipher")

    @cipher.setter
    def cipher(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cipher", value)

    @_builtins.property
    @pulumi.getter(name="customPage")
    def custom_page(self) -> Optional[pulumi.Input['DomainCustomPageArgs']]:
        """
        Specifies the custom page. Only supports one custom alarm page.
        The custom_page structure is documented below.
        """
        return pulumi.get(self, "custom_page")

    @custom_page.setter
    def custom_page(self, value: Optional[pulumi.Input['DomainCustomPageArgs']]):
        pulumi.set(self, "custom_page", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the WAF domain.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the domain name to be protected. For example, `www.example.com` or
        `*.example.com`. Changing this creates a new domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the enterprise project ID of WAF domain.
        For enterprise users, if omitted, default enterprise project will be used.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "enterprise_project_id")

    @enterprise_project_id.setter
    def enterprise_project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enterprise_project_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardHeaderMap")
    def forward_header_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the field forwarding configuration. WAF inserts the added fields into
        the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
        The options of value are as follows:
        + **$time_local**
        + **$request_id**
        + **$connection_requests**
        + **$tenant_id**
        + **$project_id**
        + **$remote_addr**
        + **$remote_port**
        + **$scheme**
        + **$request_method**
        + **$http_host**
        + **$origin_uri**
        + **$request_length**
        + **$ssl_server_name**
        + **$ssl_protocol**
        + **$ssl_curves**
        + **$ssl_session_reused**
        """
        return pulumi.get(self, "forward_header_map")

    @forward_header_map.setter
    def forward_header_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "forward_header_map", value)

    @_builtins.property
    @pulumi.getter(name="http2Enable")
    def http2_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to use the http2 protocol.
        This field is only used for communication between clients and WAF.
        Defaults to **false**.
        Things to note when using this field are as follows:
        + There must be at least one server configuration with client protocol set to **HTTPS**, or this configuration is unable
        to work.
        + This field cannot not work if the client supports **TLS 1.3**.
        + This field can work only when the client supports **TLS 1.2** or earlier versions.
        + If you want to use HTTP/2 forwarding, use a dedicated WAF instance.
        """
        return pulumi.get(self, "http2_enable")

    @http2_enable.setter
    def http2_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "http2_enable", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether IPv6 protection is enabled.
        Enable IPv6 protection if the domain name is accessible using an IPv6 address.
        After you enable it, WAF assigns an IPv6 address to the domain name.
        This field must be set to **true** when `server` contains a value of type **ipv6**.
        Defaults to false.
        """
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @_builtins.property
    @pulumi.getter(name="keepPolicy")
    def keep_policy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to retain the policy when deleting a domain name.
        Defaults to **true**.
        """
        return pulumi.get(self, "keep_policy")

    @keep_policy.setter
    def keep_policy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keep_policy", value)

    @_builtins.property
    @pulumi.getter(name="lbAlgorithm")
    def lb_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the load balancing algorithms used to
        distribute requests across origin servers.
        Only the professional edition (original enterprise edition) and platinum edition
        (original ultimate edition) support configuring the load balancing algorithm.
        The options of value are as follows:
        + **ip_hash** : Requests from the same IP address are routed to the same backend server.
        + **round_robin** : Requests are distributed across backend servers in turn based on the
        weight you assign to each server.
        + **session_hash** : Direct requests with the same session ID to the same origin server.
        Before using this configuration, please make sure to configure the traffic identifier for
        attack punishment after adding the domain name, otherwise the session hash configuration will not take effect.
        """
        return pulumi.get(self, "lb_algorithm")

    @lb_algorithm.setter
    def lb_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lb_algorithm", value)

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI 3DS compliance certification check.
        This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**. The PCI 3DS compliance certification
        check cannot be disabled after being enabled.
        The field `pci_3ds` is meaningful only if `certificate_id` is specified.
        """
        return pulumi.get(self, "pci3ds")

    @pci3ds.setter
    def pci3ds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci3ds", value)

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI DSS compliance certification check.
        This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**.
        The field `pci_dss` is meaningful only if `certificate_id` is specified.
        """
        return pulumi.get(self, "pci_dss")

    @pci_dss.setter
    def pci_dss(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci_dss", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the policy ID associated with the domain. If not specified, a new
        policy will be created automatically.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The protection status of domain. Valid values are:
        """
        return pulumi.get(self, "protect_status")

    @protect_status.setter
    def protect_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protect_status", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol type of the client. The options are HTTP, HTTPS, and HTTP&HTTPS.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether a proxy is configured.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL of the redirected page. The root domain name of the redirection
        address must be the name of the currently protected domain (including a wildcard domain name).
        The available **${http_host}** can be used to indicate the currently protected domain name and port.
        For example: **${http_host}/error.html**.

        > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the WAF domain resource.
        If omitted, the provider-level region will be used. Changing this setting will push a new certificate.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]]]:
        """
        Specifies an array of origin web servers.
        The server structure is documented below.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional[pulumi.Input['DomainTimeoutSettingsArgs']]:
        """
        Specifies the timeout setting. Only supports one timeout setting.
        The timeout_settings structure is documented below.

        <a name="Domain_server"></a>
        The `server` block supports:
        """
        return pulumi.get(self, "timeout_settings")

    @timeout_settings.setter
    def timeout_settings(self, value: Optional[pulumi.Input['DomainTimeoutSettingsArgs']]):
        pulumi.set(self, "timeout_settings", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the minimum required TLS version. The options include **TLS v1.0**, **TLS v1.1**,
        **TLS v1.2**.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter(name="trafficMark")
    def traffic_mark(self) -> Optional[pulumi.Input['DomainTrafficMarkArgs']]:
        """
        Specifies the traffic identifier.
        WAF uses the configurations to identify the malicious client IP address (proxy mode) in the header,
        session in the cookie, and user attribute in the parameter,
        and then triggers the corresponding known attack source rules to block attack sources.
        Only supports one traffic identifier.
        The traffic_mark structure is documented below.
        """
        return pulumi.get(self, "traffic_mark")

    @traffic_mark.setter
    def traffic_mark(self, value: Optional[pulumi.Input['DomainTrafficMarkArgs']]):
        pulumi.set(self, "traffic_mark", value)

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the website name.
        This website name must start with a letter and only letters, digits, underscores (_),
        hyphens (-), colons (:) and periods (.) are allowed.
        The value contains `1` to `128` characters.
        The website name must be unique within this account.
        """
        return pulumi.get(self, "website_name")

    @website_name.setter
    def website_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "website_name", value)


@pulumi.type_token("huaweicloud:Waf/domain:Domain")
class Domain(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_page: Optional[pulumi.Input[Union['DomainCustomPageArgs', 'DomainCustomPageArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 http2_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 lb_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DomainServerArgs', 'DomainServerArgsDict']]]]] = None,
                 timeout_settings: Optional[pulumi.Input[Union['DomainTimeoutSettingsArgs', 'DomainTimeoutSettingsArgsDict']]] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_mark: Optional[pulumi.Input[Union['DomainTrafficMarkArgs', 'DomainTrafficMarkArgsDict']]] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        Manages a WAF domain resource within HuaweiCloud.

        > **NOTE:** All WAF resources depend on WAF instances, and the WAF instances need to be purchased before they can be
        used. The domain name resource can be used in Cloud Mode.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        enterprise_project_id = config.require_object("enterpriseProjectId")
        certificate_id = config.require_object("certificateId")
        certificate_name = config.require_object("certificateName")
        test = huaweicloud.waf.Domain("test",
            domain="www.example.com",
            certificate_id=certificate_id,
            certificate_name=certificate_name,
            proxy=True,
            enterprise_project_id=enterprise_project_id,
            description="test description",
            website_name="websiteName",
            protect_status=1,
            forward_header_map={
                "key1": "$time_local",
                "key2": "$tenant_id",
            },
            custom_page={
                "http_return_code": "404",
                "block_page_type": "application/json",
                "page_content": \"\"\"{
          "event_id": "${waf_event_id}",
          "error_msg": "error message"
        }
        \"\"\",
            },
            timeout_settings={
                "connection_timeout": 100,
                "read_timeout": 1000,
                "write_timeout": 1000,
            },
            traffic_mark={
                "ip_tags": ["ip_tag"],
                "session_tag": "session_tag",
                "user_tag": "user_tag",
            },
            servers=[{
                "client_protocol": "HTTPS",
                "server_protocol": "HTTP",
                "address": "119.8.0.13",
                "port": 8080,
                "type": "ipv4",
            }])
        ```

        ## Import

        There are two ways to import WAF domain state.

        * Using the `id`, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/domain:Domain test <id>
        ```

        * Using `id` and `enterprise_project_id`, separated by a slash, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/domain:Domain test <id>/<enterprise_project_id>
        ```

        Note that the imported state may not be identical to your resource definition, due to some attributes missing from the

        API response, security or some other reason. The missing attributes include: `keep_policy`, `charging_mode`, `ipv6_enable`.

        It is generally recommended running `pulumi preview` after importing a resource.

        You can then decide if changes should be applied to the resource, or the resource definition should be updated to align

        with the resource. Also, you can ignore changes as below.

        hcl

        resource "huaweicloud_waf_domain" "test" {

          ...

          lifecycle {

            ignore_changes = [
            
              keep_policy,
            
              charging_mode,
            
              ipv6_enable,
            
            ]

          }

        }

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] certificate_name: Specifies the certificate name. This parameter is mandatory
               when `client_protocol` is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] charging_mode: Specifies the charging mode of the domain. Valid values are **prePaid**
               and **postPaid**, defaults to **prePaid**. Changing this creates a new instance.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain.
               The options include **cipher_1**, **cipher_2**,**cipher_3**, **cipher_4**, **cipher_default**.
        :param pulumi.Input[Union['DomainCustomPageArgs', 'DomainCustomPageArgsDict']] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF domain.
        :param pulumi.Input[_builtins.str] domain: Specifies the domain name to be protected. For example, `www.example.com` or
               `*.example.com`. Changing this creates a new domain.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF domain.
               For enterprise users, if omitted, default enterprise project will be used.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] http2_enable: Specifies whether to use the http2 protocol.
               This field is only used for communication between clients and WAF.
               Defaults to **false**.
               Things to note when using this field are as follows:
               + There must be at least one server configuration with client protocol set to **HTTPS**, or this configuration is unable
               to work.
               + This field cannot not work if the client supports **TLS 1.3**.
               + This field can work only when the client supports **TLS 1.2** or earlier versions.
               + If you want to use HTTP/2 forwarding, use a dedicated WAF instance.
        :param pulumi.Input[_builtins.bool] ipv6_enable: Specifies whether IPv6 protection is enabled.
               Enable IPv6 protection if the domain name is accessible using an IPv6 address.
               After you enable it, WAF assigns an IPv6 address to the domain name.
               This field must be set to **true** when `server` contains a value of type **ipv6**.
               Defaults to false.
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] lb_algorithm: Specifies the load balancing algorithms used to
               distribute requests across origin servers.
               Only the professional edition (original enterprise edition) and platinum edition
               (original ultimate edition) support configuring the load balancing algorithm.
               The options of value are as follows:
               + **ip_hash** : Requests from the same IP address are routed to the same backend server.
               + **round_robin** : Requests are distributed across backend servers in turn based on the
               weight you assign to each server.
               + **session_hash** : Direct requests with the same session ID to the same origin server.
               Before using this configuration, please make sure to configure the traffic identifier for
               attack punishment after adding the domain name, otherwise the session hash configuration will not take effect.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
               The field `pci_3ds` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**.
               The field `pci_dss` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new
               policy will be created automatically.
        :param pulumi.Input[_builtins.int] protect_status: The protection status of domain. Valid values are:
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the WAF domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new certificate.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DomainServerArgs', 'DomainServerArgsDict']]]] servers: Specifies an array of origin web servers.
               The server structure is documented below.
        :param pulumi.Input[Union['DomainTimeoutSettingsArgs', 'DomainTimeoutSettingsArgsDict']] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
               
               <a name="Domain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The options include **TLS v1.0**, **TLS v1.1**,
               **TLS v1.2**.
        :param pulumi.Input[Union['DomainTrafficMarkArgs', 'DomainTrafficMarkArgsDict']] traffic_mark: Specifies the traffic identifier.
               WAF uses the configurations to identify the malicious client IP address (proxy mode) in the header,
               session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name.
               This website name must start with a letter and only letters, digits, underscores (_),
               hyphens (-), colons (:) and periods (.) are allowed.
               The value contains `1` to `128` characters.
               The website name must be unique within this account.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: DomainArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Manages a WAF domain resource within HuaweiCloud.

        > **NOTE:** All WAF resources depend on WAF instances, and the WAF instances need to be purchased before they can be
        used. The domain name resource can be used in Cloud Mode.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        enterprise_project_id = config.require_object("enterpriseProjectId")
        certificate_id = config.require_object("certificateId")
        certificate_name = config.require_object("certificateName")
        test = huaweicloud.waf.Domain("test",
            domain="www.example.com",
            certificate_id=certificate_id,
            certificate_name=certificate_name,
            proxy=True,
            enterprise_project_id=enterprise_project_id,
            description="test description",
            website_name="websiteName",
            protect_status=1,
            forward_header_map={
                "key1": "$time_local",
                "key2": "$tenant_id",
            },
            custom_page={
                "http_return_code": "404",
                "block_page_type": "application/json",
                "page_content": \"\"\"{
          "event_id": "${waf_event_id}",
          "error_msg": "error message"
        }
        \"\"\",
            },
            timeout_settings={
                "connection_timeout": 100,
                "read_timeout": 1000,
                "write_timeout": 1000,
            },
            traffic_mark={
                "ip_tags": ["ip_tag"],
                "session_tag": "session_tag",
                "user_tag": "user_tag",
            },
            servers=[{
                "client_protocol": "HTTPS",
                "server_protocol": "HTTP",
                "address": "119.8.0.13",
                "port": 8080,
                "type": "ipv4",
            }])
        ```

        ## Import

        There are two ways to import WAF domain state.

        * Using the `id`, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/domain:Domain test <id>
        ```

        * Using `id` and `enterprise_project_id`, separated by a slash, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/domain:Domain test <id>/<enterprise_project_id>
        ```

        Note that the imported state may not be identical to your resource definition, due to some attributes missing from the

        API response, security or some other reason. The missing attributes include: `keep_policy`, `charging_mode`, `ipv6_enable`.

        It is generally recommended running `pulumi preview` after importing a resource.

        You can then decide if changes should be applied to the resource, or the resource definition should be updated to align

        with the resource. Also, you can ignore changes as below.

        hcl

        resource "huaweicloud_waf_domain" "test" {

          ...

          lifecycle {

            ignore_changes = [
            
              keep_policy,
            
              charging_mode,
            
              ipv6_enable,
            
            ]

          }

        }

        :param str resource_name: The name of the resource.
        :param DomainArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(DomainArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_page: Optional[pulumi.Input[Union['DomainCustomPageArgs', 'DomainCustomPageArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 http2_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 lb_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DomainServerArgs', 'DomainServerArgsDict']]]]] = None,
                 timeout_settings: Optional[pulumi.Input[Union['DomainTimeoutSettingsArgs', 'DomainTimeoutSettingsArgsDict']]] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_mark: Optional[pulumi.Input[Union['DomainTrafficMarkArgs', 'DomainTrafficMarkArgsDict']]] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = DomainArgs.__new__(DomainArgs)

            __props__.__dict__["certificate_id"] = certificate_id
            __props__.__dict__["certificate_name"] = certificate_name
            __props__.__dict__["charging_mode"] = charging_mode
            __props__.__dict__["cipher"] = cipher
            __props__.__dict__["custom_page"] = custom_page
            __props__.__dict__["description"] = description
            if domain is None and not opts.urn:
                raise TypeError("Missing required property 'domain'")
            __props__.__dict__["domain"] = domain
            __props__.__dict__["enterprise_project_id"] = enterprise_project_id
            __props__.__dict__["forward_header_map"] = forward_header_map
            __props__.__dict__["http2_enable"] = http2_enable
            __props__.__dict__["ipv6_enable"] = ipv6_enable
            __props__.__dict__["keep_policy"] = keep_policy
            __props__.__dict__["lb_algorithm"] = lb_algorithm
            __props__.__dict__["pci3ds"] = pci3ds
            __props__.__dict__["pci_dss"] = pci_dss
            __props__.__dict__["policy_id"] = policy_id
            __props__.__dict__["protect_status"] = protect_status
            __props__.__dict__["proxy"] = proxy
            __props__.__dict__["redirect_url"] = redirect_url
            __props__.__dict__["region"] = region
            if servers is None and not opts.urn:
                raise TypeError("Missing required property 'servers'")
            __props__.__dict__["servers"] = servers
            __props__.__dict__["timeout_settings"] = timeout_settings
            __props__.__dict__["tls"] = tls
            __props__.__dict__["traffic_mark"] = traffic_mark
            __props__.__dict__["website_name"] = website_name
            __props__.__dict__["access_code"] = None
            __props__.__dict__["access_status"] = None
            __props__.__dict__["protocol"] = None
        super(Domain, __self__).__init__(
            'huaweicloud:Waf/domain:Domain',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            access_code: Optional[pulumi.Input[_builtins.str]] = None,
            access_status: Optional[pulumi.Input[_builtins.int]] = None,
            certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
            certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
            charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
            cipher: Optional[pulumi.Input[_builtins.str]] = None,
            custom_page: Optional[pulumi.Input[Union['DomainCustomPageArgs', 'DomainCustomPageArgsDict']]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            domain: Optional[pulumi.Input[_builtins.str]] = None,
            enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
            forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
            http2_enable: Optional[pulumi.Input[_builtins.bool]] = None,
            ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
            keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
            lb_algorithm: Optional[pulumi.Input[_builtins.str]] = None,
            pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
            pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
            policy_id: Optional[pulumi.Input[_builtins.str]] = None,
            protect_status: Optional[pulumi.Input[_builtins.int]] = None,
            protocol: Optional[pulumi.Input[_builtins.str]] = None,
            proxy: Optional[pulumi.Input[_builtins.bool]] = None,
            redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
            region: Optional[pulumi.Input[_builtins.str]] = None,
            servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DomainServerArgs', 'DomainServerArgsDict']]]]] = None,
            timeout_settings: Optional[pulumi.Input[Union['DomainTimeoutSettingsArgs', 'DomainTimeoutSettingsArgsDict']]] = None,
            tls: Optional[pulumi.Input[_builtins.str]] = None,
            traffic_mark: Optional[pulumi.Input[Union['DomainTrafficMarkArgs', 'DomainTrafficMarkArgsDict']]] = None,
            website_name: Optional[pulumi.Input[_builtins.str]] = None) -> 'Domain':
        """
        Get an existing Domain resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] access_code: The CNAME prefix. The CNAME suffix is `.vip1.huaweicloudwaf.com`.
        :param pulumi.Input[_builtins.int] access_status: Whether a domain name is connected to WAF. 0: The domain name is not connected to WAF, 1: The domain
               name is connected to WAF.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] certificate_name: Specifies the certificate name. This parameter is mandatory
               when `client_protocol` is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] charging_mode: Specifies the charging mode of the domain. Valid values are **prePaid**
               and **postPaid**, defaults to **prePaid**. Changing this creates a new instance.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain.
               The options include **cipher_1**, **cipher_2**,**cipher_3**, **cipher_4**, **cipher_default**.
        :param pulumi.Input[Union['DomainCustomPageArgs', 'DomainCustomPageArgsDict']] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF domain.
        :param pulumi.Input[_builtins.str] domain: Specifies the domain name to be protected. For example, `www.example.com` or
               `*.example.com`. Changing this creates a new domain.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF domain.
               For enterprise users, if omitted, default enterprise project will be used.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] http2_enable: Specifies whether to use the http2 protocol.
               This field is only used for communication between clients and WAF.
               Defaults to **false**.
               Things to note when using this field are as follows:
               + There must be at least one server configuration with client protocol set to **HTTPS**, or this configuration is unable
               to work.
               + This field cannot not work if the client supports **TLS 1.3**.
               + This field can work only when the client supports **TLS 1.2** or earlier versions.
               + If you want to use HTTP/2 forwarding, use a dedicated WAF instance.
        :param pulumi.Input[_builtins.bool] ipv6_enable: Specifies whether IPv6 protection is enabled.
               Enable IPv6 protection if the domain name is accessible using an IPv6 address.
               After you enable it, WAF assigns an IPv6 address to the domain name.
               This field must be set to **true** when `server` contains a value of type **ipv6**.
               Defaults to false.
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] lb_algorithm: Specifies the load balancing algorithms used to
               distribute requests across origin servers.
               Only the professional edition (original enterprise edition) and platinum edition
               (original ultimate edition) support configuring the load balancing algorithm.
               The options of value are as follows:
               + **ip_hash** : Requests from the same IP address are routed to the same backend server.
               + **round_robin** : Requests are distributed across backend servers in turn based on the
               weight you assign to each server.
               + **session_hash** : Direct requests with the same session ID to the same origin server.
               Before using this configuration, please make sure to configure the traffic identifier for
               attack punishment after adding the domain name, otherwise the session hash configuration will not take effect.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
               The field `pci_3ds` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check.
               This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**.
               The field `pci_dss` is meaningful only if `certificate_id` is specified.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new
               policy will be created automatically.
        :param pulumi.Input[_builtins.int] protect_status: The protection status of domain. Valid values are:
        :param pulumi.Input[_builtins.str] protocol: The protocol type of the client. The options are HTTP, HTTPS, and HTTP&HTTPS.
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the WAF domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new certificate.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DomainServerArgs', 'DomainServerArgsDict']]]] servers: Specifies an array of origin web servers.
               The server structure is documented below.
        :param pulumi.Input[Union['DomainTimeoutSettingsArgs', 'DomainTimeoutSettingsArgsDict']] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
               
               <a name="Domain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The options include **TLS v1.0**, **TLS v1.1**,
               **TLS v1.2**.
        :param pulumi.Input[Union['DomainTrafficMarkArgs', 'DomainTrafficMarkArgsDict']] traffic_mark: Specifies the traffic identifier.
               WAF uses the configurations to identify the malicious client IP address (proxy mode) in the header,
               session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name.
               This website name must start with a letter and only letters, digits, underscores (_),
               hyphens (-), colons (:) and periods (.) are allowed.
               The value contains `1` to `128` characters.
               The website name must be unique within this account.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _DomainState.__new__(_DomainState)

        __props__.__dict__["access_code"] = access_code
        __props__.__dict__["access_status"] = access_status
        __props__.__dict__["certificate_id"] = certificate_id
        __props__.__dict__["certificate_name"] = certificate_name
        __props__.__dict__["charging_mode"] = charging_mode
        __props__.__dict__["cipher"] = cipher
        __props__.__dict__["custom_page"] = custom_page
        __props__.__dict__["description"] = description
        __props__.__dict__["domain"] = domain
        __props__.__dict__["enterprise_project_id"] = enterprise_project_id
        __props__.__dict__["forward_header_map"] = forward_header_map
        __props__.__dict__["http2_enable"] = http2_enable
        __props__.__dict__["ipv6_enable"] = ipv6_enable
        __props__.__dict__["keep_policy"] = keep_policy
        __props__.__dict__["lb_algorithm"] = lb_algorithm
        __props__.__dict__["pci3ds"] = pci3ds
        __props__.__dict__["pci_dss"] = pci_dss
        __props__.__dict__["policy_id"] = policy_id
        __props__.__dict__["protect_status"] = protect_status
        __props__.__dict__["protocol"] = protocol
        __props__.__dict__["proxy"] = proxy
        __props__.__dict__["redirect_url"] = redirect_url
        __props__.__dict__["region"] = region
        __props__.__dict__["servers"] = servers
        __props__.__dict__["timeout_settings"] = timeout_settings
        __props__.__dict__["tls"] = tls
        __props__.__dict__["traffic_mark"] = traffic_mark
        __props__.__dict__["website_name"] = website_name
        return Domain(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="accessCode")
    def access_code(self) -> pulumi.Output[_builtins.str]:
        """
        The CNAME prefix. The CNAME suffix is `.vip1.huaweicloudwaf.com`.
        """
        return pulumi.get(self, "access_code")

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> pulumi.Output[_builtins.int]:
        """
        Whether a domain name is connected to WAF. 0: The domain name is not connected to WAF, 1: The domain
        name is connected to WAF.
        """
        return pulumi.get(self, "access_status")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specifies the certificate ID. This parameter is mandatory when `client_protocol`
        is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specifies the certificate name. This parameter is mandatory
        when `client_protocol` is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specifies the charging mode of the domain. Valid values are **prePaid**
        and **postPaid**, defaults to **prePaid**. Changing this creates a new instance.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the cipher suite of domain.
        The options include **cipher_1**, **cipher_2**,**cipher_3**, **cipher_4**, **cipher_default**.
        """
        return pulumi.get(self, "cipher")

    @_builtins.property
    @pulumi.getter(name="customPage")
    def custom_page(self) -> pulumi.Output[Optional['outputs.DomainCustomPage']]:
        """
        Specifies the custom page. Only supports one custom alarm page.
        The custom_page structure is documented below.
        """
        return pulumi.get(self, "custom_page")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the description of the WAF domain.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the domain name to be protected. For example, `www.example.com` or
        `*.example.com`. Changing this creates a new domain.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specifies the enterprise project ID of WAF domain.
        For enterprise users, if omitted, default enterprise project will be used.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="forwardHeaderMap")
    def forward_header_map(self) -> pulumi.Output[Mapping[str, _builtins.str]]:
        """
        Specifies the field forwarding configuration. WAF inserts the added fields into
        the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
        The options of value are as follows:
        + **$time_local**
        + **$request_id**
        + **$connection_requests**
        + **$tenant_id**
        + **$project_id**
        + **$remote_addr**
        + **$remote_port**
        + **$scheme**
        + **$request_method**
        + **$http_host**
        + **$origin_uri**
        + **$request_length**
        + **$ssl_server_name**
        + **$ssl_protocol**
        + **$ssl_curves**
        + **$ssl_session_reused**
        """
        return pulumi.get(self, "forward_header_map")

    @_builtins.property
    @pulumi.getter(name="http2Enable")
    def http2_enable(self) -> pulumi.Output[_builtins.bool]:
        """
        Specifies whether to use the http2 protocol.
        This field is only used for communication between clients and WAF.
        Defaults to **false**.
        Things to note when using this field are as follows:
        + There must be at least one server configuration with client protocol set to **HTTPS**, or this configuration is unable
        to work.
        + This field cannot not work if the client supports **TLS 1.3**.
        + This field can work only when the client supports **TLS 1.2** or earlier versions.
        + If you want to use HTTP/2 forwarding, use a dedicated WAF instance.
        """
        return pulumi.get(self, "http2_enable")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> pulumi.Output[_builtins.bool]:
        """
        Specifies whether IPv6 protection is enabled.
        Enable IPv6 protection if the domain name is accessible using an IPv6 address.
        After you enable it, WAF assigns an IPv6 address to the domain name.
        This field must be set to **true** when `server` contains a value of type **ipv6**.
        Defaults to false.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="keepPolicy")
    def keep_policy(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Specifies whether to retain the policy when deleting a domain name.
        Defaults to **true**.
        """
        return pulumi.get(self, "keep_policy")

    @_builtins.property
    @pulumi.getter(name="lbAlgorithm")
    def lb_algorithm(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the load balancing algorithms used to
        distribute requests across origin servers.
        Only the professional edition (original enterprise edition) and platinum edition
        (original ultimate edition) support configuring the load balancing algorithm.
        The options of value are as follows:
        + **ip_hash** : Requests from the same IP address are routed to the same backend server.
        + **round_robin** : Requests are distributed across backend servers in turn based on the
        weight you assign to each server.
        + **session_hash** : Direct requests with the same session ID to the same origin server.
        Before using this configuration, please make sure to configure the traffic identifier for
        attack punishment after adding the domain name, otherwise the session hash configuration will not take effect.
        """
        return pulumi.get(self, "lb_algorithm")

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> pulumi.Output[_builtins.bool]:
        """
        Specifies the status of the PCI 3DS compliance certification check.
        This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**. The PCI 3DS compliance certification
        check cannot be disabled after being enabled.
        The field `pci_3ds` is meaningful only if `certificate_id` is specified.
        """
        return pulumi.get(self, "pci3ds")

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> pulumi.Output[_builtins.bool]:
        """
        Specifies the status of the PCI DSS compliance certification check.
        This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** `tls` must be set to **TLS v1.2**, and `cipher` must be set to **cipher_2**.
        The field `pci_dss` is meaningful only if `certificate_id` is specified.
        """
        return pulumi.get(self, "pci_dss")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the policy ID associated with the domain. If not specified, a new
        policy will be created automatically.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> pulumi.Output[_builtins.int]:
        """
        The protection status of domain. Valid values are:
        """
        return pulumi.get(self, "protect_status")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Output[_builtins.str]:
        """
        The protocol type of the client. The options are HTTP, HTTPS, and HTTP&HTTPS.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Specifies whether a proxy is configured.
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specifies the URL of the redirected page. The root domain name of the redirection
        address must be the name of the currently protected domain (including a wildcard domain name).
        The available **${http_host}** can be used to indicate the currently protected domain name and port.
        For example: **${http_host}/error.html**.

        > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the region in which to create the WAF domain resource.
        If omitted, the provider-level region will be used. Changing this setting will push a new certificate.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> pulumi.Output[Sequence['outputs.DomainServer']]:
        """
        Specifies an array of origin web servers.
        The server structure is documented below.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> pulumi.Output['outputs.DomainTimeoutSettings']:
        """
        Specifies the timeout setting. Only supports one timeout setting.
        The timeout_settings structure is documented below.

        <a name="Domain_server"></a>
        The `server` block supports:
        """
        return pulumi.get(self, "timeout_settings")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the minimum required TLS version. The options include **TLS v1.0**, **TLS v1.1**,
        **TLS v1.2**.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter(name="trafficMark")
    def traffic_mark(self) -> pulumi.Output['outputs.DomainTrafficMark']:
        """
        Specifies the traffic identifier.
        WAF uses the configurations to identify the malicious client IP address (proxy mode) in the header,
        session in the cookie, and user attribute in the parameter,
        and then triggers the corresponding known attack source rules to block attack sources.
        Only supports one traffic identifier.
        The traffic_mark structure is documented below.
        """
        return pulumi.get(self, "traffic_mark")

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the website name.
        This website name must start with a letter and only letters, digits, underscores (_),
        hyphens (-), colons (:) and periods (.) are allowed.
        The value contains `1` to `128` characters.
        The website name must be unique within this account.
        """
        return pulumi.get(self, "website_name")

