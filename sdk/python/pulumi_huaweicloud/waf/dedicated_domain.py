# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['DedicatedDomainArgs', 'DedicatedDomain']

@pulumi.input_type
class DedicatedDomainArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str],
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_protection: Optional[pulumi.Input['DedicatedDomainConnectionProtectionArgs']] = None,
                 custom_page: Optional[pulumi.Input['DedicatedDomainCustomPageArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_force_new: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 loadbalancer_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol_port: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]]] = None,
                 timeout_settings: Optional[pulumi.Input['DedicatedDomainTimeoutSettingsArgs']] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_mark: Optional[pulumi.Input['DedicatedDomainTrafficMarkArgs']] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a DedicatedDomain resource.
        :param pulumi.Input[_builtins.str] domain: Specifies the protected domain name or IP address (port allowed). For example,
               `www.example.com` or `*.example.com` or `www.example.com:89`.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain. The valid values are: **cipher_1**, **cipher_2**,
               **cipher_3**, **cipher_4**, **cipher_5**, **cipher_6**, and **cipher_default**.
        :param pulumi.Input['DedicatedDomainConnectionProtectionArgs'] connection_protection: Specifies the connection protection configuration to let WAF protect your
               origin servers from being crashed when WAF detects a large number of `502`/`504` error codes or pending requests.
               Only supports one protection configuration.
               The connection_protection structure is documented below.
        :param pulumi.Input['DedicatedDomainCustomPageArgs'] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF dedicated domain.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF dedicated domain.
               For enterprise users, if omitted, default enterprise project will be used.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] listener_id: Specifies the listener ID.
               Available listener IDs can be found through the datasource `dedicated_elb_get_listeners`.
               All listeners configured and to be configured for the load balancer will be protected by WAF.
               In cloud ELB access mode, you are advised to set this parameter.
        :param pulumi.Input[_builtins.str] loadbalancer_id: Specifies the load balancer ID.
               Available ELB IDs can be found through the datasource `dedicated_elb_get_loadbalancers`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.str] mode: Specifies the mode. If you use the cloud ELB access mode, enter enter **elb-shared**.
               Otherwise, leave this parameter blank. This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new policy
               will be created automatically.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] pool_ids: Specifies the dedicated engine group the domain name was added to.
               This field is valid only when creating cloud ELB mode domain.
               
               > Fields `mode`, `loadbalancer_id`, `listener_id`, `protocol_port`, and `pool_ids` are only available when creating
               cloud ELB mode domain. Due to API restrictions, the configuration of many fields will be invalid when creating a cloud
               mode ELB domain name. This means that the cloud mode elb domain name does not support the configuration of these fields.
               Please use `lifecycle` to ignore these fields. For example, you need to ignore the `proxy` or configure
               the `proxy` to **true** before creating cloud ELB mode domain. Before using this resource, please refer to the example.
               
               <a name="DedicatedDomain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.int] protect_status: Specifies the protection status of domain, `0`: suspended, `1`: enabled.
               Defaults to `0`.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the protocol port. Valid value ranges from `0` to `65,535`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured. Defaults to **false**.
               
               > **NOTE:** WAF forwards only HTTP/S traffic. So WAF cannot serve your non-HTTP/S traffic, such as UDP, SMTP, FTP,
               and basically all other non-HTTP/S traffic. If a proxy such as public network ELB (or Nginx) has been used, set
               proxy `true` to ensure that the WAF security policy takes effect for the real source IP address.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the dedicated mode domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new domain.
        :param pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]] servers: Specifies the server configuration list of the domain.
               A maximum of `80` can be configured. The server structure is documented below.
               
               > Field `server` is required only when creating dedicated domain. This field does not need to be configured when
               creating a cloud mode ELB domain name.
        :param pulumi.Input['DedicatedDomainTimeoutSettingsArgs'] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The valid values are: **TLS v1.0**,
               **TLS v1.1** and **TLS v1.2**.
        :param pulumi.Input['DedicatedDomainTrafficMarkArgs'] traffic_mark: Specifies the traffic identifier. WAF uses the configurations to identify the
               malicious client IP address (proxy mode) in the header, session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name. This website name must start with a letter and only
               letters, digits, underscores (_), hyphens (-), colons (:) and periods (.) are allowed. The value contains `1` to `128`
               characters. The website name must be unique within this account.
        """
        pulumi.set(__self__, "domain", domain)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if connection_protection is not None:
            pulumi.set(__self__, "connection_protection", connection_protection)
        if custom_page is not None:
            pulumi.set(__self__, "custom_page", custom_page)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_force_new is not None:
            pulumi.set(__self__, "enable_force_new", enable_force_new)
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        if forward_header_map is not None:
            pulumi.set(__self__, "forward_header_map", forward_header_map)
        if keep_policy is not None:
            pulumi.set(__self__, "keep_policy", keep_policy)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if loadbalancer_id is not None:
            pulumi.set(__self__, "loadbalancer_id", loadbalancer_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pci3ds is not None:
            pulumi.set(__self__, "pci3ds", pci3ds)
        if pci_dss is not None:
            pulumi.set(__self__, "pci_dss", pci_dss)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if protect_status is not None:
            pulumi.set(__self__, "protect_status", protect_status)
        if protocol_port is not None:
            pulumi.set(__self__, "protocol_port", protocol_port)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if traffic_mark is not None:
            pulumi.set(__self__, "traffic_mark", traffic_mark)
        if website_name is not None:
            pulumi.set(__self__, "website_name", website_name)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the protected domain name or IP address (port allowed). For example,
        `www.example.com` or `*.example.com` or `www.example.com:89`.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate ID. This parameter is mandatory when `client_protocol`
        is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cipher suite of domain. The valid values are: **cipher_1**, **cipher_2**,
        **cipher_3**, **cipher_4**, **cipher_5**, **cipher_6**, and **cipher_default**.
        """
        return pulumi.get(self, "cipher")

    @cipher.setter
    def cipher(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cipher", value)

    @_builtins.property
    @pulumi.getter(name="connectionProtection")
    def connection_protection(self) -> Optional[pulumi.Input['DedicatedDomainConnectionProtectionArgs']]:
        """
        Specifies the connection protection configuration to let WAF protect your
        origin servers from being crashed when WAF detects a large number of `502`/`504` error codes or pending requests.
        Only supports one protection configuration.
        The connection_protection structure is documented below.
        """
        return pulumi.get(self, "connection_protection")

    @connection_protection.setter
    def connection_protection(self, value: Optional[pulumi.Input['DedicatedDomainConnectionProtectionArgs']]):
        pulumi.set(self, "connection_protection", value)

    @_builtins.property
    @pulumi.getter(name="customPage")
    def custom_page(self) -> Optional[pulumi.Input['DedicatedDomainCustomPageArgs']]:
        """
        Specifies the custom page. Only supports one custom alarm page.
        The custom_page structure is documented below.
        """
        return pulumi.get(self, "custom_page")

    @custom_page.setter
    def custom_page(self, value: Optional[pulumi.Input['DedicatedDomainCustomPageArgs']]):
        pulumi.set(self, "custom_page", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the WAF dedicated domain.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="enableForceNew")
    def enable_force_new(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "enable_force_new")

    @enable_force_new.setter
    def enable_force_new(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable_force_new", value)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the enterprise project ID of WAF dedicated domain.
        For enterprise users, if omitted, default enterprise project will be used.
        """
        return pulumi.get(self, "enterprise_project_id")

    @enterprise_project_id.setter
    def enterprise_project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enterprise_project_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardHeaderMap")
    def forward_header_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the field forwarding configuration. WAF inserts the added fields into
        the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
        The options of value are as follows:
        + **$time_local**
        + **$request_id**
        + **$connection_requests**
        + **$tenant_id**
        + **$project_id**
        + **$remote_addr**
        + **$remote_port**
        + **$scheme**
        + **$request_method**
        + **$http_host**
        + **$origin_uri**
        + **$request_length**
        + **$ssl_server_name**
        + **$ssl_protocol**
        + **$ssl_curves**
        + **$ssl_session_reused**
        """
        return pulumi.get(self, "forward_header_map")

    @forward_header_map.setter
    def forward_header_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "forward_header_map", value)

    @_builtins.property
    @pulumi.getter(name="keepPolicy")
    def keep_policy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to retain the policy when deleting a domain name.
        Defaults to **true**.
        """
        return pulumi.get(self, "keep_policy")

    @keep_policy.setter
    def keep_policy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keep_policy", value)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the listener ID.
        Available listener IDs can be found through the datasource `dedicated_elb_get_listeners`.
        All listeners configured and to be configured for the load balancer will be protected by WAF.
        In cloud ELB access mode, you are advised to set this parameter.
        """
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="loadbalancerId")
    def loadbalancer_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the load balancer ID.
        Available ELB IDs can be found through the datasource `dedicated_elb_get_loadbalancers`.
        This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "loadbalancer_id")

    @loadbalancer_id.setter
    def loadbalancer_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "loadbalancer_id", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the mode. If you use the cloud ELB access mode, enter enter **elb-shared**.
        Otherwise, leave this parameter blank. This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI 3DS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
        check cannot be disabled after being enabled.
        """
        return pulumi.get(self, "pci3ds")

    @pci3ds.setter
    def pci3ds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci3ds", value)

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI DSS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        """
        return pulumi.get(self, "pci_dss")

    @pci_dss.setter
    def pci_dss(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci_dss", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the policy ID associated with the domain. If not specified, a new policy
        will be created automatically.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the dedicated engine group the domain name was added to.
        This field is valid only when creating cloud ELB mode domain.

        > Fields `mode`, `loadbalancer_id`, `listener_id`, `protocol_port`, and `pool_ids` are only available when creating
        cloud ELB mode domain. Due to API restrictions, the configuration of many fields will be invalid when creating a cloud
        mode ELB domain name. This means that the cloud mode elb domain name does not support the configuration of these fields.
        Please use `lifecycle` to ignore these fields. For example, you need to ignore the `proxy` or configure
        the `proxy` to **true** before creating cloud ELB mode domain. Before using this resource, please refer to the example.

        <a name="DedicatedDomain_server"></a>
        The `server` block supports:
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "pool_ids", value)

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the protection status of domain, `0`: suspended, `1`: enabled.
        Defaults to `0`.
        """
        return pulumi.get(self, "protect_status")

    @protect_status.setter
    def protect_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protect_status", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the protocol port. Valid value ranges from `0` to `65,535`.
        This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protocol_port", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether a proxy is configured. Defaults to **false**.

        > **NOTE:** WAF forwards only HTTP/S traffic. So WAF cannot serve your non-HTTP/S traffic, such as UDP, SMTP, FTP,
        and basically all other non-HTTP/S traffic. If a proxy such as public network ELB (or Nginx) has been used, set
        proxy `true` to ensure that the WAF security policy takes effect for the real source IP address.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL of the redirected page. The root domain name of the redirection
        address must be the name of the currently protected domain (including a wildcard domain name).
        The available **${http_host}** can be used to indicate the currently protected domain name and port.
        For example: **${http_host}/error.html**.

        > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the dedicated mode domain resource.
        If omitted, the provider-level region will be used. Changing this setting will push a new domain.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]]]:
        """
        Specifies the server configuration list of the domain.
        A maximum of `80` can be configured. The server structure is documented below.

        > Field `server` is required only when creating dedicated domain. This field does not need to be configured when
        creating a cloud mode ELB domain name.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional[pulumi.Input['DedicatedDomainTimeoutSettingsArgs']]:
        """
        Specifies the timeout setting. Only supports one timeout setting.
        The timeout_settings structure is documented below.
        """
        return pulumi.get(self, "timeout_settings")

    @timeout_settings.setter
    def timeout_settings(self, value: Optional[pulumi.Input['DedicatedDomainTimeoutSettingsArgs']]):
        pulumi.set(self, "timeout_settings", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the minimum required TLS version. The valid values are: **TLS v1.0**,
        **TLS v1.1** and **TLS v1.2**.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter(name="trafficMark")
    def traffic_mark(self) -> Optional[pulumi.Input['DedicatedDomainTrafficMarkArgs']]:
        """
        Specifies the traffic identifier. WAF uses the configurations to identify the
        malicious client IP address (proxy mode) in the header, session in the cookie, and user attribute in the parameter,
        and then triggers the corresponding known attack source rules to block attack sources.
        Only supports one traffic identifier.
        The traffic_mark structure is documented below.
        """
        return pulumi.get(self, "traffic_mark")

    @traffic_mark.setter
    def traffic_mark(self, value: Optional[pulumi.Input['DedicatedDomainTrafficMarkArgs']]):
        pulumi.set(self, "traffic_mark", value)

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the website name. This website name must start with a letter and only
        letters, digits, underscores (_), hyphens (-), colons (:) and periods (.) are allowed. The value contains `1` to `128`
        characters. The website name must be unique within this account.
        """
        return pulumi.get(self, "website_name")

    @website_name.setter
    def website_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "website_name", value)


@pulumi.input_type
class _DedicatedDomainState:
    def __init__(__self__, *,
                 access_status: Optional[pulumi.Input[_builtins.int]] = None,
                 alarm_page: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 block_pages: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainBlockPageArgs']]]] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 compliance_certification: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]] = None,
                 connection_protection: Optional[pulumi.Input['DedicatedDomainConnectionProtectionArgs']] = None,
                 custom_page: Optional[pulumi.Input['DedicatedDomainCustomPageArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_force_new: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 extend: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 flags: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainFlagArgs']]]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 loadbalancer_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_port: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]]] = None,
                 timeout_settings: Optional[pulumi.Input['DedicatedDomainTimeoutSettingsArgs']] = None,
                 timestamp: Optional[pulumi.Input[_builtins.int]] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_identifier: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 traffic_mark: Optional[pulumi.Input['DedicatedDomainTrafficMarkArgs']] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering DedicatedDomain resources.
        :param pulumi.Input[_builtins.int] access_status: Whether a domain name is connected to WAF. Valid values are:
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] alarm_page: The alarm page of domain. Valid values are:
        :param pulumi.Input[Sequence[pulumi.Input['DedicatedDomainBlockPageArgs']]] block_pages: The alarm page configuration.
               The block_page structure is documented below.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] certificate_name: The name of the certificate used by the domain name.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain. The valid values are: **cipher_1**, **cipher_2**,
               **cipher_3**, **cipher_4**, **cipher_5**, **cipher_6**, and **cipher_default**.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]] compliance_certification: The compliance certifications of the domain, values are:
        :param pulumi.Input['DedicatedDomainConnectionProtectionArgs'] connection_protection: Specifies the connection protection configuration to let WAF protect your
               origin servers from being crashed when WAF detects a large number of `502`/`504` error codes or pending requests.
               Only supports one protection configuration.
               The connection_protection structure is documented below.
        :param pulumi.Input['DedicatedDomainCustomPageArgs'] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF dedicated domain.
        :param pulumi.Input[_builtins.str] domain: Specifies the protected domain name or IP address (port allowed). For example,
               `www.example.com` or `*.example.com` or `www.example.com:89`.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF dedicated domain.
               For enterprise users, if omitted, default enterprise project will be used.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend: The extended field, which is used to save some configuration information about the protected domain name.
               The value is key-value pairs.
        :param pulumi.Input[Sequence[pulumi.Input['DedicatedDomainFlagArgs']]] flags: The identifier, which is used on the console.
               The flag structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] listener_id: Specifies the listener ID.
               Available listener IDs can be found through the datasource `dedicated_elb_get_listeners`.
               All listeners configured and to be configured for the load balancer will be protected by WAF.
               In cloud ELB access mode, you are advised to set this parameter.
        :param pulumi.Input[_builtins.str] loadbalancer_id: Specifies the load balancer ID.
               Available ELB IDs can be found through the datasource `dedicated_elb_get_loadbalancers`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.str] mode: Specifies the mode. If you use the cloud ELB access mode, enter enter **elb-shared**.
               Otherwise, leave this parameter blank. This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new policy
               will be created automatically.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] pool_ids: Specifies the dedicated engine group the domain name was added to.
               This field is valid only when creating cloud ELB mode domain.
               
               > Fields `mode`, `loadbalancer_id`, `listener_id`, `protocol_port`, and `pool_ids` are only available when creating
               cloud ELB mode domain. Due to API restrictions, the configuration of many fields will be invalid when creating a cloud
               mode ELB domain name. This means that the cloud mode elb domain name does not support the configuration of these fields.
               Please use `lifecycle` to ignore these fields. For example, you need to ignore the `proxy` or configure
               the `proxy` to **true** before creating cloud ELB mode domain. Before using this resource, please refer to the example.
               
               <a name="DedicatedDomain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.int] protect_status: Specifies the protection status of domain, `0`: suspended, `1`: enabled.
               Defaults to `0`.
        :param pulumi.Input[_builtins.str] protocol: The protocol type of the client. The options are `HTTP` and `HTTPS`.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the protocol port. Valid value ranges from `0` to `65,535`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured. Defaults to **false**.
               
               > **NOTE:** WAF forwards only HTTP/S traffic. So WAF cannot serve your non-HTTP/S traffic, such as UDP, SMTP, FTP,
               and basically all other non-HTTP/S traffic. If a proxy such as public network ELB (or Nginx) has been used, set
               proxy `true` to ensure that the WAF security policy takes effect for the real source IP address.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the dedicated mode domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new domain.
        :param pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]] servers: Specifies the server configuration list of the domain.
               A maximum of `80` can be configured. The server structure is documented below.
               
               > Field `server` is required only when creating dedicated domain. This field does not need to be configured when
               creating a cloud mode ELB domain name.
        :param pulumi.Input['DedicatedDomainTimeoutSettingsArgs'] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
        :param pulumi.Input[_builtins.int] timestamp: The time the domain name was added to WAF.
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The valid values are: **TLS v1.0**,
               **TLS v1.1** and **TLS v1.2**.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] traffic_identifier: The traffic identifier of domain. Valid values are:
        :param pulumi.Input['DedicatedDomainTrafficMarkArgs'] traffic_mark: Specifies the traffic identifier. WAF uses the configurations to identify the
               malicious client IP address (proxy mode) in the header, session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name. This website name must start with a letter and only
               letters, digits, underscores (_), hyphens (-), colons (:) and periods (.) are allowed. The value contains `1` to `128`
               characters. The website name must be unique within this account.
        """
        if access_status is not None:
            pulumi.set(__self__, "access_status", access_status)
        if alarm_page is not None:
            pulumi.set(__self__, "alarm_page", alarm_page)
        if block_pages is not None:
            pulumi.set(__self__, "block_pages", block_pages)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if compliance_certification is not None:
            pulumi.set(__self__, "compliance_certification", compliance_certification)
        if connection_protection is not None:
            pulumi.set(__self__, "connection_protection", connection_protection)
        if custom_page is not None:
            pulumi.set(__self__, "custom_page", custom_page)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if enable_force_new is not None:
            pulumi.set(__self__, "enable_force_new", enable_force_new)
        if enterprise_project_id is not None:
            pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        if extend is not None:
            pulumi.set(__self__, "extend", extend)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if forward_header_map is not None:
            pulumi.set(__self__, "forward_header_map", forward_header_map)
        if keep_policy is not None:
            pulumi.set(__self__, "keep_policy", keep_policy)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if loadbalancer_id is not None:
            pulumi.set(__self__, "loadbalancer_id", loadbalancer_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if pci3ds is not None:
            pulumi.set(__self__, "pci3ds", pci3ds)
        if pci_dss is not None:
            pulumi.set(__self__, "pci_dss", pci_dss)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if pool_ids is not None:
            pulumi.set(__self__, "pool_ids", pool_ids)
        if protect_status is not None:
            pulumi.set(__self__, "protect_status", protect_status)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_port is not None:
            pulumi.set(__self__, "protocol_port", protocol_port)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if timeout_settings is not None:
            pulumi.set(__self__, "timeout_settings", timeout_settings)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if traffic_identifier is not None:
            pulumi.set(__self__, "traffic_identifier", traffic_identifier)
        if traffic_mark is not None:
            pulumi.set(__self__, "traffic_mark", traffic_mark)
        if website_name is not None:
            pulumi.set(__self__, "website_name", website_name)

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Whether a domain name is connected to WAF. Valid values are:
        """
        return pulumi.get(self, "access_status")

    @access_status.setter
    def access_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "access_status", value)

    @_builtins.property
    @pulumi.getter(name="alarmPage")
    def alarm_page(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The alarm page of domain. Valid values are:
        """
        return pulumi.get(self, "alarm_page")

    @alarm_page.setter
    def alarm_page(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alarm_page", value)

    @_builtins.property
    @pulumi.getter(name="blockPages")
    def block_pages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainBlockPageArgs']]]]:
        """
        The alarm page configuration.
        The block_page structure is documented below.
        """
        return pulumi.get(self, "block_pages")

    @block_pages.setter
    def block_pages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainBlockPageArgs']]]]):
        pulumi.set(self, "block_pages", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate ID. This parameter is mandatory when `client_protocol`
        is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the certificate used by the domain name.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cipher suite of domain. The valid values are: **cipher_1**, **cipher_2**,
        **cipher_3**, **cipher_4**, **cipher_5**, **cipher_6**, and **cipher_default**.
        """
        return pulumi.get(self, "cipher")

    @cipher.setter
    def cipher(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cipher", value)

    @_builtins.property
    @pulumi.getter(name="complianceCertification")
    def compliance_certification(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]]:
        """
        The compliance certifications of the domain, values are:
        """
        return pulumi.get(self, "compliance_certification")

    @compliance_certification.setter
    def compliance_certification(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]]):
        pulumi.set(self, "compliance_certification", value)

    @_builtins.property
    @pulumi.getter(name="connectionProtection")
    def connection_protection(self) -> Optional[pulumi.Input['DedicatedDomainConnectionProtectionArgs']]:
        """
        Specifies the connection protection configuration to let WAF protect your
        origin servers from being crashed when WAF detects a large number of `502`/`504` error codes or pending requests.
        Only supports one protection configuration.
        The connection_protection structure is documented below.
        """
        return pulumi.get(self, "connection_protection")

    @connection_protection.setter
    def connection_protection(self, value: Optional[pulumi.Input['DedicatedDomainConnectionProtectionArgs']]):
        pulumi.set(self, "connection_protection", value)

    @_builtins.property
    @pulumi.getter(name="customPage")
    def custom_page(self) -> Optional[pulumi.Input['DedicatedDomainCustomPageArgs']]:
        """
        Specifies the custom page. Only supports one custom alarm page.
        The custom_page structure is documented below.
        """
        return pulumi.get(self, "custom_page")

    @custom_page.setter
    def custom_page(self, value: Optional[pulumi.Input['DedicatedDomainCustomPageArgs']]):
        pulumi.set(self, "custom_page", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the WAF dedicated domain.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the protected domain name or IP address (port allowed). For example,
        `www.example.com` or `*.example.com` or `www.example.com:89`.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="enableForceNew")
    def enable_force_new(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "enable_force_new")

    @enable_force_new.setter
    def enable_force_new(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enable_force_new", value)

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the enterprise project ID of WAF dedicated domain.
        For enterprise users, if omitted, default enterprise project will be used.
        """
        return pulumi.get(self, "enterprise_project_id")

    @enterprise_project_id.setter
    def enterprise_project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enterprise_project_id", value)

    @_builtins.property
    @pulumi.getter
    def extend(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The extended field, which is used to save some configuration information about the protected domain name.
        The value is key-value pairs.
        """
        return pulumi.get(self, "extend")

    @extend.setter
    def extend(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extend", value)

    @_builtins.property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainFlagArgs']]]]:
        """
        The identifier, which is used on the console.
        The flag structure is documented below.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainFlagArgs']]]]):
        pulumi.set(self, "flags", value)

    @_builtins.property
    @pulumi.getter(name="forwardHeaderMap")
    def forward_header_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the field forwarding configuration. WAF inserts the added fields into
        the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
        The options of value are as follows:
        + **$time_local**
        + **$request_id**
        + **$connection_requests**
        + **$tenant_id**
        + **$project_id**
        + **$remote_addr**
        + **$remote_port**
        + **$scheme**
        + **$request_method**
        + **$http_host**
        + **$origin_uri**
        + **$request_length**
        + **$ssl_server_name**
        + **$ssl_protocol**
        + **$ssl_curves**
        + **$ssl_session_reused**
        """
        return pulumi.get(self, "forward_header_map")

    @forward_header_map.setter
    def forward_header_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "forward_header_map", value)

    @_builtins.property
    @pulumi.getter(name="keepPolicy")
    def keep_policy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to retain the policy when deleting a domain name.
        Defaults to **true**.
        """
        return pulumi.get(self, "keep_policy")

    @keep_policy.setter
    def keep_policy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keep_policy", value)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the listener ID.
        Available listener IDs can be found through the datasource `dedicated_elb_get_listeners`.
        All listeners configured and to be configured for the load balancer will be protected by WAF.
        In cloud ELB access mode, you are advised to set this parameter.
        """
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="loadbalancerId")
    def loadbalancer_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the load balancer ID.
        Available ELB IDs can be found through the datasource `dedicated_elb_get_loadbalancers`.
        This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "loadbalancer_id")

    @loadbalancer_id.setter
    def loadbalancer_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "loadbalancer_id", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the mode. If you use the cloud ELB access mode, enter enter **elb-shared**.
        Otherwise, leave this parameter blank. This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI 3DS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
        check cannot be disabled after being enabled.
        """
        return pulumi.get(self, "pci3ds")

    @pci3ds.setter
    def pci3ds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci3ds", value)

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the status of the PCI DSS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        """
        return pulumi.get(self, "pci_dss")

    @pci_dss.setter
    def pci_dss(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "pci_dss", value)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the policy ID associated with the domain. If not specified, a new policy
        will be created automatically.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_id", value)

    @_builtins.property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the dedicated engine group the domain name was added to.
        This field is valid only when creating cloud ELB mode domain.

        > Fields `mode`, `loadbalancer_id`, `listener_id`, `protocol_port`, and `pool_ids` are only available when creating
        cloud ELB mode domain. Due to API restrictions, the configuration of many fields will be invalid when creating a cloud
        mode ELB domain name. This means that the cloud mode elb domain name does not support the configuration of these fields.
        Please use `lifecycle` to ignore these fields. For example, you need to ignore the `proxy` or configure
        the `proxy` to **true** before creating cloud ELB mode domain. Before using this resource, please refer to the example.

        <a name="DedicatedDomain_server"></a>
        The `server` block supports:
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "pool_ids", value)

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the protection status of domain, `0`: suspended, `1`: enabled.
        Defaults to `0`.
        """
        return pulumi.get(self, "protect_status")

    @protect_status.setter
    def protect_status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protect_status", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol type of the client. The options are `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the protocol port. Valid value ranges from `0` to `65,535`.
        This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protocol_port", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether a proxy is configured. Defaults to **false**.

        > **NOTE:** WAF forwards only HTTP/S traffic. So WAF cannot serve your non-HTTP/S traffic, such as UDP, SMTP, FTP,
        and basically all other non-HTTP/S traffic. If a proxy such as public network ELB (or Nginx) has been used, set
        proxy `true` to ensure that the WAF security policy takes effect for the real source IP address.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL of the redirected page. The root domain name of the redirection
        address must be the name of the currently protected domain (including a wildcard domain name).
        The available **${http_host}** can be used to indicate the currently protected domain name and port.
        For example: **${http_host}/error.html**.

        > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the dedicated mode domain resource.
        If omitted, the provider-level region will be used. Changing this setting will push a new domain.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]]]:
        """
        Specifies the server configuration list of the domain.
        A maximum of `80` can be configured. The server structure is documented below.

        > Field `server` is required only when creating dedicated domain. This field does not need to be configured when
        creating a cloud mode ELB domain name.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DedicatedDomainServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> Optional[pulumi.Input['DedicatedDomainTimeoutSettingsArgs']]:
        """
        Specifies the timeout setting. Only supports one timeout setting.
        The timeout_settings structure is documented below.
        """
        return pulumi.get(self, "timeout_settings")

    @timeout_settings.setter
    def timeout_settings(self, value: Optional[pulumi.Input['DedicatedDomainTimeoutSettingsArgs']]):
        pulumi.set(self, "timeout_settings", value)

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time the domain name was added to WAF.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timestamp", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the minimum required TLS version. The valid values are: **TLS v1.0**,
        **TLS v1.1** and **TLS v1.2**.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls", value)

    @_builtins.property
    @pulumi.getter(name="trafficIdentifier")
    def traffic_identifier(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The traffic identifier of domain. Valid values are:
        """
        return pulumi.get(self, "traffic_identifier")

    @traffic_identifier.setter
    def traffic_identifier(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "traffic_identifier", value)

    @_builtins.property
    @pulumi.getter(name="trafficMark")
    def traffic_mark(self) -> Optional[pulumi.Input['DedicatedDomainTrafficMarkArgs']]:
        """
        Specifies the traffic identifier. WAF uses the configurations to identify the
        malicious client IP address (proxy mode) in the header, session in the cookie, and user attribute in the parameter,
        and then triggers the corresponding known attack source rules to block attack sources.
        Only supports one traffic identifier.
        The traffic_mark structure is documented below.
        """
        return pulumi.get(self, "traffic_mark")

    @traffic_mark.setter
    def traffic_mark(self, value: Optional[pulumi.Input['DedicatedDomainTrafficMarkArgs']]):
        pulumi.set(self, "traffic_mark", value)

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the website name. This website name must start with a letter and only
        letters, digits, underscores (_), hyphens (-), colons (:) and periods (.) are allowed. The value contains `1` to `128`
        characters. The website name must be unique within this account.
        """
        return pulumi.get(self, "website_name")

    @website_name.setter
    def website_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "website_name", value)


@pulumi.type_token("huaweicloud:Waf/dedicatedDomain:DedicatedDomain")
class DedicatedDomain(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_protection: Optional[pulumi.Input[Union['DedicatedDomainConnectionProtectionArgs', 'DedicatedDomainConnectionProtectionArgsDict']]] = None,
                 custom_page: Optional[pulumi.Input[Union['DedicatedDomainCustomPageArgs', 'DedicatedDomainCustomPageArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_force_new: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 loadbalancer_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol_port: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainServerArgs', 'DedicatedDomainServerArgsDict']]]]] = None,
                 timeout_settings: Optional[pulumi.Input[Union['DedicatedDomainTimeoutSettingsArgs', 'DedicatedDomainTimeoutSettingsArgsDict']]] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_mark: Optional[pulumi.Input[Union['DedicatedDomainTrafficMarkArgs', 'DedicatedDomainTrafficMarkArgsDict']]] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        Manages a dedicated mode domain resource within HuaweiCloud.

        > **NOTE:** All WAF resources depend on WAF instances, and the WAF instances need to be purchased before they can be
        used. The dedicated mode domain name resource can be used in Dedicated Mode.

        > You can use this resource to create a cloud-mode ELB domain name, but there are usage restrictions:
        <br/>1. To use cloud load balancer WAF, you need to submit a service ticket to enable it for you first.
        <br/>2. If you want to use the load balancer access mode, make sure you are using standard, professional, or enterprise
        cloud WAF.
        <br/>3. You have purchased a dedicated load balancer with Specifications set to Application load balancing (HTTP/HTTPS).
        <br/>For more usage restrictions, please refer to the documentation:
        [Cloud Mode - Load Balancer Access](https://support.huaweicloud.com/intl/en-us/usermanual-waf/waf_01_0287.html)

        ## Example Usage

        ### Dedicated Mode domain

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        certificated_id = config.require_object("certificatedId")
        vpc_id = config.require_object("vpcId")
        enterprise_project_id = config.require_object("enterpriseProjectId")
        test = huaweicloud.waf.DedicatedDomain("test",
            domain="www.example.com",
            certificate_id=certificated_id,
            enterprise_project_id=enterprise_project_id,
            protect_status=1,
            website_name="websiteName",
            description="test description",
            servers=[{
                "client_protocol": "HTTPS",
                "server_protocol": "HTTP",
                "address": "192.168.1.100",
                "port": 8080,
                "type": "ipv4",
                "vpc_id": vpc_id,
            }],
            custom_page={
                "http_return_code": "404",
                "block_page_type": "application/json",
                "page_content": \"\"\"{
          "event_id": "${waf_event_id}",
          "error_msg": "error message"
        }
        \"\"\",
            },
            forward_header_map={
                "key1": "$time_local",
                "key2": "$tenant_id",
            },
            connection_protection={
                "error_threshold": 1000,
                "error_percentage": 90,
                "initial_downtime": 200,
                "multiplier_for_consecutive_breakdowns": 5,
                "pending_url_request_threshold": 7000,
                "duration": 10000,
                "status": True,
            },
            timeout_settings={
                "connection_timeout": 100,
                "read_timeout": 1000,
                "write_timeout": 1000,
            },
            traffic_mark={
                "ip_tags": ["ip_tag"],
                "session_tag": "session_tag",
                "user_tag": "user_tag",
            })
        ```

        ### Cloud ELB Mode domain

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        enterprise_project_id = config.require_object("enterpriseProjectId")
        loadbalancer_id = config.require_object("loadbalancerId")
        test = huaweicloud.waf.DedicatedDomain("test",
            loadbalancer_id=loadbalancer_id,
            enterprise_project_id=enterprise_project_id,
            domain="119.8.5.14",
            mode="elb-shared",
            description="test description",
            protocol_port=0,
            website_name="test-web-tag")
        ```

        ## Import

        There are two ways to import WAF dedicated domain state.

        * Using the `id`, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/dedicatedDomain:DedicatedDomain test <id>
        ```

        * Using `id` and `enterprise_project_id`, separated by a slash, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/dedicatedDomain:DedicatedDomain test <id>/<enterprise_project_id>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain. The valid values are: **cipher_1**, **cipher_2**,
               **cipher_3**, **cipher_4**, **cipher_5**, **cipher_6**, and **cipher_default**.
        :param pulumi.Input[Union['DedicatedDomainConnectionProtectionArgs', 'DedicatedDomainConnectionProtectionArgsDict']] connection_protection: Specifies the connection protection configuration to let WAF protect your
               origin servers from being crashed when WAF detects a large number of `502`/`504` error codes or pending requests.
               Only supports one protection configuration.
               The connection_protection structure is documented below.
        :param pulumi.Input[Union['DedicatedDomainCustomPageArgs', 'DedicatedDomainCustomPageArgsDict']] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF dedicated domain.
        :param pulumi.Input[_builtins.str] domain: Specifies the protected domain name or IP address (port allowed). For example,
               `www.example.com` or `*.example.com` or `www.example.com:89`.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF dedicated domain.
               For enterprise users, if omitted, default enterprise project will be used.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] listener_id: Specifies the listener ID.
               Available listener IDs can be found through the datasource `dedicated_elb_get_listeners`.
               All listeners configured and to be configured for the load balancer will be protected by WAF.
               In cloud ELB access mode, you are advised to set this parameter.
        :param pulumi.Input[_builtins.str] loadbalancer_id: Specifies the load balancer ID.
               Available ELB IDs can be found through the datasource `dedicated_elb_get_loadbalancers`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.str] mode: Specifies the mode. If you use the cloud ELB access mode, enter enter **elb-shared**.
               Otherwise, leave this parameter blank. This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new policy
               will be created automatically.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] pool_ids: Specifies the dedicated engine group the domain name was added to.
               This field is valid only when creating cloud ELB mode domain.
               
               > Fields `mode`, `loadbalancer_id`, `listener_id`, `protocol_port`, and `pool_ids` are only available when creating
               cloud ELB mode domain. Due to API restrictions, the configuration of many fields will be invalid when creating a cloud
               mode ELB domain name. This means that the cloud mode elb domain name does not support the configuration of these fields.
               Please use `lifecycle` to ignore these fields. For example, you need to ignore the `proxy` or configure
               the `proxy` to **true** before creating cloud ELB mode domain. Before using this resource, please refer to the example.
               
               <a name="DedicatedDomain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.int] protect_status: Specifies the protection status of domain, `0`: suspended, `1`: enabled.
               Defaults to `0`.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the protocol port. Valid value ranges from `0` to `65,535`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured. Defaults to **false**.
               
               > **NOTE:** WAF forwards only HTTP/S traffic. So WAF cannot serve your non-HTTP/S traffic, such as UDP, SMTP, FTP,
               and basically all other non-HTTP/S traffic. If a proxy such as public network ELB (or Nginx) has been used, set
               proxy `true` to ensure that the WAF security policy takes effect for the real source IP address.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the dedicated mode domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new domain.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainServerArgs', 'DedicatedDomainServerArgsDict']]]] servers: Specifies the server configuration list of the domain.
               A maximum of `80` can be configured. The server structure is documented below.
               
               > Field `server` is required only when creating dedicated domain. This field does not need to be configured when
               creating a cloud mode ELB domain name.
        :param pulumi.Input[Union['DedicatedDomainTimeoutSettingsArgs', 'DedicatedDomainTimeoutSettingsArgsDict']] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The valid values are: **TLS v1.0**,
               **TLS v1.1** and **TLS v1.2**.
        :param pulumi.Input[Union['DedicatedDomainTrafficMarkArgs', 'DedicatedDomainTrafficMarkArgsDict']] traffic_mark: Specifies the traffic identifier. WAF uses the configurations to identify the
               malicious client IP address (proxy mode) in the header, session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name. This website name must start with a letter and only
               letters, digits, underscores (_), hyphens (-), colons (:) and periods (.) are allowed. The value contains `1` to `128`
               characters. The website name must be unique within this account.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: DedicatedDomainArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Manages a dedicated mode domain resource within HuaweiCloud.

        > **NOTE:** All WAF resources depend on WAF instances, and the WAF instances need to be purchased before they can be
        used. The dedicated mode domain name resource can be used in Dedicated Mode.

        > You can use this resource to create a cloud-mode ELB domain name, but there are usage restrictions:
        <br/>1. To use cloud load balancer WAF, you need to submit a service ticket to enable it for you first.
        <br/>2. If you want to use the load balancer access mode, make sure you are using standard, professional, or enterprise
        cloud WAF.
        <br/>3. You have purchased a dedicated load balancer with Specifications set to Application load balancing (HTTP/HTTPS).
        <br/>For more usage restrictions, please refer to the documentation:
        [Cloud Mode - Load Balancer Access](https://support.huaweicloud.com/intl/en-us/usermanual-waf/waf_01_0287.html)

        ## Example Usage

        ### Dedicated Mode domain

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        certificated_id = config.require_object("certificatedId")
        vpc_id = config.require_object("vpcId")
        enterprise_project_id = config.require_object("enterpriseProjectId")
        test = huaweicloud.waf.DedicatedDomain("test",
            domain="www.example.com",
            certificate_id=certificated_id,
            enterprise_project_id=enterprise_project_id,
            protect_status=1,
            website_name="websiteName",
            description="test description",
            servers=[{
                "client_protocol": "HTTPS",
                "server_protocol": "HTTP",
                "address": "192.168.1.100",
                "port": 8080,
                "type": "ipv4",
                "vpc_id": vpc_id,
            }],
            custom_page={
                "http_return_code": "404",
                "block_page_type": "application/json",
                "page_content": \"\"\"{
          "event_id": "${waf_event_id}",
          "error_msg": "error message"
        }
        \"\"\",
            },
            forward_header_map={
                "key1": "$time_local",
                "key2": "$tenant_id",
            },
            connection_protection={
                "error_threshold": 1000,
                "error_percentage": 90,
                "initial_downtime": 200,
                "multiplier_for_consecutive_breakdowns": 5,
                "pending_url_request_threshold": 7000,
                "duration": 10000,
                "status": True,
            },
            timeout_settings={
                "connection_timeout": 100,
                "read_timeout": 1000,
                "write_timeout": 1000,
            },
            traffic_mark={
                "ip_tags": ["ip_tag"],
                "session_tag": "session_tag",
                "user_tag": "user_tag",
            })
        ```

        ### Cloud ELB Mode domain

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        enterprise_project_id = config.require_object("enterpriseProjectId")
        loadbalancer_id = config.require_object("loadbalancerId")
        test = huaweicloud.waf.DedicatedDomain("test",
            loadbalancer_id=loadbalancer_id,
            enterprise_project_id=enterprise_project_id,
            domain="119.8.5.14",
            mode="elb-shared",
            description="test description",
            protocol_port=0,
            website_name="test-web-tag")
        ```

        ## Import

        There are two ways to import WAF dedicated domain state.

        * Using the `id`, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/dedicatedDomain:DedicatedDomain test <id>
        ```

        * Using `id` and `enterprise_project_id`, separated by a slash, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Waf/dedicatedDomain:DedicatedDomain test <id>/<enterprise_project_id>
        ```

        :param str resource_name: The name of the resource.
        :param DedicatedDomainArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(DedicatedDomainArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cipher: Optional[pulumi.Input[_builtins.str]] = None,
                 connection_protection: Optional[pulumi.Input[Union['DedicatedDomainConnectionProtectionArgs', 'DedicatedDomainConnectionProtectionArgsDict']]] = None,
                 custom_page: Optional[pulumi.Input[Union['DedicatedDomainCustomPageArgs', 'DedicatedDomainCustomPageArgsDict']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_force_new: Optional[pulumi.Input[_builtins.str]] = None,
                 enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 loadbalancer_id: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
                 pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
                 policy_id: Optional[pulumi.Input[_builtins.str]] = None,
                 pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 protect_status: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol_port: Optional[pulumi.Input[_builtins.int]] = None,
                 proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainServerArgs', 'DedicatedDomainServerArgsDict']]]]] = None,
                 timeout_settings: Optional[pulumi.Input[Union['DedicatedDomainTimeoutSettingsArgs', 'DedicatedDomainTimeoutSettingsArgsDict']]] = None,
                 tls: Optional[pulumi.Input[_builtins.str]] = None,
                 traffic_mark: Optional[pulumi.Input[Union['DedicatedDomainTrafficMarkArgs', 'DedicatedDomainTrafficMarkArgsDict']]] = None,
                 website_name: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = DedicatedDomainArgs.__new__(DedicatedDomainArgs)

            __props__.__dict__["certificate_id"] = certificate_id
            __props__.__dict__["cipher"] = cipher
            __props__.__dict__["connection_protection"] = connection_protection
            __props__.__dict__["custom_page"] = custom_page
            __props__.__dict__["description"] = description
            if domain is None and not opts.urn:
                raise TypeError("Missing required property 'domain'")
            __props__.__dict__["domain"] = domain
            __props__.__dict__["enable_force_new"] = enable_force_new
            __props__.__dict__["enterprise_project_id"] = enterprise_project_id
            __props__.__dict__["forward_header_map"] = forward_header_map
            __props__.__dict__["keep_policy"] = keep_policy
            __props__.__dict__["listener_id"] = listener_id
            __props__.__dict__["loadbalancer_id"] = loadbalancer_id
            __props__.__dict__["mode"] = mode
            __props__.__dict__["pci3ds"] = pci3ds
            __props__.__dict__["pci_dss"] = pci_dss
            __props__.__dict__["policy_id"] = policy_id
            __props__.__dict__["pool_ids"] = pool_ids
            __props__.__dict__["protect_status"] = protect_status
            __props__.__dict__["protocol_port"] = protocol_port
            __props__.__dict__["proxy"] = proxy
            __props__.__dict__["redirect_url"] = redirect_url
            __props__.__dict__["region"] = region
            __props__.__dict__["servers"] = servers
            __props__.__dict__["timeout_settings"] = timeout_settings
            __props__.__dict__["tls"] = tls
            __props__.__dict__["traffic_mark"] = traffic_mark
            __props__.__dict__["website_name"] = website_name
            __props__.__dict__["access_status"] = None
            __props__.__dict__["alarm_page"] = None
            __props__.__dict__["block_pages"] = None
            __props__.__dict__["certificate_name"] = None
            __props__.__dict__["compliance_certification"] = None
            __props__.__dict__["extend"] = None
            __props__.__dict__["flags"] = None
            __props__.__dict__["protocol"] = None
            __props__.__dict__["timestamp"] = None
            __props__.__dict__["traffic_identifier"] = None
        super(DedicatedDomain, __self__).__init__(
            'huaweicloud:Waf/dedicatedDomain:DedicatedDomain',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            access_status: Optional[pulumi.Input[_builtins.int]] = None,
            alarm_page: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
            block_pages: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainBlockPageArgs', 'DedicatedDomainBlockPageArgsDict']]]]] = None,
            certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
            certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
            cipher: Optional[pulumi.Input[_builtins.str]] = None,
            compliance_certification: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]]] = None,
            connection_protection: Optional[pulumi.Input[Union['DedicatedDomainConnectionProtectionArgs', 'DedicatedDomainConnectionProtectionArgsDict']]] = None,
            custom_page: Optional[pulumi.Input[Union['DedicatedDomainCustomPageArgs', 'DedicatedDomainCustomPageArgsDict']]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            domain: Optional[pulumi.Input[_builtins.str]] = None,
            enable_force_new: Optional[pulumi.Input[_builtins.str]] = None,
            enterprise_project_id: Optional[pulumi.Input[_builtins.str]] = None,
            extend: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
            flags: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainFlagArgs', 'DedicatedDomainFlagArgsDict']]]]] = None,
            forward_header_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
            keep_policy: Optional[pulumi.Input[_builtins.bool]] = None,
            listener_id: Optional[pulumi.Input[_builtins.str]] = None,
            loadbalancer_id: Optional[pulumi.Input[_builtins.str]] = None,
            mode: Optional[pulumi.Input[_builtins.str]] = None,
            pci3ds: Optional[pulumi.Input[_builtins.bool]] = None,
            pci_dss: Optional[pulumi.Input[_builtins.bool]] = None,
            policy_id: Optional[pulumi.Input[_builtins.str]] = None,
            pool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
            protect_status: Optional[pulumi.Input[_builtins.int]] = None,
            protocol: Optional[pulumi.Input[_builtins.str]] = None,
            protocol_port: Optional[pulumi.Input[_builtins.int]] = None,
            proxy: Optional[pulumi.Input[_builtins.bool]] = None,
            redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
            region: Optional[pulumi.Input[_builtins.str]] = None,
            servers: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainServerArgs', 'DedicatedDomainServerArgsDict']]]]] = None,
            timeout_settings: Optional[pulumi.Input[Union['DedicatedDomainTimeoutSettingsArgs', 'DedicatedDomainTimeoutSettingsArgsDict']]] = None,
            timestamp: Optional[pulumi.Input[_builtins.int]] = None,
            tls: Optional[pulumi.Input[_builtins.str]] = None,
            traffic_identifier: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
            traffic_mark: Optional[pulumi.Input[Union['DedicatedDomainTrafficMarkArgs', 'DedicatedDomainTrafficMarkArgsDict']]] = None,
            website_name: Optional[pulumi.Input[_builtins.str]] = None) -> 'DedicatedDomain':
        """
        Get an existing DedicatedDomain resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.int] access_status: Whether a domain name is connected to WAF. Valid values are:
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] alarm_page: The alarm page of domain. Valid values are:
        :param pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainBlockPageArgs', 'DedicatedDomainBlockPageArgsDict']]]] block_pages: The alarm page configuration.
               The block_page structure is documented below.
        :param pulumi.Input[_builtins.str] certificate_id: Specifies the certificate ID. This parameter is mandatory when `client_protocol`
               is set to **HTTPS**.
        :param pulumi.Input[_builtins.str] certificate_name: The name of the certificate used by the domain name.
        :param pulumi.Input[_builtins.str] cipher: Specifies the cipher suite of domain. The valid values are: **cipher_1**, **cipher_2**,
               **cipher_3**, **cipher_4**, **cipher_5**, **cipher_6**, and **cipher_default**.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.bool]]] compliance_certification: The compliance certifications of the domain, values are:
        :param pulumi.Input[Union['DedicatedDomainConnectionProtectionArgs', 'DedicatedDomainConnectionProtectionArgsDict']] connection_protection: Specifies the connection protection configuration to let WAF protect your
               origin servers from being crashed when WAF detects a large number of `502`/`504` error codes or pending requests.
               Only supports one protection configuration.
               The connection_protection structure is documented below.
        :param pulumi.Input[Union['DedicatedDomainCustomPageArgs', 'DedicatedDomainCustomPageArgsDict']] custom_page: Specifies the custom page. Only supports one custom alarm page.
               The custom_page structure is documented below.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the WAF dedicated domain.
        :param pulumi.Input[_builtins.str] domain: Specifies the protected domain name or IP address (port allowed). For example,
               `www.example.com` or `*.example.com` or `www.example.com:89`.
        :param pulumi.Input[_builtins.str] enterprise_project_id: Specifies the enterprise project ID of WAF dedicated domain.
               For enterprise users, if omitted, default enterprise project will be used.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extend: The extended field, which is used to save some configuration information about the protected domain name.
               The value is key-value pairs.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainFlagArgs', 'DedicatedDomainFlagArgsDict']]]] flags: The identifier, which is used on the console.
               The flag structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] forward_header_map: Specifies the field forwarding configuration. WAF inserts the added fields into
               the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
               The options of value are as follows:
               + **$time_local**
               + **$request_id**
               + **$connection_requests**
               + **$tenant_id**
               + **$project_id**
               + **$remote_addr**
               + **$remote_port**
               + **$scheme**
               + **$request_method**
               + **$http_host**
               + **$origin_uri**
               + **$request_length**
               + **$ssl_server_name**
               + **$ssl_protocol**
               + **$ssl_curves**
               + **$ssl_session_reused**
        :param pulumi.Input[_builtins.bool] keep_policy: Specifies whether to retain the policy when deleting a domain name.
               Defaults to **true**.
        :param pulumi.Input[_builtins.str] listener_id: Specifies the listener ID.
               Available listener IDs can be found through the datasource `dedicated_elb_get_listeners`.
               All listeners configured and to be configured for the load balancer will be protected by WAF.
               In cloud ELB access mode, you are advised to set this parameter.
        :param pulumi.Input[_builtins.str] loadbalancer_id: Specifies the load balancer ID.
               Available ELB IDs can be found through the datasource `dedicated_elb_get_loadbalancers`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.str] mode: Specifies the mode. If you use the cloud ELB access mode, enter enter **elb-shared**.
               Otherwise, leave this parameter blank. This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] pci3ds: Specifies the status of the PCI 3DS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
               check cannot be disabled after being enabled.
        :param pulumi.Input[_builtins.bool] pci_dss: Specifies the status of the PCI DSS compliance certification check. The options
               include **true** and **false**. This parameter must be used together with `tls` and `cipher`.
               
               > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        :param pulumi.Input[_builtins.str] policy_id: Specifies the policy ID associated with the domain. If not specified, a new policy
               will be created automatically.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] pool_ids: Specifies the dedicated engine group the domain name was added to.
               This field is valid only when creating cloud ELB mode domain.
               
               > Fields `mode`, `loadbalancer_id`, `listener_id`, `protocol_port`, and `pool_ids` are only available when creating
               cloud ELB mode domain. Due to API restrictions, the configuration of many fields will be invalid when creating a cloud
               mode ELB domain name. This means that the cloud mode elb domain name does not support the configuration of these fields.
               Please use `lifecycle` to ignore these fields. For example, you need to ignore the `proxy` or configure
               the `proxy` to **true** before creating cloud ELB mode domain. Before using this resource, please refer to the example.
               
               <a name="DedicatedDomain_server"></a>
               The `server` block supports:
        :param pulumi.Input[_builtins.int] protect_status: Specifies the protection status of domain, `0`: suspended, `1`: enabled.
               Defaults to `0`.
        :param pulumi.Input[_builtins.str] protocol: The protocol type of the client. The options are `HTTP` and `HTTPS`.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the protocol port. Valid value ranges from `0` to `65,535`.
               This field is required only when creating cloud ELB mode domain.
        :param pulumi.Input[_builtins.bool] proxy: Specifies whether a proxy is configured. Defaults to **false**.
               
               > **NOTE:** WAF forwards only HTTP/S traffic. So WAF cannot serve your non-HTTP/S traffic, such as UDP, SMTP, FTP,
               and basically all other non-HTTP/S traffic. If a proxy such as public network ELB (or Nginx) has been used, set
               proxy `true` to ensure that the WAF security policy takes effect for the real source IP address.
        :param pulumi.Input[_builtins.str] redirect_url: Specifies the URL of the redirected page. The root domain name of the redirection
               address must be the name of the currently protected domain (including a wildcard domain name).
               The available **${http_host}** can be used to indicate the currently protected domain name and port.
               For example: **${http_host}/error.html**.
               
               > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the dedicated mode domain resource.
               If omitted, the provider-level region will be used. Changing this setting will push a new domain.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DedicatedDomainServerArgs', 'DedicatedDomainServerArgsDict']]]] servers: Specifies the server configuration list of the domain.
               A maximum of `80` can be configured. The server structure is documented below.
               
               > Field `server` is required only when creating dedicated domain. This field does not need to be configured when
               creating a cloud mode ELB domain name.
        :param pulumi.Input[Union['DedicatedDomainTimeoutSettingsArgs', 'DedicatedDomainTimeoutSettingsArgsDict']] timeout_settings: Specifies the timeout setting. Only supports one timeout setting.
               The timeout_settings structure is documented below.
        :param pulumi.Input[_builtins.int] timestamp: The time the domain name was added to WAF.
        :param pulumi.Input[_builtins.str] tls: Specifies the minimum required TLS version. The valid values are: **TLS v1.0**,
               **TLS v1.1** and **TLS v1.2**.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] traffic_identifier: The traffic identifier of domain. Valid values are:
        :param pulumi.Input[Union['DedicatedDomainTrafficMarkArgs', 'DedicatedDomainTrafficMarkArgsDict']] traffic_mark: Specifies the traffic identifier. WAF uses the configurations to identify the
               malicious client IP address (proxy mode) in the header, session in the cookie, and user attribute in the parameter,
               and then triggers the corresponding known attack source rules to block attack sources.
               Only supports one traffic identifier.
               The traffic_mark structure is documented below.
        :param pulumi.Input[_builtins.str] website_name: Specifies the website name. This website name must start with a letter and only
               letters, digits, underscores (_), hyphens (-), colons (:) and periods (.) are allowed. The value contains `1` to `128`
               characters. The website name must be unique within this account.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _DedicatedDomainState.__new__(_DedicatedDomainState)

        __props__.__dict__["access_status"] = access_status
        __props__.__dict__["alarm_page"] = alarm_page
        __props__.__dict__["block_pages"] = block_pages
        __props__.__dict__["certificate_id"] = certificate_id
        __props__.__dict__["certificate_name"] = certificate_name
        __props__.__dict__["cipher"] = cipher
        __props__.__dict__["compliance_certification"] = compliance_certification
        __props__.__dict__["connection_protection"] = connection_protection
        __props__.__dict__["custom_page"] = custom_page
        __props__.__dict__["description"] = description
        __props__.__dict__["domain"] = domain
        __props__.__dict__["enable_force_new"] = enable_force_new
        __props__.__dict__["enterprise_project_id"] = enterprise_project_id
        __props__.__dict__["extend"] = extend
        __props__.__dict__["flags"] = flags
        __props__.__dict__["forward_header_map"] = forward_header_map
        __props__.__dict__["keep_policy"] = keep_policy
        __props__.__dict__["listener_id"] = listener_id
        __props__.__dict__["loadbalancer_id"] = loadbalancer_id
        __props__.__dict__["mode"] = mode
        __props__.__dict__["pci3ds"] = pci3ds
        __props__.__dict__["pci_dss"] = pci_dss
        __props__.__dict__["policy_id"] = policy_id
        __props__.__dict__["pool_ids"] = pool_ids
        __props__.__dict__["protect_status"] = protect_status
        __props__.__dict__["protocol"] = protocol
        __props__.__dict__["protocol_port"] = protocol_port
        __props__.__dict__["proxy"] = proxy
        __props__.__dict__["redirect_url"] = redirect_url
        __props__.__dict__["region"] = region
        __props__.__dict__["servers"] = servers
        __props__.__dict__["timeout_settings"] = timeout_settings
        __props__.__dict__["timestamp"] = timestamp
        __props__.__dict__["tls"] = tls
        __props__.__dict__["traffic_identifier"] = traffic_identifier
        __props__.__dict__["traffic_mark"] = traffic_mark
        __props__.__dict__["website_name"] = website_name
        return DedicatedDomain(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> pulumi.Output[_builtins.int]:
        """
        Whether a domain name is connected to WAF. Valid values are:
        """
        return pulumi.get(self, "access_status")

    @_builtins.property
    @pulumi.getter(name="alarmPage")
    def alarm_page(self) -> pulumi.Output[Mapping[str, _builtins.str]]:
        """
        The alarm page of domain. Valid values are:
        """
        return pulumi.get(self, "alarm_page")

    @_builtins.property
    @pulumi.getter(name="blockPages")
    def block_pages(self) -> pulumi.Output[Sequence['outputs.DedicatedDomainBlockPage']]:
        """
        The alarm page configuration.
        The block_page structure is documented below.
        """
        return pulumi.get(self, "block_pages")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specifies the certificate ID. This parameter is mandatory when `client_protocol`
        is set to **HTTPS**.
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> pulumi.Output[_builtins.str]:
        """
        The name of the certificate used by the domain name.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter
    def cipher(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the cipher suite of domain. The valid values are: **cipher_1**, **cipher_2**,
        **cipher_3**, **cipher_4**, **cipher_5**, **cipher_6**, and **cipher_default**.
        """
        return pulumi.get(self, "cipher")

    @_builtins.property
    @pulumi.getter(name="complianceCertification")
    def compliance_certification(self) -> pulumi.Output[Mapping[str, _builtins.bool]]:
        """
        The compliance certifications of the domain, values are:
        """
        return pulumi.get(self, "compliance_certification")

    @_builtins.property
    @pulumi.getter(name="connectionProtection")
    def connection_protection(self) -> pulumi.Output['outputs.DedicatedDomainConnectionProtection']:
        """
        Specifies the connection protection configuration to let WAF protect your
        origin servers from being crashed when WAF detects a large number of `502`/`504` error codes or pending requests.
        Only supports one protection configuration.
        The connection_protection structure is documented below.
        """
        return pulumi.get(self, "connection_protection")

    @_builtins.property
    @pulumi.getter(name="customPage")
    def custom_page(self) -> pulumi.Output[Optional['outputs.DedicatedDomainCustomPage']]:
        """
        Specifies the custom page. Only supports one custom alarm page.
        The custom_page structure is documented below.
        """
        return pulumi.get(self, "custom_page")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the description of the WAF dedicated domain.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the protected domain name or IP address (port allowed). For example,
        `www.example.com` or `*.example.com` or `www.example.com:89`.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="enableForceNew")
    def enable_force_new(self) -> pulumi.Output[Optional[_builtins.str]]:
        return pulumi.get(self, "enable_force_new")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the enterprise project ID of WAF dedicated domain.
        For enterprise users, if omitted, default enterprise project will be used.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def extend(self) -> pulumi.Output[Mapping[str, _builtins.str]]:
        """
        The extended field, which is used to save some configuration information about the protected domain name.
        The value is key-value pairs.
        """
        return pulumi.get(self, "extend")

    @_builtins.property
    @pulumi.getter
    def flags(self) -> pulumi.Output[Sequence['outputs.DedicatedDomainFlag']]:
        """
        The identifier, which is used on the console.
        The flag structure is documented below.
        """
        return pulumi.get(self, "flags")

    @_builtins.property
    @pulumi.getter(name="forwardHeaderMap")
    def forward_header_map(self) -> pulumi.Output[Mapping[str, _builtins.str]]:
        """
        Specifies the field forwarding configuration. WAF inserts the added fields into
        the header and forwards the header to the origin server. The key cannot be the same as the native Nginx field.
        The options of value are as follows:
        + **$time_local**
        + **$request_id**
        + **$connection_requests**
        + **$tenant_id**
        + **$project_id**
        + **$remote_addr**
        + **$remote_port**
        + **$scheme**
        + **$request_method**
        + **$http_host**
        + **$origin_uri**
        + **$request_length**
        + **$ssl_server_name**
        + **$ssl_protocol**
        + **$ssl_curves**
        + **$ssl_session_reused**
        """
        return pulumi.get(self, "forward_header_map")

    @_builtins.property
    @pulumi.getter(name="keepPolicy")
    def keep_policy(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Specifies whether to retain the policy when deleting a domain name.
        Defaults to **true**.
        """
        return pulumi.get(self, "keep_policy")

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the listener ID.
        Available listener IDs can be found through the datasource `dedicated_elb_get_listeners`.
        All listeners configured and to be configured for the load balancer will be protected by WAF.
        In cloud ELB access mode, you are advised to set this parameter.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="loadbalancerId")
    def loadbalancer_id(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the load balancer ID.
        Available ELB IDs can be found through the datasource `dedicated_elb_get_loadbalancers`.
        This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "loadbalancer_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the mode. If you use the cloud ELB access mode, enter enter **elb-shared**.
        Otherwise, leave this parameter blank. This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def pci3ds(self) -> pulumi.Output[_builtins.bool]:
        """
        Specifies the status of the PCI 3DS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**. The PCI 3DS compliance certification
        check cannot be disabled after being enabled.
        """
        return pulumi.get(self, "pci3ds")

    @_builtins.property
    @pulumi.getter(name="pciDss")
    def pci_dss(self) -> pulumi.Output[_builtins.bool]:
        """
        Specifies the status of the PCI DSS compliance certification check. The options
        include **true** and **false**. This parameter must be used together with `tls` and `cipher`.

        > **NOTE:** Tls must be set to **TLS v1.2**, and cipher must be set to **cipher_2**.
        """
        return pulumi.get(self, "pci_dss")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the policy ID associated with the domain. If not specified, a new policy
        will be created automatically.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Output[Optional[Sequence[_builtins.str]]]:
        """
        Specifies the dedicated engine group the domain name was added to.
        This field is valid only when creating cloud ELB mode domain.

        > Fields `mode`, `loadbalancer_id`, `listener_id`, `protocol_port`, and `pool_ids` are only available when creating
        cloud ELB mode domain. Due to API restrictions, the configuration of many fields will be invalid when creating a cloud
        mode ELB domain name. This means that the cloud mode elb domain name does not support the configuration of these fields.
        Please use `lifecycle` to ignore these fields. For example, you need to ignore the `proxy` or configure
        the `proxy` to **true** before creating cloud ELB mode domain. Before using this resource, please refer to the example.

        <a name="DedicatedDomain_server"></a>
        The `server` block supports:
        """
        return pulumi.get(self, "pool_ids")

    @_builtins.property
    @pulumi.getter(name="protectStatus")
    def protect_status(self) -> pulumi.Output[_builtins.int]:
        """
        Specifies the protection status of domain, `0`: suspended, `1`: enabled.
        Defaults to `0`.
        """
        return pulumi.get(self, "protect_status")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Output[_builtins.str]:
        """
        The protocol type of the client. The options are `HTTP` and `HTTPS`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> pulumi.Output[_builtins.int]:
        """
        Specifies the protocol port. Valid value ranges from `0` to `65,535`.
        This field is required only when creating cloud ELB mode domain.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> pulumi.Output[Optional[_builtins.bool]]:
        """
        Specifies whether a proxy is configured. Defaults to **false**.

        > **NOTE:** WAF forwards only HTTP/S traffic. So WAF cannot serve your non-HTTP/S traffic, such as UDP, SMTP, FTP,
        and basically all other non-HTTP/S traffic. If a proxy such as public network ELB (or Nginx) has been used, set
        proxy `true` to ensure that the WAF security policy takes effect for the real source IP address.
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Specifies the URL of the redirected page. The root domain name of the redirection
        address must be the name of the currently protected domain (including a wildcard domain name).
        The available **${http_host}** can be used to indicate the currently protected domain name and port.
        For example: **${http_host}/error.html**.

        > The fields `redirect_url` and `custom_page` are mutually exclusive and cannot be specified simultaneously.
        """
        return pulumi.get(self, "redirect_url")

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the region in which to create the dedicated mode domain resource.
        If omitted, the provider-level region will be used. Changing this setting will push a new domain.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> pulumi.Output[Sequence['outputs.DedicatedDomainServer']]:
        """
        Specifies the server configuration list of the domain.
        A maximum of `80` can be configured. The server structure is documented below.

        > Field `server` is required only when creating dedicated domain. This field does not need to be configured when
        creating a cloud mode ELB domain name.
        """
        return pulumi.get(self, "servers")

    @_builtins.property
    @pulumi.getter(name="timeoutSettings")
    def timeout_settings(self) -> pulumi.Output['outputs.DedicatedDomainTimeoutSettings']:
        """
        Specifies the timeout setting. Only supports one timeout setting.
        The timeout_settings structure is documented below.
        """
        return pulumi.get(self, "timeout_settings")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> pulumi.Output[_builtins.int]:
        """
        The time the domain name was added to WAF.
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter
    def tls(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the minimum required TLS version. The valid values are: **TLS v1.0**,
        **TLS v1.1** and **TLS v1.2**.
        """
        return pulumi.get(self, "tls")

    @_builtins.property
    @pulumi.getter(name="trafficIdentifier")
    def traffic_identifier(self) -> pulumi.Output[Mapping[str, _builtins.str]]:
        """
        The traffic identifier of domain. Valid values are:
        """
        return pulumi.get(self, "traffic_identifier")

    @_builtins.property
    @pulumi.getter(name="trafficMark")
    def traffic_mark(self) -> pulumi.Output['outputs.DedicatedDomainTrafficMark']:
        """
        Specifies the traffic identifier. WAF uses the configurations to identify the
        malicious client IP address (proxy mode) in the header, session in the cookie, and user attribute in the parameter,
        and then triggers the corresponding known attack source rules to block attack sources.
        Only supports one traffic identifier.
        The traffic_mark structure is documented below.
        """
        return pulumi.get(self, "traffic_mark")

    @_builtins.property
    @pulumi.getter(name="websiteName")
    def website_name(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the website name. This website name must start with a letter and only
        letters, digits, underscores (_), hyphens (-), colons (:) and periods (.) are allowed. The value contains `1` to `128`
        characters. The website name must be unique within this account.
        """
        return pulumi.get(self, "website_name")

