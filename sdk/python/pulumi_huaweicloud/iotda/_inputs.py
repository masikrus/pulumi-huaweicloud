# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BatchtaskTargetsFilterArgs',
    'BatchtaskTargetsFilterArgsDict',
    'BatchtaskTaskDetailArgs',
    'BatchtaskTaskDetailArgsDict',
    'BatchtaskTaskDetailErrorArgs',
    'BatchtaskTaskDetailErrorArgsDict',
    'BatchtaskTaskProgressArgs',
    'BatchtaskTaskProgressArgsDict',
    'DataforwardingRuleTargetArgs',
    'DataforwardingRuleTargetArgsDict',
    'DataforwardingRuleTargetAmqpForwardingArgs',
    'DataforwardingRuleTargetAmqpForwardingArgsDict',
    'DataforwardingRuleTargetDisForwardingArgs',
    'DataforwardingRuleTargetDisForwardingArgsDict',
    'DataforwardingRuleTargetFgsForwardingArgs',
    'DataforwardingRuleTargetFgsForwardingArgsDict',
    'DataforwardingRuleTargetHttpForwardingArgs',
    'DataforwardingRuleTargetHttpForwardingArgsDict',
    'DataforwardingRuleTargetKafkaForwardingArgs',
    'DataforwardingRuleTargetKafkaForwardingArgsDict',
    'DataforwardingRuleTargetKafkaForwardingAddressArgs',
    'DataforwardingRuleTargetKafkaForwardingAddressArgsDict',
    'DataforwardingRuleTargetObsForwardingArgs',
    'DataforwardingRuleTargetObsForwardingArgsDict',
    'DeviceLinkageRuleActionArgs',
    'DeviceLinkageRuleActionArgsDict',
    'DeviceLinkageRuleActionDeviceAlarmArgs',
    'DeviceLinkageRuleActionDeviceAlarmArgsDict',
    'DeviceLinkageRuleActionDeviceCommandArgs',
    'DeviceLinkageRuleActionDeviceCommandArgsDict',
    'DeviceLinkageRuleActionSmnForwardingArgs',
    'DeviceLinkageRuleActionSmnForwardingArgsDict',
    'DeviceLinkageRuleEffectivePeriodArgs',
    'DeviceLinkageRuleEffectivePeriodArgsDict',
    'DeviceLinkageRuleTriggerArgs',
    'DeviceLinkageRuleTriggerArgsDict',
    'DeviceLinkageRuleTriggerDailyTimerConditionArgs',
    'DeviceLinkageRuleTriggerDailyTimerConditionArgsDict',
    'DeviceLinkageRuleTriggerDeviceDataConditionArgs',
    'DeviceLinkageRuleTriggerDeviceDataConditionArgsDict',
    'DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgs',
    'DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgsDict',
    'DeviceLinkageRuleTriggerSimpleTimerConditionArgs',
    'DeviceLinkageRuleTriggerSimpleTimerConditionArgsDict',
    'DeviceMessageErrorInfoArgs',
    'DeviceMessageErrorInfoArgsDict',
    'DeviceMessagePropertiesArgs',
    'DeviceMessagePropertiesArgsDict',
    'DeviceMessagePropertiesUserPropertyArgs',
    'DeviceMessagePropertiesUserPropertyArgsDict',
    'DevicePolicyStatementArgs',
    'DevicePolicyStatementArgsDict',
    'DeviceProxyEffectiveTimeRangeArgs',
    'DeviceProxyEffectiveTimeRangeArgsDict',
    'DeviceShadowArgs',
    'DeviceShadowArgsDict',
    'ProductServiceArgs',
    'ProductServiceArgsDict',
    'ProductServiceCommandArgs',
    'ProductServiceCommandArgsDict',
    'ProductServiceCommandParaArgs',
    'ProductServiceCommandParaArgsDict',
    'ProductServiceCommandResponseArgs',
    'ProductServiceCommandResponseArgsDict',
    'ProductServicePropertyArgs',
    'ProductServicePropertyArgsDict',
    'UpgradePackageFileLocationArgs',
    'UpgradePackageFileLocationArgsDict',
    'UpgradePackageFileLocationObsLocationArgs',
    'UpgradePackageFileLocationObsLocationArgsDict',
]

MYPY = False

if not MYPY:
    class BatchtaskTargetsFilterArgsDict(TypedDict):
        group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the list of device group IDs for executing batch task. Batch task
        will filter out devices within the groups as targets.
        """
elif False:
    BatchtaskTargetsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchtaskTargetsFilterArgs:
    def __init__(__self__, *,
                 group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_ids: Specifies the list of device group IDs for executing batch task. Batch task
               will filter out devices within the groups as targets.
        """
        pulumi.set(__self__, "group_ids", group_ids)

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the list of device group IDs for executing batch task. Batch task
        will filter out devices within the groups as targets.
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "group_ids", value)


if not MYPY:
    class BatchtaskTaskDetailArgsDict(TypedDict):
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['BatchtaskTaskDetailErrorArgsDict']]]]
        """
        Subtask execution failure information. The value only exists when the subtask fails.
        The task_details structure is documented below.
        """
        output: NotRequired[pulumi.Input[_builtins.str]]
        """
        The output information of subtask execution. The value only exists when the subtask is successfully
        executed, including device ID, space ID, device secret, and device fingerprint.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The execution status of subtask. The value can be **Success** or **Fail**.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        The goal of executing subtask. The value includes product ID and node ID.
        """
elif False:
    BatchtaskTaskDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchtaskTaskDetailArgs:
    def __init__(__self__, *,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['BatchtaskTaskDetailErrorArgs']]]] = None,
                 output: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BatchtaskTaskDetailErrorArgs']]] errors: Subtask execution failure information. The value only exists when the subtask fails.
               The task_details structure is documented below.
        :param pulumi.Input[_builtins.str] output: The output information of subtask execution. The value only exists when the subtask is successfully
               executed, including device ID, space ID, device secret, and device fingerprint.
        :param pulumi.Input[_builtins.str] status: The execution status of subtask. The value can be **Success** or **Fail**.
        :param pulumi.Input[_builtins.str] target: The goal of executing subtask. The value includes product ID and node ID.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BatchtaskTaskDetailErrorArgs']]]]:
        """
        Subtask execution failure information. The value only exists when the subtask fails.
        The task_details structure is documented below.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BatchtaskTaskDetailErrorArgs']]]]):
        pulumi.set(self, "errors", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The output information of subtask execution. The value only exists when the subtask is successfully
        executed, including device ID, space ID, device secret, and device fingerprint.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The execution status of subtask. The value can be **Success** or **Fail**.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The goal of executing subtask. The value includes product ID and node ID.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class BatchtaskTaskDetailErrorArgsDict(TypedDict):
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subtask execution failure error code.
        """
        error_msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subtask execution failure error message.
        """
elif False:
    BatchtaskTaskDetailErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchtaskTaskDetailErrorArgs:
    def __init__(__self__, *,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_msg: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_code: Subtask execution failure error code.
        :param pulumi.Input[_builtins.str] error_msg: Subtask execution failure error message.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_msg is not None:
            pulumi.set(__self__, "error_msg", error_msg)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subtask execution failure error code.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subtask execution failure error message.
        """
        return pulumi.get(self, "error_msg")

    @error_msg.setter
    def error_msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_msg", value)


if not MYPY:
    class BatchtaskTaskProgressArgsDict(TypedDict):
        fail: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of subtasks that failed to execute.
        """
        success: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of successfully executed subtasks.
        """
        total: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total number of subtasks.
        """
elif False:
    BatchtaskTaskProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchtaskTaskProgressArgs:
    def __init__(__self__, *,
                 fail: Optional[pulumi.Input[_builtins.int]] = None,
                 success: Optional[pulumi.Input[_builtins.int]] = None,
                 total: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] fail: The number of subtasks that failed to execute.
        :param pulumi.Input[_builtins.int] success: The number of successfully executed subtasks.
        :param pulumi.Input[_builtins.int] total: The total number of subtasks.
        """
        if fail is not None:
            pulumi.set(__self__, "fail", fail)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if total is not None:
            pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def fail(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of subtasks that failed to execute.
        """
        return pulumi.get(self, "fail")

    @fail.setter
    def fail(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fail", value)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of successfully executed subtasks.
        """
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success", value)

    @_builtins.property
    @pulumi.getter
    def total(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total number of subtasks.
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total", value)


if not MYPY:
    class DataforwardingRuleTargetArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of forwarding target. The options are as follows:
        + **HTTP_FORWARDING**: The platform can push specified device data to a Third-party application (HTTP push).
        You can set different addresses that different types of device data are pushed to.
        + **DIS_FORWARDING**: DIS provides efficient collection, transmission, and distribution of real-time data. It also
        provides an abundant selection of APIs to help you quickly create real-time data applications.
        + **OBS_FORWARDING**: OBS is a stable, secure, cloud storage service that is scalable, efficient and easy-to-use.
        It allows you to store any amount of unstructured data in any format, and provides REST APIs so you can access your
        data from anywhere.
        + **AMQP_FORWARDING**: AMQP provides a scalable, distributed message queue that supports high throughput with low
        latency. AMQP is ready from the get-go and is O&M free.
        + **DMS_KAFKA_FORWARDING**: Distributed Message Service (DMS) for Kafka features high throughput, concurrency, and
        scalability. It is suitable for real-time data transmission, stream data processing, system decoupling,
        and traffic balancing.
        + **FUNCTIONGRAPH_FORWARDING**: By forwarding data to FunctionGraph service, you only need to write your business
        function code and set the conditions for execution in FunctionGraph. There is no need to configure and manage
        servers or other infrastructure. Functions will run in an elastic, maintenance-free, and highly reliable manner.
        Currently, only standard and enterprise edition IoTDA instances are supported.
        """
        amqp_forwarding: NotRequired[pulumi.Input['DataforwardingRuleTargetAmqpForwardingArgsDict']]
        """
        Specifies the detail of AMQP forwards. It is required when type
        is `AMQP_FORWARDING`. The amqp_forwarding structure is documented below.
        """
        dis_forwarding: NotRequired[pulumi.Input['DataforwardingRuleTargetDisForwardingArgsDict']]
        """
        Specifies the detail of the DIS forwards. It is required when type
        is `DIS_FORWARDING`. The dis_forwarding structure is documented below.
        """
        fgs_forwarding: NotRequired[pulumi.Input['DataforwardingRuleTargetFgsForwardingArgsDict']]
        """
        Specifies the detail of the FunctionGraph forwards. It is required when
        type is **FUNCTIONGRAPH_FORWARDING**. The fgs_forwarding structure is documented below.

        <a name="IoTDA_http_forwarding"></a>
        The `http_forwarding` block supports:
        """
        http_forwarding: NotRequired[pulumi.Input['DataforwardingRuleTargetHttpForwardingArgsDict']]
        """
        Specifies the detail of the HTTP forwards. It is required when type
        is `HTTP_FORWARDING`. The http_forwarding structure is documented below.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID in UUID format.
        """
        kafka_forwarding: NotRequired[pulumi.Input['DataforwardingRuleTargetKafkaForwardingArgsDict']]
        """
        Specifies the detail of the KAFKA forwards. It is required when type
        is `DMS_KAFKA_FORWARDING`. The properties structure is documented below.
        """
        obs_forwarding: NotRequired[pulumi.Input['DataforwardingRuleTargetObsForwardingArgsDict']]
        """
        Specifies the detail of the OBS forwards. It is required when type
        is `OBS_FORWARDING`. The obs_forwarding structure is documented below.
        """
elif False:
    DataforwardingRuleTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 amqp_forwarding: Optional[pulumi.Input['DataforwardingRuleTargetAmqpForwardingArgs']] = None,
                 dis_forwarding: Optional[pulumi.Input['DataforwardingRuleTargetDisForwardingArgs']] = None,
                 fgs_forwarding: Optional[pulumi.Input['DataforwardingRuleTargetFgsForwardingArgs']] = None,
                 http_forwarding: Optional[pulumi.Input['DataforwardingRuleTargetHttpForwardingArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 kafka_forwarding: Optional[pulumi.Input['DataforwardingRuleTargetKafkaForwardingArgs']] = None,
                 obs_forwarding: Optional[pulumi.Input['DataforwardingRuleTargetObsForwardingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of forwarding target. The options are as follows:
               + **HTTP_FORWARDING**: The platform can push specified device data to a Third-party application (HTTP push).
               You can set different addresses that different types of device data are pushed to.
               + **DIS_FORWARDING**: DIS provides efficient collection, transmission, and distribution of real-time data. It also
               provides an abundant selection of APIs to help you quickly create real-time data applications.
               + **OBS_FORWARDING**: OBS is a stable, secure, cloud storage service that is scalable, efficient and easy-to-use.
               It allows you to store any amount of unstructured data in any format, and provides REST APIs so you can access your
               data from anywhere.
               + **AMQP_FORWARDING**: AMQP provides a scalable, distributed message queue that supports high throughput with low
               latency. AMQP is ready from the get-go and is O&M free.
               + **DMS_KAFKA_FORWARDING**: Distributed Message Service (DMS) for Kafka features high throughput, concurrency, and
               scalability. It is suitable for real-time data transmission, stream data processing, system decoupling,
               and traffic balancing.
               + **FUNCTIONGRAPH_FORWARDING**: By forwarding data to FunctionGraph service, you only need to write your business
               function code and set the conditions for execution in FunctionGraph. There is no need to configure and manage
               servers or other infrastructure. Functions will run in an elastic, maintenance-free, and highly reliable manner.
               Currently, only standard and enterprise edition IoTDA instances are supported.
        :param pulumi.Input['DataforwardingRuleTargetAmqpForwardingArgs'] amqp_forwarding: Specifies the detail of AMQP forwards. It is required when type
               is `AMQP_FORWARDING`. The amqp_forwarding structure is documented below.
        :param pulumi.Input['DataforwardingRuleTargetDisForwardingArgs'] dis_forwarding: Specifies the detail of the DIS forwards. It is required when type
               is `DIS_FORWARDING`. The dis_forwarding structure is documented below.
        :param pulumi.Input['DataforwardingRuleTargetFgsForwardingArgs'] fgs_forwarding: Specifies the detail of the FunctionGraph forwards. It is required when
               type is **FUNCTIONGRAPH_FORWARDING**. The fgs_forwarding structure is documented below.
               
               <a name="IoTDA_http_forwarding"></a>
               The `http_forwarding` block supports:
        :param pulumi.Input['DataforwardingRuleTargetHttpForwardingArgs'] http_forwarding: Specifies the detail of the HTTP forwards. It is required when type
               is `HTTP_FORWARDING`. The http_forwarding structure is documented below.
        :param pulumi.Input[_builtins.str] id: The resource ID in UUID format.
        :param pulumi.Input['DataforwardingRuleTargetKafkaForwardingArgs'] kafka_forwarding: Specifies the detail of the KAFKA forwards. It is required when type
               is `DMS_KAFKA_FORWARDING`. The properties structure is documented below.
        :param pulumi.Input['DataforwardingRuleTargetObsForwardingArgs'] obs_forwarding: Specifies the detail of the OBS forwards. It is required when type
               is `OBS_FORWARDING`. The obs_forwarding structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if amqp_forwarding is not None:
            pulumi.set(__self__, "amqp_forwarding", amqp_forwarding)
        if dis_forwarding is not None:
            pulumi.set(__self__, "dis_forwarding", dis_forwarding)
        if fgs_forwarding is not None:
            pulumi.set(__self__, "fgs_forwarding", fgs_forwarding)
        if http_forwarding is not None:
            pulumi.set(__self__, "http_forwarding", http_forwarding)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kafka_forwarding is not None:
            pulumi.set(__self__, "kafka_forwarding", kafka_forwarding)
        if obs_forwarding is not None:
            pulumi.set(__self__, "obs_forwarding", obs_forwarding)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of forwarding target. The options are as follows:
        + **HTTP_FORWARDING**: The platform can push specified device data to a Third-party application (HTTP push).
        You can set different addresses that different types of device data are pushed to.
        + **DIS_FORWARDING**: DIS provides efficient collection, transmission, and distribution of real-time data. It also
        provides an abundant selection of APIs to help you quickly create real-time data applications.
        + **OBS_FORWARDING**: OBS is a stable, secure, cloud storage service that is scalable, efficient and easy-to-use.
        It allows you to store any amount of unstructured data in any format, and provides REST APIs so you can access your
        data from anywhere.
        + **AMQP_FORWARDING**: AMQP provides a scalable, distributed message queue that supports high throughput with low
        latency. AMQP is ready from the get-go and is O&M free.
        + **DMS_KAFKA_FORWARDING**: Distributed Message Service (DMS) for Kafka features high throughput, concurrency, and
        scalability. It is suitable for real-time data transmission, stream data processing, system decoupling,
        and traffic balancing.
        + **FUNCTIONGRAPH_FORWARDING**: By forwarding data to FunctionGraph service, you only need to write your business
        function code and set the conditions for execution in FunctionGraph. There is no need to configure and manage
        servers or other infrastructure. Functions will run in an elastic, maintenance-free, and highly reliable manner.
        Currently, only standard and enterprise edition IoTDA instances are supported.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="amqpForwarding")
    def amqp_forwarding(self) -> Optional[pulumi.Input['DataforwardingRuleTargetAmqpForwardingArgs']]:
        """
        Specifies the detail of AMQP forwards. It is required when type
        is `AMQP_FORWARDING`. The amqp_forwarding structure is documented below.
        """
        return pulumi.get(self, "amqp_forwarding")

    @amqp_forwarding.setter
    def amqp_forwarding(self, value: Optional[pulumi.Input['DataforwardingRuleTargetAmqpForwardingArgs']]):
        pulumi.set(self, "amqp_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="disForwarding")
    def dis_forwarding(self) -> Optional[pulumi.Input['DataforwardingRuleTargetDisForwardingArgs']]:
        """
        Specifies the detail of the DIS forwards. It is required when type
        is `DIS_FORWARDING`. The dis_forwarding structure is documented below.
        """
        return pulumi.get(self, "dis_forwarding")

    @dis_forwarding.setter
    def dis_forwarding(self, value: Optional[pulumi.Input['DataforwardingRuleTargetDisForwardingArgs']]):
        pulumi.set(self, "dis_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="fgsForwarding")
    def fgs_forwarding(self) -> Optional[pulumi.Input['DataforwardingRuleTargetFgsForwardingArgs']]:
        """
        Specifies the detail of the FunctionGraph forwards. It is required when
        type is **FUNCTIONGRAPH_FORWARDING**. The fgs_forwarding structure is documented below.

        <a name="IoTDA_http_forwarding"></a>
        The `http_forwarding` block supports:
        """
        return pulumi.get(self, "fgs_forwarding")

    @fgs_forwarding.setter
    def fgs_forwarding(self, value: Optional[pulumi.Input['DataforwardingRuleTargetFgsForwardingArgs']]):
        pulumi.set(self, "fgs_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="httpForwarding")
    def http_forwarding(self) -> Optional[pulumi.Input['DataforwardingRuleTargetHttpForwardingArgs']]:
        """
        Specifies the detail of the HTTP forwards. It is required when type
        is `HTTP_FORWARDING`. The http_forwarding structure is documented below.
        """
        return pulumi.get(self, "http_forwarding")

    @http_forwarding.setter
    def http_forwarding(self, value: Optional[pulumi.Input['DataforwardingRuleTargetHttpForwardingArgs']]):
        pulumi.set(self, "http_forwarding", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID in UUID format.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="kafkaForwarding")
    def kafka_forwarding(self) -> Optional[pulumi.Input['DataforwardingRuleTargetKafkaForwardingArgs']]:
        """
        Specifies the detail of the KAFKA forwards. It is required when type
        is `DMS_KAFKA_FORWARDING`. The properties structure is documented below.
        """
        return pulumi.get(self, "kafka_forwarding")

    @kafka_forwarding.setter
    def kafka_forwarding(self, value: Optional[pulumi.Input['DataforwardingRuleTargetKafkaForwardingArgs']]):
        pulumi.set(self, "kafka_forwarding", value)

    @_builtins.property
    @pulumi.getter(name="obsForwarding")
    def obs_forwarding(self) -> Optional[pulumi.Input['DataforwardingRuleTargetObsForwardingArgs']]:
        """
        Specifies the detail of the OBS forwards. It is required when type
        is `OBS_FORWARDING`. The obs_forwarding structure is documented below.
        """
        return pulumi.get(self, "obs_forwarding")

    @obs_forwarding.setter
    def obs_forwarding(self, value: Optional[pulumi.Input['DataforwardingRuleTargetObsForwardingArgs']]):
        pulumi.set(self, "obs_forwarding", value)


if not MYPY:
    class DataforwardingRuleTargetAmqpForwardingArgsDict(TypedDict):
        queue_name: pulumi.Input[_builtins.str]
        """
        Specifies the AMQP Queue name.

        <a name="IoTDA_kafka_forwarding"></a>
        The `kafka_forwarding` block supports:
        """
elif False:
    DataforwardingRuleTargetAmqpForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetAmqpForwardingArgs:
    def __init__(__self__, *,
                 queue_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] queue_name: Specifies the AMQP Queue name.
               
               <a name="IoTDA_kafka_forwarding"></a>
               The `kafka_forwarding` block supports:
        """
        pulumi.set(__self__, "queue_name", queue_name)

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the AMQP Queue name.

        <a name="IoTDA_kafka_forwarding"></a>
        The `kafka_forwarding` block supports:
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue_name", value)


if not MYPY:
    class DataforwardingRuleTargetDisForwardingArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        Specifies the region to which the KAFKA belongs.
        """
        stream_id: pulumi.Input[_builtins.str]
        """
        Specifies the DIS stream ID.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
elif False:
    DataforwardingRuleTargetDisForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetDisForwardingArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 stream_id: pulumi.Input[_builtins.str],
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: Specifies the region to which the KAFKA belongs.
        :param pulumi.Input[_builtins.str] stream_id: Specifies the DIS stream ID.
        :param pulumi.Input[_builtins.str] project_id: Specifies the project ID to which the KAFKA belongs.
               If omitted, the default project in the region will be used.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "stream_id", stream_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the region to which the KAFKA belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DIS stream ID.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_id", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class DataforwardingRuleTargetFgsForwardingArgsDict(TypedDict):
        func_name: pulumi.Input[_builtins.str]
        """
        Specifies the function name.

        <a name="IoTDA_forwarding_addresses"></a>
        The `addresses` block supports:
        """
        func_urn: pulumi.Input[_builtins.str]
        """
        Specifies the function URN.
        """
elif False:
    DataforwardingRuleTargetFgsForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetFgsForwardingArgs:
    def __init__(__self__, *,
                 func_name: pulumi.Input[_builtins.str],
                 func_urn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] func_name: Specifies the function name.
               
               <a name="IoTDA_forwarding_addresses"></a>
               The `addresses` block supports:
        :param pulumi.Input[_builtins.str] func_urn: Specifies the function URN.
        """
        pulumi.set(__self__, "func_name", func_name)
        pulumi.set(__self__, "func_urn", func_urn)

    @_builtins.property
    @pulumi.getter(name="funcName")
    def func_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the function name.

        <a name="IoTDA_forwarding_addresses"></a>
        The `addresses` block supports:
        """
        return pulumi.get(self, "func_name")

    @func_name.setter
    def func_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "func_name", value)

    @_builtins.property
    @pulumi.getter(name="funcUrn")
    def func_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the function URN.
        """
        return pulumi.get(self, "func_urn")

    @func_urn.setter
    def func_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "func_urn", value)


if not MYPY:
    class DataforwardingRuleTargetHttpForwardingArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the Push URL. The request method must is post.

        <a name="IoTDA_dis_forwarding"></a>
        The `dis_forwarding` block supports:
        """
elif False:
    DataforwardingRuleTargetHttpForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetHttpForwardingArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the Push URL. The request method must is post.
               
               <a name="IoTDA_dis_forwarding"></a>
               The `dis_forwarding` block supports:
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Push URL. The request method must is post.

        <a name="IoTDA_dis_forwarding"></a>
        The `dis_forwarding` block supports:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class DataforwardingRuleTargetKafkaForwardingArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input['DataforwardingRuleTargetKafkaForwardingAddressArgsDict']]]
        """
        Specifies the list of the connected service addresses.
        The addresses structure is documented below.
        """
        region: pulumi.Input[_builtins.str]
        """
        Specifies the region to which the KAFKA belongs.
        """
        topic: pulumi.Input[_builtins.str]
        """
        Specifies the topic.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the password.

        <a name="IoTDA_fgs_forwarding"></a>
        The `fgs_forwarding` block supports:
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the SASL user name.
        """
elif False:
    DataforwardingRuleTargetKafkaForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetKafkaForwardingArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input['DataforwardingRuleTargetKafkaForwardingAddressArgs']]],
                 region: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataforwardingRuleTargetKafkaForwardingAddressArgs']]] addresses: Specifies the list of the connected service addresses.
               The addresses structure is documented below.
        :param pulumi.Input[_builtins.str] region: Specifies the region to which the KAFKA belongs.
        :param pulumi.Input[_builtins.str] topic: Specifies the topic.
        :param pulumi.Input[_builtins.str] password: Specifies the password.
               
               <a name="IoTDA_fgs_forwarding"></a>
               The `fgs_forwarding` block supports:
        :param pulumi.Input[_builtins.str] project_id: Specifies the project ID to which the KAFKA belongs.
               If omitted, the default project in the region will be used.
        :param pulumi.Input[_builtins.str] user_name: Specifies the SASL user name.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "topic", topic)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input['DataforwardingRuleTargetKafkaForwardingAddressArgs']]]:
        """
        Specifies the list of the connected service addresses.
        The addresses structure is documented below.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input['DataforwardingRuleTargetKafkaForwardingAddressArgs']]]):
        pulumi.set(self, "addresses", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the region to which the KAFKA belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the password.

        <a name="IoTDA_fgs_forwarding"></a>
        The `fgs_forwarding` block supports:
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the SASL user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class DataforwardingRuleTargetKafkaForwardingAddressArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        Specifies the port of the connected service address.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the domain of the connected service address.
        Exactly one of `ip` or `domain` must be provided.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP of the connected service address.
        Exactly one of `ip` or `domain` must be provided.
        """
elif False:
    DataforwardingRuleTargetKafkaForwardingAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetKafkaForwardingAddressArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] port: Specifies the port of the connected service address.
        :param pulumi.Input[_builtins.str] domain: Specifies the domain of the connected service address.
               Exactly one of `ip` or `domain` must be provided.
        :param pulumi.Input[_builtins.str] ip: Specifies the IP of the connected service address.
               Exactly one of `ip` or `domain` must be provided.
        """
        pulumi.set(__self__, "port", port)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the port of the connected service address.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the domain of the connected service address.
        Exactly one of `ip` or `domain` must be provided.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP of the connected service address.
        Exactly one of `ip` or `domain` must be provided.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class DataforwardingRuleTargetObsForwardingArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Specifies the OBS Bucket.
        """
        region: pulumi.Input[_builtins.str]
        """
        Specifies the region to which the KAFKA belongs.
        """
        custom_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the custom directory for storing channel files. The ID contains a
        maximum of `256` characters. Multi-level directories can be separated by (/), and cannot start or end with a slash (/),
        and cannot contain more than two adjacent slashes (/). Only letters, digits, hyphens (-), underscores (_), slash (/)
        and braces ({}) are allowed. Braces can be used only for the time template parameters. For example, if the custom
        directory is in the format of {YYYY}/{MM}/{DD}/{HH}, data is generated in the directory based on the current
        time(for example, 2022/06/14/10) when data is forwarded.

        <a name="IoTDA_amqp_forwarding"></a>
        The `amqp_forwarding` block supports:
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
elif False:
    DataforwardingRuleTargetObsForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataforwardingRuleTargetObsForwardingArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 custom_directory: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Specifies the OBS Bucket.
        :param pulumi.Input[_builtins.str] region: Specifies the region to which the KAFKA belongs.
        :param pulumi.Input[_builtins.str] custom_directory: Specifies the custom directory for storing channel files. The ID contains a
               maximum of `256` characters. Multi-level directories can be separated by (/), and cannot start or end with a slash (/),
               and cannot contain more than two adjacent slashes (/). Only letters, digits, hyphens (-), underscores (_), slash (/)
               and braces ({}) are allowed. Braces can be used only for the time template parameters. For example, if the custom
               directory is in the format of {YYYY}/{MM}/{DD}/{HH}, data is generated in the directory based on the current
               time(for example, 2022/06/14/10) when data is forwarded.
               
               <a name="IoTDA_amqp_forwarding"></a>
               The `amqp_forwarding` block supports:
        :param pulumi.Input[_builtins.str] project_id: Specifies the project ID to which the KAFKA belongs.
               If omitted, the default project in the region will be used.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "region", region)
        if custom_directory is not None:
            pulumi.set(__self__, "custom_directory", custom_directory)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the OBS Bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the region to which the KAFKA belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="customDirectory")
    def custom_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the custom directory for storing channel files. The ID contains a
        maximum of `256` characters. Multi-level directories can be separated by (/), and cannot start or end with a slash (/),
        and cannot contain more than two adjacent slashes (/). Only letters, digits, hyphens (-), underscores (_), slash (/)
        and braces ({}) are allowed. Braces can be used only for the time template parameters. For example, if the custom
        directory is in the format of {YYYY}/{MM}/{DD}/{HH}, data is generated in the directory based on the current
        time(for example, 2022/06/14/10) when data is forwarded.

        <a name="IoTDA_amqp_forwarding"></a>
        The `amqp_forwarding` block supports:
        """
        return pulumi.get(self, "custom_directory")

    @custom_directory.setter
    def custom_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_directory", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class DeviceLinkageRuleActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        device_alarm: NotRequired[pulumi.Input['DeviceLinkageRuleActionDeviceAlarmArgsDict']]
        """
        Specifies the detail of device alarm. It is required when type
        is `DEVICE_ALARM`. The device_alarm structure is documented below.

        <a name="IoTDA_device_command"></a>
        The `device_command` block supports:
        """
        device_command: NotRequired[pulumi.Input['DeviceLinkageRuleActionDeviceCommandArgsDict']]
        """
        Specifies the detail of device command. It is required when type
        is `DEVICE_CMD`. The device_command structure is documented below.
        """
        smn_forwarding: NotRequired[pulumi.Input['DeviceLinkageRuleActionSmnForwardingArgsDict']]
        """
        Specifies the detail of SMN notifications. It is required when type
        is `SMN_FORWARDING`. The smn_forwarding structure is documented below.
        """
elif False:
    DeviceLinkageRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 device_alarm: Optional[pulumi.Input['DeviceLinkageRuleActionDeviceAlarmArgs']] = None,
                 device_command: Optional[pulumi.Input['DeviceLinkageRuleActionDeviceCommandArgs']] = None,
                 smn_forwarding: Optional[pulumi.Input['DeviceLinkageRuleActionSmnForwardingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of the alarm. The options are as follows:
               + **fault**: Report alarms.
               + **recovery**: Clear alarms.
        :param pulumi.Input['DeviceLinkageRuleActionDeviceAlarmArgs'] device_alarm: Specifies the detail of device alarm. It is required when type
               is `DEVICE_ALARM`. The device_alarm structure is documented below.
               
               <a name="IoTDA_device_command"></a>
               The `device_command` block supports:
        :param pulumi.Input['DeviceLinkageRuleActionDeviceCommandArgs'] device_command: Specifies the detail of device command. It is required when type
               is `DEVICE_CMD`. The device_command structure is documented below.
        :param pulumi.Input['DeviceLinkageRuleActionSmnForwardingArgs'] smn_forwarding: Specifies the detail of SMN notifications. It is required when type
               is `SMN_FORWARDING`. The smn_forwarding structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if device_alarm is not None:
            pulumi.set(__self__, "device_alarm", device_alarm)
        if device_command is not None:
            pulumi.set(__self__, "device_command", device_command)
        if smn_forwarding is not None:
            pulumi.set(__self__, "smn_forwarding", smn_forwarding)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="deviceAlarm")
    def device_alarm(self) -> Optional[pulumi.Input['DeviceLinkageRuleActionDeviceAlarmArgs']]:
        """
        Specifies the detail of device alarm. It is required when type
        is `DEVICE_ALARM`. The device_alarm structure is documented below.

        <a name="IoTDA_device_command"></a>
        The `device_command` block supports:
        """
        return pulumi.get(self, "device_alarm")

    @device_alarm.setter
    def device_alarm(self, value: Optional[pulumi.Input['DeviceLinkageRuleActionDeviceAlarmArgs']]):
        pulumi.set(self, "device_alarm", value)

    @_builtins.property
    @pulumi.getter(name="deviceCommand")
    def device_command(self) -> Optional[pulumi.Input['DeviceLinkageRuleActionDeviceCommandArgs']]:
        """
        Specifies the detail of device command. It is required when type
        is `DEVICE_CMD`. The device_command structure is documented below.
        """
        return pulumi.get(self, "device_command")

    @device_command.setter
    def device_command(self, value: Optional[pulumi.Input['DeviceLinkageRuleActionDeviceCommandArgs']]):
        pulumi.set(self, "device_command", value)

    @_builtins.property
    @pulumi.getter(name="smnForwarding")
    def smn_forwarding(self) -> Optional[pulumi.Input['DeviceLinkageRuleActionSmnForwardingArgs']]:
        """
        Specifies the detail of SMN notifications. It is required when type
        is `SMN_FORWARDING`. The smn_forwarding structure is documented below.
        """
        return pulumi.get(self, "smn_forwarding")

    @smn_forwarding.setter
    def smn_forwarding(self, value: Optional[pulumi.Input['DeviceLinkageRuleActionSmnForwardingArgs']]):
        pulumi.set(self, "smn_forwarding", value)


if not MYPY:
    class DeviceLinkageRuleActionDeviceAlarmArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the alarm.
        """
        severity: pulumi.Input[_builtins.str]
        """
        Specifies the severity level of the alarm.
        The valid values are **warning**, **minor**, **major** and **critical**.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the alarm.  
        The value can contain a maximum of `256` characters.

        <a name="IoTDA_effective_period"></a>
        The `effective_period` block supports:
        """
        dimension: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the dimension of the alarm. Combine the alarm name and alarm level to
        jointly identify an alarm.
        The valid values are as follows:
        + **device**: Device dimension
        + **app**: Resource space dimension.

        If not specified, default to user dimension.
        """
elif False:
    DeviceLinkageRuleActionDeviceAlarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleActionDeviceAlarmArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 severity: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dimension: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the alarm.
        :param pulumi.Input[_builtins.str] severity: Specifies the severity level of the alarm.
               The valid values are **warning**, **minor**, **major** and **critical**.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the alarm. The options are as follows:
               + **fault**: Report alarms.
               + **recovery**: Clear alarms.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the alarm.  
               The value can contain a maximum of `256` characters.
               
               <a name="IoTDA_effective_period"></a>
               The `effective_period` block supports:
        :param pulumi.Input[_builtins.str] dimension: Specifies the dimension of the alarm. Combine the alarm name and alarm level to
               jointly identify an alarm.
               The valid values are as follows:
               + **device**: Device dimension
               + **app**: Resource space dimension.
               
               If not specified, default to user dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the alarm.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the severity level of the alarm.
        The valid values are **warning**, **minor**, **major** and **critical**.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the alarm.  
        The value can contain a maximum of `256` characters.

        <a name="IoTDA_effective_period"></a>
        The `effective_period` block supports:
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the dimension of the alarm. Combine the alarm name and alarm level to
        jointly identify an alarm.
        The valid values are as follows:
        + **device**: Device dimension
        + **app**: Resource space dimension.

        If not specified, default to user dimension.
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dimension", value)


if not MYPY:
    class DeviceLinkageRuleActionDeviceCommandArgsDict(TypedDict):
        command_body: pulumi.Input[_builtins.str]
        """
        Specifies the command parameters, in json format.
        + Example of device command using LWM2M protocol: `{"value":"1"}`, there are key-value pairs, each key is the
        parameter name of the command in the product model.
        + Example of device command using MQTT protocol: `{"header": {"mode": "ACK","from": "/users/testUser","method":
        "SET_TEMPERATURE_READ_PERIOD","to":"/devices/{device_id }/services/{service_id}"},"body": {"value" : "1"}}`.
        - **mode**: Required, whether the device needs to reply to the confirmation message after receiving the command.
        The default is ACK mode. `ACK` indicates that the confirmation message needs to be replied,
        `NOACK` indicates that the confirmation message does not need to be replied.
        - **from**: Optional, the address of the command sender.
        When the App initiates a request, the format is /users/{userId},
        when the application server initiates a request, the format is /{serviceName},
        and when the IoT platform initiates a request, the format is /cloud/{serviceName}.
        - **to**: optional, the address of the command receiver, the format is /devices/{device_id}/services/{service_id}.
        - **method**: optional, the command name defined in the product model.
        - **body**: optional, the message body of the command, which contains key-value pairs, each key is the parameter
        name of the command in the product model. The specific format requires application and device conventions.
        """
        command_name: pulumi.Input[_builtins.str]
        """
        Specifies the command name.
        """
        device_id: pulumi.Input[_builtins.str]
        """
        Specifies the device id which executes the command.
        """
        service_id: pulumi.Input[_builtins.str]
        """
        Specifies the service id to which the command belongs.
        """
        buffer_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the cache time of device commands, in seconds. Representing the effective
        time for the IoT platform to cache commands before issuing them to the device. After this time, the commands will no
        longer be issued. The default value is `172,800` seconds (`48` hours). If set to `0`, the command will be immediately
        issued to the device regardless of the command issuance mode set on the IoT platform.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the issuance mode of device commands, which is only valid when the value of
        `buffer_timeout` is greater than `0`.
        The valid values are as follows:
        + **ACTIVE**: Active mode, the IoT platform actively issues commands to devices.
        + **PASSIVE**: Passive mode, after the IoT platform creates device commands, it will directly cache the commands.
        Wait until the device goes online again or reports the execution result of the previous command before issuing the
        command.

        <a name="IoTDA_smn_forwarding"></a>
        The `smn_forwarding` block supports:
        """
        response_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the effective time of the command response, in seconds. Indicating that
        the device responds effectively within the `response_timeout` time after receiving the command. If no response is
        received after this time, the command response is considered to have timed out. The default value is `1,800` seconds.
        """
elif False:
    DeviceLinkageRuleActionDeviceCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleActionDeviceCommandArgs:
    def __init__(__self__, *,
                 command_body: pulumi.Input[_builtins.str],
                 command_name: pulumi.Input[_builtins.str],
                 device_id: pulumi.Input[_builtins.str],
                 service_id: pulumi.Input[_builtins.str],
                 buffer_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 response_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] command_body: Specifies the command parameters, in json format.
               + Example of device command using LWM2M protocol: `{"value":"1"}`, there are key-value pairs, each key is the
               parameter name of the command in the product model.
               + Example of device command using MQTT protocol: `{"header": {"mode": "ACK","from": "/users/testUser","method":
               "SET_TEMPERATURE_READ_PERIOD","to":"/devices/{device_id }/services/{service_id}"},"body": {"value" : "1"}}`.
               - **mode**: Required, whether the device needs to reply to the confirmation message after receiving the command.
               The default is ACK mode. `ACK` indicates that the confirmation message needs to be replied,
               `NOACK` indicates that the confirmation message does not need to be replied.
               - **from**: Optional, the address of the command sender.
               When the App initiates a request, the format is /users/{userId},
               when the application server initiates a request, the format is /{serviceName},
               and when the IoT platform initiates a request, the format is /cloud/{serviceName}.
               - **to**: optional, the address of the command receiver, the format is /devices/{device_id}/services/{service_id}.
               - **method**: optional, the command name defined in the product model.
               - **body**: optional, the message body of the command, which contains key-value pairs, each key is the parameter
               name of the command in the product model. The specific format requires application and device conventions.
        :param pulumi.Input[_builtins.str] command_name: Specifies the command name.
        :param pulumi.Input[_builtins.str] device_id: Specifies the device id which executes the command.
        :param pulumi.Input[_builtins.str] service_id: Specifies the service id to which the command belongs.
        :param pulumi.Input[_builtins.int] buffer_timeout: Specifies the cache time of device commands, in seconds. Representing the effective
               time for the IoT platform to cache commands before issuing them to the device. After this time, the commands will no
               longer be issued. The default value is `172,800` seconds (`48` hours). If set to `0`, the command will be immediately
               issued to the device regardless of the command issuance mode set on the IoT platform.
        :param pulumi.Input[_builtins.str] mode: Specifies the issuance mode of device commands, which is only valid when the value of
               `buffer_timeout` is greater than `0`.
               The valid values are as follows:
               + **ACTIVE**: Active mode, the IoT platform actively issues commands to devices.
               + **PASSIVE**: Passive mode, after the IoT platform creates device commands, it will directly cache the commands.
               Wait until the device goes online again or reports the execution result of the previous command before issuing the
               command.
               
               <a name="IoTDA_smn_forwarding"></a>
               The `smn_forwarding` block supports:
        :param pulumi.Input[_builtins.int] response_timeout: Specifies the effective time of the command response, in seconds. Indicating that
               the device responds effectively within the `response_timeout` time after receiving the command. If no response is
               received after this time, the command response is considered to have timed out. The default value is `1,800` seconds.
        """
        pulumi.set(__self__, "command_body", command_body)
        pulumi.set(__self__, "command_name", command_name)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "service_id", service_id)
        if buffer_timeout is not None:
            pulumi.set(__self__, "buffer_timeout", buffer_timeout)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response_timeout is not None:
            pulumi.set(__self__, "response_timeout", response_timeout)

    @_builtins.property
    @pulumi.getter(name="commandBody")
    def command_body(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the command parameters, in json format.
        + Example of device command using LWM2M protocol: `{"value":"1"}`, there are key-value pairs, each key is the
        parameter name of the command in the product model.
        + Example of device command using MQTT protocol: `{"header": {"mode": "ACK","from": "/users/testUser","method":
        "SET_TEMPERATURE_READ_PERIOD","to":"/devices/{device_id }/services/{service_id}"},"body": {"value" : "1"}}`.
        - **mode**: Required, whether the device needs to reply to the confirmation message after receiving the command.
        The default is ACK mode. `ACK` indicates that the confirmation message needs to be replied,
        `NOACK` indicates that the confirmation message does not need to be replied.
        - **from**: Optional, the address of the command sender.
        When the App initiates a request, the format is /users/{userId},
        when the application server initiates a request, the format is /{serviceName},
        and when the IoT platform initiates a request, the format is /cloud/{serviceName}.
        - **to**: optional, the address of the command receiver, the format is /devices/{device_id}/services/{service_id}.
        - **method**: optional, the command name defined in the product model.
        - **body**: optional, the message body of the command, which contains key-value pairs, each key is the parameter
        name of the command in the product model. The specific format requires application and device conventions.
        """
        return pulumi.get(self, "command_body")

    @command_body.setter
    def command_body(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "command_body", value)

    @_builtins.property
    @pulumi.getter(name="commandName")
    def command_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the command name.
        """
        return pulumi.get(self, "command_name")

    @command_name.setter
    def command_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "command_name", value)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the device id which executes the command.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the service id to which the command belongs.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_id", value)

    @_builtins.property
    @pulumi.getter(name="bufferTimeout")
    def buffer_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the cache time of device commands, in seconds. Representing the effective
        time for the IoT platform to cache commands before issuing them to the device. After this time, the commands will no
        longer be issued. The default value is `172,800` seconds (`48` hours). If set to `0`, the command will be immediately
        issued to the device regardless of the command issuance mode set on the IoT platform.
        """
        return pulumi.get(self, "buffer_timeout")

    @buffer_timeout.setter
    def buffer_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "buffer_timeout", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the issuance mode of device commands, which is only valid when the value of
        `buffer_timeout` is greater than `0`.
        The valid values are as follows:
        + **ACTIVE**: Active mode, the IoT platform actively issues commands to devices.
        + **PASSIVE**: Passive mode, after the IoT platform creates device commands, it will directly cache the commands.
        Wait until the device goes online again or reports the execution result of the previous command before issuing the
        command.

        <a name="IoTDA_smn_forwarding"></a>
        The `smn_forwarding` block supports:
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="responseTimeout")
    def response_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the effective time of the command response, in seconds. Indicating that
        the device responds effectively within the `response_timeout` time after receiving the command. If no response is
        received after this time, the command response is considered to have timed out. The default value is `1,800` seconds.
        """
        return pulumi.get(self, "response_timeout")

    @response_timeout.setter
    def response_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "response_timeout", value)


if not MYPY:
    class DeviceLinkageRuleActionSmnForwardingArgsDict(TypedDict):
        message_title: pulumi.Input[_builtins.str]
        """
        Specifies the message title.
        """
        region: pulumi.Input[_builtins.str]
        """
        Specifies the region to which the SMN belongs.
        """
        topic_name: pulumi.Input[_builtins.str]
        """
        Specifies the topic name of the SMN.
        """
        topic_urn: pulumi.Input[_builtins.str]
        """
        Specifies the topic URN of the SMN.
        """
        message_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the message content.
        """
        message_template_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the template name corresponding to the SMN service.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the project ID to which the SMN belongs.
        If omitted, the default project in the region will be used.

        <a name="IoTDA_device_alarm"></a>
        The `device_alarm` block supports:
        """
elif False:
    DeviceLinkageRuleActionSmnForwardingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleActionSmnForwardingArgs:
    def __init__(__self__, *,
                 message_title: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 topic_name: pulumi.Input[_builtins.str],
                 topic_urn: pulumi.Input[_builtins.str],
                 message_content: Optional[pulumi.Input[_builtins.str]] = None,
                 message_template_name: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message_title: Specifies the message title.
        :param pulumi.Input[_builtins.str] region: Specifies the region to which the SMN belongs.
        :param pulumi.Input[_builtins.str] topic_name: Specifies the topic name of the SMN.
        :param pulumi.Input[_builtins.str] topic_urn: Specifies the topic URN of the SMN.
        :param pulumi.Input[_builtins.str] message_content: Specifies the message content.
        :param pulumi.Input[_builtins.str] message_template_name: Specifies the template name corresponding to the SMN service.
        :param pulumi.Input[_builtins.str] project_id: Specifies the project ID to which the SMN belongs.
               If omitted, the default project in the region will be used.
               
               <a name="IoTDA_device_alarm"></a>
               The `device_alarm` block supports:
        """
        pulumi.set(__self__, "message_title", message_title)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "topic_name", topic_name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if message_content is not None:
            pulumi.set(__self__, "message_content", message_content)
        if message_template_name is not None:
            pulumi.set(__self__, "message_template_name", message_template_name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="messageTitle")
    def message_title(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the message title.
        """
        return pulumi.get(self, "message_title")

    @message_title.setter
    def message_title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message_title", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the region to which the SMN belongs.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic name of the SMN.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_name", value)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the topic URN of the SMN.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_urn", value)

    @_builtins.property
    @pulumi.getter(name="messageContent")
    def message_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the message content.
        """
        return pulumi.get(self, "message_content")

    @message_content.setter
    def message_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_content", value)

    @_builtins.property
    @pulumi.getter(name="messageTemplateName")
    def message_template_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the template name corresponding to the SMN service.
        """
        return pulumi.get(self, "message_template_name")

    @message_template_name.setter
    def message_template_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_template_name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the project ID to which the SMN belongs.
        If omitted, the default project in the region will be used.

        <a name="IoTDA_device_alarm"></a>
        The `device_alarm` block supports:
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class DeviceLinkageRuleEffectivePeriodArgsDict(TypedDict):
        end_time: pulumi.Input[_builtins.str]
        """
        Specifies the end time, in the format: `HH:mm`.
        For example: `10:00`. If the end time is the same as the start time, the effective period is the whole day.
        """
        start_time: pulumi.Input[_builtins.str]
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        days_of_week: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a list of days of week, separated by commas. 1 represents Sunday,
        2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
elif False:
    DeviceLinkageRuleEffectivePeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleEffectivePeriodArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[_builtins.str],
                 start_time: pulumi.Input[_builtins.str],
                 days_of_week: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time, in the format: `HH:mm`.
               For example: `10:00`. If the end time is the same as the start time, the effective period is the whole day.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time, in the format: `HH:mm`.
               For example: `03:00`.
        :param pulumi.Input[_builtins.str] days_of_week: Specifies a list of days of week, separated by commas. 1 represents Sunday,
               2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the end time, in the format: `HH:mm`.
        For example: `10:00`. If the end time is the same as the start time, the effective period is the whole day.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a list of days of week, separated by commas. 1 represents Sunday,
        2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        return pulumi.get(self, "days_of_week")

    @days_of_week.setter
    def days_of_week(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "days_of_week", value)


if not MYPY:
    class DeviceLinkageRuleTriggerArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        daily_timer_condition: NotRequired[pulumi.Input['DeviceLinkageRuleTriggerDailyTimerConditionArgsDict']]
        """
        Specifies the condition triggered at specified time every day. It is
        required when `type` is **DAILY_TIMER**.
        The daily_timer_condition structure is documented below.
        """
        device_data_condition: NotRequired[pulumi.Input['DeviceLinkageRuleTriggerDeviceDataConditionArgsDict']]
        """
        Specifies the condition triggered upon the property of device. It is
        required when `type` is **DEVICE_DATA**.
        The device_data_condition structure is documented below.
        """
        device_linkage_status_condition: NotRequired[pulumi.Input['DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgsDict']]
        """
        Specifies the condition triggered by device status. It is
        required when `type` is **DEVICE_LINKAGE_STATUS**.
        The device_linkage_status_condition structure is documented below.

        <a name="IoTDA_device_data_condition"></a>
        The `device_data_condition` block supports:
        """
        simple_timer_condition: NotRequired[pulumi.Input['DeviceLinkageRuleTriggerSimpleTimerConditionArgsDict']]
        """
        Specifies the condition triggered by policy. It is required when `type`
        is **SIMPLE_TIMER**.
        The simple_timer_condition structure is documented below.
        """
elif False:
    DeviceLinkageRuleTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleTriggerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 daily_timer_condition: Optional[pulumi.Input['DeviceLinkageRuleTriggerDailyTimerConditionArgs']] = None,
                 device_data_condition: Optional[pulumi.Input['DeviceLinkageRuleTriggerDeviceDataConditionArgs']] = None,
                 device_linkage_status_condition: Optional[pulumi.Input['DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgs']] = None,
                 simple_timer_condition: Optional[pulumi.Input['DeviceLinkageRuleTriggerSimpleTimerConditionArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of the alarm. The options are as follows:
               + **fault**: Report alarms.
               + **recovery**: Clear alarms.
        :param pulumi.Input['DeviceLinkageRuleTriggerDailyTimerConditionArgs'] daily_timer_condition: Specifies the condition triggered at specified time every day. It is
               required when `type` is **DAILY_TIMER**.
               The daily_timer_condition structure is documented below.
        :param pulumi.Input['DeviceLinkageRuleTriggerDeviceDataConditionArgs'] device_data_condition: Specifies the condition triggered upon the property of device. It is
               required when `type` is **DEVICE_DATA**.
               The device_data_condition structure is documented below.
        :param pulumi.Input['DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgs'] device_linkage_status_condition: Specifies the condition triggered by device status. It is
               required when `type` is **DEVICE_LINKAGE_STATUS**.
               The device_linkage_status_condition structure is documented below.
               
               <a name="IoTDA_device_data_condition"></a>
               The `device_data_condition` block supports:
        :param pulumi.Input['DeviceLinkageRuleTriggerSimpleTimerConditionArgs'] simple_timer_condition: Specifies the condition triggered by policy. It is required when `type`
               is **SIMPLE_TIMER**.
               The simple_timer_condition structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if daily_timer_condition is not None:
            pulumi.set(__self__, "daily_timer_condition", daily_timer_condition)
        if device_data_condition is not None:
            pulumi.set(__self__, "device_data_condition", device_data_condition)
        if device_linkage_status_condition is not None:
            pulumi.set(__self__, "device_linkage_status_condition", device_linkage_status_condition)
        if simple_timer_condition is not None:
            pulumi.set(__self__, "simple_timer_condition", simple_timer_condition)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="dailyTimerCondition")
    def daily_timer_condition(self) -> Optional[pulumi.Input['DeviceLinkageRuleTriggerDailyTimerConditionArgs']]:
        """
        Specifies the condition triggered at specified time every day. It is
        required when `type` is **DAILY_TIMER**.
        The daily_timer_condition structure is documented below.
        """
        return pulumi.get(self, "daily_timer_condition")

    @daily_timer_condition.setter
    def daily_timer_condition(self, value: Optional[pulumi.Input['DeviceLinkageRuleTriggerDailyTimerConditionArgs']]):
        pulumi.set(self, "daily_timer_condition", value)

    @_builtins.property
    @pulumi.getter(name="deviceDataCondition")
    def device_data_condition(self) -> Optional[pulumi.Input['DeviceLinkageRuleTriggerDeviceDataConditionArgs']]:
        """
        Specifies the condition triggered upon the property of device. It is
        required when `type` is **DEVICE_DATA**.
        The device_data_condition structure is documented below.
        """
        return pulumi.get(self, "device_data_condition")

    @device_data_condition.setter
    def device_data_condition(self, value: Optional[pulumi.Input['DeviceLinkageRuleTriggerDeviceDataConditionArgs']]):
        pulumi.set(self, "device_data_condition", value)

    @_builtins.property
    @pulumi.getter(name="deviceLinkageStatusCondition")
    def device_linkage_status_condition(self) -> Optional[pulumi.Input['DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgs']]:
        """
        Specifies the condition triggered by device status. It is
        required when `type` is **DEVICE_LINKAGE_STATUS**.
        The device_linkage_status_condition structure is documented below.

        <a name="IoTDA_device_data_condition"></a>
        The `device_data_condition` block supports:
        """
        return pulumi.get(self, "device_linkage_status_condition")

    @device_linkage_status_condition.setter
    def device_linkage_status_condition(self, value: Optional[pulumi.Input['DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgs']]):
        pulumi.set(self, "device_linkage_status_condition", value)

    @_builtins.property
    @pulumi.getter(name="simpleTimerCondition")
    def simple_timer_condition(self) -> Optional[pulumi.Input['DeviceLinkageRuleTriggerSimpleTimerConditionArgs']]:
        """
        Specifies the condition triggered by policy. It is required when `type`
        is **SIMPLE_TIMER**.
        The simple_timer_condition structure is documented below.
        """
        return pulumi.get(self, "simple_timer_condition")

    @simple_timer_condition.setter
    def simple_timer_condition(self, value: Optional[pulumi.Input['DeviceLinkageRuleTriggerSimpleTimerConditionArgs']]):
        pulumi.set(self, "simple_timer_condition", value)


if not MYPY:
    class DeviceLinkageRuleTriggerDailyTimerConditionArgsDict(TypedDict):
        start_time: pulumi.Input[_builtins.str]
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        days_of_week: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a list of days of week, separated by commas. 1 represents Sunday,
        2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
elif False:
    DeviceLinkageRuleTriggerDailyTimerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleTriggerDailyTimerConditionArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[_builtins.str],
                 days_of_week: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time, in the format: `HH:mm`.
               For example: `03:00`.
        :param pulumi.Input[_builtins.str] days_of_week: Specifies a list of days of week, separated by commas. 1 represents Sunday,
               2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        pulumi.set(__self__, "start_time", start_time)
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a list of days of week, separated by commas. 1 represents Sunday,
        2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        return pulumi.get(self, "days_of_week")

    @days_of_week.setter
    def days_of_week(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "days_of_week", value)


if not MYPY:
    class DeviceLinkageRuleTriggerDeviceDataConditionArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        Specifies the data comparison operator. The valid values are: **>**, **<**,
        **>=**, **<=**, **=**, **in** and **between**.
        """
        path: pulumi.Input[_builtins.str]
        """
        Specifies the path of the device property, in the format: **service_id/DataProperty**.
        """
        data_validatiy_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies data validity period, Unit is `seconds`. Defaults to `300`.
        For example, if Data Validity Period is set to 30 minutes, a device generates data at 19:00, and the platform receives
        the data at 20:00, the action is not triggered regardless of whether the conditions are met.

        <a name="IoTDA_simple_timer_condition"></a>
        The `simple_timer_condition` block supports:
        """
        device_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the device id which executes the command.
        """
        in_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the Rvalue of a data comparison expression. Only when the `operator` is
        **in**, this field is valid and required, with a maximum of `20` characters, represents matching within the specified
        values, e.g. **20,30,40**,
        """
        product_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the product ID. If this field is set and the `device_id` is empty, the
        device attribute will trigger the matching of all devices under this product.

        > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
        set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        """
        trigger_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the trigger strategy. The options are as follows:
        + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
        + **reverse**: Repetition suppression. For example, if an alarm is configured to be triggered when the battery level
        is lower than 20%, the alarm will be triggered once the battery initially drops below 20% but will not be triggered
        again each time the battery drops to a lower level.

        Defaults to `pulse`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Rvalue of a data comparison expression. When the `operator` is **between**,
        the Rvalue represents the minimum and maximum values, separated by commas, such as **20,30**,
        which means greater than or equal to `20` and less than `30`.
        """
elif False:
    DeviceLinkageRuleTriggerDeviceDataConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleTriggerDeviceDataConditionArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 data_validatiy_period: Optional[pulumi.Input[_builtins.int]] = None,
                 device_id: Optional[pulumi.Input[_builtins.str]] = None,
                 in_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 product_id: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: Specifies the data comparison operator. The valid values are: **>**, **<**,
               **>=**, **<=**, **=**, **in** and **between**.
        :param pulumi.Input[_builtins.str] path: Specifies the path of the device property, in the format: **service_id/DataProperty**.
        :param pulumi.Input[_builtins.int] data_validatiy_period: Specifies data validity period, Unit is `seconds`. Defaults to `300`.
               For example, if Data Validity Period is set to 30 minutes, a device generates data at 19:00, and the platform receives
               the data at 20:00, the action is not triggered regardless of whether the conditions are met.
               
               <a name="IoTDA_simple_timer_condition"></a>
               The `simple_timer_condition` block supports:
        :param pulumi.Input[_builtins.str] device_id: Specifies the device id which executes the command.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] in_values: Specifies the Rvalue of a data comparison expression. Only when the `operator` is
               **in**, this field is valid and required, with a maximum of `20` characters, represents matching within the specified
               values, e.g. **20,30,40**,
        :param pulumi.Input[_builtins.str] product_id: Specifies the product ID. If this field is set and the `device_id` is empty, the
               device attribute will trigger the matching of all devices under this product.
               
               > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
               set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        :param pulumi.Input[_builtins.str] trigger_strategy: Specifies the trigger strategy. The options are as follows:
               + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
               + **reverse**: Repetition suppression. For example, if an alarm is configured to be triggered when the battery level
               is lower than 20%, the alarm will be triggered once the battery initially drops below 20% but will not be triggered
               again each time the battery drops to a lower level.
               
               Defaults to `pulse`.
        :param pulumi.Input[_builtins.str] value: Specifies the Rvalue of a data comparison expression. When the `operator` is **between**,
               the Rvalue represents the minimum and maximum values, separated by commas, such as **20,30**,
               which means greater than or equal to `20` and less than `30`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "path", path)
        if data_validatiy_period is not None:
            pulumi.set(__self__, "data_validatiy_period", data_validatiy_period)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if product_id is not None:
            pulumi.set(__self__, "product_id", product_id)
        if trigger_strategy is not None:
            pulumi.set(__self__, "trigger_strategy", trigger_strategy)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the data comparison operator. The valid values are: **>**, **<**,
        **>=**, **<=**, **=**, **in** and **between**.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the path of the device property, in the format: **service_id/DataProperty**.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="dataValidatiyPeriod")
    def data_validatiy_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies data validity period, Unit is `seconds`. Defaults to `300`.
        For example, if Data Validity Period is set to 30 minutes, a device generates data at 19:00, and the platform receives
        the data at 20:00, the action is not triggered regardless of whether the conditions are met.

        <a name="IoTDA_simple_timer_condition"></a>
        The `simple_timer_condition` block supports:
        """
        return pulumi.get(self, "data_validatiy_period")

    @data_validatiy_period.setter
    def data_validatiy_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_validatiy_period", value)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the device id which executes the command.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the Rvalue of a data comparison expression. Only when the `operator` is
        **in**, this field is valid and required, with a maximum of `20` characters, represents matching within the specified
        values, e.g. **20,30,40**,
        """
        return pulumi.get(self, "in_values")

    @in_values.setter
    def in_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "in_values", value)

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the product ID. If this field is set and the `device_id` is empty, the
        device attribute will trigger the matching of all devices under this product.

        > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
        set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        """
        return pulumi.get(self, "product_id")

    @product_id.setter
    def product_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_id", value)

    @_builtins.property
    @pulumi.getter(name="triggerStrategy")
    def trigger_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the trigger strategy. The options are as follows:
        + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
        + **reverse**: Repetition suppression. For example, if an alarm is configured to be triggered when the battery level
        is lower than 20%, the alarm will be triggered once the battery initially drops below 20% but will not be triggered
        again each time the battery drops to a lower level.

        Defaults to `pulse`.
        """
        return pulumi.get(self, "trigger_strategy")

    @trigger_strategy.setter
    def trigger_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trigger_strategy", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Rvalue of a data comparison expression. When the `operator` is **between**,
        the Rvalue represents the minimum and maximum values, separated by commas, such as **20,30**,
        which means greater than or equal to `20` and less than `30`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgsDict(TypedDict):
        device_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the device id which executes the command.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the duration of device status. The valid value ranges from `0` to `60` minutes.

        <a name="IoTDA_actions"></a>
        The `actions` block supports:
        """
        product_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the product ID. If this field is set and the `device_id` is empty, the
        device attribute will trigger the matching of all devices under this product.

        > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
        set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        """
        status_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies device status list, separate multiple status with commas.
        e.g. **ONLINE**, **OFFLINE**.
        The valid device status values are as follows:
        + **ONLINE**: Device online.
        + **OFFLINE**: Device offline.
        """
elif False:
    DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgs:
    def __init__(__self__, *,
                 device_id: Optional[pulumi.Input[_builtins.str]] = None,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 product_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] device_id: Specifies the device id which executes the command.
        :param pulumi.Input[_builtins.int] duration: Specifies the duration of device status. The valid value ranges from `0` to `60` minutes.
               
               <a name="IoTDA_actions"></a>
               The `actions` block supports:
        :param pulumi.Input[_builtins.str] product_id: Specifies the product ID. If this field is set and the `device_id` is empty, the
               device attribute will trigger the matching of all devices under this product.
               
               > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
               set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] status_lists: Specifies device status list, separate multiple status with commas.
               e.g. **ONLINE**, **OFFLINE**.
               The valid device status values are as follows:
               + **ONLINE**: Device online.
               + **OFFLINE**: Device offline.
        """
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if product_id is not None:
            pulumi.set(__self__, "product_id", product_id)
        if status_lists is not None:
            pulumi.set(__self__, "status_lists", status_lists)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the device id which executes the command.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the duration of device status. The valid value ranges from `0` to `60` minutes.

        <a name="IoTDA_actions"></a>
        The `actions` block supports:
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the product ID. If this field is set and the `device_id` is empty, the
        device attribute will trigger the matching of all devices under this product.

        > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
        set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        """
        return pulumi.get(self, "product_id")

    @product_id.setter
    def product_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_id", value)

    @_builtins.property
    @pulumi.getter(name="statusLists")
    def status_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies device status list, separate multiple status with commas.
        e.g. **ONLINE**, **OFFLINE**.
        The valid device status values are as follows:
        + **ONLINE**: Device online.
        + **OFFLINE**: Device offline.
        """
        return pulumi.get(self, "status_lists")

    @status_lists.setter
    def status_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "status_lists", value)


if not MYPY:
    class DeviceLinkageRuleTriggerSimpleTimerConditionArgsDict(TypedDict):
        repeat_count: pulumi.Input[_builtins.int]
        """
        Specifies total number of repetition.

        <a name="IoTDA_daily_timer_condition"></a>
        The `daily_timer_condition` block supports:
        """
        repeat_interval: pulumi.Input[_builtins.int]
        """
        Specifies the interval of repetition, Unit is `minutes`.
        """
        start_time: pulumi.Input[_builtins.str]
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
elif False:
    DeviceLinkageRuleTriggerSimpleTimerConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceLinkageRuleTriggerSimpleTimerConditionArgs:
    def __init__(__self__, *,
                 repeat_count: pulumi.Input[_builtins.int],
                 repeat_interval: pulumi.Input[_builtins.int],
                 start_time: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] repeat_count: Specifies total number of repetition.
               
               <a name="IoTDA_daily_timer_condition"></a>
               The `daily_timer_condition` block supports:
        :param pulumi.Input[_builtins.int] repeat_interval: Specifies the interval of repetition, Unit is `minutes`.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time, in the format: `HH:mm`.
               For example: `03:00`.
        """
        pulumi.set(__self__, "repeat_count", repeat_count)
        pulumi.set(__self__, "repeat_interval", repeat_interval)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies total number of repetition.

        <a name="IoTDA_daily_timer_condition"></a>
        The `daily_timer_condition` block supports:
        """
        return pulumi.get(self, "repeat_count")

    @repeat_count.setter
    def repeat_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "repeat_count", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the interval of repetition, Unit is `minutes`.
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "repeat_interval", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DeviceMessageErrorInfoArgsDict(TypedDict):
        error_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The abnormal information error code.  
        The valid values are as follows:
        + **IOTDA.014016**: Indicates that the device is not online.
        + **IOTDA.014112**: Indicates that the device has not subscribed to the topic.
        """
        error_msg: NotRequired[pulumi.Input[_builtins.str]]
        """
        The abnormal information explanation. Includes instructions for devices not online and devices not
        subscribed to the topic.
        """
elif False:
    DeviceMessageErrorInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceMessageErrorInfoArgs:
    def __init__(__self__, *,
                 error_code: Optional[pulumi.Input[_builtins.str]] = None,
                 error_msg: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] error_code: The abnormal information error code.  
               The valid values are as follows:
               + **IOTDA.014016**: Indicates that the device is not online.
               + **IOTDA.014112**: Indicates that the device has not subscribed to the topic.
        :param pulumi.Input[_builtins.str] error_msg: The abnormal information explanation. Includes instructions for devices not online and devices not
               subscribed to the topic.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_msg is not None:
            pulumi.set(__self__, "error_msg", error_msg)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The abnormal information error code.  
        The valid values are as follows:
        + **IOTDA.014016**: Indicates that the device is not online.
        + **IOTDA.014112**: Indicates that the device has not subscribed to the topic.
        """
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_code", value)

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The abnormal information explanation. Includes instructions for devices not online and devices not
        subscribed to the topic.
        """
        return pulumi.get(self, "error_msg")

    @error_msg.setter
    def error_msg(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_msg", value)


if not MYPY:
    class DeviceMessagePropertiesArgsDict(TypedDict):
        correlation_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies relevant data in MQTT 5.0 request and response patterns.
        The length should not exceed `128`, and only combinations of letters, numbers, underscores (_), and hyphens (-) are
        allowed. Changing this parameter will create a new resource.
        """
        response_topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies response topic in MQTT 5.0 request and response patterns.
        The length should not exceed 128, and only letters, numbers, and the following characters are allowed: `_-?=$#+/`.
        Changing this parameter will create a new resource.
        """
        user_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeviceMessagePropertiesUserPropertyArgsDict']]]]
        """
        Specifies user-defined attributes. The maximum number that can be
        configured is `20`. Changing this parameter will create a new resource.
        The user_properties structure is documented below.

        <a name="iotda_user_properties"></a>
        The `user_properties` block supports:
        """
elif False:
    DeviceMessagePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceMessagePropertiesArgs:
    def __init__(__self__, *,
                 correlation_data: Optional[pulumi.Input[_builtins.str]] = None,
                 response_topic: Optional[pulumi.Input[_builtins.str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceMessagePropertiesUserPropertyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] correlation_data: Specifies relevant data in MQTT 5.0 request and response patterns.
               The length should not exceed `128`, and only combinations of letters, numbers, underscores (_), and hyphens (-) are
               allowed. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] response_topic: Specifies response topic in MQTT 5.0 request and response patterns.
               The length should not exceed 128, and only letters, numbers, and the following characters are allowed: `_-?=$#+/`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['DeviceMessagePropertiesUserPropertyArgs']]] user_properties: Specifies user-defined attributes. The maximum number that can be
               configured is `20`. Changing this parameter will create a new resource.
               The user_properties structure is documented below.
               
               <a name="iotda_user_properties"></a>
               The `user_properties` block supports:
        """
        if correlation_data is not None:
            pulumi.set(__self__, "correlation_data", correlation_data)
        if response_topic is not None:
            pulumi.set(__self__, "response_topic", response_topic)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @_builtins.property
    @pulumi.getter(name="correlationData")
    def correlation_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies relevant data in MQTT 5.0 request and response patterns.
        The length should not exceed `128`, and only combinations of letters, numbers, underscores (_), and hyphens (-) are
        allowed. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "correlation_data")

    @correlation_data.setter
    def correlation_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "correlation_data", value)

    @_builtins.property
    @pulumi.getter(name="responseTopic")
    def response_topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies response topic in MQTT 5.0 request and response patterns.
        The length should not exceed 128, and only letters, numbers, and the following characters are allowed: `_-?=$#+/`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "response_topic")

    @response_topic.setter
    def response_topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_topic", value)

    @_builtins.property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeviceMessagePropertiesUserPropertyArgs']]]]:
        """
        Specifies user-defined attributes. The maximum number that can be
        configured is `20`. Changing this parameter will create a new resource.
        The user_properties structure is documented below.

        <a name="iotda_user_properties"></a>
        The `user_properties` block supports:
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeviceMessagePropertiesUserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


if not MYPY:
    class DeviceMessagePropertiesUserPropertyArgsDict(TypedDict):
        prop_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies custom attribute key. The length should not exceed `128`, and only
        combinations of letters, numbers, underscores (_), and hyphens (-) are allowed.
        Changing this parameter will create a new resource.
        """
        prop_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies custom attribute value. The length should not exceed `128`, and
        only Chinese, letters, numbers, and the following characters are allowed: `_? '#().,&%@!-`.
        Changing this parameter will create a new resource.
        """
elif False:
    DeviceMessagePropertiesUserPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceMessagePropertiesUserPropertyArgs:
    def __init__(__self__, *,
                 prop_key: Optional[pulumi.Input[_builtins.str]] = None,
                 prop_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] prop_key: Specifies custom attribute key. The length should not exceed `128`, and only
               combinations of letters, numbers, underscores (_), and hyphens (-) are allowed.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] prop_value: Specifies custom attribute value. The length should not exceed `128`, and
               only Chinese, letters, numbers, and the following characters are allowed: `_? '#().,&%@!-`.
               Changing this parameter will create a new resource.
        """
        if prop_key is not None:
            pulumi.set(__self__, "prop_key", prop_key)
        if prop_value is not None:
            pulumi.set(__self__, "prop_value", prop_value)

    @_builtins.property
    @pulumi.getter(name="propKey")
    def prop_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies custom attribute key. The length should not exceed `128`, and only
        combinations of letters, numbers, underscores (_), and hyphens (-) are allowed.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "prop_key")

    @prop_key.setter
    def prop_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prop_key", value)

    @_builtins.property
    @pulumi.getter(name="propValue")
    def prop_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies custom attribute value. The length should not exceed `128`, and
        only Chinese, letters, numbers, and the following characters are allowed: `_? '#().,&%@!-`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "prop_value")

    @prop_value.setter
    def prop_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prop_value", value)


if not MYPY:
    class DevicePolicyStatementArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the operations allowed or denied by the policy. This value is in string list
        format, the format of a single operation is **service name:resource:operation**.
        The valid values are as follows:
        + **iotda:devices:publish**: The device uses MQTT protocol to publish messages.
        + **iotda:devices:subscribe**: The device subscribes to messages using the MQTT protocol.
        """
        effect: pulumi.Input[_builtins.str]
        """
        Specifies whether to allow or deny the operation. When there are authorization
        statements that both allow and deny, follow the principle of prioritizing denial.
        The valid values are as follows:
        + **ALLOW**
        + **DENY**
        """
        resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the resources that allow or deny operations to be performed on them.
        This value is in string list format, the format of a single resource is **resource type:resource name**.
        For example, the resources subscribed to by the device are **topic:/v1/${devices.deviceId}/test/hello**.
        When using this parameter,
        please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-iothub/iot_01_1114.html).
        """
elif False:
    DevicePolicyStatementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevicePolicyStatementArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 effect: pulumi.Input[_builtins.str],
                 resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] actions: Specifies the operations allowed or denied by the policy. This value is in string list
               format, the format of a single operation is **service name:resource:operation**.
               The valid values are as follows:
               + **iotda:devices:publish**: The device uses MQTT protocol to publish messages.
               + **iotda:devices:subscribe**: The device subscribes to messages using the MQTT protocol.
        :param pulumi.Input[_builtins.str] effect: Specifies whether to allow or deny the operation. When there are authorization
               statements that both allow and deny, follow the principle of prioritizing denial.
               The valid values are as follows:
               + **ALLOW**
               + **DENY**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: Specifies the resources that allow or deny operations to be performed on them.
               This value is in string list format, the format of a single resource is **resource type:resource name**.
               For example, the resources subscribed to by the device are **topic:/v1/${devices.deviceId}/test/hello**.
               When using this parameter,
               please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-iothub/iot_01_1114.html).
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the operations allowed or denied by the policy. This value is in string list
        format, the format of a single operation is **service name:resource:operation**.
        The valid values are as follows:
        + **iotda:devices:publish**: The device uses MQTT protocol to publish messages.
        + **iotda:devices:subscribe**: The device subscribes to messages using the MQTT protocol.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies whether to allow or deny the operation. When there are authorization
        statements that both allow and deny, follow the principle of prioritizing denial.
        The valid values are as follows:
        + **ALLOW**
        + **DENY**
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the resources that allow or deny operations to be performed on them.
        This value is in string list format, the format of a single resource is **resource type:resource name**.
        For example, the resources subscribed to by the device are **topic:/v1/${devices.deviceId}/test/hello**.
        When using this parameter,
        please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-iothub/iot_01_1114.html).
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class DeviceProxyEffectiveTimeRangeArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the device proxy expiration time, must be greater than `start_time`,
        using UTC time zone, the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the effective time of the device proxy, using UTC time zone,
        the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
elif False:
    DeviceProxyEffectiveTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceProxyEffectiveTimeRangeArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end_time: Specifies the device proxy expiration time, must be greater than `start_time`,
               using UTC time zone, the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        :param pulumi.Input[_builtins.str] start_time: Specifies the effective time of the device proxy, using UTC time zone,
               the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the device proxy expiration time, must be greater than `start_time`,
        using UTC time zone, the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the effective time of the device proxy, using UTC time zone,
        the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DeviceShadowArgsDict(TypedDict):
        desired: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]
        """
        Specifies the initial properties data of the device.
        The each key is a parameter name of a property in the product model.
        If you want to delete the entire `desired`, please enter an empty Map. e.g. **desired = {}**.
        """
        service_id: pulumi.Input[_builtins.str]
        """
        Specifies the service ID of the device.
        Which is defined in the product model associated with the device.
        """
elif False:
    DeviceShadowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceShadowArgs:
    def __init__(__self__, *,
                 desired: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]],
                 service_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] desired: Specifies the initial properties data of the device.
               The each key is a parameter name of a property in the product model.
               If you want to delete the entire `desired`, please enter an empty Map. e.g. **desired = {}**.
        :param pulumi.Input[_builtins.str] service_id: Specifies the service ID of the device.
               Which is defined in the product model associated with the device.
        """
        pulumi.set(__self__, "desired", desired)
        pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter
    def desired(self) -> pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]:
        """
        Specifies the initial properties data of the device.
        The each key is a parameter name of a property in the product model.
        If you want to delete the entire `desired`, please enter an empty Map. e.g. **desired = {}**.
        """
        return pulumi.get(self, "desired")

    @desired.setter
    def desired(self, value: pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "desired", value)

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the service ID of the device.
        Which is defined in the product model associated with the device.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_id", value)


if not MYPY:
    class ProductServiceArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the service ID. The ID contains a maximum of `64` characters. Only letters,
        Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are allowed: `?'#().,&%@!`.
        """
        commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandArgsDict']]]]
        """
        Specifies the list of commands for the service.
        The commands structure is documented below.

        <a name="IoTDA_service_properties"></a>
        The `properties` block supports:
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        option: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether the device service is mandatory.
        Currently, this field is not a functional field and is used only for identification.
        The valid values are as follows:
        + **Master**: The master service.
        + **Mandatory**: The mandatory service.
        + **Optional**:  The optional service.

        Defaults to **Optional**.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProductServicePropertyArgsDict']]]]
        """
        Specifies the list of properties for the service.
        The properties structure is documented below.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
elif False:
    ProductServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProductServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 commands: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 option: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServicePropertyArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the service ID. The ID contains a maximum of `64` characters. Only letters,
               Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are allowed: `?'#().,&%@!`.
        :param pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandArgs']]] commands: Specifies the list of commands for the service.
               The commands structure is documented below.
               
               <a name="IoTDA_service_properties"></a>
               The `properties` block supports:
        :param pulumi.Input[_builtins.str] description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param pulumi.Input[_builtins.str] option: Specifies whether the device service is mandatory.
               Currently, this field is not a functional field and is used only for identification.
               The valid values are as follows:
               + **Master**: The master service.
               + **Mandatory**: The mandatory service.
               + **Optional**:  The optional service.
               
               Defaults to **Optional**.
        :param pulumi.Input[Sequence[pulumi.Input['ProductServicePropertyArgs']]] properties: Specifies the list of properties for the service.
               The properties structure is documented below.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        pulumi.set(__self__, "id", id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if option is not None:
            pulumi.set(__self__, "option", option)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the service ID. The ID contains a maximum of `64` characters. Only letters,
        Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandArgs']]]]:
        """
        Specifies the list of commands for the service.
        The commands structure is documented below.

        <a name="IoTDA_service_properties"></a>
        The `properties` block supports:
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandArgs']]]]):
        pulumi.set(self, "commands", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def option(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether the device service is mandatory.
        Currently, this field is not a functional field and is used only for identification.
        The valid values are as follows:
        + **Master**: The master service.
        + **Mandatory**: The mandatory service.
        + **Optional**:  The optional service.

        Defaults to **Optional**.
        """
        return pulumi.get(self, "option")

    @option.setter
    def option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "option", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductServicePropertyArgs']]]]:
        """
        Specifies the list of properties for the service.
        The properties structure is documented below.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServicePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProductServiceCommandArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        paras: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandParaArgsDict']]]]
        """
        Specifies the list of parameters for the command.
        The paras structure is documented below.
        """
        responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandResponseArgsDict']]]]
        """
        Specifies the list of responses for the command.
        The responses structure is documented below.

        <a name="IoTDA_service_commands_properties"></a>
        The `paras` and `responses` block supports:
        """
elif False:
    ProductServiceCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProductServiceCommandArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 paras: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandParaArgs']]]] = None,
                 responses: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandResponseArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandParaArgs']]] paras: Specifies the list of parameters for the command.
               The paras structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandResponseArgs']]] responses: Specifies the list of responses for the command.
               The responses structure is documented below.
               
               <a name="IoTDA_service_commands_properties"></a>
               The `paras` and `responses` block supports:
        """
        pulumi.set(__self__, "name", name)
        if paras is not None:
            pulumi.set(__self__, "paras", paras)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def paras(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandParaArgs']]]]:
        """
        Specifies the list of parameters for the command.
        The paras structure is documented below.
        """
        return pulumi.get(self, "paras")

    @paras.setter
    def paras(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandParaArgs']]]]):
        pulumi.set(self, "paras", value)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandResponseArgs']]]]:
        """
        Specifies the list of responses for the command.
        The responses structure is documented below.

        <a name="IoTDA_service_commands_properties"></a>
        The `paras` and `responses` block supports:
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductServiceCommandResponseArgs']]]]):
        pulumi.set(self, "responses", value)


if not MYPY:
    class ProductServiceCommandParaArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        enum_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of enumerated values of the parameter.
        """
        max: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        max_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        min: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        step: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
elif False:
    ProductServiceCommandParaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProductServiceCommandParaArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enum_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max: Optional[pulumi.Input[_builtins.str]] = None,
                 max_length: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 step: Optional[pulumi.Input[_builtins.float]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        :param pulumi.Input[_builtins.str] default_value: Specifies the default value of the device property.
               This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
               If this parameter is set value, the value will be written to the desired data of the device shadow when
               the product is used to create a device. When the device goes online, the value will be delivered to the device.
               
               > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.
               
               <a name="IoTDA_service_commands"></a>
               The `commands` block supports:
        :param pulumi.Input[_builtins.str] description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enum_lists: Specifies the list of enumerated values of the parameter.
        :param pulumi.Input[_builtins.str] max: Specifies the max value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        :param pulumi.Input[_builtins.int] max_length: Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
               **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param pulumi.Input[_builtins.str] min: Specifies the min value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        :param pulumi.Input[_builtins.bool] required: Specifies the parameter is mandatory or not.
               The default value is **false**.
        :param pulumi.Input[_builtins.float] step: Specifies the step of the parameter when the `type` is **int** or **decimal**.
               Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit of the parameter when the `type` is **int** or **decimal**.
               The unit contains a maximum of 16 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum_lists is not None:
            pulumi.set(__self__, "enum_lists", enum_lists)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if step is not None:
            pulumi.set(__self__, "step", step)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="enumLists")
    def enum_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of enumerated values of the parameter.
        """
        return pulumi.get(self, "enum_lists")

    @enum_lists.setter
    def enum_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enum_lists", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_length", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "step", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ProductServiceCommandResponseArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        enum_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of enumerated values of the parameter.
        """
        max: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        max_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        min: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        step: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
elif False:
    ProductServiceCommandResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProductServiceCommandResponseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enum_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max: Optional[pulumi.Input[_builtins.str]] = None,
                 max_length: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 step: Optional[pulumi.Input[_builtins.float]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        :param pulumi.Input[_builtins.str] default_value: Specifies the default value of the device property.
               This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
               If this parameter is set value, the value will be written to the desired data of the device shadow when
               the product is used to create a device. When the device goes online, the value will be delivered to the device.
               
               > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.
               
               <a name="IoTDA_service_commands"></a>
               The `commands` block supports:
        :param pulumi.Input[_builtins.str] description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enum_lists: Specifies the list of enumerated values of the parameter.
        :param pulumi.Input[_builtins.str] max: Specifies the max value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        :param pulumi.Input[_builtins.int] max_length: Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
               **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param pulumi.Input[_builtins.str] min: Specifies the min value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        :param pulumi.Input[_builtins.bool] required: Specifies the parameter is mandatory or not.
               The default value is **false**.
        :param pulumi.Input[_builtins.float] step: Specifies the step of the parameter when the `type` is **int** or **decimal**.
               Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit of the parameter when the `type` is **int** or **decimal**.
               The unit contains a maximum of 16 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum_lists is not None:
            pulumi.set(__self__, "enum_lists", enum_lists)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if step is not None:
            pulumi.set(__self__, "step", step)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="enumLists")
    def enum_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of enumerated values of the parameter.
        """
        return pulumi.get(self, "enum_lists")

    @enum_lists.setter
    def enum_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enum_lists", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_length", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "step", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ProductServicePropertyArgsDict(TypedDict):
        method: pulumi.Input[_builtins.str]
        """
        Specifies the access mode of the device property.
        The value can be **RWE**, **RW**, **RE**, **WE**, **R** (the property value can be read),
        **W** (the property value can be written) or **E** (the property value can be subscribed to).
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        enum_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of enumerated values of the parameter.
        """
        max: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        max_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        min: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        step: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
elif False:
    ProductServicePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProductServicePropertyArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enum_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max: Optional[pulumi.Input[_builtins.str]] = None,
                 max_length: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None,
                 step: Optional[pulumi.Input[_builtins.float]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] method: Specifies the access mode of the device property.
               The value can be **RWE**, **RW**, **RE**, **WE**, **R** (the property value can be read),
               **W** (the property value can be written) or **E** (the property value can be subscribed to).
        :param pulumi.Input[_builtins.str] name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        :param pulumi.Input[_builtins.str] default_value: Specifies the default value of the device property.
               This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
               If this parameter is set value, the value will be written to the desired data of the device shadow when
               the product is used to create a device. When the device goes online, the value will be delivered to the device.
               
               > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.
               
               <a name="IoTDA_service_commands"></a>
               The `commands` block supports:
        :param pulumi.Input[_builtins.str] description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enum_lists: Specifies the list of enumerated values of the parameter.
        :param pulumi.Input[_builtins.str] max: Specifies the max value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        :param pulumi.Input[_builtins.int] max_length: Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
               **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param pulumi.Input[_builtins.str] min: Specifies the min value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        :param pulumi.Input[_builtins.bool] required: Specifies the parameter is mandatory or not.
               The default value is **false**.
        :param pulumi.Input[_builtins.float] step: Specifies the step of the parameter when the `type` is **int** or **decimal**.
               Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit of the parameter when the `type` is **int** or **decimal**.
               The unit contains a maximum of 16 characters.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum_lists is not None:
            pulumi.set(__self__, "enum_lists", enum_lists)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if step is not None:
            pulumi.set(__self__, "step", step)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the access mode of the device property.
        The value can be **RWE**, **RW**, **RE**, **WE**, **R** (the property value can be read),
        **W** (the property value can be written) or **E** (the property value can be subscribed to).
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="enumLists")
    def enum_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of enumerated values of the parameter.
        """
        return pulumi.get(self, "enum_lists")

    @enum_lists.setter
    def enum_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enum_lists", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_length", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "step", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class UpgradePackageFileLocationArgsDict(TypedDict):
        obs_location: NotRequired[pulumi.Input['UpgradePackageFileLocationObsLocationArgsDict']]
        """
        Specifies the location of the OBS object associated with the upgrade
        package. Changing this parameter will create a new resource.
        The obs_location structure is documented below.

        <a name="iotda_upgrade_package_obs_location"></a>
        The `obs_location` block supports:
        """
elif False:
    UpgradePackageFileLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpgradePackageFileLocationArgs:
    def __init__(__self__, *,
                 obs_location: Optional[pulumi.Input['UpgradePackageFileLocationObsLocationArgs']] = None):
        """
        :param pulumi.Input['UpgradePackageFileLocationObsLocationArgs'] obs_location: Specifies the location of the OBS object associated with the upgrade
               package. Changing this parameter will create a new resource.
               The obs_location structure is documented below.
               
               <a name="iotda_upgrade_package_obs_location"></a>
               The `obs_location` block supports:
        """
        if obs_location is not None:
            pulumi.set(__self__, "obs_location", obs_location)

    @_builtins.property
    @pulumi.getter(name="obsLocation")
    def obs_location(self) -> Optional[pulumi.Input['UpgradePackageFileLocationObsLocationArgs']]:
        """
        Specifies the location of the OBS object associated with the upgrade
        package. Changing this parameter will create a new resource.
        The obs_location structure is documented below.

        <a name="iotda_upgrade_package_obs_location"></a>
        The `obs_location` block supports:
        """
        return pulumi.get(self, "obs_location")

    @obs_location.setter
    def obs_location(self, value: Optional[pulumi.Input['UpgradePackageFileLocationObsLocationArgs']]):
        pulumi.set(self, "obs_location", value)


if not MYPY:
    class UpgradePackageFileLocationObsLocationArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the OBS bucket where the upgrade package is located.
        Changing this parameter will create a new resource.
        """
        object_key: pulumi.Input[_builtins.str]
        """
        Specifies the name of the OBS object where the upgrade package is located,
        including the folder path. The maximum size of OBS objects is **1GB**, and only supports files in **.bin**, **.dav**,
        **.tar**, **.gz**, **.zip**, **.gzip**, **.apk**, **.ta.gz**, **.tar.xz**, **.pack**, **.exe**, **.bat** and **.img**
        formats. The valid length is limited from `1` to `1024`.
        Changing this parameter will create a new resource.
        """
        region: pulumi.Input[_builtins.str]
        """
        Specifies the region where OBS is located.
        Changing this parameter will create a new resource.
        """
        sign: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the signature value of the upgrade package calculated by SHA256 algorithm.
        After added the upgrade package and created the upgrade task, when the IoT platform issues an upgrade notification to the
        device, it will send the signature to the device.
        The valid length is `64`, only letters `a(A)` to `f(F)` and digits are allowed.

        Changing this parameter will create a new resource.
        """
elif False:
    UpgradePackageFileLocationObsLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UpgradePackageFileLocationObsLocationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 object_key: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 sign: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Specifies the name of the OBS bucket where the upgrade package is located.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] object_key: Specifies the name of the OBS object where the upgrade package is located,
               including the folder path. The maximum size of OBS objects is **1GB**, and only supports files in **.bin**, **.dav**,
               **.tar**, **.gz**, **.zip**, **.gzip**, **.apk**, **.ta.gz**, **.tar.xz**, **.pack**, **.exe**, **.bat** and **.img**
               formats. The valid length is limited from `1` to `1024`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] region: Specifies the region where OBS is located.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] sign: Specifies the signature value of the upgrade package calculated by SHA256 algorithm.
               After added the upgrade package and created the upgrade task, when the IoT platform issues an upgrade notification to the
               device, it will send the signature to the device.
               The valid length is `64`, only letters `a(A)` to `f(F)` and digits are allowed.
               
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "object_key", object_key)
        pulumi.set(__self__, "region", region)
        if sign is not None:
            pulumi.set(__self__, "sign", sign)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the OBS bucket where the upgrade package is located.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the OBS object where the upgrade package is located,
        including the folder path. The maximum size of OBS objects is **1GB**, and only supports files in **.bin**, **.dav**,
        **.tar**, **.gz**, **.zip**, **.gzip**, **.apk**, **.ta.gz**, **.tar.xz**, **.pack**, **.exe**, **.bat** and **.img**
        formats. The valid length is limited from `1` to `1024`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "object_key")

    @object_key.setter
    def object_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the region where OBS is located.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def sign(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the signature value of the upgrade package calculated by SHA256 algorithm.
        After added the upgrade package and created the upgrade task, when the IoT platform issues an upgrade notification to the
        device, it will send the signature to the device.
        The valid length is `64`, only letters `a(A)` to `f(F)` and digits are allowed.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sign")

    @sign.setter
    def sign(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign", value)


