# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BatchtaskTargetsFilter',
    'BatchtaskTaskDetail',
    'BatchtaskTaskDetailError',
    'BatchtaskTaskProgress',
    'DataforwardingRuleTarget',
    'DataforwardingRuleTargetAmqpForwarding',
    'DataforwardingRuleTargetDisForwarding',
    'DataforwardingRuleTargetFgsForwarding',
    'DataforwardingRuleTargetHttpForwarding',
    'DataforwardingRuleTargetKafkaForwarding',
    'DataforwardingRuleTargetKafkaForwardingAddress',
    'DataforwardingRuleTargetObsForwarding',
    'DeviceLinkageRuleAction',
    'DeviceLinkageRuleActionDeviceAlarm',
    'DeviceLinkageRuleActionDeviceCommand',
    'DeviceLinkageRuleActionSmnForwarding',
    'DeviceLinkageRuleEffectivePeriod',
    'DeviceLinkageRuleTrigger',
    'DeviceLinkageRuleTriggerDailyTimerCondition',
    'DeviceLinkageRuleTriggerDeviceDataCondition',
    'DeviceLinkageRuleTriggerDeviceLinkageStatusCondition',
    'DeviceLinkageRuleTriggerSimpleTimerCondition',
    'DeviceMessageErrorInfo',
    'DeviceMessageProperties',
    'DeviceMessagePropertiesUserProperty',
    'DevicePolicyStatement',
    'DeviceProxyEffectiveTimeRange',
    'DeviceShadow',
    'ProductService',
    'ProductServiceCommand',
    'ProductServiceCommandPara',
    'ProductServiceCommandResponse',
    'ProductServiceProperty',
    'UpgradePackageFileLocation',
    'UpgradePackageFileLocationObsLocation',
    'GetAmqpsQueueResult',
    'GetBatchtasksBatchtaskResult',
    'GetBatchtasksBatchtaskTaskPolicyResult',
    'GetBatchtasksBatchtaskTaskProgressResult',
    'GetCustomAuthenticationsAuthorizerResult',
    'GetDataBacklogPoliciesPolicyResult',
    'GetDataFlowControlPoliciesPolicyResult',
    'GetDataforwardingRulesRuleResult',
    'GetDeviceBindingGroupsGroupResult',
    'GetDeviceCertificatesCertificateResult',
    'GetDeviceGroupsGroupResult',
    'GetDeviceLinkageRulesRuleResult',
    'GetDeviceLinkageRulesRuleActionResult',
    'GetDeviceLinkageRulesRuleActionDeviceAlarmResult',
    'GetDeviceLinkageRulesRuleActionDeviceCommandResult',
    'GetDeviceLinkageRulesRuleActionSmnForwardingResult',
    'GetDeviceLinkageRulesRuleEffectivePeriodResult',
    'GetDeviceLinkageRulesRuleTriggerResult',
    'GetDeviceLinkageRulesRuleTriggerDailyTimerConditionResult',
    'GetDeviceLinkageRulesRuleTriggerDeviceDataConditionResult',
    'GetDeviceLinkageRulesRuleTriggerDeviceLinkageStatusConditionResult',
    'GetDeviceLinkageRulesRuleTriggerSimpleTimerConditionResult',
    'GetDeviceMessagesMessageResult',
    'GetDeviceMessagesMessageErrorInfoResult',
    'GetDeviceMessagesMessagePropertyResult',
    'GetDeviceMessagesMessagePropertyUserPropertyResult',
    'GetDeviceProxiesProxyResult',
    'GetDeviceProxiesProxyEffectiveTimeRangeResult',
    'GetDevicesDeviceResult',
    'GetProductsProductResult',
    'GetSpacesSpaceResult',
    'GetUpgradePackagesPackageResult',
]

@pulumi.output_type
class BatchtaskTargetsFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchtaskTargetsFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchtaskTargetsFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchtaskTargetsFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] group_ids: Specifies the list of device group IDs for executing batch task. Batch task
               will filter out devices within the groups as targets.
        """
        pulumi.set(__self__, "group_ids", group_ids)

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of device group IDs for executing batch task. Batch task
        will filter out devices within the groups as targets.
        """
        return pulumi.get(self, "group_ids")


@pulumi.output_type
class BatchtaskTaskDetail(dict):
    def __init__(__self__, *,
                 errors: Optional[Sequence['outputs.BatchtaskTaskDetailError']] = None,
                 output: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None):
        """
        :param Sequence['BatchtaskTaskDetailErrorArgs'] errors: Subtask execution failure information. The value only exists when the subtask fails.
               The task_details structure is documented below.
        :param _builtins.str output: The output information of subtask execution. The value only exists when the subtask is successfully
               executed, including device ID, space ID, device secret, and device fingerprint.
        :param _builtins.str status: The execution status of subtask. The value can be **Success** or **Fail**.
        :param _builtins.str target: The goal of executing subtask. The value includes product ID and node ID.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.BatchtaskTaskDetailError']]:
        """
        Subtask execution failure information. The value only exists when the subtask fails.
        The task_details structure is documented below.
        """
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[_builtins.str]:
        """
        The output information of subtask execution. The value only exists when the subtask is successfully
        executed, including device ID, space ID, device secret, and device fingerprint.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The execution status of subtask. The value can be **Success** or **Fail**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        The goal of executing subtask. The value includes product ID and node ID.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BatchtaskTaskDetailError(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorMsg":
            suggest = "error_msg"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BatchtaskTaskDetailError. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BatchtaskTaskDetailError.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BatchtaskTaskDetailError.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: Optional[_builtins.str] = None,
                 error_msg: Optional[_builtins.str] = None):
        """
        :param _builtins.str error_code: Subtask execution failure error code.
        :param _builtins.str error_msg: Subtask execution failure error message.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_msg is not None:
            pulumi.set(__self__, "error_msg", error_msg)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[_builtins.str]:
        """
        Subtask execution failure error code.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> Optional[_builtins.str]:
        """
        Subtask execution failure error message.
        """
        return pulumi.get(self, "error_msg")


@pulumi.output_type
class BatchtaskTaskProgress(dict):
    def __init__(__self__, *,
                 fail: Optional[_builtins.int] = None,
                 success: Optional[_builtins.int] = None,
                 total: Optional[_builtins.int] = None):
        """
        :param _builtins.int fail: The number of subtasks that failed to execute.
        :param _builtins.int success: The number of successfully executed subtasks.
        :param _builtins.int total: The total number of subtasks.
        """
        if fail is not None:
            pulumi.set(__self__, "fail", fail)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if total is not None:
            pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def fail(self) -> Optional[_builtins.int]:
        """
        The number of subtasks that failed to execute.
        """
        return pulumi.get(self, "fail")

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[_builtins.int]:
        """
        The number of successfully executed subtasks.
        """
        return pulumi.get(self, "success")

    @_builtins.property
    @pulumi.getter
    def total(self) -> Optional[_builtins.int]:
        """
        The total number of subtasks.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class DataforwardingRuleTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amqpForwarding":
            suggest = "amqp_forwarding"
        elif key == "disForwarding":
            suggest = "dis_forwarding"
        elif key == "fgsForwarding":
            suggest = "fgs_forwarding"
        elif key == "httpForwarding":
            suggest = "http_forwarding"
        elif key == "kafkaForwarding":
            suggest = "kafka_forwarding"
        elif key == "obsForwarding":
            suggest = "obs_forwarding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataforwardingRuleTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataforwardingRuleTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataforwardingRuleTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 amqp_forwarding: Optional['outputs.DataforwardingRuleTargetAmqpForwarding'] = None,
                 dis_forwarding: Optional['outputs.DataforwardingRuleTargetDisForwarding'] = None,
                 fgs_forwarding: Optional['outputs.DataforwardingRuleTargetFgsForwarding'] = None,
                 http_forwarding: Optional['outputs.DataforwardingRuleTargetHttpForwarding'] = None,
                 id: Optional[_builtins.str] = None,
                 kafka_forwarding: Optional['outputs.DataforwardingRuleTargetKafkaForwarding'] = None,
                 obs_forwarding: Optional['outputs.DataforwardingRuleTargetObsForwarding'] = None):
        """
        :param _builtins.str type: Specifies the type of forwarding target. The options are as follows:
               + **HTTP_FORWARDING**: The platform can push specified device data to a Third-party application (HTTP push).
               You can set different addresses that different types of device data are pushed to.
               + **DIS_FORWARDING**: DIS provides efficient collection, transmission, and distribution of real-time data. It also
               provides an abundant selection of APIs to help you quickly create real-time data applications.
               + **OBS_FORWARDING**: OBS is a stable, secure, cloud storage service that is scalable, efficient and easy-to-use.
               It allows you to store any amount of unstructured data in any format, and provides REST APIs so you can access your
               data from anywhere.
               + **AMQP_FORWARDING**: AMQP provides a scalable, distributed message queue that supports high throughput with low
               latency. AMQP is ready from the get-go and is O&M free.
               + **DMS_KAFKA_FORWARDING**: Distributed Message Service (DMS) for Kafka features high throughput, concurrency, and
               scalability. It is suitable for real-time data transmission, stream data processing, system decoupling,
               and traffic balancing.
               + **FUNCTIONGRAPH_FORWARDING**: By forwarding data to FunctionGraph service, you only need to write your business
               function code and set the conditions for execution in FunctionGraph. There is no need to configure and manage
               servers or other infrastructure. Functions will run in an elastic, maintenance-free, and highly reliable manner.
               Currently, only standard and enterprise edition IoTDA instances are supported.
        :param 'DataforwardingRuleTargetAmqpForwardingArgs' amqp_forwarding: Specifies the detail of AMQP forwards. It is required when type
               is `AMQP_FORWARDING`. The amqp_forwarding structure is documented below.
        :param 'DataforwardingRuleTargetDisForwardingArgs' dis_forwarding: Specifies the detail of the DIS forwards. It is required when type
               is `DIS_FORWARDING`. The dis_forwarding structure is documented below.
        :param 'DataforwardingRuleTargetFgsForwardingArgs' fgs_forwarding: Specifies the detail of the FunctionGraph forwards. It is required when
               type is **FUNCTIONGRAPH_FORWARDING**. The fgs_forwarding structure is documented below.
               
               <a name="IoTDA_http_forwarding"></a>
               The `http_forwarding` block supports:
        :param 'DataforwardingRuleTargetHttpForwardingArgs' http_forwarding: Specifies the detail of the HTTP forwards. It is required when type
               is `HTTP_FORWARDING`. The http_forwarding structure is documented below.
        :param _builtins.str id: The resource ID in UUID format.
        :param 'DataforwardingRuleTargetKafkaForwardingArgs' kafka_forwarding: Specifies the detail of the KAFKA forwards. It is required when type
               is `DMS_KAFKA_FORWARDING`. The properties structure is documented below.
        :param 'DataforwardingRuleTargetObsForwardingArgs' obs_forwarding: Specifies the detail of the OBS forwards. It is required when type
               is `OBS_FORWARDING`. The obs_forwarding structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if amqp_forwarding is not None:
            pulumi.set(__self__, "amqp_forwarding", amqp_forwarding)
        if dis_forwarding is not None:
            pulumi.set(__self__, "dis_forwarding", dis_forwarding)
        if fgs_forwarding is not None:
            pulumi.set(__self__, "fgs_forwarding", fgs_forwarding)
        if http_forwarding is not None:
            pulumi.set(__self__, "http_forwarding", http_forwarding)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kafka_forwarding is not None:
            pulumi.set(__self__, "kafka_forwarding", kafka_forwarding)
        if obs_forwarding is not None:
            pulumi.set(__self__, "obs_forwarding", obs_forwarding)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of forwarding target. The options are as follows:
        + **HTTP_FORWARDING**: The platform can push specified device data to a Third-party application (HTTP push).
        You can set different addresses that different types of device data are pushed to.
        + **DIS_FORWARDING**: DIS provides efficient collection, transmission, and distribution of real-time data. It also
        provides an abundant selection of APIs to help you quickly create real-time data applications.
        + **OBS_FORWARDING**: OBS is a stable, secure, cloud storage service that is scalable, efficient and easy-to-use.
        It allows you to store any amount of unstructured data in any format, and provides REST APIs so you can access your
        data from anywhere.
        + **AMQP_FORWARDING**: AMQP provides a scalable, distributed message queue that supports high throughput with low
        latency. AMQP is ready from the get-go and is O&M free.
        + **DMS_KAFKA_FORWARDING**: Distributed Message Service (DMS) for Kafka features high throughput, concurrency, and
        scalability. It is suitable for real-time data transmission, stream data processing, system decoupling,
        and traffic balancing.
        + **FUNCTIONGRAPH_FORWARDING**: By forwarding data to FunctionGraph service, you only need to write your business
        function code and set the conditions for execution in FunctionGraph. There is no need to configure and manage
        servers or other infrastructure. Functions will run in an elastic, maintenance-free, and highly reliable manner.
        Currently, only standard and enterprise edition IoTDA instances are supported.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="amqpForwarding")
    def amqp_forwarding(self) -> Optional['outputs.DataforwardingRuleTargetAmqpForwarding']:
        """
        Specifies the detail of AMQP forwards. It is required when type
        is `AMQP_FORWARDING`. The amqp_forwarding structure is documented below.
        """
        return pulumi.get(self, "amqp_forwarding")

    @_builtins.property
    @pulumi.getter(name="disForwarding")
    def dis_forwarding(self) -> Optional['outputs.DataforwardingRuleTargetDisForwarding']:
        """
        Specifies the detail of the DIS forwards. It is required when type
        is `DIS_FORWARDING`. The dis_forwarding structure is documented below.
        """
        return pulumi.get(self, "dis_forwarding")

    @_builtins.property
    @pulumi.getter(name="fgsForwarding")
    def fgs_forwarding(self) -> Optional['outputs.DataforwardingRuleTargetFgsForwarding']:
        """
        Specifies the detail of the FunctionGraph forwards. It is required when
        type is **FUNCTIONGRAPH_FORWARDING**. The fgs_forwarding structure is documented below.

        <a name="IoTDA_http_forwarding"></a>
        The `http_forwarding` block supports:
        """
        return pulumi.get(self, "fgs_forwarding")

    @_builtins.property
    @pulumi.getter(name="httpForwarding")
    def http_forwarding(self) -> Optional['outputs.DataforwardingRuleTargetHttpForwarding']:
        """
        Specifies the detail of the HTTP forwards. It is required when type
        is `HTTP_FORWARDING`. The http_forwarding structure is documented below.
        """
        return pulumi.get(self, "http_forwarding")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The resource ID in UUID format.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="kafkaForwarding")
    def kafka_forwarding(self) -> Optional['outputs.DataforwardingRuleTargetKafkaForwarding']:
        """
        Specifies the detail of the KAFKA forwards. It is required when type
        is `DMS_KAFKA_FORWARDING`. The properties structure is documented below.
        """
        return pulumi.get(self, "kafka_forwarding")

    @_builtins.property
    @pulumi.getter(name="obsForwarding")
    def obs_forwarding(self) -> Optional['outputs.DataforwardingRuleTargetObsForwarding']:
        """
        Specifies the detail of the OBS forwards. It is required when type
        is `OBS_FORWARDING`. The obs_forwarding structure is documented below.
        """
        return pulumi.get(self, "obs_forwarding")


@pulumi.output_type
class DataforwardingRuleTargetAmqpForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueName":
            suggest = "queue_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataforwardingRuleTargetAmqpForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataforwardingRuleTargetAmqpForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataforwardingRuleTargetAmqpForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_name: _builtins.str):
        """
        :param _builtins.str queue_name: Specifies the AMQP Queue name.
               
               <a name="IoTDA_kafka_forwarding"></a>
               The `kafka_forwarding` block supports:
        """
        pulumi.set(__self__, "queue_name", queue_name)

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> _builtins.str:
        """
        Specifies the AMQP Queue name.

        <a name="IoTDA_kafka_forwarding"></a>
        The `kafka_forwarding` block supports:
        """
        return pulumi.get(self, "queue_name")


@pulumi.output_type
class DataforwardingRuleTargetDisForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamId":
            suggest = "stream_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataforwardingRuleTargetDisForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataforwardingRuleTargetDisForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataforwardingRuleTargetDisForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: _builtins.str,
                 stream_id: _builtins.str,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str region: Specifies the region to which the KAFKA belongs.
        :param _builtins.str stream_id: Specifies the DIS stream ID.
        :param _builtins.str project_id: Specifies the project ID to which the KAFKA belongs.
               If omitted, the default project in the region will be used.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "stream_id", stream_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region to which the KAFKA belongs.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> _builtins.str:
        """
        Specifies the DIS stream ID.
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class DataforwardingRuleTargetFgsForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "funcName":
            suggest = "func_name"
        elif key == "funcUrn":
            suggest = "func_urn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataforwardingRuleTargetFgsForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataforwardingRuleTargetFgsForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataforwardingRuleTargetFgsForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 func_name: _builtins.str,
                 func_urn: _builtins.str):
        """
        :param _builtins.str func_name: Specifies the function name.
               
               <a name="IoTDA_forwarding_addresses"></a>
               The `addresses` block supports:
        :param _builtins.str func_urn: Specifies the function URN.
        """
        pulumi.set(__self__, "func_name", func_name)
        pulumi.set(__self__, "func_urn", func_urn)

    @_builtins.property
    @pulumi.getter(name="funcName")
    def func_name(self) -> _builtins.str:
        """
        Specifies the function name.

        <a name="IoTDA_forwarding_addresses"></a>
        The `addresses` block supports:
        """
        return pulumi.get(self, "func_name")

    @_builtins.property
    @pulumi.getter(name="funcUrn")
    def func_urn(self) -> _builtins.str:
        """
        Specifies the function URN.
        """
        return pulumi.get(self, "func_urn")


@pulumi.output_type
class DataforwardingRuleTargetHttpForwarding(dict):
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        :param _builtins.str url: Specifies the Push URL. The request method must is post.
               
               <a name="IoTDA_dis_forwarding"></a>
               The `dis_forwarding` block supports:
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the Push URL. The request method must is post.

        <a name="IoTDA_dis_forwarding"></a>
        The `dis_forwarding` block supports:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DataforwardingRuleTargetKafkaForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataforwardingRuleTargetKafkaForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataforwardingRuleTargetKafkaForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataforwardingRuleTargetKafkaForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence['outputs.DataforwardingRuleTargetKafkaForwardingAddress'],
                 region: _builtins.str,
                 topic: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param Sequence['DataforwardingRuleTargetKafkaForwardingAddressArgs'] addresses: Specifies the list of the connected service addresses.
               The addresses structure is documented below.
        :param _builtins.str region: Specifies the region to which the KAFKA belongs.
        :param _builtins.str topic: Specifies the topic.
        :param _builtins.str password: Specifies the password.
               
               <a name="IoTDA_fgs_forwarding"></a>
               The `fgs_forwarding` block supports:
        :param _builtins.str project_id: Specifies the project ID to which the KAFKA belongs.
               If omitted, the default project in the region will be used.
        :param _builtins.str user_name: Specifies the SASL user name.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "topic", topic)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence['outputs.DataforwardingRuleTargetKafkaForwardingAddress']:
        """
        Specifies the list of the connected service addresses.
        The addresses structure is documented below.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region to which the KAFKA belongs.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        Specifies the topic.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Specifies the password.

        <a name="IoTDA_fgs_forwarding"></a>
        The `fgs_forwarding` block supports:
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Specifies the SASL user name.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class DataforwardingRuleTargetKafkaForwardingAddress(dict):
    def __init__(__self__, *,
                 port: _builtins.int,
                 domain: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None):
        """
        :param _builtins.int port: Specifies the port of the connected service address.
        :param _builtins.str domain: Specifies the domain of the connected service address.
               Exactly one of `ip` or `domain` must be provided.
        :param _builtins.str ip: Specifies the IP of the connected service address.
               Exactly one of `ip` or `domain` must be provided.
        """
        pulumi.set(__self__, "port", port)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Specifies the port of the connected service address.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        Specifies the domain of the connected service address.
        Exactly one of `ip` or `domain` must be provided.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Specifies the IP of the connected service address.
        Exactly one of `ip` or `domain` must be provided.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class DataforwardingRuleTargetObsForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDirectory":
            suggest = "custom_directory"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataforwardingRuleTargetObsForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataforwardingRuleTargetObsForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataforwardingRuleTargetObsForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 region: _builtins.str,
                 custom_directory: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: Specifies the OBS Bucket.
        :param _builtins.str region: Specifies the region to which the KAFKA belongs.
        :param _builtins.str custom_directory: Specifies the custom directory for storing channel files. The ID contains a
               maximum of `256` characters. Multi-level directories can be separated by (/), and cannot start or end with a slash (/),
               and cannot contain more than two adjacent slashes (/). Only letters, digits, hyphens (-), underscores (_), slash (/)
               and braces ({}) are allowed. Braces can be used only for the time template parameters. For example, if the custom
               directory is in the format of {YYYY}/{MM}/{DD}/{HH}, data is generated in the directory based on the current
               time(for example, 2022/06/14/10) when data is forwarded.
               
               <a name="IoTDA_amqp_forwarding"></a>
               The `amqp_forwarding` block supports:
        :param _builtins.str project_id: Specifies the project ID to which the KAFKA belongs.
               If omitted, the default project in the region will be used.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "region", region)
        if custom_directory is not None:
            pulumi.set(__self__, "custom_directory", custom_directory)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Specifies the OBS Bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region to which the KAFKA belongs.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="customDirectory")
    def custom_directory(self) -> Optional[_builtins.str]:
        """
        Specifies the custom directory for storing channel files. The ID contains a
        maximum of `256` characters. Multi-level directories can be separated by (/), and cannot start or end with a slash (/),
        and cannot contain more than two adjacent slashes (/). Only letters, digits, hyphens (-), underscores (_), slash (/)
        and braces ({}) are allowed. Braces can be used only for the time template parameters. For example, if the custom
        directory is in the format of {YYYY}/{MM}/{DD}/{HH}, data is generated in the directory based on the current
        time(for example, 2022/06/14/10) when data is forwarded.

        <a name="IoTDA_amqp_forwarding"></a>
        The `amqp_forwarding` block supports:
        """
        return pulumi.get(self, "custom_directory")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Specifies the project ID to which the KAFKA belongs.
        If omitted, the default project in the region will be used.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class DeviceLinkageRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceAlarm":
            suggest = "device_alarm"
        elif key == "deviceCommand":
            suggest = "device_command"
        elif key == "smnForwarding":
            suggest = "smn_forwarding"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 device_alarm: Optional['outputs.DeviceLinkageRuleActionDeviceAlarm'] = None,
                 device_command: Optional['outputs.DeviceLinkageRuleActionDeviceCommand'] = None,
                 smn_forwarding: Optional['outputs.DeviceLinkageRuleActionSmnForwarding'] = None):
        """
        :param _builtins.str type: Specifies the type of the alarm. The options are as follows:
               + **fault**: Report alarms.
               + **recovery**: Clear alarms.
        :param 'DeviceLinkageRuleActionDeviceAlarmArgs' device_alarm: Specifies the detail of device alarm. It is required when type
               is `DEVICE_ALARM`. The device_alarm structure is documented below.
               
               <a name="IoTDA_device_command"></a>
               The `device_command` block supports:
        :param 'DeviceLinkageRuleActionDeviceCommandArgs' device_command: Specifies the detail of device command. It is required when type
               is `DEVICE_CMD`. The device_command structure is documented below.
        :param 'DeviceLinkageRuleActionSmnForwardingArgs' smn_forwarding: Specifies the detail of SMN notifications. It is required when type
               is `SMN_FORWARDING`. The smn_forwarding structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if device_alarm is not None:
            pulumi.set(__self__, "device_alarm", device_alarm)
        if device_command is not None:
            pulumi.set(__self__, "device_command", device_command)
        if smn_forwarding is not None:
            pulumi.set(__self__, "smn_forwarding", smn_forwarding)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="deviceAlarm")
    def device_alarm(self) -> Optional['outputs.DeviceLinkageRuleActionDeviceAlarm']:
        """
        Specifies the detail of device alarm. It is required when type
        is `DEVICE_ALARM`. The device_alarm structure is documented below.

        <a name="IoTDA_device_command"></a>
        The `device_command` block supports:
        """
        return pulumi.get(self, "device_alarm")

    @_builtins.property
    @pulumi.getter(name="deviceCommand")
    def device_command(self) -> Optional['outputs.DeviceLinkageRuleActionDeviceCommand']:
        """
        Specifies the detail of device command. It is required when type
        is `DEVICE_CMD`. The device_command structure is documented below.
        """
        return pulumi.get(self, "device_command")

    @_builtins.property
    @pulumi.getter(name="smnForwarding")
    def smn_forwarding(self) -> Optional['outputs.DeviceLinkageRuleActionSmnForwarding']:
        """
        Specifies the detail of SMN notifications. It is required when type
        is `SMN_FORWARDING`. The smn_forwarding structure is documented below.
        """
        return pulumi.get(self, "smn_forwarding")


@pulumi.output_type
class DeviceLinkageRuleActionDeviceAlarm(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 severity: _builtins.str,
                 type: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 dimension: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name of the alarm.
        :param _builtins.str severity: Specifies the severity level of the alarm.
               The valid values are **warning**, **minor**, **major** and **critical**.
        :param _builtins.str type: Specifies the type of the alarm. The options are as follows:
               + **fault**: Report alarms.
               + **recovery**: Clear alarms.
        :param _builtins.str description: Specifies the description of the alarm.  
               The value can contain a maximum of `256` characters.
               
               <a name="IoTDA_effective_period"></a>
               The `effective_period` block supports:
        :param _builtins.str dimension: Specifies the dimension of the alarm. Combine the alarm name and alarm level to
               jointly identify an alarm.
               The valid values are as follows:
               + **device**: Device dimension
               + **app**: Resource space dimension.
               
               If not specified, default to user dimension.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dimension is not None:
            pulumi.set(__self__, "dimension", dimension)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the alarm.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        Specifies the severity level of the alarm.
        The valid values are **warning**, **minor**, **major** and **critical**.
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the alarm.  
        The value can contain a maximum of `256` characters.

        <a name="IoTDA_effective_period"></a>
        The `effective_period` block supports:
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> Optional[_builtins.str]:
        """
        Specifies the dimension of the alarm. Combine the alarm name and alarm level to
        jointly identify an alarm.
        The valid values are as follows:
        + **device**: Device dimension
        + **app**: Resource space dimension.

        If not specified, default to user dimension.
        """
        return pulumi.get(self, "dimension")


@pulumi.output_type
class DeviceLinkageRuleActionDeviceCommand(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandBody":
            suggest = "command_body"
        elif key == "commandName":
            suggest = "command_name"
        elif key == "deviceId":
            suggest = "device_id"
        elif key == "serviceId":
            suggest = "service_id"
        elif key == "bufferTimeout":
            suggest = "buffer_timeout"
        elif key == "responseTimeout":
            suggest = "response_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleActionDeviceCommand. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleActionDeviceCommand.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleActionDeviceCommand.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_body: _builtins.str,
                 command_name: _builtins.str,
                 device_id: _builtins.str,
                 service_id: _builtins.str,
                 buffer_timeout: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 response_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.str command_body: Specifies the command parameters, in json format.
               + Example of device command using LWM2M protocol: `{"value":"1"}`, there are key-value pairs, each key is the
               parameter name of the command in the product model.
               + Example of device command using MQTT protocol: `{"header": {"mode": "ACK","from": "/users/testUser","method":
               "SET_TEMPERATURE_READ_PERIOD","to":"/devices/{device_id }/services/{service_id}"},"body": {"value" : "1"}}`.
               - **mode**: Required, whether the device needs to reply to the confirmation message after receiving the command.
               The default is ACK mode. `ACK` indicates that the confirmation message needs to be replied,
               `NOACK` indicates that the confirmation message does not need to be replied.
               - **from**: Optional, the address of the command sender.
               When the App initiates a request, the format is /users/{userId},
               when the application server initiates a request, the format is /{serviceName},
               and when the IoT platform initiates a request, the format is /cloud/{serviceName}.
               - **to**: optional, the address of the command receiver, the format is /devices/{device_id}/services/{service_id}.
               - **method**: optional, the command name defined in the product model.
               - **body**: optional, the message body of the command, which contains key-value pairs, each key is the parameter
               name of the command in the product model. The specific format requires application and device conventions.
        :param _builtins.str command_name: Specifies the command name.
        :param _builtins.str device_id: Specifies the device id which executes the command.
        :param _builtins.str service_id: Specifies the service id to which the command belongs.
        :param _builtins.int buffer_timeout: Specifies the cache time of device commands, in seconds. Representing the effective
               time for the IoT platform to cache commands before issuing them to the device. After this time, the commands will no
               longer be issued. The default value is `172,800` seconds (`48` hours). If set to `0`, the command will be immediately
               issued to the device regardless of the command issuance mode set on the IoT platform.
        :param _builtins.str mode: Specifies the issuance mode of device commands, which is only valid when the value of
               `buffer_timeout` is greater than `0`.
               The valid values are as follows:
               + **ACTIVE**: Active mode, the IoT platform actively issues commands to devices.
               + **PASSIVE**: Passive mode, after the IoT platform creates device commands, it will directly cache the commands.
               Wait until the device goes online again or reports the execution result of the previous command before issuing the
               command.
               
               <a name="IoTDA_smn_forwarding"></a>
               The `smn_forwarding` block supports:
        :param _builtins.int response_timeout: Specifies the effective time of the command response, in seconds. Indicating that
               the device responds effectively within the `response_timeout` time after receiving the command. If no response is
               received after this time, the command response is considered to have timed out. The default value is `1,800` seconds.
        """
        pulumi.set(__self__, "command_body", command_body)
        pulumi.set(__self__, "command_name", command_name)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "service_id", service_id)
        if buffer_timeout is not None:
            pulumi.set(__self__, "buffer_timeout", buffer_timeout)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if response_timeout is not None:
            pulumi.set(__self__, "response_timeout", response_timeout)

    @_builtins.property
    @pulumi.getter(name="commandBody")
    def command_body(self) -> _builtins.str:
        """
        Specifies the command parameters, in json format.
        + Example of device command using LWM2M protocol: `{"value":"1"}`, there are key-value pairs, each key is the
        parameter name of the command in the product model.
        + Example of device command using MQTT protocol: `{"header": {"mode": "ACK","from": "/users/testUser","method":
        "SET_TEMPERATURE_READ_PERIOD","to":"/devices/{device_id }/services/{service_id}"},"body": {"value" : "1"}}`.
        - **mode**: Required, whether the device needs to reply to the confirmation message after receiving the command.
        The default is ACK mode. `ACK` indicates that the confirmation message needs to be replied,
        `NOACK` indicates that the confirmation message does not need to be replied.
        - **from**: Optional, the address of the command sender.
        When the App initiates a request, the format is /users/{userId},
        when the application server initiates a request, the format is /{serviceName},
        and when the IoT platform initiates a request, the format is /cloud/{serviceName}.
        - **to**: optional, the address of the command receiver, the format is /devices/{device_id}/services/{service_id}.
        - **method**: optional, the command name defined in the product model.
        - **body**: optional, the message body of the command, which contains key-value pairs, each key is the parameter
        name of the command in the product model. The specific format requires application and device conventions.
        """
        return pulumi.get(self, "command_body")

    @_builtins.property
    @pulumi.getter(name="commandName")
    def command_name(self) -> _builtins.str:
        """
        Specifies the command name.
        """
        return pulumi.get(self, "command_name")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        Specifies the device id which executes the command.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        Specifies the service id to which the command belongs.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter(name="bufferTimeout")
    def buffer_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the cache time of device commands, in seconds. Representing the effective
        time for the IoT platform to cache commands before issuing them to the device. After this time, the commands will no
        longer be issued. The default value is `172,800` seconds (`48` hours). If set to `0`, the command will be immediately
        issued to the device regardless of the command issuance mode set on the IoT platform.
        """
        return pulumi.get(self, "buffer_timeout")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Specifies the issuance mode of device commands, which is only valid when the value of
        `buffer_timeout` is greater than `0`.
        The valid values are as follows:
        + **ACTIVE**: Active mode, the IoT platform actively issues commands to devices.
        + **PASSIVE**: Passive mode, after the IoT platform creates device commands, it will directly cache the commands.
        Wait until the device goes online again or reports the execution result of the previous command before issuing the
        command.

        <a name="IoTDA_smn_forwarding"></a>
        The `smn_forwarding` block supports:
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="responseTimeout")
    def response_timeout(self) -> Optional[_builtins.int]:
        """
        Specifies the effective time of the command response, in seconds. Indicating that
        the device responds effectively within the `response_timeout` time after receiving the command. If no response is
        received after this time, the command response is considered to have timed out. The default value is `1,800` seconds.
        """
        return pulumi.get(self, "response_timeout")


@pulumi.output_type
class DeviceLinkageRuleActionSmnForwarding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageTitle":
            suggest = "message_title"
        elif key == "topicName":
            suggest = "topic_name"
        elif key == "topicUrn":
            suggest = "topic_urn"
        elif key == "messageContent":
            suggest = "message_content"
        elif key == "messageTemplateName":
            suggest = "message_template_name"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleActionSmnForwarding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleActionSmnForwarding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleActionSmnForwarding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_title: _builtins.str,
                 region: _builtins.str,
                 topic_name: _builtins.str,
                 topic_urn: _builtins.str,
                 message_content: Optional[_builtins.str] = None,
                 message_template_name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str message_title: Specifies the message title.
        :param _builtins.str region: Specifies the region to which the SMN belongs.
        :param _builtins.str topic_name: Specifies the topic name of the SMN.
        :param _builtins.str topic_urn: Specifies the topic URN of the SMN.
        :param _builtins.str message_content: Specifies the message content.
        :param _builtins.str message_template_name: Specifies the template name corresponding to the SMN service.
        :param _builtins.str project_id: Specifies the project ID to which the SMN belongs.
               If omitted, the default project in the region will be used.
               
               <a name="IoTDA_device_alarm"></a>
               The `device_alarm` block supports:
        """
        pulumi.set(__self__, "message_title", message_title)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "topic_name", topic_name)
        pulumi.set(__self__, "topic_urn", topic_urn)
        if message_content is not None:
            pulumi.set(__self__, "message_content", message_content)
        if message_template_name is not None:
            pulumi.set(__self__, "message_template_name", message_template_name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="messageTitle")
    def message_title(self) -> _builtins.str:
        """
        Specifies the message title.
        """
        return pulumi.get(self, "message_title")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region to which the SMN belongs.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        Specifies the topic name of the SMN.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the topic URN of the SMN.
        """
        return pulumi.get(self, "topic_urn")

    @_builtins.property
    @pulumi.getter(name="messageContent")
    def message_content(self) -> Optional[_builtins.str]:
        """
        Specifies the message content.
        """
        return pulumi.get(self, "message_content")

    @_builtins.property
    @pulumi.getter(name="messageTemplateName")
    def message_template_name(self) -> Optional[_builtins.str]:
        """
        Specifies the template name corresponding to the SMN service.
        """
        return pulumi.get(self, "message_template_name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Specifies the project ID to which the SMN belongs.
        If omitted, the default project in the region will be used.

        <a name="IoTDA_device_alarm"></a>
        The `device_alarm` block supports:
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class DeviceLinkageRuleEffectivePeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "daysOfWeek":
            suggest = "days_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleEffectivePeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleEffectivePeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleEffectivePeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: _builtins.str,
                 start_time: _builtins.str,
                 days_of_week: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_time: Specifies the end time, in the format: `HH:mm`.
               For example: `10:00`. If the end time is the same as the start time, the effective period is the whole day.
        :param _builtins.str start_time: Specifies the start time, in the format: `HH:mm`.
               For example: `03:00`.
        :param _builtins.str days_of_week: Specifies a list of days of week, separated by commas. 1 represents Sunday,
               2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Specifies the end time, in the format: `HH:mm`.
        For example: `10:00`. If the end time is the same as the start time, the effective period is the whole day.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[_builtins.str]:
        """
        Specifies a list of days of week, separated by commas. 1 represents Sunday,
        2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        return pulumi.get(self, "days_of_week")


@pulumi.output_type
class DeviceLinkageRuleTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dailyTimerCondition":
            suggest = "daily_timer_condition"
        elif key == "deviceDataCondition":
            suggest = "device_data_condition"
        elif key == "deviceLinkageStatusCondition":
            suggest = "device_linkage_status_condition"
        elif key == "simpleTimerCondition":
            suggest = "simple_timer_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 daily_timer_condition: Optional['outputs.DeviceLinkageRuleTriggerDailyTimerCondition'] = None,
                 device_data_condition: Optional['outputs.DeviceLinkageRuleTriggerDeviceDataCondition'] = None,
                 device_linkage_status_condition: Optional['outputs.DeviceLinkageRuleTriggerDeviceLinkageStatusCondition'] = None,
                 simple_timer_condition: Optional['outputs.DeviceLinkageRuleTriggerSimpleTimerCondition'] = None):
        """
        :param _builtins.str type: Specifies the type of the alarm. The options are as follows:
               + **fault**: Report alarms.
               + **recovery**: Clear alarms.
        :param 'DeviceLinkageRuleTriggerDailyTimerConditionArgs' daily_timer_condition: Specifies the condition triggered at specified time every day. It is
               required when `type` is **DAILY_TIMER**.
               The daily_timer_condition structure is documented below.
        :param 'DeviceLinkageRuleTriggerDeviceDataConditionArgs' device_data_condition: Specifies the condition triggered upon the property of device. It is
               required when `type` is **DEVICE_DATA**.
               The device_data_condition structure is documented below.
        :param 'DeviceLinkageRuleTriggerDeviceLinkageStatusConditionArgs' device_linkage_status_condition: Specifies the condition triggered by device status. It is
               required when `type` is **DEVICE_LINKAGE_STATUS**.
               The device_linkage_status_condition structure is documented below.
               
               <a name="IoTDA_device_data_condition"></a>
               The `device_data_condition` block supports:
        :param 'DeviceLinkageRuleTriggerSimpleTimerConditionArgs' simple_timer_condition: Specifies the condition triggered by policy. It is required when `type`
               is **SIMPLE_TIMER**.
               The simple_timer_condition structure is documented below.
        """
        pulumi.set(__self__, "type", type)
        if daily_timer_condition is not None:
            pulumi.set(__self__, "daily_timer_condition", daily_timer_condition)
        if device_data_condition is not None:
            pulumi.set(__self__, "device_data_condition", device_data_condition)
        if device_linkage_status_condition is not None:
            pulumi.set(__self__, "device_linkage_status_condition", device_linkage_status_condition)
        if simple_timer_condition is not None:
            pulumi.set(__self__, "simple_timer_condition", simple_timer_condition)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the alarm. The options are as follows:
        + **fault**: Report alarms.
        + **recovery**: Clear alarms.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dailyTimerCondition")
    def daily_timer_condition(self) -> Optional['outputs.DeviceLinkageRuleTriggerDailyTimerCondition']:
        """
        Specifies the condition triggered at specified time every day. It is
        required when `type` is **DAILY_TIMER**.
        The daily_timer_condition structure is documented below.
        """
        return pulumi.get(self, "daily_timer_condition")

    @_builtins.property
    @pulumi.getter(name="deviceDataCondition")
    def device_data_condition(self) -> Optional['outputs.DeviceLinkageRuleTriggerDeviceDataCondition']:
        """
        Specifies the condition triggered upon the property of device. It is
        required when `type` is **DEVICE_DATA**.
        The device_data_condition structure is documented below.
        """
        return pulumi.get(self, "device_data_condition")

    @_builtins.property
    @pulumi.getter(name="deviceLinkageStatusCondition")
    def device_linkage_status_condition(self) -> Optional['outputs.DeviceLinkageRuleTriggerDeviceLinkageStatusCondition']:
        """
        Specifies the condition triggered by device status. It is
        required when `type` is **DEVICE_LINKAGE_STATUS**.
        The device_linkage_status_condition structure is documented below.

        <a name="IoTDA_device_data_condition"></a>
        The `device_data_condition` block supports:
        """
        return pulumi.get(self, "device_linkage_status_condition")

    @_builtins.property
    @pulumi.getter(name="simpleTimerCondition")
    def simple_timer_condition(self) -> Optional['outputs.DeviceLinkageRuleTriggerSimpleTimerCondition']:
        """
        Specifies the condition triggered by policy. It is required when `type`
        is **SIMPLE_TIMER**.
        The simple_timer_condition structure is documented below.
        """
        return pulumi.get(self, "simple_timer_condition")


@pulumi.output_type
class DeviceLinkageRuleTriggerDailyTimerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "daysOfWeek":
            suggest = "days_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleTriggerDailyTimerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleTriggerDailyTimerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleTriggerDailyTimerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: _builtins.str,
                 days_of_week: Optional[_builtins.str] = None):
        """
        :param _builtins.str start_time: Specifies the start time, in the format: `HH:mm`.
               For example: `03:00`.
        :param _builtins.str days_of_week: Specifies a list of days of week, separated by commas. 1 represents Sunday,
               2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        pulumi.set(__self__, "start_time", start_time)
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[_builtins.str]:
        """
        Specifies a list of days of week, separated by commas. 1 represents Sunday,
        2 represents Monday, and so on. Defaults to `1,2,3,4,5,6,7` (every day).
        """
        return pulumi.get(self, "days_of_week")


@pulumi.output_type
class DeviceLinkageRuleTriggerDeviceDataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataValidatiyPeriod":
            suggest = "data_validatiy_period"
        elif key == "deviceId":
            suggest = "device_id"
        elif key == "inValues":
            suggest = "in_values"
        elif key == "productId":
            suggest = "product_id"
        elif key == "triggerStrategy":
            suggest = "trigger_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleTriggerDeviceDataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleTriggerDeviceDataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleTriggerDeviceDataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: _builtins.str,
                 path: _builtins.str,
                 data_validatiy_period: Optional[_builtins.int] = None,
                 device_id: Optional[_builtins.str] = None,
                 in_values: Optional[Sequence[_builtins.str]] = None,
                 product_id: Optional[_builtins.str] = None,
                 trigger_strategy: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str operator: Specifies the data comparison operator. The valid values are: **>**, **<**,
               **>=**, **<=**, **=**, **in** and **between**.
        :param _builtins.str path: Specifies the path of the device property, in the format: **service_id/DataProperty**.
        :param _builtins.int data_validatiy_period: Specifies data validity period, Unit is `seconds`. Defaults to `300`.
               For example, if Data Validity Period is set to 30 minutes, a device generates data at 19:00, and the platform receives
               the data at 20:00, the action is not triggered regardless of whether the conditions are met.
               
               <a name="IoTDA_simple_timer_condition"></a>
               The `simple_timer_condition` block supports:
        :param _builtins.str device_id: Specifies the device id which executes the command.
        :param Sequence[_builtins.str] in_values: Specifies the Rvalue of a data comparison expression. Only when the `operator` is
               **in**, this field is valid and required, with a maximum of `20` characters, represents matching within the specified
               values, e.g. **20,30,40**,
        :param _builtins.str product_id: Specifies the product ID. If this field is set and the `device_id` is empty, the
               device attribute will trigger the matching of all devices under this product.
               
               > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
               set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        :param _builtins.str trigger_strategy: Specifies the trigger strategy. The options are as follows:
               + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
               + **reverse**: Repetition suppression. For example, if an alarm is configured to be triggered when the battery level
               is lower than 20%, the alarm will be triggered once the battery initially drops below 20% but will not be triggered
               again each time the battery drops to a lower level.
               
               Defaults to `pulse`.
        :param _builtins.str value: Specifies the Rvalue of a data comparison expression. When the `operator` is **between**,
               the Rvalue represents the minimum and maximum values, separated by commas, such as **20,30**,
               which means greater than or equal to `20` and less than `30`.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "path", path)
        if data_validatiy_period is not None:
            pulumi.set(__self__, "data_validatiy_period", data_validatiy_period)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if in_values is not None:
            pulumi.set(__self__, "in_values", in_values)
        if product_id is not None:
            pulumi.set(__self__, "product_id", product_id)
        if trigger_strategy is not None:
            pulumi.set(__self__, "trigger_strategy", trigger_strategy)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Specifies the data comparison operator. The valid values are: **>**, **<**,
        **>=**, **<=**, **=**, **in** and **between**.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Specifies the path of the device property, in the format: **service_id/DataProperty**.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="dataValidatiyPeriod")
    def data_validatiy_period(self) -> Optional[_builtins.int]:
        """
        Specifies data validity period, Unit is `seconds`. Defaults to `300`.
        For example, if Data Validity Period is set to 30 minutes, a device generates data at 19:00, and the platform receives
        the data at 20:00, the action is not triggered regardless of whether the conditions are met.

        <a name="IoTDA_simple_timer_condition"></a>
        The `simple_timer_condition` block supports:
        """
        return pulumi.get(self, "data_validatiy_period")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[_builtins.str]:
        """
        Specifies the device id which executes the command.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the Rvalue of a data comparison expression. Only when the `operator` is
        **in**, this field is valid and required, with a maximum of `20` characters, represents matching within the specified
        values, e.g. **20,30,40**,
        """
        return pulumi.get(self, "in_values")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> Optional[_builtins.str]:
        """
        Specifies the product ID. If this field is set and the `device_id` is empty, the
        device attribute will trigger the matching of all devices under this product.

        > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
        set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="triggerStrategy")
    def trigger_strategy(self) -> Optional[_builtins.str]:
        """
        Specifies the trigger strategy. The options are as follows:
        + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
        + **reverse**: Repetition suppression. For example, if an alarm is configured to be triggered when the battery level
        is lower than 20%, the alarm will be triggered once the battery initially drops below 20% but will not be triggered
        again each time the battery drops to a lower level.

        Defaults to `pulse`.
        """
        return pulumi.get(self, "trigger_strategy")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the Rvalue of a data comparison expression. When the `operator` is **between**,
        the Rvalue represents the minimum and maximum values, separated by commas, such as **20,30**,
        which means greater than or equal to `20` and less than `30`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DeviceLinkageRuleTriggerDeviceLinkageStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceId":
            suggest = "device_id"
        elif key == "productId":
            suggest = "product_id"
        elif key == "statusLists":
            suggest = "status_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleTriggerDeviceLinkageStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleTriggerDeviceLinkageStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleTriggerDeviceLinkageStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_id: Optional[_builtins.str] = None,
                 duration: Optional[_builtins.int] = None,
                 product_id: Optional[_builtins.str] = None,
                 status_lists: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str device_id: Specifies the device id which executes the command.
        :param _builtins.int duration: Specifies the duration of device status. The valid value ranges from `0` to `60` minutes.
               
               <a name="IoTDA_actions"></a>
               The `actions` block supports:
        :param _builtins.str product_id: Specifies the product ID. If this field is set and the `device_id` is empty, the
               device attribute will trigger the matching of all devices under this product.
               
               > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
               set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        :param Sequence[_builtins.str] status_lists: Specifies device status list, separate multiple status with commas.
               e.g. **ONLINE**, **OFFLINE**.
               The valid device status values are as follows:
               + **ONLINE**: Device online.
               + **OFFLINE**: Device offline.
        """
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if product_id is not None:
            pulumi.set(__self__, "product_id", product_id)
        if status_lists is not None:
            pulumi.set(__self__, "status_lists", status_lists)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[_builtins.str]:
        """
        Specifies the device id which executes the command.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        Specifies the duration of device status. The valid value ranges from `0` to `60` minutes.

        <a name="IoTDA_actions"></a>
        The `actions` block supports:
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> Optional[_builtins.str]:
        """
        Specifies the product ID. If this field is set and the `device_id` is empty, the
        device attribute will trigger the matching of all devices under this product.

        > 1. `device_id` and `product_id` cannot be empty at the same time.<br/>2. If both the `device_id` and `product_id` are
        set, the `device_id` field will prevail, and `product_id` will not take effect at this time.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="statusLists")
    def status_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies device status list, separate multiple status with commas.
        e.g. **ONLINE**, **OFFLINE**.
        The valid device status values are as follows:
        + **ONLINE**: Device online.
        + **OFFLINE**: Device offline.
        """
        return pulumi.get(self, "status_lists")


@pulumi.output_type
class DeviceLinkageRuleTriggerSimpleTimerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repeatCount":
            suggest = "repeat_count"
        elif key == "repeatInterval":
            suggest = "repeat_interval"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceLinkageRuleTriggerSimpleTimerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceLinkageRuleTriggerSimpleTimerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceLinkageRuleTriggerSimpleTimerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repeat_count: _builtins.int,
                 repeat_interval: _builtins.int,
                 start_time: _builtins.str):
        """
        :param _builtins.int repeat_count: Specifies total number of repetition.
               
               <a name="IoTDA_daily_timer_condition"></a>
               The `daily_timer_condition` block supports:
        :param _builtins.int repeat_interval: Specifies the interval of repetition, Unit is `minutes`.
        :param _builtins.str start_time: Specifies the start time, in the format: `HH:mm`.
               For example: `03:00`.
        """
        pulumi.set(__self__, "repeat_count", repeat_count)
        pulumi.set(__self__, "repeat_interval", repeat_interval)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> _builtins.int:
        """
        Specifies total number of repetition.

        <a name="IoTDA_daily_timer_condition"></a>
        The `daily_timer_condition` block supports:
        """
        return pulumi.get(self, "repeat_count")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> _builtins.int:
        """
        Specifies the interval of repetition, Unit is `minutes`.
        """
        return pulumi.get(self, "repeat_interval")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Specifies the start time, in the format: `HH:mm`.
        For example: `03:00`.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class DeviceMessageErrorInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorMsg":
            suggest = "error_msg"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceMessageErrorInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceMessageErrorInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceMessageErrorInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: Optional[_builtins.str] = None,
                 error_msg: Optional[_builtins.str] = None):
        """
        :param _builtins.str error_code: The abnormal information error code.  
               The valid values are as follows:
               + **IOTDA.014016**: Indicates that the device is not online.
               + **IOTDA.014112**: Indicates that the device has not subscribed to the topic.
        :param _builtins.str error_msg: The abnormal information explanation. Includes instructions for devices not online and devices not
               subscribed to the topic.
        """
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if error_msg is not None:
            pulumi.set(__self__, "error_msg", error_msg)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[_builtins.str]:
        """
        The abnormal information error code.  
        The valid values are as follows:
        + **IOTDA.014016**: Indicates that the device is not online.
        + **IOTDA.014112**: Indicates that the device has not subscribed to the topic.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> Optional[_builtins.str]:
        """
        The abnormal information explanation. Includes instructions for devices not online and devices not
        subscribed to the topic.
        """
        return pulumi.get(self, "error_msg")


@pulumi.output_type
class DeviceMessageProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "correlationData":
            suggest = "correlation_data"
        elif key == "responseTopic":
            suggest = "response_topic"
        elif key == "userProperties":
            suggest = "user_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceMessageProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceMessageProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceMessageProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 correlation_data: Optional[_builtins.str] = None,
                 response_topic: Optional[_builtins.str] = None,
                 user_properties: Optional[Sequence['outputs.DeviceMessagePropertiesUserProperty']] = None):
        """
        :param _builtins.str correlation_data: Specifies relevant data in MQTT 5.0 request and response patterns.
               The length should not exceed `128`, and only combinations of letters, numbers, underscores (_), and hyphens (-) are
               allowed. Changing this parameter will create a new resource.
        :param _builtins.str response_topic: Specifies response topic in MQTT 5.0 request and response patterns.
               The length should not exceed 128, and only letters, numbers, and the following characters are allowed: `_-?=$#+/`.
               Changing this parameter will create a new resource.
        :param Sequence['DeviceMessagePropertiesUserPropertyArgs'] user_properties: Specifies user-defined attributes. The maximum number that can be
               configured is `20`. Changing this parameter will create a new resource.
               The user_properties structure is documented below.
               
               <a name="iotda_user_properties"></a>
               The `user_properties` block supports:
        """
        if correlation_data is not None:
            pulumi.set(__self__, "correlation_data", correlation_data)
        if response_topic is not None:
            pulumi.set(__self__, "response_topic", response_topic)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @_builtins.property
    @pulumi.getter(name="correlationData")
    def correlation_data(self) -> Optional[_builtins.str]:
        """
        Specifies relevant data in MQTT 5.0 request and response patterns.
        The length should not exceed `128`, and only combinations of letters, numbers, underscores (_), and hyphens (-) are
        allowed. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "correlation_data")

    @_builtins.property
    @pulumi.getter(name="responseTopic")
    def response_topic(self) -> Optional[_builtins.str]:
        """
        Specifies response topic in MQTT 5.0 request and response patterns.
        The length should not exceed 128, and only letters, numbers, and the following characters are allowed: `_-?=$#+/`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "response_topic")

    @_builtins.property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[Sequence['outputs.DeviceMessagePropertiesUserProperty']]:
        """
        Specifies user-defined attributes. The maximum number that can be
        configured is `20`. Changing this parameter will create a new resource.
        The user_properties structure is documented below.

        <a name="iotda_user_properties"></a>
        The `user_properties` block supports:
        """
        return pulumi.get(self, "user_properties")


@pulumi.output_type
class DeviceMessagePropertiesUserProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propKey":
            suggest = "prop_key"
        elif key == "propValue":
            suggest = "prop_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceMessagePropertiesUserProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceMessagePropertiesUserProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceMessagePropertiesUserProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prop_key: Optional[_builtins.str] = None,
                 prop_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str prop_key: Specifies custom attribute key. The length should not exceed `128`, and only
               combinations of letters, numbers, underscores (_), and hyphens (-) are allowed.
               Changing this parameter will create a new resource.
        :param _builtins.str prop_value: Specifies custom attribute value. The length should not exceed `128`, and
               only Chinese, letters, numbers, and the following characters are allowed: `_? '#().,&%@!-`.
               Changing this parameter will create a new resource.
        """
        if prop_key is not None:
            pulumi.set(__self__, "prop_key", prop_key)
        if prop_value is not None:
            pulumi.set(__self__, "prop_value", prop_value)

    @_builtins.property
    @pulumi.getter(name="propKey")
    def prop_key(self) -> Optional[_builtins.str]:
        """
        Specifies custom attribute key. The length should not exceed `128`, and only
        combinations of letters, numbers, underscores (_), and hyphens (-) are allowed.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "prop_key")

    @_builtins.property
    @pulumi.getter(name="propValue")
    def prop_value(self) -> Optional[_builtins.str]:
        """
        Specifies custom attribute value. The length should not exceed `128`, and
        only Chinese, letters, numbers, and the following characters are allowed: `_? '#().,&%@!-`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "prop_value")


@pulumi.output_type
class DevicePolicyStatement(dict):
    def __init__(__self__, *,
                 actions: Sequence[_builtins.str],
                 effect: _builtins.str,
                 resources: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] actions: Specifies the operations allowed or denied by the policy. This value is in string list
               format, the format of a single operation is **service name:resource:operation**.
               The valid values are as follows:
               + **iotda:devices:publish**: The device uses MQTT protocol to publish messages.
               + **iotda:devices:subscribe**: The device subscribes to messages using the MQTT protocol.
        :param _builtins.str effect: Specifies whether to allow or deny the operation. When there are authorization
               statements that both allow and deny, follow the principle of prioritizing denial.
               The valid values are as follows:
               + **ALLOW**
               + **DENY**
        :param Sequence[_builtins.str] resources: Specifies the resources that allow or deny operations to be performed on them.
               This value is in string list format, the format of a single resource is **resource type:resource name**.
               For example, the resources subscribed to by the device are **topic:/v1/${devices.deviceId}/test/hello**.
               When using this parameter,
               please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-iothub/iot_01_1114.html).
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence[_builtins.str]:
        """
        Specifies the operations allowed or denied by the policy. This value is in string list
        format, the format of a single operation is **service name:resource:operation**.
        The valid values are as follows:
        + **iotda:devices:publish**: The device uses MQTT protocol to publish messages.
        + **iotda:devices:subscribe**: The device subscribes to messages using the MQTT protocol.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Specifies whether to allow or deny the operation. When there are authorization
        statements that both allow and deny, follow the principle of prioritizing denial.
        The valid values are as follows:
        + **ALLOW**
        + **DENY**
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence[_builtins.str]:
        """
        Specifies the resources that allow or deny operations to be performed on them.
        This value is in string list format, the format of a single resource is **resource type:resource name**.
        For example, the resources subscribed to by the device are **topic:/v1/${devices.deviceId}/test/hello**.
        When using this parameter,
        please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-iothub/iot_01_1114.html).
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class DeviceProxyEffectiveTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceProxyEffectiveTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceProxyEffectiveTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceProxyEffectiveTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_time: Specifies the device proxy expiration time, must be greater than `start_time`,
               using UTC time zone, the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        :param _builtins.str start_time: Specifies the effective time of the device proxy, using UTC time zone,
               the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Specifies the device proxy expiration time, must be greater than `start_time`,
        using UTC time zone, the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Specifies the effective time of the device proxy, using UTC time zone,
        the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class DeviceShadow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeviceShadow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeviceShadow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeviceShadow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired: Mapping[str, _builtins.str],
                 service_id: _builtins.str):
        """
        :param Mapping[str, _builtins.str] desired: Specifies the initial properties data of the device.
               The each key is a parameter name of a property in the product model.
               If you want to delete the entire `desired`, please enter an empty Map. e.g. **desired = {}**.
        :param _builtins.str service_id: Specifies the service ID of the device.
               Which is defined in the product model associated with the device.
        """
        pulumi.set(__self__, "desired", desired)
        pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter
    def desired(self) -> Mapping[str, _builtins.str]:
        """
        Specifies the initial properties data of the device.
        The each key is a parameter name of a property in the product model.
        If you want to delete the entire `desired`, please enter an empty Map. e.g. **desired = {}**.
        """
        return pulumi.get(self, "desired")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        Specifies the service ID of the device.
        Which is defined in the product model associated with the device.
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class ProductService(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 commands: Optional[Sequence['outputs.ProductServiceCommand']] = None,
                 description: Optional[_builtins.str] = None,
                 option: Optional[_builtins.str] = None,
                 properties: Optional[Sequence['outputs.ProductServiceProperty']] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Specifies the service ID. The ID contains a maximum of `64` characters. Only letters,
               Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are allowed: `?'#().,&%@!`.
        :param Sequence['ProductServiceCommandArgs'] commands: Specifies the list of commands for the service.
               The commands structure is documented below.
               
               <a name="IoTDA_service_properties"></a>
               The `properties` block supports:
        :param _builtins.str description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param _builtins.str option: Specifies whether the device service is mandatory.
               Currently, this field is not a functional field and is used only for identification.
               The valid values are as follows:
               + **Master**: The master service.
               + **Mandatory**: The mandatory service.
               + **Optional**:  The optional service.
               
               Defaults to **Optional**.
        :param Sequence['ProductServicePropertyArgs'] properties: Specifies the list of properties for the service.
               The properties structure is documented below.
        :param _builtins.str type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        pulumi.set(__self__, "id", id)
        if commands is not None:
            pulumi.set(__self__, "commands", commands)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if option is not None:
            pulumi.set(__self__, "option", option)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Specifies the service ID. The ID contains a maximum of `64` characters. Only letters,
        Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Optional[Sequence['outputs.ProductServiceCommand']]:
        """
        Specifies the list of commands for the service.
        The commands structure is documented below.

        <a name="IoTDA_service_properties"></a>
        The `properties` block supports:
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def option(self) -> Optional[_builtins.str]:
        """
        Specifies whether the device service is mandatory.
        Currently, this field is not a functional field and is used only for identification.
        The valid values are as follows:
        + **Master**: The master service.
        + **Mandatory**: The mandatory service.
        + **Optional**:  The optional service.

        Defaults to **Optional**.
        """
        return pulumi.get(self, "option")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.ProductServiceProperty']]:
        """
        Specifies the list of properties for the service.
        The properties structure is documented below.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProductServiceCommand(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 paras: Optional[Sequence['outputs.ProductServiceCommandPara']] = None,
                 responses: Optional[Sequence['outputs.ProductServiceCommandResponse']] = None):
        """
        :param _builtins.str name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param Sequence['ProductServiceCommandParaArgs'] paras: Specifies the list of parameters for the command.
               The paras structure is documented below.
        :param Sequence['ProductServiceCommandResponseArgs'] responses: Specifies the list of responses for the command.
               The responses structure is documented below.
               
               <a name="IoTDA_service_commands_properties"></a>
               The `paras` and `responses` block supports:
        """
        pulumi.set(__self__, "name", name)
        if paras is not None:
            pulumi.set(__self__, "paras", paras)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def paras(self) -> Optional[Sequence['outputs.ProductServiceCommandPara']]:
        """
        Specifies the list of parameters for the command.
        The paras structure is documented below.
        """
        return pulumi.get(self, "paras")

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional[Sequence['outputs.ProductServiceCommandResponse']]:
        """
        Specifies the list of responses for the command.
        The responses structure is documented below.

        <a name="IoTDA_service_commands_properties"></a>
        The `paras` and `responses` block supports:
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class ProductServiceCommandPara(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "enumLists":
            suggest = "enum_lists"
        elif key == "maxLength":
            suggest = "max_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductServiceCommandPara. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductServiceCommandPara.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductServiceCommandPara.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enum_lists: Optional[Sequence[_builtins.str]] = None,
                 max: Optional[_builtins.str] = None,
                 max_length: Optional[_builtins.int] = None,
                 min: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 step: Optional[_builtins.float] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param _builtins.str type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        :param _builtins.str default_value: Specifies the default value of the device property.
               This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
               If this parameter is set value, the value will be written to the desired data of the device shadow when
               the product is used to create a device. When the device goes online, the value will be delivered to the device.
               
               > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.
               
               <a name="IoTDA_service_commands"></a>
               The `commands` block supports:
        :param _builtins.str description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param Sequence[_builtins.str] enum_lists: Specifies the list of enumerated values of the parameter.
        :param _builtins.str max: Specifies the max value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        :param _builtins.int max_length: Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
               **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param _builtins.str min: Specifies the min value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        :param _builtins.bool required: Specifies the parameter is mandatory or not.
               The default value is **false**.
        :param _builtins.float step: Specifies the step of the parameter when the `type` is **int** or **decimal**.
               Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param _builtins.str unit: Specifies the unit of the parameter when the `type` is **int** or **decimal**.
               The unit contains a maximum of 16 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum_lists is not None:
            pulumi.set(__self__, "enum_lists", enum_lists)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if step is not None:
            pulumi.set(__self__, "step", step)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enumLists")
    def enum_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of enumerated values of the parameter.
        """
        return pulumi.get(self, "enum_lists")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.str]:
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[_builtins.int]:
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.str]:
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[_builtins.float]:
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ProductServiceCommandResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "enumLists":
            suggest = "enum_lists"
        elif key == "maxLength":
            suggest = "max_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductServiceCommandResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductServiceCommandResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductServiceCommandResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enum_lists: Optional[Sequence[_builtins.str]] = None,
                 max: Optional[_builtins.str] = None,
                 max_length: Optional[_builtins.int] = None,
                 min: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 step: Optional[_builtins.float] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param _builtins.str type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        :param _builtins.str default_value: Specifies the default value of the device property.
               This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
               If this parameter is set value, the value will be written to the desired data of the device shadow when
               the product is used to create a device. When the device goes online, the value will be delivered to the device.
               
               > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.
               
               <a name="IoTDA_service_commands"></a>
               The `commands` block supports:
        :param _builtins.str description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param Sequence[_builtins.str] enum_lists: Specifies the list of enumerated values of the parameter.
        :param _builtins.str max: Specifies the max value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        :param _builtins.int max_length: Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
               **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param _builtins.str min: Specifies the min value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        :param _builtins.bool required: Specifies the parameter is mandatory or not.
               The default value is **false**.
        :param _builtins.float step: Specifies the step of the parameter when the `type` is **int** or **decimal**.
               Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param _builtins.str unit: Specifies the unit of the parameter when the `type` is **int** or **decimal**.
               The unit contains a maximum of 16 characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum_lists is not None:
            pulumi.set(__self__, "enum_lists", enum_lists)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if step is not None:
            pulumi.set(__self__, "step", step)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enumLists")
    def enum_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of enumerated values of the parameter.
        """
        return pulumi.get(self, "enum_lists")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.str]:
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[_builtins.int]:
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.str]:
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[_builtins.float]:
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ProductServiceProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"
        elif key == "enumLists":
            suggest = "enum_lists"
        elif key == "maxLength":
            suggest = "max_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProductServiceProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProductServiceProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProductServiceProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enum_lists: Optional[Sequence[_builtins.str]] = None,
                 max: Optional[_builtins.str] = None,
                 max_length: Optional[_builtins.int] = None,
                 min: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None,
                 step: Optional[_builtins.float] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str method: Specifies the access mode of the device property.
               The value can be **RWE**, **RW**, **RE**, **WE**, **R** (the property value can be read),
               **W** (the property value can be written) or **E** (the property value can be subscribed to).
        :param _builtins.str name: Specifies the name of the parameter. The name contains a maximum of `64` characters.
               Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
               allowed: `?'#().,&%@!`.
        :param _builtins.str type: Specifies the type of the parameter.
               The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        :param _builtins.str default_value: Specifies the default value of the device property.
               This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
               If this parameter is set value, the value will be written to the desired data of the device shadow when
               the product is used to create a device. When the device goes online, the value will be delivered to the device.
               
               > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.
               
               <a name="IoTDA_service_commands"></a>
               The `commands` block supports:
        :param _builtins.str description: Specifies the description of the parameter. The description contains a maximum of
               `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
               characters are allowed: `?'#().,&%@!`.
        :param Sequence[_builtins.str] enum_lists: Specifies the list of enumerated values of the parameter.
        :param _builtins.str max: Specifies the max value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        :param _builtins.int max_length: Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
               **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param _builtins.str min: Specifies the min value of the parameter when the `type` is **int** or **decimal**.
               Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        :param _builtins.bool required: Specifies the parameter is mandatory or not.
               The default value is **false**.
        :param _builtins.float step: Specifies the step of the parameter when the `type` is **int** or **decimal**.
               Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        :param _builtins.str unit: Specifies the unit of the parameter when the `type` is **int** or **decimal**.
               The unit contains a maximum of 16 characters.
        """
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum_lists is not None:
            pulumi.set(__self__, "enum_lists", enum_lists)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if step is not None:
            pulumi.set(__self__, "step", step)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        Specifies the access mode of the device property.
        The value can be **RWE**, **RW**, **RE**, **WE**, **R** (the property value can be read),
        **W** (the property value can be written) or **E** (the property value can be subscribed to).
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the parameter. The name contains a maximum of `64` characters.
        Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special characters are
        allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the parameter.
        The valid values are **int**, **decimal**, **string**, **DateTime**, **jsonObject** and **string list**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        """
        Specifies the default value of the device property.
        This parameter allowed value is a JSON string. e.g. **{\\"foo\\":\\"bar\\"}**
        If this parameter is set value, the value will be written to the desired data of the device shadow when
        the product is used to create a device. When the device goes online, the value will be delivered to the device.

        > If you want to set this parameter, the `method` must set **RWE**, **RW**, **WE** or **W**.

        <a name="IoTDA_service_commands"></a>
        The `commands` block supports:
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the parameter. The description contains a maximum of
        `128` characters. Only letters, Chinese characters, digits, hyphens (-), underscores (_) and the following special
        characters are allowed: `?'#().,&%@!`.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enumLists")
    def enum_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of enumerated values of the parameter.
        """
        return pulumi.get(self, "enum_lists")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.str]:
        """
        Specifies the max value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"65535"**.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[_builtins.int]:
        """
        Specifies the max length of the parameter when the `type` is **string**, **DateTime**,
        **jsonObject** or **string list**. Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.str]:
        """
        Specifies the min value of the parameter when the `type` is **int** or **decimal**.
        Value range: -2147483647 ~ 2147483647. Defaults to **"0"**.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Specifies the parameter is mandatory or not.
        The default value is **false**.
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def step(self) -> Optional[_builtins.float]:
        """
        Specifies the step of the parameter when the `type` is **int** or **decimal**.
        Value range: `0` ~ `2,147,483,647`. Defaults to `0`.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit of the parameter when the `type` is **int** or **decimal**.
        The unit contains a maximum of 16 characters.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class UpgradePackageFileLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "obsLocation":
            suggest = "obs_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpgradePackageFileLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpgradePackageFileLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpgradePackageFileLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 obs_location: Optional['outputs.UpgradePackageFileLocationObsLocation'] = None):
        """
        :param 'UpgradePackageFileLocationObsLocationArgs' obs_location: Specifies the location of the OBS object associated with the upgrade
               package. Changing this parameter will create a new resource.
               The obs_location structure is documented below.
               
               <a name="iotda_upgrade_package_obs_location"></a>
               The `obs_location` block supports:
        """
        if obs_location is not None:
            pulumi.set(__self__, "obs_location", obs_location)

    @_builtins.property
    @pulumi.getter(name="obsLocation")
    def obs_location(self) -> Optional['outputs.UpgradePackageFileLocationObsLocation']:
        """
        Specifies the location of the OBS object associated with the upgrade
        package. Changing this parameter will create a new resource.
        The obs_location structure is documented below.

        <a name="iotda_upgrade_package_obs_location"></a>
        The `obs_location` block supports:
        """
        return pulumi.get(self, "obs_location")


@pulumi.output_type
class UpgradePackageFileLocationObsLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "objectKey":
            suggest = "object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UpgradePackageFileLocationObsLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UpgradePackageFileLocationObsLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UpgradePackageFileLocationObsLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 object_key: _builtins.str,
                 region: _builtins.str,
                 sign: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: Specifies the name of the OBS bucket where the upgrade package is located.
               Changing this parameter will create a new resource.
        :param _builtins.str object_key: Specifies the name of the OBS object where the upgrade package is located,
               including the folder path. The maximum size of OBS objects is **1GB**, and only supports files in **.bin**, **.dav**,
               **.tar**, **.gz**, **.zip**, **.gzip**, **.apk**, **.ta.gz**, **.tar.xz**, **.pack**, **.exe**, **.bat** and **.img**
               formats. The valid length is limited from `1` to `1024`.
               Changing this parameter will create a new resource.
        :param _builtins.str region: Specifies the region where OBS is located.
               Changing this parameter will create a new resource.
        :param _builtins.str sign: Specifies the signature value of the upgrade package calculated by SHA256 algorithm.
               After added the upgrade package and created the upgrade task, when the IoT platform issues an upgrade notification to the
               device, it will send the signature to the device.
               The valid length is `64`, only letters `a(A)` to `f(F)` and digits are allowed.
               
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "object_key", object_key)
        pulumi.set(__self__, "region", region)
        if sign is not None:
            pulumi.set(__self__, "sign", sign)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Specifies the name of the OBS bucket where the upgrade package is located.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="objectKey")
    def object_key(self) -> _builtins.str:
        """
        Specifies the name of the OBS object where the upgrade package is located,
        including the folder path. The maximum size of OBS objects is **1GB**, and only supports files in **.bin**, **.dav**,
        **.tar**, **.gz**, **.zip**, **.gzip**, **.apk**, **.ta.gz**, **.tar.xz**, **.pack**, **.exe**, **.bat** and **.img**
        formats. The valid length is limited from `1` to `1024`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "object_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region where OBS is located.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def sign(self) -> Optional[_builtins.str]:
        """
        Specifies the signature value of the upgrade package calculated by SHA256 algorithm.
        After added the upgrade package and created the upgrade task, when the IoT platform issues an upgrade notification to the
        device, it will send the signature to the device.
        The valid length is `64`, only letters `a(A)` to `f(F)` and digits are allowed.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sign")


@pulumi.output_type
class GetAmqpsQueueResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the AMQP queue.
               The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        :param _builtins.str id: The ID of the AMQP queue.
        :param _builtins.str name: Specifies the name of the AMQP queue.
        :param _builtins.str updated_at: The latest update time of the AMQP queue.
               The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the AMQP queue.
        The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the AMQP queue.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the AMQP queue.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest update time of the AMQP queue.
        The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetBatchtasksBatchtaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 status: _builtins.str,
                 status_desc: _builtins.str,
                 targets: Sequence[_builtins.str],
                 targets_filter: Mapping[str, _builtins.str],
                 task_policies: Sequence['outputs.GetBatchtasksBatchtaskTaskPolicyResult'],
                 task_progresses: Sequence['outputs.GetBatchtasksBatchtaskTaskProgressResult'],
                 type: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the batch task. The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        :param _builtins.str id: The batch task ID.
        :param _builtins.str name: The batch task name.
        :param _builtins.str status: Specifies the status of the batch task.
               The valid values are as follows:
               + **Initializing**
               + **Waitting**
               + **Processing**
               + **Success**
               + **Fail**
               + **PartialSuccess**
               + **Stopped**
               + **Stopping**
        :param _builtins.str status_desc: The batch task status description, including main task failure error information.
        :param Sequence[_builtins.str] targets: The target device ID array for executing the batch task.
        :param Mapping[str, _builtins.str] targets_filter: The batch task target filtering parameters. Json format, which contains key value pairs and (K, V)
               format to identify the parameters required for filtering targets. Currently, the supported K format includes
               group_ids, and the task will select devices that meet the conditions of the group as targets.
        :param Sequence['GetBatchtasksBatchtaskTaskPolicyArgs'] task_policies: The task execution strategy.
               The task_policy structure is documented below.
        :param Sequence['GetBatchtasksBatchtaskTaskProgressArgs'] task_progresses: The subtask execution statistics results.
               The task_progress structure is documented below.
        :param _builtins.str type: Specifies the type of the batch task.
               The valid values are as follows:
               + **createDevices**: Batch create devices task.
               + **updateDevices**: Batch update devices task.
               + **deleteDevices**: Batch deletion of devices task.
               + **freezeDevices**: Batch freeze devices task.
               + **unfreezeDevices**: Batch unfreeze devices task.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_desc", status_desc)
        pulumi.set(__self__, "targets", targets)
        pulumi.set(__self__, "targets_filter", targets_filter)
        pulumi.set(__self__, "task_policies", task_policies)
        pulumi.set(__self__, "task_progresses", task_progresses)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the batch task. The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The batch task ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The batch task name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the batch task.
        The valid values are as follows:
        + **Initializing**
        + **Waitting**
        + **Processing**
        + **Success**
        + **Fail**
        + **PartialSuccess**
        + **Stopped**
        + **Stopping**
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusDesc")
    def status_desc(self) -> _builtins.str:
        """
        The batch task status description, including main task failure error information.
        """
        return pulumi.get(self, "status_desc")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Sequence[_builtins.str]:
        """
        The target device ID array for executing the batch task.
        """
        return pulumi.get(self, "targets")

    @_builtins.property
    @pulumi.getter(name="targetsFilter")
    def targets_filter(self) -> Mapping[str, _builtins.str]:
        """
        The batch task target filtering parameters. Json format, which contains key value pairs and (K, V)
        format to identify the parameters required for filtering targets. Currently, the supported K format includes
        group_ids, and the task will select devices that meet the conditions of the group as targets.
        """
        return pulumi.get(self, "targets_filter")

    @_builtins.property
    @pulumi.getter(name="taskPolicies")
    def task_policies(self) -> Sequence['outputs.GetBatchtasksBatchtaskTaskPolicyResult']:
        """
        The task execution strategy.
        The task_policy structure is documented below.
        """
        return pulumi.get(self, "task_policies")

    @_builtins.property
    @pulumi.getter(name="taskProgresses")
    def task_progresses(self) -> Sequence['outputs.GetBatchtasksBatchtaskTaskProgressResult']:
        """
        The subtask execution statistics results.
        The task_progress structure is documented below.
        """
        return pulumi.get(self, "task_progresses")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the batch task.
        The valid values are as follows:
        + **createDevices**: Batch create devices task.
        + **updateDevices**: Batch update devices task.
        + **deleteDevices**: Batch deletion of devices task.
        + **freezeDevices**: Batch freeze devices task.
        + **unfreezeDevices**: Batch unfreeze devices task.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBatchtasksBatchtaskTaskPolicyResult(dict):
    def __init__(__self__, *,
                 retry_count: _builtins.int,
                 retry_interval: _builtins.int,
                 schedule_time: _builtins.str):
        """
        :param _builtins.int retry_count: The automatic retry times for subtasks of batch tasks.
               The valid value is range form `1` to `5`.
        :param _builtins.int retry_interval: The time interval for automatic retry after a subtask of a batch task fails. Unit in minutes,
               the valid value is range form `0` to `1,440`, the `0` means no retry.
        :param _builtins.str schedule_time: The batch task specifies execution time.
               The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
               The valid value is within `7` days. If it is empty, it means task will be executed immediately.
        """
        pulumi.set(__self__, "retry_count", retry_count)
        pulumi.set(__self__, "retry_interval", retry_interval)
        pulumi.set(__self__, "schedule_time", schedule_time)

    @_builtins.property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> _builtins.int:
        """
        The automatic retry times for subtasks of batch tasks.
        The valid value is range form `1` to `5`.
        """
        return pulumi.get(self, "retry_count")

    @_builtins.property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> _builtins.int:
        """
        The time interval for automatic retry after a subtask of a batch task fails. Unit in minutes,
        the valid value is range form `0` to `1,440`, the `0` means no retry.
        """
        return pulumi.get(self, "retry_interval")

    @_builtins.property
    @pulumi.getter(name="scheduleTime")
    def schedule_time(self) -> _builtins.str:
        """
        The batch task specifies execution time.
        The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        The valid value is within `7` days. If it is empty, it means task will be executed immediately.
        """
        return pulumi.get(self, "schedule_time")


@pulumi.output_type
class GetBatchtasksBatchtaskTaskProgressResult(dict):
    def __init__(__self__, *,
                 fail: _builtins.int,
                 fail_wait_retry: _builtins.int,
                 processing: _builtins.int,
                 removed: _builtins.int,
                 stopped: _builtins.int,
                 success: _builtins.int,
                 total: _builtins.int,
                 waitting: _builtins.int):
        """
        :param _builtins.int fail: The number of subtasks that failed to execute.
        :param _builtins.int fail_wait_retry: The number of subtasks waiting for retry due to failure.
        :param _builtins.int processing: The number of subtasks currently being executed.
        :param _builtins.int removed: The number of subtasks removed.
        :param _builtins.int stopped: The number of stopped subtasks.
        :param _builtins.int success: The number of successfully executed subtasks.
        :param _builtins.int total: The total number of subtasks.
        :param _builtins.int waitting: The number of subtasks waiting to be executed.
        """
        pulumi.set(__self__, "fail", fail)
        pulumi.set(__self__, "fail_wait_retry", fail_wait_retry)
        pulumi.set(__self__, "processing", processing)
        pulumi.set(__self__, "removed", removed)
        pulumi.set(__self__, "stopped", stopped)
        pulumi.set(__self__, "success", success)
        pulumi.set(__self__, "total", total)
        pulumi.set(__self__, "waitting", waitting)

    @_builtins.property
    @pulumi.getter
    def fail(self) -> _builtins.int:
        """
        The number of subtasks that failed to execute.
        """
        return pulumi.get(self, "fail")

    @_builtins.property
    @pulumi.getter(name="failWaitRetry")
    def fail_wait_retry(self) -> _builtins.int:
        """
        The number of subtasks waiting for retry due to failure.
        """
        return pulumi.get(self, "fail_wait_retry")

    @_builtins.property
    @pulumi.getter
    def processing(self) -> _builtins.int:
        """
        The number of subtasks currently being executed.
        """
        return pulumi.get(self, "processing")

    @_builtins.property
    @pulumi.getter
    def removed(self) -> _builtins.int:
        """
        The number of subtasks removed.
        """
        return pulumi.get(self, "removed")

    @_builtins.property
    @pulumi.getter
    def stopped(self) -> _builtins.int:
        """
        The number of stopped subtasks.
        """
        return pulumi.get(self, "stopped")

    @_builtins.property
    @pulumi.getter
    def success(self) -> _builtins.int:
        """
        The number of successfully executed subtasks.
        """
        return pulumi.get(self, "success")

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        The total number of subtasks.
        """
        return pulumi.get(self, "total")

    @_builtins.property
    @pulumi.getter
    def waitting(self) -> _builtins.int:
        """
        The number of subtasks waiting to be executed.
        """
        return pulumi.get(self, "waitting")


@pulumi.output_type
class GetCustomAuthenticationsAuthorizerResult(dict):
    def __init__(__self__, *,
                 authorizer_id: _builtins.str,
                 authorizer_name: _builtins.str,
                 cache_enable: _builtins.bool,
                 create_time: _builtins.str,
                 default_authorizer: _builtins.bool,
                 func_name: _builtins.str,
                 func_urn: _builtins.str,
                 signing_enable: _builtins.bool,
                 status: _builtins.str,
                 update_time: _builtins.str):
        """
        :param _builtins.str authorizer_id: The ID of the custom authentication.
        :param _builtins.str authorizer_name: Specifies the name of the custom authentication.
        :param _builtins.bool cache_enable: Whether to enable the cache function.
        :param _builtins.str create_time: The creation time of the custom authentication.
               The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        :param _builtins.bool default_authorizer: Whether the custom authentication is the default authentication mode.
        :param _builtins.str func_name: The name of the function associated with the custom authentication.
        :param _builtins.str func_urn: The URN of the function associated with the custom authentication.
        :param _builtins.bool signing_enable: Whether to enable signature authentication.
        :param _builtins.str status: Whether to enable the custom authentication mode.
        :param _builtins.str update_time: The latest update time of the custom authentication.
               The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        pulumi.set(__self__, "authorizer_id", authorizer_id)
        pulumi.set(__self__, "authorizer_name", authorizer_name)
        pulumi.set(__self__, "cache_enable", cache_enable)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "default_authorizer", default_authorizer)
        pulumi.set(__self__, "func_name", func_name)
        pulumi.set(__self__, "func_urn", func_urn)
        pulumi.set(__self__, "signing_enable", signing_enable)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> _builtins.str:
        """
        The ID of the custom authentication.
        """
        return pulumi.get(self, "authorizer_id")

    @_builtins.property
    @pulumi.getter(name="authorizerName")
    def authorizer_name(self) -> _builtins.str:
        """
        Specifies the name of the custom authentication.
        """
        return pulumi.get(self, "authorizer_name")

    @_builtins.property
    @pulumi.getter(name="cacheEnable")
    def cache_enable(self) -> _builtins.bool:
        """
        Whether to enable the cache function.
        """
        return pulumi.get(self, "cache_enable")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the custom authentication.
        The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="defaultAuthorizer")
    def default_authorizer(self) -> _builtins.bool:
        """
        Whether the custom authentication is the default authentication mode.
        """
        return pulumi.get(self, "default_authorizer")

    @_builtins.property
    @pulumi.getter(name="funcName")
    def func_name(self) -> _builtins.str:
        """
        The name of the function associated with the custom authentication.
        """
        return pulumi.get(self, "func_name")

    @_builtins.property
    @pulumi.getter(name="funcUrn")
    def func_urn(self) -> _builtins.str:
        """
        The URN of the function associated with the custom authentication.
        """
        return pulumi.get(self, "func_urn")

    @_builtins.property
    @pulumi.getter(name="signingEnable")
    def signing_enable(self) -> _builtins.bool:
        """
        Whether to enable signature authentication.
        """
        return pulumi.get(self, "signing_enable")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Whether to enable the custom authentication mode.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        The latest update time of the custom authentication.
        The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetDataBacklogPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 backlog_size: _builtins.int,
                 backlog_time: _builtins.int,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.int backlog_size: The size of data backlog in bytes. The range of valid values is integers from `0` to
               `1,073,741,823` (`1` GB), `0` means no backlog.
        :param _builtins.int backlog_time: The data backlog time in seconds. The range of valid values is integers from `0` to
               `86,399` (`1` day), `0` means no backlog.
        :param _builtins.str description: The description of the data backlog policy.
        :param _builtins.str id: The ID of the data backlog policy.
        :param _builtins.str name: The name of the data backlog policy.
        """
        pulumi.set(__self__, "backlog_size", backlog_size)
        pulumi.set(__self__, "backlog_time", backlog_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="backlogSize")
    def backlog_size(self) -> _builtins.int:
        """
        The size of data backlog in bytes. The range of valid values is integers from `0` to
        `1,073,741,823` (`1` GB), `0` means no backlog.
        """
        return pulumi.get(self, "backlog_size")

    @_builtins.property
    @pulumi.getter(name="backlogTime")
    def backlog_time(self) -> _builtins.int:
        """
        The data backlog time in seconds. The range of valid values is integers from `0` to
        `86,399` (`1` day), `0` means no backlog.
        """
        return pulumi.get(self, "backlog_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the data backlog policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the data backlog policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the data backlog policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataFlowControlPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 limit: _builtins.int,
                 name: _builtins.str,
                 scope: _builtins.str,
                 scope_value: _builtins.str):
        """
        :param _builtins.str description: The description of the data flow control policy.
        :param _builtins.str id: The ID of the data flow control policy.
        :param _builtins.int limit: The size of the data forwarding flow control, in tps.
        :param _builtins.str name: The name of the data flow control policy.
        :param _builtins.str scope: Specifies the scope of the data flow control policies.  
               The valid values are as follows:
               + **USER**: Tenant level flow control strategy.
               + **CHANNEL**: Forwarding channel level flow control strategy.
               + **RULE**: Forwarding rule level flow control strategy.
               + **ACTION**: Forwarding action level flow control strategy.
               
               If omitted, query all scope data flow control policies.
        :param _builtins.str scope_value: Specifies the scope add value of the data flow control policies.
               + If omitted or the `scope` is set to **USER**, this field does not need to be set, representing the query of tenant
               level flow control policies.
               + If the `scope` is set to **CHANNEL**, the valid values are **HTTP_FORWARDING**, **DIS_FORWARDING**,
               **OBS_FORWARDING**, **AMQP_FORWARDING**, and **DMS_KAFKA_FORWARDING**. If omitted, query all forwarding channel
               level flow control policies.
               + If the `scope` is set to **RULE**, the value of this field is the corresponding rule ID. If omitted, query all
               forwarding rule level flow control policies.
               + If the `scope` is set to **ACTION**, the value of this field is the corresponding rule action ID. If omitted, query
               all forwarding action level flow control policies.
               
               > The `scope_value` must be used together with `scope` and is invalid when used alone.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "scope_value", scope_value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the data flow control policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the data flow control policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def limit(self) -> _builtins.int:
        """
        The size of the data forwarding flow control, in tps.
        """
        return pulumi.get(self, "limit")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the data flow control policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Specifies the scope of the data flow control policies.  
        The valid values are as follows:
        + **USER**: Tenant level flow control strategy.
        + **CHANNEL**: Forwarding channel level flow control strategy.
        + **RULE**: Forwarding rule level flow control strategy.
        + **ACTION**: Forwarding action level flow control strategy.

        If omitted, query all scope data flow control policies.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="scopeValue")
    def scope_value(self) -> _builtins.str:
        """
        Specifies the scope add value of the data flow control policies.
        + If omitted or the `scope` is set to **USER**, this field does not need to be set, representing the query of tenant
        level flow control policies.
        + If the `scope` is set to **CHANNEL**, the valid values are **HTTP_FORWARDING**, **DIS_FORWARDING**,
        **OBS_FORWARDING**, **AMQP_FORWARDING**, and **DMS_KAFKA_FORWARDING**. If omitted, query all forwarding channel
        level flow control policies.
        + If the `scope` is set to **RULE**, the value of this field is the corresponding rule ID. If omitted, query all
        forwarding rule level flow control policies.
        + If the `scope` is set to **ACTION**, the value of this field is the corresponding rule action ID. If omitted, query
        all forwarding action level flow control policies.

        > The `scope_value` must be used together with `scope` and is invalid when used alone.
        """
        return pulumi.get(self, "scope_value")


@pulumi.output_type
class GetDataforwardingRulesRuleResult(dict):
    def __init__(__self__, *,
                 app_type: _builtins.str,
                 description: _builtins.str,
                 enabled: _builtins.bool,
                 id: _builtins.str,
                 name: _builtins.str,
                 resource: _builtins.str,
                 select: _builtins.str,
                 space_id: _builtins.str,
                 trigger: _builtins.str,
                 where: _builtins.str):
        """
        :param _builtins.str app_type: Specifies the validity scope of the dataforwarding rule.
               The valid values are as follows:
               + **GLOBAL**: The validity scope is tenant level.
               + **APP**: The validity scope is resource space level.
               
               > If the `app_type` value is **APP**, this parameter can be used together with the `space_id` to query
               the dataforwarding rules in the corresponding resource space, if not associated with the `space_id`,
               will be query the dataforwarding rules in the default resource space.
        :param _builtins.str description: The description of the dataforwarding rule.
        :param _builtins.bool enabled: Specifies whether to enable the dataforwarding rule.
               The value can be **true** or **false**.
        :param _builtins.str id: The ID of the dataforwarding rule.
        :param _builtins.str name: Specifies the name of the dataforwarding rule.
        :param _builtins.str resource: Specifies the data source of the dataforwarding rule.
               This parameter must be used together with `trigger`. The valid values are as follows:
               + **device**
               + **device.property**
               + **device.message**
               + **device.message.status**
               + **device.status**
               + **batchtask**
               + **product**
               + **device.command.status**
        :param _builtins.str select: The user defined SQL **select** statement.
        :param _builtins.str space_id: Specifies the ID of the resource space to which the dataforwarding rule belongs.
               
               > If use this parameter to query, the parameter `app_type` must be set to **APP**.
        :param _builtins.str trigger: Specifies the triggering event of the data source corresponding to
               the dataforwarding rule. This parameter must be used together with `resource`. The valid values are as follows:
               + **device:create**: Device added.
               + **device:delete**: Device deleted.
               + **device:update**: Device updated.
               + **device.status:update**: Device status changed.
               + **device.property:report**: Device property reported.
               + **device.message:report**: Device message reported.
               + **device.message.status:update**: Device message status changed.
               + **batchtask:update**: Batch task status changed.
               + **product:create**: Product added.
               + **product:delete**: Product deleted.
               + **product:update**: Product updated.
               + **device.command.status:update**: Device asynchronous command status updated.
        :param _builtins.str where: The user defined SQL **where** statement.
        """
        pulumi.set(__self__, "app_type", app_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "select", select)
        pulumi.set(__self__, "space_id", space_id)
        pulumi.set(__self__, "trigger", trigger)
        pulumi.set(__self__, "where", where)

    @_builtins.property
    @pulumi.getter(name="appType")
    def app_type(self) -> _builtins.str:
        """
        Specifies the validity scope of the dataforwarding rule.
        The valid values are as follows:
        + **GLOBAL**: The validity scope is tenant level.
        + **APP**: The validity scope is resource space level.

        > If the `app_type` value is **APP**, this parameter can be used together with the `space_id` to query
        the dataforwarding rules in the corresponding resource space, if not associated with the `space_id`,
        will be query the dataforwarding rules in the default resource space.
        """
        return pulumi.get(self, "app_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the dataforwarding rule.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable the dataforwarding rule.
        The value can be **true** or **false**.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dataforwarding rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the dataforwarding rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        """
        Specifies the data source of the dataforwarding rule.
        This parameter must be used together with `trigger`. The valid values are as follows:
        + **device**
        + **device.property**
        + **device.message**
        + **device.message.status**
        + **device.status**
        + **batchtask**
        + **product**
        + **device.command.status**
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter
    def select(self) -> _builtins.str:
        """
        The user defined SQL **select** statement.
        """
        return pulumi.get(self, "select")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        Specifies the ID of the resource space to which the dataforwarding rule belongs.

        > If use this parameter to query, the parameter `app_type` must be set to **APP**.
        """
        return pulumi.get(self, "space_id")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> _builtins.str:
        """
        Specifies the triggering event of the data source corresponding to
        the dataforwarding rule. This parameter must be used together with `resource`. The valid values are as follows:
        + **device:create**: Device added.
        + **device:delete**: Device deleted.
        + **device:update**: Device updated.
        + **device.status:update**: Device status changed.
        + **device.property:report**: Device property reported.
        + **device.message:report**: Device message reported.
        + **device.message.status:update**: Device message status changed.
        + **batchtask:update**: Batch task status changed.
        + **product:create**: Product added.
        + **product:delete**: Product deleted.
        + **product:update**: Product updated.
        + **device.command.status:update**: Device asynchronous command status updated.
        """
        return pulumi.get(self, "trigger")

    @_builtins.property
    @pulumi.getter
    def where(self) -> _builtins.str:
        """
        The user defined SQL **where** statement.
        """
        return pulumi.get(self, "where")


@pulumi.output_type
class GetDeviceBindingGroupsGroupResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 parent_group_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The description of the device group.
        :param _builtins.str id: The ID of the device group.
        :param _builtins.str name: The name of the device group.
        :param _builtins.str parent_group_id: The ID of the parent device group to which the device group belongs.
        :param _builtins.str type: The type of the device group. The valid values are **STATIC** and **DYNAMIC**.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_group_id", parent_group_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the device group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the device group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the device group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> _builtins.str:
        """
        The ID of the parent device group to which the device group belongs.
        """
        return pulumi.get(self, "parent_group_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the device group. The valid values are **STATIC** and **DYNAMIC**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDeviceCertificatesCertificateResult(dict):
    def __init__(__self__, *,
                 cn: _builtins.str,
                 created_at: _builtins.str,
                 effective_date: _builtins.str,
                 expiry_date: _builtins.str,
                 id: _builtins.str,
                 owner: _builtins.str,
                 status: _builtins.str,
                 verify_code: _builtins.str):
        """
        :param _builtins.str cn: Specifies the CN name of the certificates to be queried.
        :param _builtins.str created_at: The creation time of the certificate.
        :param _builtins.str effective_date: The effective time of the certificate.
        :param _builtins.str expiry_date: The expiration time of the certificate.
        :param _builtins.str id: The certificate ID.
        :param _builtins.str owner: The certificate owner.
        :param _builtins.str status: Specifies the verification status of the certificates to be queried.  
               The value can be **Verified** or **Unverified**.
        :param _builtins.str verify_code: The certificate verification code.
        """
        pulumi.set(__self__, "cn", cn)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "effective_date", effective_date)
        pulumi.set(__self__, "expiry_date", expiry_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "verify_code", verify_code)

    @_builtins.property
    @pulumi.getter
    def cn(self) -> _builtins.str:
        """
        Specifies the CN name of the certificates to be queried.
        """
        return pulumi.get(self, "cn")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the certificate.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="effectiveDate")
    def effective_date(self) -> _builtins.str:
        """
        The effective time of the certificate.
        """
        return pulumi.get(self, "effective_date")

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> _builtins.str:
        """
        The expiration time of the certificate.
        """
        return pulumi.get(self, "expiry_date")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The certificate ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        The certificate owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the verification status of the certificates to be queried.  
        The value can be **Verified** or **Unverified**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="verifyCode")
    def verify_code(self) -> _builtins.str:
        """
        The certificate verification code.
        """
        return pulumi.get(self, "verify_code")


@pulumi.output_type
class GetDeviceGroupsGroupResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 parent_group_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The description of the device group.
        :param _builtins.str id: The ID of the device group.
        :param _builtins.str name: Specifies the name of the device group.
        :param _builtins.str parent_group_id: Specifies the ID of the parent device group to which the device group belongs.
        :param _builtins.str type: Specifies the type of the device groups.
               The valid values are as follows:
               + **STATIC**: The device group is a static group.
               + **DYNAMIC**: The device group is a dynamical group.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_group_id", parent_group_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the device group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the device group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the device group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentGroupId")
    def parent_group_id(self) -> _builtins.str:
        """
        Specifies the ID of the parent device group to which the device group belongs.
        """
        return pulumi.get(self, "parent_group_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the device groups.
        The valid values are as follows:
        + **STATIC**: The device group is a static group.
        + **DYNAMIC**: The device group is a dynamical group.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDeviceLinkageRulesRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetDeviceLinkageRulesRuleActionResult'],
                 description: _builtins.str,
                 effective_periods: Sequence['outputs.GetDeviceLinkageRulesRuleEffectivePeriodResult'],
                 id: _builtins.str,
                 name: _builtins.str,
                 space_id: _builtins.str,
                 status: _builtins.str,
                 trigger_logic: _builtins.str,
                 triggers: Sequence['outputs.GetDeviceLinkageRulesRuleTriggerResult'],
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param Sequence['GetDeviceLinkageRulesRuleActionArgs'] actions: The action list of the device linkage rule.
               The actions structure is documented below.
        :param _builtins.str description: The description of the alarm.
        :param Sequence['GetDeviceLinkageRulesRuleEffectivePeriodArgs'] effective_periods: The rule condition triggered validity period of the device linkage rule.
               The effective_period structure is documented below.
        :param _builtins.str id: The ID of the device linkage rule.
        :param _builtins.str name: Specifies the name of the device linkage rule.
        :param _builtins.str space_id: Specifies the ID of the resource space to which the device linkage rules belong.
        :param _builtins.str status: Specifies the current status of the device linkage rule.
               The valid values are as follows:
               + **active**: The device linkage rule is active.
               + **inactive**: The device linkage rule is not enabled.
        :param _builtins.str trigger_logic: The logical relationship between multiple rule conditions of the device linkage rule.
        :param Sequence['GetDeviceLinkageRulesRuleTriggerArgs'] triggers: The condition list of the device linkage rule.
               The triggers structure is documented below.
        :param _builtins.str type: Specifies the type of the device linkage rules.
               The valid values are as follows:
               + **DEVICE_LINKAGE**: Cloud based linkage rule.
               + **DEVICE_SIDE**: Device side rule.
        :param _builtins.str updated_at: The latest update time of the device linkage rule.
               The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "effective_periods", effective_periods)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "space_id", space_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "trigger_logic", trigger_logic)
        pulumi.set(__self__, "triggers", triggers)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleActionResult']:
        """
        The action list of the device linkage rule.
        The actions structure is documented below.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the alarm.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="effectivePeriods")
    def effective_periods(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleEffectivePeriodResult']:
        """
        The rule condition triggered validity period of the device linkage rule.
        The effective_period structure is documented below.
        """
        return pulumi.get(self, "effective_periods")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the device linkage rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the device linkage rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        Specifies the ID of the resource space to which the device linkage rules belong.
        """
        return pulumi.get(self, "space_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the current status of the device linkage rule.
        The valid values are as follows:
        + **active**: The device linkage rule is active.
        + **inactive**: The device linkage rule is not enabled.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="triggerLogic")
    def trigger_logic(self) -> _builtins.str:
        """
        The logical relationship between multiple rule conditions of the device linkage rule.
        """
        return pulumi.get(self, "trigger_logic")

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleTriggerResult']:
        """
        The condition list of the device linkage rule.
        The triggers structure is documented below.
        """
        return pulumi.get(self, "triggers")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the device linkage rules.
        The valid values are as follows:
        + **DEVICE_LINKAGE**: Cloud based linkage rule.
        + **DEVICE_SIDE**: Device side rule.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest update time of the device linkage rule.
        The format is **yyyyMMdd'T'HHmmss'Z'**. e.g. **20151212T121212Z**.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetDeviceLinkageRulesRuleActionResult(dict):
    def __init__(__self__, *,
                 device_alarms: Sequence['outputs.GetDeviceLinkageRulesRuleActionDeviceAlarmResult'],
                 device_commands: Sequence['outputs.GetDeviceLinkageRulesRuleActionDeviceCommandResult'],
                 smn_forwardings: Sequence['outputs.GetDeviceLinkageRulesRuleActionSmnForwardingResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetDeviceLinkageRulesRuleActionDeviceAlarmArgs'] device_alarms: The detail of device alarm.
               The device_alarm structure is documented below.
        :param Sequence['GetDeviceLinkageRulesRuleActionDeviceCommandArgs'] device_commands: The detail of device command.
               The device_command structure is documented below.
        :param Sequence['GetDeviceLinkageRulesRuleActionSmnForwardingArgs'] smn_forwardings: The detail of SMN notifications.
               The smn_forwarding structure is documented below.
        :param _builtins.str type: Specifies the type of the device linkage rules.
               The valid values are as follows:
               + **DEVICE_LINKAGE**: Cloud based linkage rule.
               + **DEVICE_SIDE**: Device side rule.
        """
        pulumi.set(__self__, "device_alarms", device_alarms)
        pulumi.set(__self__, "device_commands", device_commands)
        pulumi.set(__self__, "smn_forwardings", smn_forwardings)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="deviceAlarms")
    def device_alarms(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleActionDeviceAlarmResult']:
        """
        The detail of device alarm.
        The device_alarm structure is documented below.
        """
        return pulumi.get(self, "device_alarms")

    @_builtins.property
    @pulumi.getter(name="deviceCommands")
    def device_commands(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleActionDeviceCommandResult']:
        """
        The detail of device command.
        The device_command structure is documented below.
        """
        return pulumi.get(self, "device_commands")

    @_builtins.property
    @pulumi.getter(name="smnForwardings")
    def smn_forwardings(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleActionSmnForwardingResult']:
        """
        The detail of SMN notifications.
        The smn_forwarding structure is documented below.
        """
        return pulumi.get(self, "smn_forwardings")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the device linkage rules.
        The valid values are as follows:
        + **DEVICE_LINKAGE**: Cloud based linkage rule.
        + **DEVICE_SIDE**: Device side rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDeviceLinkageRulesRuleActionDeviceAlarmResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 dimension: _builtins.str,
                 name: _builtins.str,
                 severity: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The description of the alarm.
        :param _builtins.str dimension: The dimension of the alarm. Combine the alarm name and alarm level to jointly identify an alarm.
               The valid values are **device** and **app**. Defaults to user dimension.
        :param _builtins.str name: Specifies the name of the device linkage rule.
        :param _builtins.str severity: The severity level of the alarm.
               The valid values can be **warning**, **minor**, **major**, or **critical**.
        :param _builtins.str type: Specifies the type of the device linkage rules.
               The valid values are as follows:
               + **DEVICE_LINKAGE**: Cloud based linkage rule.
               + **DEVICE_SIDE**: Device side rule.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the alarm.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def dimension(self) -> _builtins.str:
        """
        The dimension of the alarm. Combine the alarm name and alarm level to jointly identify an alarm.
        The valid values are **device** and **app**. Defaults to user dimension.
        """
        return pulumi.get(self, "dimension")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the device linkage rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The severity level of the alarm.
        The valid values can be **warning**, **minor**, **major**, or **critical**.
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the device linkage rules.
        The valid values are as follows:
        + **DEVICE_LINKAGE**: Cloud based linkage rule.
        + **DEVICE_SIDE**: Device side rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDeviceLinkageRulesRuleActionDeviceCommandResult(dict):
    def __init__(__self__, *,
                 buffer_timeout: _builtins.int,
                 command_body: _builtins.str,
                 command_name: _builtins.str,
                 device_id: _builtins.str,
                 mode: _builtins.str,
                 response_timeout: _builtins.int,
                 service_id: _builtins.str):
        """
        :param _builtins.int buffer_timeout: The cache time of device commands, in seconds.
        :param _builtins.str command_body: The command parameters.
        :param _builtins.str command_name: The name of the command.
        :param _builtins.str device_id: The ID of the device to which the command is delivered.
        :param _builtins.str mode: The issuance mode of device commands, which is only valid when the value of `buffer_timeout` is greater than
               `0`. The valid values are **ACTIVE** and **PASSIVE**.
        :param _builtins.int response_timeout: The effective time of the command response, in seconds.
        :param _builtins.str service_id: The ID of the service to which the command belongs.
        """
        pulumi.set(__self__, "buffer_timeout", buffer_timeout)
        pulumi.set(__self__, "command_body", command_body)
        pulumi.set(__self__, "command_name", command_name)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "response_timeout", response_timeout)
        pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter(name="bufferTimeout")
    def buffer_timeout(self) -> _builtins.int:
        """
        The cache time of device commands, in seconds.
        """
        return pulumi.get(self, "buffer_timeout")

    @_builtins.property
    @pulumi.getter(name="commandBody")
    def command_body(self) -> _builtins.str:
        """
        The command parameters.
        """
        return pulumi.get(self, "command_body")

    @_builtins.property
    @pulumi.getter(name="commandName")
    def command_name(self) -> _builtins.str:
        """
        The name of the command.
        """
        return pulumi.get(self, "command_name")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The ID of the device to which the command is delivered.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        The issuance mode of device commands, which is only valid when the value of `buffer_timeout` is greater than
        `0`. The valid values are **ACTIVE** and **PASSIVE**.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="responseTimeout")
    def response_timeout(self) -> _builtins.int:
        """
        The effective time of the command response, in seconds.
        """
        return pulumi.get(self, "response_timeout")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The ID of the service to which the command belongs.
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class GetDeviceLinkageRulesRuleActionSmnForwardingResult(dict):
    def __init__(__self__, *,
                 message_content: _builtins.str,
                 message_template_name: _builtins.str,
                 message_title: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 topic_name: _builtins.str,
                 topic_urn: _builtins.str):
        """
        :param _builtins.str message_content: The message content.
        :param _builtins.str message_template_name: The template name corresponding to the SMN service.
        :param _builtins.str message_title: The message title.
        :param _builtins.str project_id: The project ID to which the SMN belongs.
        :param _builtins.str region: Specifies the region in which to query the device linkage rules.
               If omitted, the provider-level region will be used.
        :param _builtins.str topic_name: The topic name of the SMN.
        :param _builtins.str topic_urn: The topic URN of the SMN.
        """
        pulumi.set(__self__, "message_content", message_content)
        pulumi.set(__self__, "message_template_name", message_template_name)
        pulumi.set(__self__, "message_title", message_title)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "topic_name", topic_name)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter(name="messageContent")
    def message_content(self) -> _builtins.str:
        """
        The message content.
        """
        return pulumi.get(self, "message_content")

    @_builtins.property
    @pulumi.getter(name="messageTemplateName")
    def message_template_name(self) -> _builtins.str:
        """
        The template name corresponding to the SMN service.
        """
        return pulumi.get(self, "message_template_name")

    @_builtins.property
    @pulumi.getter(name="messageTitle")
    def message_title(self) -> _builtins.str:
        """
        The message title.
        """
        return pulumi.get(self, "message_title")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The project ID to which the SMN belongs.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region in which to query the device linkage rules.
        If omitted, the provider-level region will be used.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        The topic name of the SMN.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        The topic URN of the SMN.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetDeviceLinkageRulesRuleEffectivePeriodResult(dict):
    def __init__(__self__, *,
                 days_of_week: _builtins.str,
                 end_time: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str days_of_week: The week list of the rule validity period, separated by commas. **1** represents Sunday,
               **2** represents Monday, and so on.
        :param _builtins.str end_time: The end time for triggering the rule.
               The format is **HH:MM**. e.g. **10:00**.
        :param _builtins.str start_time: The start time for triggering the rule.
               The format is **HH:MM**. e.g. **10:00**.
        """
        pulumi.set(__self__, "days_of_week", days_of_week)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> _builtins.str:
        """
        The week list of the rule validity period, separated by commas. **1** represents Sunday,
        **2** represents Monday, and so on.
        """
        return pulumi.get(self, "days_of_week")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time for triggering the rule.
        The format is **HH:MM**. e.g. **10:00**.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time for triggering the rule.
        The format is **HH:MM**. e.g. **10:00**.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetDeviceLinkageRulesRuleTriggerResult(dict):
    def __init__(__self__, *,
                 daily_timer_conditions: Sequence['outputs.GetDeviceLinkageRulesRuleTriggerDailyTimerConditionResult'],
                 device_data_conditions: Sequence['outputs.GetDeviceLinkageRulesRuleTriggerDeviceDataConditionResult'],
                 device_linkage_status_conditions: Sequence['outputs.GetDeviceLinkageRulesRuleTriggerDeviceLinkageStatusConditionResult'],
                 simple_timer_conditions: Sequence['outputs.GetDeviceLinkageRulesRuleTriggerSimpleTimerConditionResult'],
                 type: _builtins.str):
        """
        :param Sequence['GetDeviceLinkageRulesRuleTriggerDailyTimerConditionArgs'] daily_timer_conditions: The rule condition triggered by schedule upon period.
               The daily_timer_condition structure is documented below.
        :param Sequence['GetDeviceLinkageRulesRuleTriggerDeviceDataConditionArgs'] device_data_conditions: The rule condition triggered upon the property of device.
               The device_data_condition structure is documented below.
        :param Sequence['GetDeviceLinkageRulesRuleTriggerDeviceLinkageStatusConditionArgs'] device_linkage_status_conditions: The rule condition triggered upon the status of device.
               The device_linkage_status_condition structure is documented below.
        :param Sequence['GetDeviceLinkageRulesRuleTriggerSimpleTimerConditionArgs'] simple_timer_conditions: The rule condition triggered by schedule upon policy.
               The simple_timer_condition structure is documented below.
        :param _builtins.str type: Specifies the type of the device linkage rules.
               The valid values are as follows:
               + **DEVICE_LINKAGE**: Cloud based linkage rule.
               + **DEVICE_SIDE**: Device side rule.
        """
        pulumi.set(__self__, "daily_timer_conditions", daily_timer_conditions)
        pulumi.set(__self__, "device_data_conditions", device_data_conditions)
        pulumi.set(__self__, "device_linkage_status_conditions", device_linkage_status_conditions)
        pulumi.set(__self__, "simple_timer_conditions", simple_timer_conditions)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="dailyTimerConditions")
    def daily_timer_conditions(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleTriggerDailyTimerConditionResult']:
        """
        The rule condition triggered by schedule upon period.
        The daily_timer_condition structure is documented below.
        """
        return pulumi.get(self, "daily_timer_conditions")

    @_builtins.property
    @pulumi.getter(name="deviceDataConditions")
    def device_data_conditions(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleTriggerDeviceDataConditionResult']:
        """
        The rule condition triggered upon the property of device.
        The device_data_condition structure is documented below.
        """
        return pulumi.get(self, "device_data_conditions")

    @_builtins.property
    @pulumi.getter(name="deviceLinkageStatusConditions")
    def device_linkage_status_conditions(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleTriggerDeviceLinkageStatusConditionResult']:
        """
        The rule condition triggered upon the status of device.
        The device_linkage_status_condition structure is documented below.
        """
        return pulumi.get(self, "device_linkage_status_conditions")

    @_builtins.property
    @pulumi.getter(name="simpleTimerConditions")
    def simple_timer_conditions(self) -> Sequence['outputs.GetDeviceLinkageRulesRuleTriggerSimpleTimerConditionResult']:
        """
        The rule condition triggered by schedule upon policy.
        The simple_timer_condition structure is documented below.
        """
        return pulumi.get(self, "simple_timer_conditions")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the device linkage rules.
        The valid values are as follows:
        + **DEVICE_LINKAGE**: Cloud based linkage rule.
        + **DEVICE_SIDE**: Device side rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDeviceLinkageRulesRuleTriggerDailyTimerConditionResult(dict):
    def __init__(__self__, *,
                 days_of_week: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str days_of_week: The week list of the rule validity period, separated by commas. **1** represents Sunday,
               **2** represents Monday, and so on.
        :param _builtins.str start_time: The start time for triggering the rule.
               The format is **HH:MM**. e.g. **10:00**.
        """
        pulumi.set(__self__, "days_of_week", days_of_week)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> _builtins.str:
        """
        The week list of the rule validity period, separated by commas. **1** represents Sunday,
        **2** represents Monday, and so on.
        """
        return pulumi.get(self, "days_of_week")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time for triggering the rule.
        The format is **HH:MM**. e.g. **10:00**.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetDeviceLinkageRulesRuleTriggerDeviceDataConditionResult(dict):
    def __init__(__self__, *,
                 data_validatiy_period: _builtins.int,
                 device_id: _builtins.str,
                 in_values: Sequence[_builtins.str],
                 operator: _builtins.str,
                 path: _builtins.str,
                 product_id: _builtins.str,
                 trigger_strategy: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.int data_validatiy_period: The data validity period, in seconds.
        :param _builtins.str device_id: The ID of the device to which the command is delivered.
        :param Sequence[_builtins.str] in_values: The Rvalue of a data comparison expression. Only when the `operator` is **in**, this field is valid,
               with a maximum of `20` characters, represents matching within the specified values, e.g. **20,30,40**,
        :param _builtins.str operator: The data comparison operator. The valid values are: **>**, **<**,
               **>=**, **<=**, **=**, **in**, and **between**.
        :param _builtins.str path: The path of the device property.
               The format is **service_id/DataProperty**. e.g. **DoorWindow/status**
        :param _builtins.str product_id: The ID of the product associated with the device.
        :param _builtins.str trigger_strategy: The judgment strategy triggered by rule conditions. The valid values are:
               + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
               + **reverse**: When the data reported by the device last time does not meet the conditions and the
               data reported this time meets the conditions, the rule can be triggered.
        :param _builtins.str value: The Rvalue of a data comparison expression. When the `operator` is **between**, the Rvalue represents the
               minimum and maximum values, separated by commas, such as **20,30**, which means greater than or equal to `20` and less
               than `30`.
        """
        pulumi.set(__self__, "data_validatiy_period", data_validatiy_period)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "in_values", in_values)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "trigger_strategy", trigger_strategy)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="dataValidatiyPeriod")
    def data_validatiy_period(self) -> _builtins.int:
        """
        The data validity period, in seconds.
        """
        return pulumi.get(self, "data_validatiy_period")

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The ID of the device to which the command is delivered.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter(name="inValues")
    def in_values(self) -> Sequence[_builtins.str]:
        """
        The Rvalue of a data comparison expression. Only when the `operator` is **in**, this field is valid,
        with a maximum of `20` characters, represents matching within the specified values, e.g. **20,30,40**,
        """
        return pulumi.get(self, "in_values")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The data comparison operator. The valid values are: **>**, **<**,
        **>=**, **<=**, **=**, **in**, and **between**.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the device property.
        The format is **service_id/DataProperty**. e.g. **DoorWindow/status**
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        The ID of the product associated with the device.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="triggerStrategy")
    def trigger_strategy(self) -> _builtins.str:
        """
        The judgment strategy triggered by rule conditions. The valid values are:
        + **pulse**: When the data reported by the device meets the conditions, the rule can be triggered.
        + **reverse**: When the data reported by the device last time does not meet the conditions and the
        data reported this time meets the conditions, the rule can be triggered.
        """
        return pulumi.get(self, "trigger_strategy")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The Rvalue of a data comparison expression. When the `operator` is **between**, the Rvalue represents the
        minimum and maximum values, separated by commas, such as **20,30**, which means greater than or equal to `20` and less
        than `30`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDeviceLinkageRulesRuleTriggerDeviceLinkageStatusConditionResult(dict):
    def __init__(__self__, *,
                 device_id: _builtins.str,
                 duration: _builtins.int,
                 product_id: _builtins.str,
                 status_lists: Sequence[_builtins.str]):
        """
        :param _builtins.str device_id: The ID of the device to which the command is delivered.
        :param _builtins.int duration: The duration of the device status, in minutes.
               The valid value is range from `0` to `60`.
        :param _builtins.str product_id: The ID of the product associated with the device.
        :param Sequence[_builtins.str] status_lists: All devices status which trigger the rule. The valid values can be **ONLINE** or **OFFLINE**.
        """
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "status_lists", status_lists)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> _builtins.str:
        """
        The ID of the device to which the command is delivered.
        """
        return pulumi.get(self, "device_id")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        The duration of the device status, in minutes.
        The valid value is range from `0` to `60`.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        The ID of the product associated with the device.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="statusLists")
    def status_lists(self) -> Sequence[_builtins.str]:
        """
        All devices status which trigger the rule. The valid values can be **ONLINE** or **OFFLINE**.
        """
        return pulumi.get(self, "status_lists")


@pulumi.output_type
class GetDeviceLinkageRulesRuleTriggerSimpleTimerConditionResult(dict):
    def __init__(__self__, *,
                 repeat_count: _builtins.int,
                 repeat_interval: _builtins.int,
                 start_time: _builtins.str):
        """
        :param _builtins.int repeat_count: The repeat times for triggering the rule.
               The valid value is range from `1` to `9,999`.
        :param _builtins.int repeat_interval: The repeat time interval for triggering the rule, in minutes.
        :param _builtins.str start_time: The start time for triggering the rule.
               The format is **HH:MM**. e.g. **10:00**.
        """
        pulumi.set(__self__, "repeat_count", repeat_count)
        pulumi.set(__self__, "repeat_interval", repeat_interval)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> _builtins.int:
        """
        The repeat times for triggering the rule.
        The valid value is range from `1` to `9,999`.
        """
        return pulumi.get(self, "repeat_count")

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> _builtins.int:
        """
        The repeat time interval for triggering the rule, in minutes.
        """
        return pulumi.get(self, "repeat_interval")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time for triggering the rule.
        The format is **HH:MM**. e.g. **10:00**.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetDeviceMessagesMessageResult(dict):
    def __init__(__self__, *,
                 created_time: _builtins.str,
                 encoding: _builtins.str,
                 error_infos: Sequence['outputs.GetDeviceMessagesMessageErrorInfoResult'],
                 finished_time: _builtins.str,
                 id: _builtins.str,
                 message: _builtins.str,
                 name: _builtins.str,
                 payload_format: _builtins.str,
                 properties: Sequence['outputs.GetDeviceMessagesMessagePropertyResult'],
                 status: _builtins.str,
                 topic: _builtins.str):
        """
        :param _builtins.str created_time: The creation time of the device message.
               The format is **yyyyMMdd'T'HHmmss'Z'**, e.g. **20151212T121212Z**.
        :param _builtins.str encoding: The encoding format for message content. The value can be **none** or **base64**.
        :param Sequence['GetDeviceMessagesMessageErrorInfoArgs'] error_infos: The message delivery failure details.
               The error_info structure is documented below.
        :param _builtins.str finished_time: The end time of the device message. Contains the time for the message to transition to the
               **DELIVERED* and **TIMEOUT** status. The format is **yyyyMMdd'T'HHmmss'Z'**, e.g. **20151212T121212Z**.
        :param _builtins.str id: The message ID.
        :param _builtins.str message: The message content.
        :param _builtins.str name: The message name.
        :param _builtins.str payload_format: The payload format. The value can be **standard** or **raw**.
        :param Sequence['GetDeviceMessagesMessagePropertyArgs'] properties: The attribute parameters of the message downstream to the device.
               The properties structure is documented below.
        :param _builtins.str status: The status of the message.  
               The valid values are as follows:
               + **PENDING**: The device is not online, the message is cached and will be issued after the device is online.
               + **DELIVERED**: The message sent successfully.
               + **FAILED**: The message sending failed.
               + **TIMEOUT**: The message has not been sent to the device within the default time of the platform (`1` day).
        :param _builtins.str topic: The message topic.
        """
        pulumi.set(__self__, "created_time", created_time)
        pulumi.set(__self__, "encoding", encoding)
        pulumi.set(__self__, "error_infos", error_infos)
        pulumi.set(__self__, "finished_time", finished_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "payload_format", payload_format)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> _builtins.str:
        """
        The creation time of the device message.
        The format is **yyyyMMdd'T'HHmmss'Z'**, e.g. **20151212T121212Z**.
        """
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> _builtins.str:
        """
        The encoding format for message content. The value can be **none** or **base64**.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter(name="errorInfos")
    def error_infos(self) -> Sequence['outputs.GetDeviceMessagesMessageErrorInfoResult']:
        """
        The message delivery failure details.
        The error_info structure is documented below.
        """
        return pulumi.get(self, "error_infos")

    @_builtins.property
    @pulumi.getter(name="finishedTime")
    def finished_time(self) -> _builtins.str:
        """
        The end time of the device message. Contains the time for the message to transition to the
        **DELIVERED* and **TIMEOUT** status. The format is **yyyyMMdd'T'HHmmss'Z'**, e.g. **20151212T121212Z**.
        """
        return pulumi.get(self, "finished_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The message ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The message content.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The message name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="payloadFormat")
    def payload_format(self) -> _builtins.str:
        """
        The payload format. The value can be **standard** or **raw**.
        """
        return pulumi.get(self, "payload_format")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Sequence['outputs.GetDeviceMessagesMessagePropertyResult']:
        """
        The attribute parameters of the message downstream to the device.
        The properties structure is documented below.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the message.  
        The valid values are as follows:
        + **PENDING**: The device is not online, the message is cached and will be issued after the device is online.
        + **DELIVERED**: The message sent successfully.
        + **FAILED**: The message sending failed.
        + **TIMEOUT**: The message has not been sent to the device within the default time of the platform (`1` day).
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        The message topic.
        """
        return pulumi.get(self, "topic")


@pulumi.output_type
class GetDeviceMessagesMessageErrorInfoResult(dict):
    def __init__(__self__, *,
                 error_code: _builtins.str,
                 error_msg: _builtins.str):
        """
        :param _builtins.str error_code: The abnormal information error code.  
               The valid values are as follows:
               + **IOTDA.014016**: Indicates that the device is not online.
               + **IOTDA.014112**: Indicates that the device has not subscribed to the topic.
        :param _builtins.str error_msg: The abnormal information explanation. Includes instructions for devices not online and devices not
               subscribed to the topic.
        """
        pulumi.set(__self__, "error_code", error_code)
        pulumi.set(__self__, "error_msg", error_msg)

    @_builtins.property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> _builtins.str:
        """
        The abnormal information error code.  
        The valid values are as follows:
        + **IOTDA.014016**: Indicates that the device is not online.
        + **IOTDA.014112**: Indicates that the device has not subscribed to the topic.
        """
        return pulumi.get(self, "error_code")

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> _builtins.str:
        """
        The abnormal information explanation. Includes instructions for devices not online and devices not
        subscribed to the topic.
        """
        return pulumi.get(self, "error_msg")


@pulumi.output_type
class GetDeviceMessagesMessagePropertyResult(dict):
    def __init__(__self__, *,
                 correlation_data: _builtins.str,
                 response_topic: _builtins.str,
                 user_properties: Sequence['outputs.GetDeviceMessagesMessagePropertyUserPropertyResult']):
        """
        :param _builtins.str correlation_data: The relevant data in MQTT 5.0 request and response patterns.
        :param _builtins.str response_topic: The response topic in MQTT 5.0 request and response patterns.
        :param Sequence['GetDeviceMessagesMessagePropertyUserPropertyArgs'] user_properties: The user-defined attributes.
               The user_properties structure is documented below.
        """
        pulumi.set(__self__, "correlation_data", correlation_data)
        pulumi.set(__self__, "response_topic", response_topic)
        pulumi.set(__self__, "user_properties", user_properties)

    @_builtins.property
    @pulumi.getter(name="correlationData")
    def correlation_data(self) -> _builtins.str:
        """
        The relevant data in MQTT 5.0 request and response patterns.
        """
        return pulumi.get(self, "correlation_data")

    @_builtins.property
    @pulumi.getter(name="responseTopic")
    def response_topic(self) -> _builtins.str:
        """
        The response topic in MQTT 5.0 request and response patterns.
        """
        return pulumi.get(self, "response_topic")

    @_builtins.property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Sequence['outputs.GetDeviceMessagesMessagePropertyUserPropertyResult']:
        """
        The user-defined attributes.
        The user_properties structure is documented below.
        """
        return pulumi.get(self, "user_properties")


@pulumi.output_type
class GetDeviceMessagesMessagePropertyUserPropertyResult(dict):
    def __init__(__self__, *,
                 prop_key: _builtins.str,
                 prop_value: _builtins.str):
        """
        :param _builtins.str prop_key: The custom attribute key.
        :param _builtins.str prop_value: The custom attribute value.
        """
        pulumi.set(__self__, "prop_key", prop_key)
        pulumi.set(__self__, "prop_value", prop_value)

    @_builtins.property
    @pulumi.getter(name="propKey")
    def prop_key(self) -> _builtins.str:
        """
        The custom attribute key.
        """
        return pulumi.get(self, "prop_key")

    @_builtins.property
    @pulumi.getter(name="propValue")
    def prop_value(self) -> _builtins.str:
        """
        The custom attribute value.
        """
        return pulumi.get(self, "prop_value")


@pulumi.output_type
class GetDeviceProxiesProxyResult(dict):
    def __init__(__self__, *,
                 effective_time_ranges: Sequence['outputs.GetDeviceProxiesProxyEffectiveTimeRangeResult'],
                 id: _builtins.str,
                 name: _builtins.str,
                 space_id: _builtins.str):
        """
        :param Sequence['GetDeviceProxiesProxyEffectiveTimeRangeArgs'] effective_time_ranges: The validity period of the device proxy rule.
               The effective_time_range structure is documented below.
        :param _builtins.str id: The device proxy ID.
        :param _builtins.str name: Specifies the name of the device proxy.
        :param _builtins.str space_id: Specifies the space ID to which the device proxies belong.
               If omitted, query all device proxies under the current instance.
        """
        pulumi.set(__self__, "effective_time_ranges", effective_time_ranges)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "space_id", space_id)

    @_builtins.property
    @pulumi.getter(name="effectiveTimeRanges")
    def effective_time_ranges(self) -> Sequence['outputs.GetDeviceProxiesProxyEffectiveTimeRangeResult']:
        """
        The validity period of the device proxy rule.
        The effective_time_range structure is documented below.
        """
        return pulumi.get(self, "effective_time_ranges")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The device proxy ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the device proxy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        Specifies the space ID to which the device proxies belong.
        If omitted, query all device proxies under the current instance.
        """
        return pulumi.get(self, "space_id")


@pulumi.output_type
class GetDeviceProxiesProxyEffectiveTimeRangeResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str end_time: The device proxy expiration time, using UTC time zone,
               the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        :param _builtins.str start_time: The effective time of the device proxy, using UTC time zone,
               the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The device proxy expiration time, using UTC time zone,
        the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The effective time of the device proxy, using UTC time zone,
        the format is **yyyyMMdd'T'HHMmmss-Z**. e.g. **20250528T153000Z**.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetDevicesDeviceResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 fw_version: _builtins.str,
                 gateway_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 node_id: _builtins.str,
                 node_type: _builtins.str,
                 product_id: _builtins.str,
                 product_name: _builtins.str,
                 sdk_version: _builtins.str,
                 space_id: _builtins.str,
                 space_name: _builtins.str,
                 status: _builtins.str,
                 sw_version: _builtins.str,
                 tags: Mapping[str, _builtins.str]):
        """
        :param _builtins.str description: The description of the device.
        :param _builtins.str fw_version: The firmware version of the device.
        :param _builtins.str gateway_id: Specifies the gateway ID of the devices to be queried;
               The `gateway_id` is the ID of the parent device to which the devices belong.
        :param _builtins.str id: The device ID.
        :param _builtins.str name: Specifies the name of the device to be queried.
        :param _builtins.str node_id: Specifies the node ID of the device to be queried.
        :param _builtins.str node_type: Specifies the node type of the devices to be queried.  
               The valid values are as follows:
               + **ENDPOINT**: Non-directly connected devices.
               + **GATEWAY**: Directly connected devices or gateways.
               + **UNKNOWN**: Unknown.
        :param _builtins.str product_id: Specifies the ID of the product to be queried.
               If omitted, query the devices in all products under the current instance.
        :param _builtins.str product_name: The product name to which the device belongs.
        :param _builtins.str sdk_version: The SDK information of the device.
        :param _builtins.str space_id: Specifies the space ID of the devices to be queried.
               If omitted, query the devices in all spaces under the current instance.
        :param _builtins.str space_name: The space name to which the device belongs.
        :param _builtins.str status: Specifies the status of the devices to be queried.  
               The valid values are as follows:
               + **ONLINE**: Device is online.
               + **OFFLINE**: Device is offline.
               + **ABNORMAL**: Device is abnormal.
               + **INACTIVE**: Device is inactive.
               + **FROZEN**: Device is frozen.
        :param _builtins.str sw_version: The software version of the device.
        :param Mapping[str, _builtins.str] tags: The tags of the device, key/value pair format.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "fw_version", fw_version)
        pulumi.set(__self__, "gateway_id", gateway_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_type", node_type)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "product_name", product_name)
        pulumi.set(__self__, "sdk_version", sdk_version)
        pulumi.set(__self__, "space_id", space_id)
        pulumi.set(__self__, "space_name", space_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "sw_version", sw_version)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the device.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fwVersion")
    def fw_version(self) -> _builtins.str:
        """
        The firmware version of the device.
        """
        return pulumi.get(self, "fw_version")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> _builtins.str:
        """
        Specifies the gateway ID of the devices to be queried;
        The `gateway_id` is the ID of the parent device to which the devices belong.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The device ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the device to be queried.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        Specifies the node ID of the device to be queried.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> _builtins.str:
        """
        Specifies the node type of the devices to be queried.  
        The valid values are as follows:
        + **ENDPOINT**: Non-directly connected devices.
        + **GATEWAY**: Directly connected devices or gateways.
        + **UNKNOWN**: Unknown.
        """
        return pulumi.get(self, "node_type")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        Specifies the ID of the product to be queried.
        If omitted, query the devices in all products under the current instance.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="productName")
    def product_name(self) -> _builtins.str:
        """
        The product name to which the device belongs.
        """
        return pulumi.get(self, "product_name")

    @_builtins.property
    @pulumi.getter(name="sdkVersion")
    def sdk_version(self) -> _builtins.str:
        """
        The SDK information of the device.
        """
        return pulumi.get(self, "sdk_version")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        Specifies the space ID of the devices to be queried.
        If omitted, query the devices in all spaces under the current instance.
        """
        return pulumi.get(self, "space_id")

    @_builtins.property
    @pulumi.getter(name="spaceName")
    def space_name(self) -> _builtins.str:
        """
        The space name to which the device belongs.
        """
        return pulumi.get(self, "space_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the devices to be queried.  
        The valid values are as follows:
        + **ONLINE**: Device is online.
        + **OFFLINE**: Device is offline.
        + **ABNORMAL**: Device is abnormal.
        + **INACTIVE**: Device is inactive.
        + **FROZEN**: Device is frozen.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="swVersion")
    def sw_version(self) -> _builtins.str:
        """
        The software version of the device.
        """
        return pulumi.get(self, "sw_version")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The tags of the device, key/value pair format.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetProductsProductResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 data_type: _builtins.str,
                 description: _builtins.str,
                 device_type: _builtins.str,
                 id: _builtins.str,
                 industry: _builtins.str,
                 manufacturer_name: _builtins.str,
                 name: _builtins.str,
                 protocol_type: _builtins.str,
                 space_id: _builtins.str,
                 space_name: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the product. The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        :param _builtins.str data_type: The format of data reported by devices under the product.
               The value can be **json** or **binary**.
        :param _builtins.str description: The description of the product.
        :param _builtins.str device_type: Specifies the device type of the products to be queried.
        :param _builtins.str id: The product ID.
        :param _builtins.str industry: The industry to which the devices under the product belongs.
        :param _builtins.str manufacturer_name: The manufacturer name.
        :param _builtins.str name: The product name.
        :param _builtins.str protocol_type: The protocol type used by devices under the product.
               The value can be **MQTT**, **CoAP**, **HTTP**, **HTTPS**, **Modbus**, **ONVIF**, **OPC-UA**, **OPC-DA**, or **Other**.
        :param _builtins.str space_id: Specifies the space ID of the products to be queried.
               If omitted, query all products under the current instance.
        :param _builtins.str space_name: Specifies the space name of the products to be queried.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "device_type", device_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "industry", industry)
        pulumi.set(__self__, "manufacturer_name", manufacturer_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol_type", protocol_type)
        pulumi.set(__self__, "space_id", space_id)
        pulumi.set(__self__, "space_name", space_name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the product. The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.str:
        """
        The format of data reported by devices under the product.
        The value can be **json** or **binary**.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the product.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> _builtins.str:
        """
        Specifies the device type of the products to be queried.
        """
        return pulumi.get(self, "device_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The product ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def industry(self) -> _builtins.str:
        """
        The industry to which the devices under the product belongs.
        """
        return pulumi.get(self, "industry")

    @_builtins.property
    @pulumi.getter(name="manufacturerName")
    def manufacturer_name(self) -> _builtins.str:
        """
        The manufacturer name.
        """
        return pulumi.get(self, "manufacturer_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The product name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> _builtins.str:
        """
        The protocol type used by devices under the product.
        The value can be **MQTT**, **CoAP**, **HTTP**, **HTTPS**, **Modbus**, **ONVIF**, **OPC-UA**, **OPC-DA**, or **Other**.
        """
        return pulumi.get(self, "protocol_type")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        Specifies the space ID of the products to be queried.
        If omitted, query all products under the current instance.
        """
        return pulumi.get(self, "space_id")

    @_builtins.property
    @pulumi.getter(name="spaceName")
    def space_name(self) -> _builtins.str:
        """
        Specifies the space name of the products to be queried.
        """
        return pulumi.get(self, "space_name")


@pulumi.output_type
class GetSpacesSpaceResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 is_default: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the space. The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        :param _builtins.str id: The space ID.
        :param _builtins.bool is_default: Specifies whether to query the default space.
               The valid values are as follows:
               + **true**: Query the default space.
               + **false**: Query all non default spaces.
               If omitted, query all spaces under the current instance.
        :param _builtins.str name: The space name.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the space. The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The space ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Specifies whether to query the default space.
        The valid values are as follows:
        + **true**: Query the default space.
        + **false**: Query all non default spaces.
        If omitted, query all spaces under the current instance.
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The space name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetUpgradePackagesPackageResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 custom_info: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 product_id: _builtins.str,
                 space_id: _builtins.str,
                 support_source_versions: Sequence[_builtins.str],
                 type: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str created_at: The time when the software and firmware packages are uploaded to the IoT platform.
               The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        :param _builtins.str custom_info: The custom information pushed to the device.
        :param _builtins.str description: The description of the upgrade package.
        :param _builtins.str id: The ID of the upgrade package.
        :param _builtins.str product_id: Specifies the product ID associated with the upgrade package.
        :param _builtins.str space_id: Specifies the resource space ID to which the upgrade packages belong.
        :param Sequence[_builtins.str] support_source_versions: The list of source versions that support the upgrade of this version package.
        :param _builtins.str type: Specifies the type of the upgrade package.
               The valid values are as follows:
               + **softwarePackage**
               + **firmwarePackage**
        :param _builtins.str version: Specifies the version number of the upgrade package.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_info", custom_info)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "space_id", space_id)
        pulumi.set(__self__, "support_source_versions", support_source_versions)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The time when the software and firmware packages are uploaded to the IoT platform.
        The format is **yyyyMMdd'T'HHmmss'Z**. e.g. **20190528T153000Z**.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="customInfo")
    def custom_info(self) -> _builtins.str:
        """
        The custom information pushed to the device.
        """
        return pulumi.get(self, "custom_info")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the upgrade package.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the upgrade package.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        Specifies the product ID associated with the upgrade package.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        Specifies the resource space ID to which the upgrade packages belong.
        """
        return pulumi.get(self, "space_id")

    @_builtins.property
    @pulumi.getter(name="supportSourceVersions")
    def support_source_versions(self) -> Sequence[_builtins.str]:
        """
        The list of source versions that support the upgrade of this version package.
        """
        return pulumi.get(self, "support_source_versions")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the upgrade package.
        The valid values are as follows:
        + **softwarePackage**
        + **firmwarePackage**
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Specifies the version number of the upgrade package.
        """
        return pulumi.get(self, "version")


