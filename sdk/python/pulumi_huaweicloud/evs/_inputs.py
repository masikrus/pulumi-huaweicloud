# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'SnapshotV5SnapshotChainArgs',
    'SnapshotV5SnapshotChainArgsDict',
    'VolumeAttachmentArgs',
    'VolumeAttachmentArgsDict',
    'VolumeIopsAttributeArgs',
    'VolumeIopsAttributeArgsDict',
    'VolumeLinkArgs',
    'VolumeLinkArgsDict',
    'VolumeThroughputAttributeArgs',
    'VolumeThroughputAttributeArgsDict',
    'VolumeTransferV3LinkArgs',
    'VolumeTransferV3LinkArgsDict',
    'VolumeV3AttachmentArgs',
    'VolumeV3AttachmentArgsDict',
    'VolumeV3IopsAttributeArgs',
    'VolumeV3IopsAttributeArgsDict',
    'VolumeV3LinkArgs',
    'VolumeV3LinkArgsDict',
    'VolumeV3ThroughputAttributeArgs',
    'VolumeV3ThroughputAttributeArgsDict',
    'VolumesBatchExpandVolumeArgs',
    'VolumesBatchExpandVolumeArgsDict',
    'GetVolumesByTagsMatchArgs',
    'GetVolumesByTagsMatchArgsDict',
    'GetVolumesByTagsTagArgs',
    'GetVolumesByTagsTagArgsDict',
]

MYPY = False

if not MYPY:
    class SnapshotV5SnapshotChainArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AZ to which the snapshot chain belongs.
        """
        capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The total size of the snapshot chain.
        """
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        The category of snapshot chain.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time when the snapshot chain was created.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The snapshot chain ID.
        """
        snapshot_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of snapshots on the snapshot chain.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time when the snapshot chain was updated.
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the source cloud disk for the snapshot.
        """
elif False:
    SnapshotV5SnapshotChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SnapshotV5SnapshotChainArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_count: Optional[pulumi.Input[_builtins.int]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: The AZ to which the snapshot chain belongs.
        :param pulumi.Input[_builtins.int] capacity: The total size of the snapshot chain.
        :param pulumi.Input[_builtins.str] category: The category of snapshot chain.
        :param pulumi.Input[_builtins.str] created_at: The time when the snapshot chain was created.
        :param pulumi.Input[_builtins.str] id: The snapshot chain ID.
        :param pulumi.Input[_builtins.int] snapshot_count: The number of snapshots on the snapshot chain.
        :param pulumi.Input[_builtins.str] updated_at: The time when the snapshot chain was updated.
        :param pulumi.Input[_builtins.str] volume_id: Specifies the ID of the source cloud disk for the snapshot.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if snapshot_count is not None:
            pulumi.set(__self__, "snapshot_count", snapshot_count)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AZ to which the snapshot chain belongs.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The total size of the snapshot chain.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "capacity", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The category of snapshot chain.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time when the snapshot chain was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The snapshot chain ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotCount")
    def snapshot_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of snapshots on the snapshot chain.
        """
        return pulumi.get(self, "snapshot_count")

    @snapshot_count.setter
    def snapshot_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "snapshot_count", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time when the snapshot chain was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the source cloud disk for the snapshot.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class VolumeAttachmentArgsDict(TypedDict):
        attached_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time when the disk was attached.
        """
        attached_volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the attached disk.
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device name.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the physical host housing the cloud server to which the disk is attached.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the attachment information.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the server to which the disk is attached.
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The disk ID.
        """
elif False:
    VolumeAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeAttachmentArgs:
    def __init__(__self__, *,
                 attached_at: Optional[pulumi.Input[_builtins.str]] = None,
                 attached_volume_id: Optional[pulumi.Input[_builtins.str]] = None,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attached_at: The time when the disk was attached.
        :param pulumi.Input[_builtins.str] attached_volume_id: The ID of the attached disk.
        :param pulumi.Input[_builtins.str] device: The device name.
        :param pulumi.Input[_builtins.str] host_name: The name of the physical host housing the cloud server to which the disk is attached.
        :param pulumi.Input[_builtins.str] id: The ID of the attachment information.
        :param pulumi.Input[_builtins.str] instance_id: The ID of the server to which the disk is attached.
        :param pulumi.Input[_builtins.str] volume_id: The disk ID.
        """
        if attached_at is not None:
            pulumi.set(__self__, "attached_at", attached_at)
        if attached_volume_id is not None:
            pulumi.set(__self__, "attached_volume_id", attached_volume_id)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter(name="attachedAt")
    def attached_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time when the disk was attached.
        """
        return pulumi.get(self, "attached_at")

    @attached_at.setter
    def attached_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attached_at", value)

    @_builtins.property
    @pulumi.getter(name="attachedVolumeId")
    def attached_volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the attached disk.
        """
        return pulumi.get(self, "attached_volume_id")

    @attached_volume_id.setter
    def attached_volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attached_volume_id", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device name.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the physical host housing the cloud server to which the disk is attached.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the attachment information.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the server to which the disk is attached.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The disk ID.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class VolumeIopsAttributeArgsDict(TypedDict):
        frozened: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The frozen tag.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the attachment information.
        """
        total_val: NotRequired[pulumi.Input[_builtins.int]]
        """
        The throughput.
        """
elif False:
    VolumeIopsAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeIopsAttributeArgs:
    def __init__(__self__, *,
                 frozened: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 total_val: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] frozened: The frozen tag.
        :param pulumi.Input[_builtins.str] id: The ID of the attachment information.
        :param pulumi.Input[_builtins.int] total_val: The throughput.
        """
        if frozened is not None:
            pulumi.set(__self__, "frozened", frozened)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if total_val is not None:
            pulumi.set(__self__, "total_val", total_val)

    @_builtins.property
    @pulumi.getter
    def frozened(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The frozen tag.
        """
        return pulumi.get(self, "frozened")

    @frozened.setter
    def frozened(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "frozened", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the attachment information.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="totalVal")
    def total_val(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The throughput.
        """
        return pulumi.get(self, "total_val")

    @total_val.setter
    def total_val(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_val", value)


if not MYPY:
    class VolumeLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The corresponding shortcut link.
        """
        rel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shortcut link marker name.
        """
elif False:
    VolumeLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 rel: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: The corresponding shortcut link.
        :param pulumi.Input[_builtins.str] rel: The shortcut link marker name.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The corresponding shortcut link.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shortcut link marker name.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class VolumeThroughputAttributeArgsDict(TypedDict):
        frozened: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The frozen tag.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the attachment information.
        """
        total_val: NotRequired[pulumi.Input[_builtins.int]]
        """
        The throughput.
        """
elif False:
    VolumeThroughputAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeThroughputAttributeArgs:
    def __init__(__self__, *,
                 frozened: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 total_val: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] frozened: The frozen tag.
        :param pulumi.Input[_builtins.str] id: The ID of the attachment information.
        :param pulumi.Input[_builtins.int] total_val: The throughput.
        """
        if frozened is not None:
            pulumi.set(__self__, "frozened", frozened)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if total_val is not None:
            pulumi.set(__self__, "total_val", total_val)

    @_builtins.property
    @pulumi.getter
    def frozened(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The frozen tag.
        """
        return pulumi.get(self, "frozened")

    @frozened.setter
    def frozened(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "frozened", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the attachment information.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="totalVal")
    def total_val(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The throughput.
        """
        return pulumi.get(self, "total_val")

    @total_val.setter
    def total_val(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_val", value)


if not MYPY:
    class VolumeTransferV3LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The corresponding shortcut link.
        """
        rel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shortcut link marker name.
        """
elif False:
    VolumeTransferV3LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeTransferV3LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 rel: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: The corresponding shortcut link.
        :param pulumi.Input[_builtins.str] rel: The shortcut link marker name.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The corresponding shortcut link.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shortcut link marker name.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class VolumeV3AttachmentArgsDict(TypedDict):
        attached_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time when the disk was attached.
        """
        attachment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the attachment information.
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device name.
        """
        host_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the physical host housing the cloud server to which the disk is attached.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The throughput ID.
        """
        server_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the server to which the disk is attached.
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The disk ID.
        """
elif False:
    VolumeV3AttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeV3AttachmentArgs:
    def __init__(__self__, *,
                 attached_at: Optional[pulumi.Input[_builtins.str]] = None,
                 attachment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 host_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 server_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attached_at: The time when the disk was attached.
        :param pulumi.Input[_builtins.str] attachment_id: The ID of the attachment information.
        :param pulumi.Input[_builtins.str] device: The device name.
        :param pulumi.Input[_builtins.str] host_name: The name of the physical host housing the cloud server to which the disk is attached.
        :param pulumi.Input[_builtins.str] id: The throughput ID.
        :param pulumi.Input[_builtins.str] server_id: The ID of the server to which the disk is attached.
        :param pulumi.Input[_builtins.str] volume_id: The disk ID.
        """
        if attached_at is not None:
            pulumi.set(__self__, "attached_at", attached_at)
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if host_name is not None:
            pulumi.set(__self__, "host_name", host_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if server_id is not None:
            pulumi.set(__self__, "server_id", server_id)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter(name="attachedAt")
    def attached_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time when the disk was attached.
        """
        return pulumi.get(self, "attached_at")

    @attached_at.setter
    def attached_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attached_at", value)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the attachment information.
        """
        return pulumi.get(self, "attachment_id")

    @attachment_id.setter
    def attachment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attachment_id", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device name.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the physical host housing the cloud server to which the disk is attached.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The throughput ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the server to which the disk is attached.
        """
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The disk ID.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class VolumeV3IopsAttributeArgsDict(TypedDict):
        frozened: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The frozen tag.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The throughput ID.
        """
        total_val: NotRequired[pulumi.Input[_builtins.int]]
        """
        The throughput.
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The disk ID.
        """
elif False:
    VolumeV3IopsAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeV3IopsAttributeArgs:
    def __init__(__self__, *,
                 frozened: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 total_val: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] frozened: The frozen tag.
        :param pulumi.Input[_builtins.str] id: The throughput ID.
        :param pulumi.Input[_builtins.int] total_val: The throughput.
        :param pulumi.Input[_builtins.str] volume_id: The disk ID.
        """
        if frozened is not None:
            pulumi.set(__self__, "frozened", frozened)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if total_val is not None:
            pulumi.set(__self__, "total_val", total_val)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter
    def frozened(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The frozen tag.
        """
        return pulumi.get(self, "frozened")

    @frozened.setter
    def frozened(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "frozened", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The throughput ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="totalVal")
    def total_val(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The throughput.
        """
        return pulumi.get(self, "total_val")

    @total_val.setter
    def total_val(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_val", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The disk ID.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class VolumeV3LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The corresponding shortcut link.
        """
        rel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shortcut link marker name.
        """
elif False:
    VolumeV3LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeV3LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 rel: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: The corresponding shortcut link.
        :param pulumi.Input[_builtins.str] rel: The shortcut link marker name.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The corresponding shortcut link.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shortcut link marker name.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class VolumeV3ThroughputAttributeArgsDict(TypedDict):
        frozened: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The frozen tag.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The throughput ID.
        """
        total_val: NotRequired[pulumi.Input[_builtins.int]]
        """
        The throughput.
        """
        volume_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The disk ID.
        """
elif False:
    VolumeV3ThroughputAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeV3ThroughputAttributeArgs:
    def __init__(__self__, *,
                 frozened: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 total_val: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] frozened: The frozen tag.
        :param pulumi.Input[_builtins.str] id: The throughput ID.
        :param pulumi.Input[_builtins.int] total_val: The throughput.
        :param pulumi.Input[_builtins.str] volume_id: The disk ID.
        """
        if frozened is not None:
            pulumi.set(__self__, "frozened", frozened)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if total_val is not None:
            pulumi.set(__self__, "total_val", total_val)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter
    def frozened(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The frozen tag.
        """
        return pulumi.get(self, "frozened")

    @frozened.setter
    def frozened(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "frozened", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The throughput ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="totalVal")
    def total_val(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The throughput.
        """
        return pulumi.get(self, "total_val")

    @total_val.setter
    def total_val(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_val", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The disk ID.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class VolumesBatchExpandVolumeArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the volume ID.
        """
        new_size: pulumi.Input[_builtins.int]
        """
        Specifies the new size of the to-be-expanded volume, in GiB.
        Must be greater than the current size. The maximum disk size: Data disk: `32,768` GiB, System disk: `1,024` GiB
        """
elif False:
    VolumesBatchExpandVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumesBatchExpandVolumeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 new_size: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the volume ID.
        :param pulumi.Input[_builtins.int] new_size: Specifies the new size of the to-be-expanded volume, in GiB.
               Must be greater than the current size. The maximum disk size: Data disk: `32,768` GiB, System disk: `1,024` GiB
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "new_size", new_size)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="newSize")
    def new_size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the new size of the to-be-expanded volume, in GiB.
        Must be greater than the current size. The maximum disk size: Data disk: `32,768` GiB, System disk: `1,024` GiB
        """
        return pulumi.get(self, "new_size")

    @new_size.setter
    def new_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "new_size", value)


if not MYPY:
    class GetVolumesByTagsMatchArgsDict(TypedDict):
        key: NotRequired[_builtins.str]
        """
        Specifies the key of the resource match.
        Supported keys: **resource_name**, **service_type**.
        """
        value: NotRequired[_builtins.str]
        """
        Specifies the value of the resource match.
        The value, which can contain a maximum of `255` characters. If **resource_name** is specified for `key`,
        the tag value uses a fuzzy match.
        """
elif False:
    GetVolumesByTagsMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumesByTagsMatchArgs:
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Specifies the key of the resource match.
               Supported keys: **resource_name**, **service_type**.
        :param _builtins.str value: Specifies the value of the resource match.
               The value, which can contain a maximum of `255` characters. If **resource_name** is specified for `key`,
               the tag value uses a fuzzy match.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Specifies the key of the resource match.
        Supported keys: **resource_name**, **service_type**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the value of the resource match.
        The value, which can contain a maximum of `255` characters. If **resource_name** is specified for `key`,
        the tag value uses a fuzzy match.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetVolumesByTagsTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the resource match.
        Supported keys: **resource_name**, **service_type**.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the list of values corresponding to the key.
        A tag list can contain a maximum of `10` values. Tag values in a tag list must be unique.
        If the tag value list is empty, disks that contain any key can be queried.
        When there are multiple values and the key requirements are met, disks that have any of the specified values are queried.

        <a name="matches_struct"></a>
        The `matches` block supports:
        """
elif False:
    GetVolumesByTagsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumesByTagsTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the key of the resource match.
               Supported keys: **resource_name**, **service_type**.
        :param Sequence[_builtins.str] values: Specifies the list of values corresponding to the key.
               A tag list can contain a maximum of `10` values. Tag values in a tag list must be unique.
               If the tag value list is empty, disks that contain any key can be queried.
               When there are multiple values and the key requirements are met, disks that have any of the specified values are queried.
               
               <a name="matches_struct"></a>
               The `matches` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the resource match.
        Supported keys: **resource_name**, **service_type**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of values corresponding to the key.
        A tag list can contain a maximum of `10` values. Tag values in a tag list must be unique.
        If the tag value list is empty, disks that contain any key can be queried.
        When there are multiple values and the key requirements are met, disks that have any of the specified values are queried.

        <a name="matches_struct"></a>
        The `matches` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


