# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ApplicationRepositoryArgs',
    'ApplicationRepositoryArgsDict',
    'ApplicationStackResourceArgs',
    'ApplicationStackResourceArgsDict',
    'AsyncInvokeConfigurationOnFailureArgs',
    'AsyncInvokeConfigurationOnFailureArgsDict',
    'AsyncInvokeConfigurationOnSuccessArgs',
    'AsyncInvokeConfigurationOnSuccessArgsDict',
    'FunctionCustomImageArgs',
    'FunctionCustomImageArgsDict',
    'FunctionFuncMountArgs',
    'FunctionFuncMountArgsDict',
    'FunctionNetworkControllerArgs',
    'FunctionNetworkControllerArgsDict',
    'FunctionNetworkControllerTriggerAccessVpcArgs',
    'FunctionNetworkControllerTriggerAccessVpcArgsDict',
    'FunctionReservedInstanceArgs',
    'FunctionReservedInstanceArgsDict',
    'FunctionReservedInstanceTacticsConfigArgs',
    'FunctionReservedInstanceTacticsConfigArgsDict',
    'FunctionReservedInstanceTacticsConfigCronConfigArgs',
    'FunctionReservedInstanceTacticsConfigCronConfigArgsDict',
    'FunctionReservedInstanceTacticsConfigMetricConfigArgs',
    'FunctionReservedInstanceTacticsConfigMetricConfigArgsDict',
    'FunctionV2CustomImageArgs',
    'FunctionV2CustomImageArgsDict',
    'FunctionV2FuncMountArgs',
    'FunctionV2FuncMountArgsDict',
    'FunctionV2NetworkControllerArgs',
    'FunctionV2NetworkControllerArgsDict',
    'FunctionV2NetworkControllerTriggerAccessVpcArgs',
    'FunctionV2NetworkControllerTriggerAccessVpcArgsDict',
    'FunctionV2ReservedInstanceArgs',
    'FunctionV2ReservedInstanceArgsDict',
    'FunctionV2ReservedInstanceTacticsConfigArgs',
    'FunctionV2ReservedInstanceTacticsConfigArgsDict',
    'FunctionV2ReservedInstanceTacticsConfigCronConfigArgs',
    'FunctionV2ReservedInstanceTacticsConfigCronConfigArgsDict',
    'FunctionV2ReservedInstanceTacticsConfigMetricConfigArgs',
    'FunctionV2ReservedInstanceTacticsConfigMetricConfigArgsDict',
    'FunctionV2VersionArgs',
    'FunctionV2VersionArgsDict',
    'FunctionV2VersionAliasesArgs',
    'FunctionV2VersionAliasesArgsDict',
    'FunctionVersionArgs',
    'FunctionVersionArgsDict',
    'FunctionVersionAliasesArgs',
    'FunctionVersionAliasesArgsDict',
    'TriggerApigArgs',
    'TriggerApigArgsDict',
    'TriggerDisArgs',
    'TriggerDisArgsDict',
    'TriggerKafkaArgs',
    'TriggerKafkaArgsDict',
    'TriggerLtsArgs',
    'TriggerLtsArgsDict',
    'TriggerObsArgs',
    'TriggerObsArgsDict',
    'TriggerSmnArgs',
    'TriggerSmnArgsDict',
    'TriggerTimerArgs',
    'TriggerTimerArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationRepositoryArgsDict(TypedDict):
        https_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP address of the repository.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project ID of the repository.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository status.
        """
        web_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository link.
        """
elif False:
    ApplicationRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationRepositoryArgs:
    def __init__(__self__, *,
                 https_url: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 web_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] https_url: The HTTP address of the repository.
        :param pulumi.Input[_builtins.str] project_id: The project ID of the repository.
        :param pulumi.Input[_builtins.str] status: The repository status.
        :param pulumi.Input[_builtins.str] web_url: The repository link.
        """
        if https_url is not None:
            pulumi.set(__self__, "https_url", https_url)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if web_url is not None:
            pulumi.set(__self__, "web_url", web_url)

    @_builtins.property
    @pulumi.getter(name="httpsUrl")
    def https_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP address of the repository.
        """
        return pulumi.get(self, "https_url")

    @https_url.setter
    def https_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "https_url", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project ID of the repository.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="webUrl")
    def web_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository link.
        """
        return pulumi.get(self, "web_url")

    @web_url.setter
    def web_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_url", value)


if not MYPY:
    class ApplicationStackResourceArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud service name.
        """
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hyperlink.
        """
        logical_resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logical resource name.
        """
        logical_resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logical resource type.
        """
        physical_resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical resource ID.
        """
        physical_resource_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical resource name.
        """
        resource_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of resource.
        """
        status_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status information.
        """
elif False:
    ApplicationStackResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationStackResourceArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 logical_resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 logical_resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 physical_resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 physical_resource_name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_status: Optional[pulumi.Input[_builtins.str]] = None,
                 status_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: The cloud service name.
        :param pulumi.Input[_builtins.str] href: The hyperlink.
        :param pulumi.Input[_builtins.str] logical_resource_name: The logical resource name.
        :param pulumi.Input[_builtins.str] logical_resource_type: The logical resource type.
        :param pulumi.Input[_builtins.str] physical_resource_id: The physical resource ID.
        :param pulumi.Input[_builtins.str] physical_resource_name: The physical resource name.
        :param pulumi.Input[_builtins.str] resource_status: The status of resource.
        :param pulumi.Input[_builtins.str] status_message: The status information.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if href is not None:
            pulumi.set(__self__, "href", href)
        if logical_resource_name is not None:
            pulumi.set(__self__, "logical_resource_name", logical_resource_name)
        if logical_resource_type is not None:
            pulumi.set(__self__, "logical_resource_type", logical_resource_type)
        if physical_resource_id is not None:
            pulumi.set(__self__, "physical_resource_id", physical_resource_id)
        if physical_resource_name is not None:
            pulumi.set(__self__, "physical_resource_name", physical_resource_name)
        if resource_status is not None:
            pulumi.set(__self__, "resource_status", resource_status)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud service name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hyperlink.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter(name="logicalResourceName")
    def logical_resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logical resource name.
        """
        return pulumi.get(self, "logical_resource_name")

    @logical_resource_name.setter
    def logical_resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical_resource_name", value)

    @_builtins.property
    @pulumi.getter(name="logicalResourceType")
    def logical_resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logical resource type.
        """
        return pulumi.get(self, "logical_resource_type")

    @logical_resource_type.setter
    def logical_resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logical_resource_type", value)

    @_builtins.property
    @pulumi.getter(name="physicalResourceId")
    def physical_resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical resource ID.
        """
        return pulumi.get(self, "physical_resource_id")

    @physical_resource_id.setter
    def physical_resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "physical_resource_id", value)

    @_builtins.property
    @pulumi.getter(name="physicalResourceName")
    def physical_resource_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical resource name.
        """
        return pulumi.get(self, "physical_resource_name")

    @physical_resource_name.setter
    def physical_resource_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "physical_resource_name", value)

    @_builtins.property
    @pulumi.getter(name="resourceStatus")
    def resource_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of resource.
        """
        return pulumi.get(self, "resource_status")

    @resource_status.setter
    def resource_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_status", value)

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status information.
        """
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status_message", value)


if not MYPY:
    class AsyncInvokeConfigurationOnFailureArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        param: pulumi.Input[_builtins.str]
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
elif False:
    AsyncInvokeConfigurationOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsyncInvokeConfigurationOnFailureArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 param: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the object type.  
               The valid values are as follows:
               + **OBS**
               + **SMN**
               + **DIS**
               + **FunctionGraph**
        :param pulumi.Input[_builtins.str] param: Specifies the parameters (map object in JSON format) corresponding to the target service.
               + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
               expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
               + The **SMN** objects include: `topic_urn`.
               + The **DIS** objects include: `stream_name`.
               + The **FunctionGraph** objects include: `func_urn` (function URN).
               
               > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
               corresponding service.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "param", param)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def param(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
        return pulumi.get(self, "param")

    @param.setter
    def param(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param", value)


if not MYPY:
    class AsyncInvokeConfigurationOnSuccessArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        param: pulumi.Input[_builtins.str]
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
elif False:
    AsyncInvokeConfigurationOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsyncInvokeConfigurationOnSuccessArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 param: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the object type.  
               The valid values are as follows:
               + **OBS**
               + **SMN**
               + **DIS**
               + **FunctionGraph**
        :param pulumi.Input[_builtins.str] param: Specifies the parameters (map object in JSON format) corresponding to the target service.
               + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
               expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
               + The **SMN** objects include: `topic_urn`.
               + The **DIS** objects include: `stream_name`.
               + The **FunctionGraph** objects include: `func_urn` (function URN).
               
               > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
               corresponding service.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "param", param)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object type.  
        The valid values are as follows:
        + **OBS**
        + **SMN**
        + **DIS**
        + **FunctionGraph**
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def param(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the parameters (map object in JSON format) corresponding to the target service.
        + The **OBS** objects include: `bucket` (bucket name), `prefix` (object directory prefix) and `expires` (object
        expiration time, the valid value ranges from `0` to `365`. If the value is `0`, the object will not expire.).
        + The **SMN** objects include: `topic_urn`.
        + The **DIS** objects include: `stream_name`.
        + The **FunctionGraph** objects include: `func_urn` (function URN).

        > If you enable the destination function, you must be ensured that the agent contains the operation authority of the
        corresponding service.
        """
        return pulumi.get(self, "param")

    @param.setter
    def param(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "param", value)


if not MYPY:
    class FunctionCustomImageArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL of SWR image, the URL must start with `swr.`.
        """
        args: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the command line arguments used to start the SWR image.  
        If multiple arguments are separated by commas (,). e.g. `-args,value`.
        If this parameter is not specified, the CMD in the image configuration will be used by default.
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the startup commands of the SWR image.  
        Multiple commands are separated by commas (,). e.g. `/bin/sh`.
        If this parameter is not specified, the entrypoint or CMD in the image configuration will be used by default.
        """
        user_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user group ID that used to run SWR image.
        """
        user_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user ID that used to run SWR image.
        """
        working_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the working directory of the SWR image.  
        If not specified, the default value is `/`.
        Currently, the folder path can only be set to `/` and it cannot be created or modified.

        <a name="function_versions"></a>
        The `versions` block supports:
        """
elif False:
    FunctionCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionCustomImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[_builtins.str]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 user_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 working_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL of SWR image, the URL must start with `swr.`.
        :param pulumi.Input[_builtins.str] args: Specifies the command line arguments used to start the SWR image.  
               If multiple arguments are separated by commas (,). e.g. `-args,value`.
               If this parameter is not specified, the CMD in the image configuration will be used by default.
        :param pulumi.Input[_builtins.str] command: Specifies the startup commands of the SWR image.  
               Multiple commands are separated by commas (,). e.g. `/bin/sh`.
               If this parameter is not specified, the entrypoint or CMD in the image configuration will be used by default.
        :param pulumi.Input[_builtins.str] user_group_id: The user group ID that used to run SWR image.
        :param pulumi.Input[_builtins.str] user_id: The user ID that used to run SWR image.
        :param pulumi.Input[_builtins.str] working_dir: Specifies the working directory of the SWR image.  
               If not specified, the default value is `/`.
               Currently, the folder path can only be set to `/` and it cannot be created or modified.
               
               <a name="function_versions"></a>
               The `versions` block supports:
        """
        pulumi.set(__self__, "url", url)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL of SWR image, the URL must start with `swr.`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the command line arguments used to start the SWR image.  
        If multiple arguments are separated by commas (,). e.g. `-args,value`.
        If this parameter is not specified, the CMD in the image configuration will be used by default.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the startup commands of the SWR image.  
        Multiple commands are separated by commas (,). e.g. `/bin/sh`.
        If this parameter is not specified, the entrypoint or CMD in the image configuration will be used by default.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user group ID that used to run SWR image.
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user ID that used to run SWR image.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the working directory of the SWR image.  
        If not specified, the default value is `/`.
        Currently, the folder path can only be set to `/` and it cannot be created or modified.

        <a name="function_versions"></a>
        The `versions` block supports:
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class FunctionFuncMountArgsDict(TypedDict):
        local_mount_path: pulumi.Input[_builtins.str]
        """
        Specifies the function access path.

        <a name="function_custom_image"></a>
        The `custom_image` block supports:
        """
        mount_resource: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the mounted resource (corresponding cloud service).
        """
        mount_share_path: pulumi.Input[_builtins.str]
        """
        Specifies the remote mount path, e.g. **192.168.0.12:/data**.
        """
        mount_type: pulumi.Input[_builtins.str]
        """
        Specifies the mount type.
        + **sfs**
        + **sfsTurbo**
        + **ecs**
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mount status.
        """
elif False:
    FunctionFuncMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionFuncMountArgs:
    def __init__(__self__, *,
                 local_mount_path: pulumi.Input[_builtins.str],
                 mount_resource: pulumi.Input[_builtins.str],
                 mount_share_path: pulumi.Input[_builtins.str],
                 mount_type: pulumi.Input[_builtins.str],
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] local_mount_path: Specifies the function access path.
               
               <a name="function_custom_image"></a>
               The `custom_image` block supports:
        :param pulumi.Input[_builtins.str] mount_resource: Specifies the ID of the mounted resource (corresponding cloud service).
        :param pulumi.Input[_builtins.str] mount_share_path: Specifies the remote mount path, e.g. **192.168.0.12:/data**.
        :param pulumi.Input[_builtins.str] mount_type: Specifies the mount type.
               + **sfs**
               + **sfsTurbo**
               + **ecs**
        :param pulumi.Input[_builtins.str] status: The mount status.
        """
        pulumi.set(__self__, "local_mount_path", local_mount_path)
        pulumi.set(__self__, "mount_resource", mount_resource)
        pulumi.set(__self__, "mount_share_path", mount_share_path)
        pulumi.set(__self__, "mount_type", mount_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the function access path.

        <a name="function_custom_image"></a>
        The `custom_image` block supports:
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_path", value)

    @_builtins.property
    @pulumi.getter(name="mountResource")
    def mount_resource(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the mounted resource (corresponding cloud service).
        """
        return pulumi.get(self, "mount_resource")

    @mount_resource.setter
    def mount_resource(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_resource", value)

    @_builtins.property
    @pulumi.getter(name="mountSharePath")
    def mount_share_path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the remote mount path, e.g. **192.168.0.12:/data**.
        """
        return pulumi.get(self, "mount_share_path")

    @mount_share_path.setter
    def mount_share_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_share_path", value)

    @_builtins.property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the mount type.
        + **sfs**
        + **sfsTurbo**
        + **ecs**
        """
        return pulumi.get(self, "mount_type")

    @mount_type.setter
    def mount_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mount status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FunctionNetworkControllerArgsDict(TypedDict):
        disable_public_network: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to disable the public network access.

        <a name="function_network_controller_trigger_access_vpcs"></a>
        The `trigger_access_vpcs` block supports:
        """
        trigger_access_vpcs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionNetworkControllerTriggerAccessVpcArgsDict']]]]
        """
        Specifies the configuration of the VPCs that can trigger the function.  
        The trigger_access_vpcs structure is documented below.
        """
elif False:
    FunctionNetworkControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionNetworkControllerArgs:
    def __init__(__self__, *,
                 disable_public_network: Optional[pulumi.Input[_builtins.bool]] = None,
                 trigger_access_vpcs: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionNetworkControllerTriggerAccessVpcArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_public_network: Specifies whether to disable the public network access.
               
               <a name="function_network_controller_trigger_access_vpcs"></a>
               The `trigger_access_vpcs` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['FunctionNetworkControllerTriggerAccessVpcArgs']]] trigger_access_vpcs: Specifies the configuration of the VPCs that can trigger the function.  
               The trigger_access_vpcs structure is documented below.
        """
        if disable_public_network is not None:
            pulumi.set(__self__, "disable_public_network", disable_public_network)
        if trigger_access_vpcs is not None:
            pulumi.set(__self__, "trigger_access_vpcs", trigger_access_vpcs)

    @_builtins.property
    @pulumi.getter(name="disablePublicNetwork")
    def disable_public_network(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to disable the public network access.

        <a name="function_network_controller_trigger_access_vpcs"></a>
        The `trigger_access_vpcs` block supports:
        """
        return pulumi.get(self, "disable_public_network")

    @disable_public_network.setter
    def disable_public_network(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_public_network", value)

    @_builtins.property
    @pulumi.getter(name="triggerAccessVpcs")
    def trigger_access_vpcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionNetworkControllerTriggerAccessVpcArgs']]]]:
        """
        Specifies the configuration of the VPCs that can trigger the function.  
        The trigger_access_vpcs structure is documented below.
        """
        return pulumi.get(self, "trigger_access_vpcs")

    @trigger_access_vpcs.setter
    def trigger_access_vpcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionNetworkControllerTriggerAccessVpcArgs']]]]):
        pulumi.set(self, "trigger_access_vpcs", value)


if not MYPY:
    class FunctionNetworkControllerTriggerAccessVpcArgsDict(TypedDict):
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the VPC that can trigger the function.
        """
        vpc_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the VPC that can trigger the function.
        """
elif False:
    FunctionNetworkControllerTriggerAccessVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionNetworkControllerTriggerAccessVpcArgs:
    def __init__(__self__, *,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] vpc_id: Specifies the ID of the VPC that can trigger the function.
        :param pulumi.Input[_builtins.str] vpc_name: Specifies the name of the VPC that can trigger the function.
        """
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vpc_name is not None:
            pulumi.set(__self__, "vpc_name", vpc_name)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the VPC that can trigger the function.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcName")
    def vpc_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the VPC that can trigger the function.
        """
        return pulumi.get(self, "vpc_name")

    @vpc_name.setter
    def vpc_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_name", value)


if not MYPY:
    class FunctionReservedInstanceArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Specifies the number of reserved instance to which the policy belongs.  
        The valid value is range from `0` to `1,000`.

        > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.
        """
        qualifier_name: pulumi.Input[_builtins.str]
        """
        Specifies the version name or alias name.
        """
        qualifier_type: pulumi.Input[_builtins.str]
        """
        Specifies the qualifier type of reserved instance.  
        The valid values are as follows:
        + **version**
        + **alias**

        > Reserved instances cannot be configured for both a function alias and the corresponding version.
        <br>For example, if the alias of the `latest` version is `1.0` and reserved instances have been configured for this
        version, no more instances can be configured for alias `1.0`.
        """
        idle_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable the idle mode.  
        Defaults to **false**.
        If this parameter is enabled, reserved instances are initialized and the mode change needs some time to take effect.
        You will still be billed at the price of reserved instances for non-idle mode in this period.
        """
        tactics_config: NotRequired[pulumi.Input['FunctionReservedInstanceTacticsConfigArgsDict']]
        """
        Specifies the auto scaling policies for reserved instance.  
        The tactics_config structure is documented below.

        <a name="function_reserved_instances_tactics_config"></a>
        The `tactics_config` block supports:
        """
elif False:
    FunctionReservedInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionReservedInstanceArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 qualifier_name: pulumi.Input[_builtins.str],
                 qualifier_type: pulumi.Input[_builtins.str],
                 idle_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 tactics_config: Optional[pulumi.Input['FunctionReservedInstanceTacticsConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] count: Specifies the number of reserved instance to which the policy belongs.  
               The valid value is range from `0` to `1,000`.
               
               > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.
        :param pulumi.Input[_builtins.str] qualifier_name: Specifies the version name or alias name.
        :param pulumi.Input[_builtins.str] qualifier_type: Specifies the qualifier type of reserved instance.  
               The valid values are as follows:
               + **version**
               + **alias**
               
               > Reserved instances cannot be configured for both a function alias and the corresponding version.
               <br>For example, if the alias of the `latest` version is `1.0` and reserved instances have been configured for this
               version, no more instances can be configured for alias `1.0`.
        :param pulumi.Input[_builtins.bool] idle_mode: Specifies whether to enable the idle mode.  
               Defaults to **false**.
               If this parameter is enabled, reserved instances are initialized and the mode change needs some time to take effect.
               You will still be billed at the price of reserved instances for non-idle mode in this period.
        :param pulumi.Input['FunctionReservedInstanceTacticsConfigArgs'] tactics_config: Specifies the auto scaling policies for reserved instance.  
               The tactics_config structure is documented below.
               
               <a name="function_reserved_instances_tactics_config"></a>
               The `tactics_config` block supports:
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "qualifier_name", qualifier_name)
        pulumi.set(__self__, "qualifier_type", qualifier_type)
        if idle_mode is not None:
            pulumi.set(__self__, "idle_mode", idle_mode)
        if tactics_config is not None:
            pulumi.set(__self__, "tactics_config", tactics_config)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of reserved instance to which the policy belongs.  
        The valid value is range from `0` to `1,000`.

        > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="qualifierName")
    def qualifier_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the version name or alias name.
        """
        return pulumi.get(self, "qualifier_name")

    @qualifier_name.setter
    def qualifier_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "qualifier_name", value)

    @_builtins.property
    @pulumi.getter(name="qualifierType")
    def qualifier_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the qualifier type of reserved instance.  
        The valid values are as follows:
        + **version**
        + **alias**

        > Reserved instances cannot be configured for both a function alias and the corresponding version.
        <br>For example, if the alias of the `latest` version is `1.0` and reserved instances have been configured for this
        version, no more instances can be configured for alias `1.0`.
        """
        return pulumi.get(self, "qualifier_type")

    @qualifier_type.setter
    def qualifier_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "qualifier_type", value)

    @_builtins.property
    @pulumi.getter(name="idleMode")
    def idle_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable the idle mode.  
        Defaults to **false**.
        If this parameter is enabled, reserved instances are initialized and the mode change needs some time to take effect.
        You will still be billed at the price of reserved instances for non-idle mode in this period.
        """
        return pulumi.get(self, "idle_mode")

    @idle_mode.setter
    def idle_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "idle_mode", value)

    @_builtins.property
    @pulumi.getter(name="tacticsConfig")
    def tactics_config(self) -> Optional[pulumi.Input['FunctionReservedInstanceTacticsConfigArgs']]:
        """
        Specifies the auto scaling policies for reserved instance.  
        The tactics_config structure is documented below.

        <a name="function_reserved_instances_tactics_config"></a>
        The `tactics_config` block supports:
        """
        return pulumi.get(self, "tactics_config")

    @tactics_config.setter
    def tactics_config(self, value: Optional[pulumi.Input['FunctionReservedInstanceTacticsConfigArgs']]):
        pulumi.set(self, "tactics_config", value)


if not MYPY:
    class FunctionReservedInstanceTacticsConfigArgsDict(TypedDict):
        cron_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigCronConfigArgsDict']]]]
        """
        Specifies the list of scheduled policy configurations.  
        The cron_configs structure is documented below.
        """
        metric_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigMetricConfigArgsDict']]]]
        """
        Specifies the list of metric policy configurations.  
        The metric_configs structure is documented below.

        > Submit a service ticket to open this function (metric policy), for the way please refer to
        the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html).

        <a name="function_reserved_instances_tactics_config_cron_configs"></a>
        The `cron_configs` block supports:
        """
elif False:
    FunctionReservedInstanceTacticsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionReservedInstanceTacticsConfigArgs:
    def __init__(__self__, *,
                 cron_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigCronConfigArgs']]]] = None,
                 metric_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigMetricConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigCronConfigArgs']]] cron_configs: Specifies the list of scheduled policy configurations.  
               The cron_configs structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigMetricConfigArgs']]] metric_configs: Specifies the list of metric policy configurations.  
               The metric_configs structure is documented below.
               
               > Submit a service ticket to open this function (metric policy), for the way please refer to
               the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html).
               
               <a name="function_reserved_instances_tactics_config_cron_configs"></a>
               The `cron_configs` block supports:
        """
        if cron_configs is not None:
            pulumi.set(__self__, "cron_configs", cron_configs)
        if metric_configs is not None:
            pulumi.set(__self__, "metric_configs", metric_configs)

    @_builtins.property
    @pulumi.getter(name="cronConfigs")
    def cron_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigCronConfigArgs']]]]:
        """
        Specifies the list of scheduled policy configurations.  
        The cron_configs structure is documented below.
        """
        return pulumi.get(self, "cron_configs")

    @cron_configs.setter
    def cron_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigCronConfigArgs']]]]):
        pulumi.set(self, "cron_configs", value)

    @_builtins.property
    @pulumi.getter(name="metricConfigs")
    def metric_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigMetricConfigArgs']]]]:
        """
        Specifies the list of metric policy configurations.  
        The metric_configs structure is documented below.

        > Submit a service ticket to open this function (metric policy), for the way please refer to
        the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-ticket/topic_0065264094.html).

        <a name="function_reserved_instances_tactics_config_cron_configs"></a>
        The `cron_configs` block supports:
        """
        return pulumi.get(self, "metric_configs")

    @metric_configs.setter
    def metric_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionReservedInstanceTacticsConfigMetricConfigArgs']]]]):
        pulumi.set(self, "metric_configs", value)


if not MYPY:
    class FunctionReservedInstanceTacticsConfigCronConfigArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Specifies the number of reserved instance to which the policy belongs.  
        The valid value is range from `0` to `1,000`.

        > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.
        """
        cron: pulumi.Input[_builtins.str]
        """
        Specifies the cron expression.  
        For the syntax, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
        """
        expired_time: pulumi.Input[_builtins.int]
        """
        Specifies the expiration timestamp of the policy. The unit is `s`, e.g. **1740560074**.

        <a name="function_reserved_instances_tactics_metric_configs"></a>
        The `metric_configs` block supports:
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        start_time: pulumi.Input[_builtins.int]
        """
        Specifies the effective timestamp of policy. The unit is `s`, e.g. **1740560074**.
        """
elif False:
    FunctionReservedInstanceTacticsConfigCronConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionReservedInstanceTacticsConfigCronConfigArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 cron: pulumi.Input[_builtins.str],
                 expired_time: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 start_time: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] count: Specifies the number of reserved instance to which the policy belongs.  
               The valid value is range from `0` to `1,000`.
               
               > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.
        :param pulumi.Input[_builtins.str] cron: Specifies the cron expression.  
               For the syntax, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
        :param pulumi.Input[_builtins.int] expired_time: Specifies the expiration timestamp of the policy. The unit is `s`, e.g. **1740560074**.
               
               <a name="function_reserved_instances_tactics_metric_configs"></a>
               The `metric_configs` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the name of metric policy.  
               The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
               allowed. The name must start with a letter and ending with a letter or digit.
        :param pulumi.Input[_builtins.int] start_time: Specifies the effective timestamp of policy. The unit is `s`, e.g. **1740560074**.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "expired_time", expired_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of reserved instance to which the policy belongs.  
        The valid value is range from `0` to `1,000`.

        > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the cron expression.  
        For the syntax, please refer to the [documentation](https://support.huaweicloud.com/intl/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron", value)

    @_builtins.property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the expiration timestamp of the policy. The unit is `s`, e.g. **1740560074**.

        <a name="function_reserved_instances_tactics_metric_configs"></a>
        The `metric_configs` block supports:
        """
        return pulumi.get(self, "expired_time")

    @expired_time.setter
    def expired_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "expired_time", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the effective timestamp of policy. The unit is `s`, e.g. **1740560074**.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class FunctionReservedInstanceTacticsConfigMetricConfigArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        """
        Specifies the minimun of traffic.  
        The valid value is range from `0` to `1,000`.

        > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.

        <a name="function_network_controller"></a>
        The `network_controller` block supports:
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        threshold: pulumi.Input[_builtins.int]
        """
        Specifies the metric policy threshold.  
        The valid value is range from `1` to `99`.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of metric policy.  
        The valid value is as follows:
        + **Concurrency**: Reserved instance usage.
        """
elif False:
    FunctionReservedInstanceTacticsConfigMetricConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionReservedInstanceTacticsConfigMetricConfigArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] min: Specifies the minimun of traffic.  
               The valid value is range from `0` to `1,000`.
               
               > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.
               
               <a name="function_network_controller"></a>
               The `network_controller` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the name of metric policy.  
               The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
               allowed. The name must start with a letter and ending with a letter or digit.
        :param pulumi.Input[_builtins.int] threshold: Specifies the metric policy threshold.  
               The valid value is range from `1` to `99`.
        :param pulumi.Input[_builtins.str] type: Specifies the type of metric policy.  
               The valid value is as follows:
               + **Concurrency**: Reserved instance usage.
        """
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the minimun of traffic.  
        The valid value is range from `0` to `1,000`.

        > The number of reserved instances must be greater than or equal to the number of reserved instances in the basic configuration.

        <a name="function_network_controller"></a>
        The `network_controller` block supports:
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the metric policy threshold.  
        The valid value is range from `1` to `99`.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of metric policy.  
        The valid value is as follows:
        + **Concurrency**: Reserved instance usage.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FunctionV2CustomImageArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The URL of SWR image.
        """
        args: NotRequired[pulumi.Input[_builtins.str]]
        """
        The command line arguments used to start the SWR image.
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        The startup commands of the SWR image.
        """
        user_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user group ID that used to run SWR image.
        """
        user_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user ID that used to run SWR image.
        """
        working_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        The working directory of the SWR image.
        """
elif False:
    FunctionV2CustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2CustomImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[_builtins.str]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 user_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 working_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The URL of SWR image.
        :param pulumi.Input[_builtins.str] args: The command line arguments used to start the SWR image.
        :param pulumi.Input[_builtins.str] command: The startup commands of the SWR image.
        :param pulumi.Input[_builtins.str] user_group_id: The user group ID that used to run SWR image.
        :param pulumi.Input[_builtins.str] user_id: The user ID that used to run SWR image.
        :param pulumi.Input[_builtins.str] working_dir: The working directory of the SWR image.
        """
        pulumi.set(__self__, "url", url)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of SWR image.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The command line arguments used to start the SWR image.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The startup commands of the SWR image.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user group ID that used to run SWR image.
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_group_id", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user ID that used to run SWR image.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The working directory of the SWR image.
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class FunctionV2FuncMountArgsDict(TypedDict):
        local_mount_path: pulumi.Input[_builtins.str]
        """
        The function access path.
        """
        mount_resource: pulumi.Input[_builtins.str]
        """
        The ID of the mounted resource (corresponding cloud service).
        """
        mount_share_path: pulumi.Input[_builtins.str]
        """
        The remote mount path.
        """
        mount_type: pulumi.Input[_builtins.str]
        """
        The mount type.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mount status.
        """
elif False:
    FunctionV2FuncMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2FuncMountArgs:
    def __init__(__self__, *,
                 local_mount_path: pulumi.Input[_builtins.str],
                 mount_resource: pulumi.Input[_builtins.str],
                 mount_share_path: pulumi.Input[_builtins.str],
                 mount_type: pulumi.Input[_builtins.str],
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] local_mount_path: The function access path.
        :param pulumi.Input[_builtins.str] mount_resource: The ID of the mounted resource (corresponding cloud service).
        :param pulumi.Input[_builtins.str] mount_share_path: The remote mount path.
        :param pulumi.Input[_builtins.str] mount_type: The mount type.
        :param pulumi.Input[_builtins.str] status: The mount status.
        """
        pulumi.set(__self__, "local_mount_path", local_mount_path)
        pulumi.set(__self__, "mount_resource", mount_resource)
        pulumi.set(__self__, "mount_share_path", mount_share_path)
        pulumi.set(__self__, "mount_type", mount_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        The function access path.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "local_mount_path", value)

    @_builtins.property
    @pulumi.getter(name="mountResource")
    def mount_resource(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the mounted resource (corresponding cloud service).
        """
        return pulumi.get(self, "mount_resource")

    @mount_resource.setter
    def mount_resource(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_resource", value)

    @_builtins.property
    @pulumi.getter(name="mountSharePath")
    def mount_share_path(self) -> pulumi.Input[_builtins.str]:
        """
        The remote mount path.
        """
        return pulumi.get(self, "mount_share_path")

    @mount_share_path.setter
    def mount_share_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_share_path", value)

    @_builtins.property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> pulumi.Input[_builtins.str]:
        """
        The mount type.
        """
        return pulumi.get(self, "mount_type")

    @mount_type.setter
    def mount_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mount status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FunctionV2NetworkControllerArgsDict(TypedDict):
        disable_public_network: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable the public network access.
        """
        trigger_access_vpcs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionV2NetworkControllerTriggerAccessVpcArgsDict']]]]
        """
        The configuration of the VPCs that can trigger the function.
        """
elif False:
    FunctionV2NetworkControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2NetworkControllerArgs:
    def __init__(__self__, *,
                 disable_public_network: Optional[pulumi.Input[_builtins.bool]] = None,
                 trigger_access_vpcs: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2NetworkControllerTriggerAccessVpcArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_public_network: Whether to disable the public network access.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionV2NetworkControllerTriggerAccessVpcArgs']]] trigger_access_vpcs: The configuration of the VPCs that can trigger the function.
        """
        if disable_public_network is not None:
            pulumi.set(__self__, "disable_public_network", disable_public_network)
        if trigger_access_vpcs is not None:
            pulumi.set(__self__, "trigger_access_vpcs", trigger_access_vpcs)

    @_builtins.property
    @pulumi.getter(name="disablePublicNetwork")
    def disable_public_network(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable the public network access.
        """
        return pulumi.get(self, "disable_public_network")

    @disable_public_network.setter
    def disable_public_network(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_public_network", value)

    @_builtins.property
    @pulumi.getter(name="triggerAccessVpcs")
    def trigger_access_vpcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2NetworkControllerTriggerAccessVpcArgs']]]]:
        """
        The configuration of the VPCs that can trigger the function.
        """
        return pulumi.get(self, "trigger_access_vpcs")

    @trigger_access_vpcs.setter
    def trigger_access_vpcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2NetworkControllerTriggerAccessVpcArgs']]]]):
        pulumi.set(self, "trigger_access_vpcs", value)


if not MYPY:
    class FunctionV2NetworkControllerTriggerAccessVpcArgsDict(TypedDict):
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the VPC that can trigger the function.
        """
        vpc_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the VPC that can trigger the function.
        """
elif False:
    FunctionV2NetworkControllerTriggerAccessVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2NetworkControllerTriggerAccessVpcArgs:
    def __init__(__self__, *,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] vpc_id: The ID of the VPC that can trigger the function.
        :param pulumi.Input[_builtins.str] vpc_name: The ID of the VPC that can trigger the function.
        """
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)
        if vpc_name is not None:
            pulumi.set(__self__, "vpc_name", vpc_name)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the VPC that can trigger the function.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcName")
    def vpc_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the VPC that can trigger the function.
        """
        return pulumi.get(self, "vpc_name")

    @vpc_name.setter
    def vpc_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_name", value)


if not MYPY:
    class FunctionV2ReservedInstanceArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        The number of reserved instance.
        """
        qualifier_name: pulumi.Input[_builtins.str]
        """
        The version name or alias name.
        """
        qualifier_type: pulumi.Input[_builtins.str]
        """
        The qualifier type of reserved instance.
        """
        idle_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable the idle mode.
        """
        tactics_config: NotRequired[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigArgsDict']]
        """
        The auto scaling policies for reserved instance.
        """
elif False:
    FunctionV2ReservedInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2ReservedInstanceArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 qualifier_name: pulumi.Input[_builtins.str],
                 qualifier_type: pulumi.Input[_builtins.str],
                 idle_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 tactics_config: Optional[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] count: The number of reserved instance.
        :param pulumi.Input[_builtins.str] qualifier_name: The version name or alias name.
        :param pulumi.Input[_builtins.str] qualifier_type: The qualifier type of reserved instance.
        :param pulumi.Input[_builtins.bool] idle_mode: Whether to enable the idle mode.
        :param pulumi.Input['FunctionV2ReservedInstanceTacticsConfigArgs'] tactics_config: The auto scaling policies for reserved instance.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "qualifier_name", qualifier_name)
        pulumi.set(__self__, "qualifier_type", qualifier_type)
        if idle_mode is not None:
            pulumi.set(__self__, "idle_mode", idle_mode)
        if tactics_config is not None:
            pulumi.set(__self__, "tactics_config", tactics_config)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        The number of reserved instance.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="qualifierName")
    def qualifier_name(self) -> pulumi.Input[_builtins.str]:
        """
        The version name or alias name.
        """
        return pulumi.get(self, "qualifier_name")

    @qualifier_name.setter
    def qualifier_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "qualifier_name", value)

    @_builtins.property
    @pulumi.getter(name="qualifierType")
    def qualifier_type(self) -> pulumi.Input[_builtins.str]:
        """
        The qualifier type of reserved instance.
        """
        return pulumi.get(self, "qualifier_type")

    @qualifier_type.setter
    def qualifier_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "qualifier_type", value)

    @_builtins.property
    @pulumi.getter(name="idleMode")
    def idle_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable the idle mode.
        """
        return pulumi.get(self, "idle_mode")

    @idle_mode.setter
    def idle_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "idle_mode", value)

    @_builtins.property
    @pulumi.getter(name="tacticsConfig")
    def tactics_config(self) -> Optional[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigArgs']]:
        """
        The auto scaling policies for reserved instance.
        """
        return pulumi.get(self, "tactics_config")

    @tactics_config.setter
    def tactics_config(self, value: Optional[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigArgs']]):
        pulumi.set(self, "tactics_config", value)


if not MYPY:
    class FunctionV2ReservedInstanceTacticsConfigArgsDict(TypedDict):
        cron_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigCronConfigArgsDict']]]]
        """
        The list of scheduled policy configurations.
        """
        metric_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigMetricConfigArgsDict']]]]
        """
        The list of metric policy configurations.
        """
elif False:
    FunctionV2ReservedInstanceTacticsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2ReservedInstanceTacticsConfigArgs:
    def __init__(__self__, *,
                 cron_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigCronConfigArgs']]]] = None,
                 metric_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigMetricConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigCronConfigArgs']]] cron_configs: The list of scheduled policy configurations.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigMetricConfigArgs']]] metric_configs: The list of metric policy configurations.
        """
        if cron_configs is not None:
            pulumi.set(__self__, "cron_configs", cron_configs)
        if metric_configs is not None:
            pulumi.set(__self__, "metric_configs", metric_configs)

    @_builtins.property
    @pulumi.getter(name="cronConfigs")
    def cron_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigCronConfigArgs']]]]:
        """
        The list of scheduled policy configurations.
        """
        return pulumi.get(self, "cron_configs")

    @cron_configs.setter
    def cron_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigCronConfigArgs']]]]):
        pulumi.set(self, "cron_configs", value)

    @_builtins.property
    @pulumi.getter(name="metricConfigs")
    def metric_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigMetricConfigArgs']]]]:
        """
        The list of metric policy configurations.
        """
        return pulumi.get(self, "metric_configs")

    @metric_configs.setter
    def metric_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionV2ReservedInstanceTacticsConfigMetricConfigArgs']]]]):
        pulumi.set(self, "metric_configs", value)


if not MYPY:
    class FunctionV2ReservedInstanceTacticsConfigCronConfigArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        The number of reserved instance to which the policy belongs.
        """
        cron: pulumi.Input[_builtins.str]
        """
        The cron expression.
        """
        expired_time: pulumi.Input[_builtins.int]
        """
        The expiration timestamp of the policy.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of scheduled policy configuration.
        """
        start_time: pulumi.Input[_builtins.int]
        """
        The effective timestamp of policy.
        """
elif False:
    FunctionV2ReservedInstanceTacticsConfigCronConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2ReservedInstanceTacticsConfigCronConfigArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 cron: pulumi.Input[_builtins.str],
                 expired_time: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 start_time: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] count: The number of reserved instance to which the policy belongs.
        :param pulumi.Input[_builtins.str] cron: The cron expression.
        :param pulumi.Input[_builtins.int] expired_time: The expiration timestamp of the policy.
        :param pulumi.Input[_builtins.str] name: The name of scheduled policy configuration.
        :param pulumi.Input[_builtins.int] start_time: The effective timestamp of policy.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "expired_time", expired_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        The number of reserved instance to which the policy belongs.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> pulumi.Input[_builtins.str]:
        """
        The cron expression.
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cron", value)

    @_builtins.property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> pulumi.Input[_builtins.int]:
        """
        The expiration timestamp of the policy.
        """
        return pulumi.get(self, "expired_time")

    @expired_time.setter
    def expired_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "expired_time", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of scheduled policy configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.int]:
        """
        The effective timestamp of policy.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class FunctionV2ReservedInstanceTacticsConfigMetricConfigArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        """
        The minimun of traffic.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of metric policy.
        """
        threshold: pulumi.Input[_builtins.int]
        """
        The metric policy threshold.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of metric policy.
        """
elif False:
    FunctionV2ReservedInstanceTacticsConfigMetricConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2ReservedInstanceTacticsConfigMetricConfigArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] min: The minimun of traffic.
        :param pulumi.Input[_builtins.str] name: The name of metric policy.
        :param pulumi.Input[_builtins.int] threshold: The metric policy threshold.
        :param pulumi.Input[_builtins.str] type: The type of metric policy.
        """
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        """
        The minimun of traffic.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of metric policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.int]:
        """
        The metric policy threshold.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of metric policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FunctionV2VersionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The version name.
        """
        aliases: NotRequired[pulumi.Input['FunctionV2VersionAliasesArgsDict']]
        """
        The aliases management for specified version.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the version.
        """
elif False:
    FunctionV2VersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2VersionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 aliases: Optional[pulumi.Input['FunctionV2VersionAliasesArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The version name.
        :param pulumi.Input['FunctionV2VersionAliasesArgs'] aliases: The aliases management for specified version.
        :param pulumi.Input[_builtins.str] description: The description of the version.
        """
        pulumi.set(__self__, "name", name)
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The version name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input['FunctionV2VersionAliasesArgs']]:
        """
        The aliases management for specified version.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input['FunctionV2VersionAliasesArgs']]):
        pulumi.set(self, "aliases", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FunctionV2VersionAliasesArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the version alias.
        """
        additional_version_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the version alias.
        """
        additional_version_weights: NotRequired[pulumi.Input[_builtins.str]]
        """
        The percentage grayscale configuration of the version alias.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the version alias.
        """
elif False:
    FunctionV2VersionAliasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionV2VersionAliasesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 additional_version_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 additional_version_weights: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the version alias.
        :param pulumi.Input[_builtins.str] additional_version_strategy: The description of the version alias.
        :param pulumi.Input[_builtins.str] additional_version_weights: The percentage grayscale configuration of the version alias.
        :param pulumi.Input[_builtins.str] description: The description of the version alias.
        """
        pulumi.set(__self__, "name", name)
        if additional_version_strategy is not None:
            pulumi.set(__self__, "additional_version_strategy", additional_version_strategy)
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the version alias.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="additionalVersionStrategy")
    def additional_version_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the version alias.
        """
        return pulumi.get(self, "additional_version_strategy")

    @additional_version_strategy.setter
    def additional_version_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_version_strategy", value)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The percentage grayscale configuration of the version alias.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_version_weights", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the version alias.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FunctionVersionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        aliases: NotRequired[pulumi.Input['FunctionVersionAliasesArgsDict']]
        """
        Specifies the aliases management for specified version.  
        The aliases structure is documented below.

        > 1. A version can configure at most **one** alias.
        <br>2. A function can have a maximum of `10` aliases.

        <a name="function_versions_aliases"></a>
        The `aliases` block supports:
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the version alias.
        """
elif False:
    FunctionVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionVersionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 aliases: Optional[pulumi.Input['FunctionVersionAliasesArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of metric policy.  
               The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
               allowed. The name must start with a letter and ending with a letter or digit.
        :param pulumi.Input['FunctionVersionAliasesArgs'] aliases: Specifies the aliases management for specified version.  
               The aliases structure is documented below.
               
               > 1. A version can configure at most **one** alias.
               <br>2. A function can have a maximum of `10` aliases.
               
               <a name="function_versions_aliases"></a>
               The `aliases` block supports:
        :param pulumi.Input[_builtins.str] description: Specifies the description of the version alias.
        """
        pulumi.set(__self__, "name", name)
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input['FunctionVersionAliasesArgs']]:
        """
        Specifies the aliases management for specified version.  
        The aliases structure is documented below.

        > 1. A version can configure at most **one** alias.
        <br>2. A function can have a maximum of `10` aliases.

        <a name="function_versions_aliases"></a>
        The `aliases` block supports:
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input['FunctionVersionAliasesArgs']]):
        pulumi.set(self, "aliases", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the version alias.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FunctionVersionAliasesArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        additional_version_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the rule grayscale configuration of the version
        alias, in JSON format.

        > Only one of `additional_version_weights` and `additional_version_strategy` can be configured.

        <a name="function_reserved_instances"></a>
        The `reserved_instances` block supports:
        """
        additional_version_weights: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the percentage grayscale configuration of the version
        alias, in JSON format.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the version alias.
        """
elif False:
    FunctionVersionAliasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionVersionAliasesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 additional_version_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 additional_version_weights: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of metric policy.  
               The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
               allowed. The name must start with a letter and ending with a letter or digit.
        :param pulumi.Input[_builtins.str] additional_version_strategy: Specifies the rule grayscale configuration of the version
               alias, in JSON format.
               
               > Only one of `additional_version_weights` and `additional_version_strategy` can be configured.
               
               <a name="function_reserved_instances"></a>
               The `reserved_instances` block supports:
        :param pulumi.Input[_builtins.str] additional_version_weights: Specifies the percentage grayscale configuration of the version
               alias, in JSON format.
        :param pulumi.Input[_builtins.str] description: Specifies the description of the version alias.
        """
        pulumi.set(__self__, "name", name)
        if additional_version_strategy is not None:
            pulumi.set(__self__, "additional_version_strategy", additional_version_strategy)
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of metric policy.  
        The valid length is limited from `1` to `60` characters, only letters, digits, hyphens (-), and underscores (_) are
        allowed. The name must start with a letter and ending with a letter or digit.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="additionalVersionStrategy")
    def additional_version_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the rule grayscale configuration of the version
        alias, in JSON format.

        > Only one of `additional_version_weights` and `additional_version_strategy` can be configured.

        <a name="function_reserved_instances"></a>
        The `reserved_instances` block supports:
        """
        return pulumi.get(self, "additional_version_strategy")

    @additional_version_strategy.setter
    def additional_version_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_version_strategy", value)

    @_builtins.property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the percentage grayscale configuration of the version
        alias, in JSON format.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_version_weights", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the version alias.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TriggerApigArgsDict(TypedDict):
        api_name: pulumi.Input[_builtins.str]
        """
        Specifies the API name. Changing this will create a new trigger resource.
        """
        env_name: pulumi.Input[_builtins.str]
        """
        Specifies the API environment name.
        Changing this will create a new trigger resource.
        """
        group_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the APIG group to which the API belongs.
        Changing this will create a new trigger resource.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the APIG dedicated instance to which the API belongs.
        Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
        """
        request_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the request protocol of the API. The valid value are
        **HTTP** and **HTTPS**. Default to **HTTPS**. Changing this will create a new trigger resource.
        """
        security_authentication: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the security authentication mode. The valid values
        are **NONE**, **APP** and **IAM**, default to **IAM**. Changing this will create a new trigger resource.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the timeout for request sending. The valid value is range form
        `1` to `60,000`, default to `5,000`. Changing this will create a new trigger resource.

        <a name="fgs_trigger_lts"></a>
        The `lts` block supports:
        """
elif False:
    TriggerApigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerApigArgs:
    def __init__(__self__, *,
                 api_name: pulumi.Input[_builtins.str],
                 env_name: pulumi.Input[_builtins.str],
                 group_id: pulumi.Input[_builtins.str],
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 security_authentication: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] api_name: Specifies the API name. Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] env_name: Specifies the API environment name.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] group_id: Specifies the ID of the APIG group to which the API belongs.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] instance_id: Specifies the ID of the APIG dedicated instance to which the API belongs.
               Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] request_protocol: Specifies the request protocol of the API. The valid value are
               **HTTP** and **HTTPS**. Default to **HTTPS**. Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] security_authentication: Specifies the security authentication mode. The valid values
               are **NONE**, **APP** and **IAM**, default to **IAM**. Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.int] timeout: Specifies the timeout for request sending. The valid value is range form
               `1` to `60,000`, default to `5,000`. Changing this will create a new trigger resource.
               
               <a name="fgs_trigger_lts"></a>
               The `lts` block supports:
        """
        pulumi.set(__self__, "api_name", api_name)
        pulumi.set(__self__, "env_name", env_name)
        pulumi.set(__self__, "group_id", group_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if security_authentication is not None:
            pulumi.set(__self__, "security_authentication", security_authentication)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="apiName")
    def api_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the API name. Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "api_name")

    @api_name.setter
    def api_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_name", value)

    @_builtins.property
    @pulumi.getter(name="envName")
    def env_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the API environment name.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "env_name")

    @env_name.setter
    def env_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "env_name", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the APIG group to which the API belongs.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the APIG dedicated instance to which the API belongs.
        Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the request protocol of the API. The valid value are
        **HTTP** and **HTTPS**. Default to **HTTPS**. Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @_builtins.property
    @pulumi.getter(name="securityAuthentication")
    def security_authentication(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the security authentication mode. The valid values
        are **NONE**, **APP** and **IAM**, default to **IAM**. Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "security_authentication")

    @security_authentication.setter
    def security_authentication(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_authentication", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the timeout for request sending. The valid value is range form
        `1` to `60,000`, default to `5,000`. Changing this will create a new trigger resource.

        <a name="fgs_trigger_lts"></a>
        The `lts` block supports:
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class TriggerDisArgsDict(TypedDict):
        max_fetch_bytes: pulumi.Input[_builtins.int]
        """
        Specifies the maximum volume of data that can be obtained for a single
        request, in Byte. Only the records with a size smaller than this value can be obtained.
        The valid value is range from `1,024` to `4,194,304`.
        Changing this will create a new trigger resource.
        """
        pull_period: pulumi.Input[_builtins.int]
        """
        Specifies the interval at which data is pulled from the specified stream.
        The valid value is range from `2` to `60,000`.
        Changing this will create a new trigger resource.
        """
        serial_enable: pulumi.Input[_builtins.bool]
        """
        Specifies the determines whether to pull data only after the data pulled
        in the last period has been processed.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_kafka"></a>
        The `kafka` block supports:
        """
        starting_position: pulumi.Input[_builtins.str]
        """
        Specifies the type of starting position for DIS queue.
        The valid values are as follows:
        + **TRIM_HORIZON**: Starts reading from the earliest data stored in the partitions.
        + **LATEST**: Starts reading from the latest data stored in the partitions.
        Changing this will create a new trigger resource.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the DIS stream resource.
        Changing this will create a new trigger resource.
        """
elif False:
    TriggerDisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerDisArgs:
    def __init__(__self__, *,
                 max_fetch_bytes: pulumi.Input[_builtins.int],
                 pull_period: pulumi.Input[_builtins.int],
                 serial_enable: pulumi.Input[_builtins.bool],
                 starting_position: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] max_fetch_bytes: Specifies the maximum volume of data that can be obtained for a single
               request, in Byte. Only the records with a size smaller than this value can be obtained.
               The valid value is range from `1,024` to `4,194,304`.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.int] pull_period: Specifies the interval at which data is pulled from the specified stream.
               The valid value is range from `2` to `60,000`.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.bool] serial_enable: Specifies the determines whether to pull data only after the data pulled
               in the last period has been processed.
               Changing this will create a new trigger resource.
               
               <a name="fgs_trigger_kafka"></a>
               The `kafka` block supports:
        :param pulumi.Input[_builtins.str] starting_position: Specifies the type of starting position for DIS queue.
               The valid values are as follows:
               + **TRIM_HORIZON**: Starts reading from the earliest data stored in the partitions.
               + **LATEST**: Starts reading from the latest data stored in the partitions.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] stream_name: Specifies the name of the DIS stream resource.
               Changing this will create a new trigger resource.
        """
        pulumi.set(__self__, "max_fetch_bytes", max_fetch_bytes)
        pulumi.set(__self__, "pull_period", pull_period)
        pulumi.set(__self__, "serial_enable", serial_enable)
        pulumi.set(__self__, "starting_position", starting_position)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="maxFetchBytes")
    def max_fetch_bytes(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the maximum volume of data that can be obtained for a single
        request, in Byte. Only the records with a size smaller than this value can be obtained.
        The valid value is range from `1,024` to `4,194,304`.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "max_fetch_bytes")

    @max_fetch_bytes.setter
    def max_fetch_bytes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_fetch_bytes", value)

    @_builtins.property
    @pulumi.getter(name="pullPeriod")
    def pull_period(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the interval at which data is pulled from the specified stream.
        The valid value is range from `2` to `60,000`.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "pull_period")

    @pull_period.setter
    def pull_period(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "pull_period", value)

    @_builtins.property
    @pulumi.getter(name="serialEnable")
    def serial_enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies the determines whether to pull data only after the data pulled
        in the last period has been processed.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_kafka"></a>
        The `kafka` block supports:
        """
        return pulumi.get(self, "serial_enable")

    @serial_enable.setter
    def serial_enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "serial_enable", value)

    @_builtins.property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of starting position for DIS queue.
        The valid values are as follows:
        + **TRIM_HORIZON**: Starts reading from the earliest data stored in the partitions.
        + **LATEST**: Starts reading from the latest data stored in the partitions.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "starting_position", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the DIS stream resource.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class TriggerKafkaArgsDict(TypedDict):
        instance_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the APIG dedicated instance to which the API belongs.
        Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
        """
        topic_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies one or more topic IDs of DMS kafka instance.
        Changing this will create a new trigger resource.
        """
        batch_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the The number of messages consumed from the topic each time.
        The valid value is range from `1` to `1,000`. Defaults to `100`.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_apig"></a>
        The `apig` block supports:
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the password for logging in to the Kafka Manager.
        Changing this will create a new trigger resource.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the username for logging in to the Kafka Manager.
        Changing this will create a new trigger resource.
        """
elif False:
    TriggerKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerKafkaArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[_builtins.str],
                 topic_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 batch_size: Optional[pulumi.Input[_builtins.int]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_id: Specifies the ID of the APIG dedicated instance to which the API belongs.
               Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] topic_ids: Specifies one or more topic IDs of DMS kafka instance.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.int] batch_size: Specifies the The number of messages consumed from the topic each time.
               The valid value is range from `1` to `1,000`. Defaults to `100`.
               Changing this will create a new trigger resource.
               
               <a name="fgs_trigger_apig"></a>
               The `apig` block supports:
        :param pulumi.Input[_builtins.str] password: Specifies the password for logging in to the Kafka Manager.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] user_name: Specifies the username for logging in to the Kafka Manager.
               Changing this will create a new trigger resource.
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "topic_ids", topic_ids)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the APIG dedicated instance to which the API belongs.
        Required if the `type` is `DEDICATEDGATEWAY`. Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="topicIds")
    def topic_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies one or more topic IDs of DMS kafka instance.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "topic_ids")

    @topic_ids.setter
    def topic_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "topic_ids", value)

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the The number of messages consumed from the topic each time.
        The valid value is range from `1` to `1,000`. Defaults to `100`.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_apig"></a>
        The `apig` block supports:
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_size", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the password for logging in to the Kafka Manager.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the username for logging in to the Kafka Manager.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class TriggerLtsArgsDict(TypedDict):
        log_group_id: pulumi.Input[_builtins.str]
        """
        Specifies the log group ID.
        Changing this will create a new trigger resource.
        """
        log_topic_id: pulumi.Input[_builtins.str]
        """
        Specifies the log stream ID.
        Changing this will create a new trigger resource.
        """
elif False:
    TriggerLtsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerLtsArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[_builtins.str],
                 log_topic_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] log_group_id: Specifies the log group ID.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] log_topic_id: Specifies the log stream ID.
               Changing this will create a new trigger resource.
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_topic_id", log_topic_id)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log group ID.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logTopicId")
    def log_topic_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the log stream ID.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "log_topic_id")

    @log_topic_id.setter
    def log_topic_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_topic_id", value)


if not MYPY:
    class TriggerObsArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Specifies the OBS bucket name.
        Changing this will create a new trigger resource.
        """
        event_notification_name: pulumi.Input[_builtins.str]
        """
        Specifies the event notification name.
        Changing this will create a new trigger resource.
        """
        events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the events that can trigger functions.
        Changing this will create a new trigger resource.
        The valid values are as follows:
        + **ObjectCreated**, **Put**, **Post**, **Copy** and **CompleteMultipartUpload**.
        + **ObjectRemoved**, **Delete** and **DeleteMarkerCreated**.

        > **NOTE:** If **ObjectCreated** is configured, **Put**, **Post**, **Copy** and **CompleteMultipartUpload** cannot
        be configured. If **ObjectRemoved** is configured, **Delete** and **DeleteMarkerCreated** cannot be configured.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prefix to limit notifications to objects beginning with this keyword.
        Changing this will create a new trigger resource.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the suffix to limit notifications to objects ending with this keyword.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_smn"></a>
        The `smn` block supports:
        """
elif False:
    TriggerObsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerObsArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 event_notification_name: pulumi.Input[_builtins.str],
                 events: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Specifies the OBS bucket name.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] event_notification_name: Specifies the event notification name.
               Changing this will create a new trigger resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] events: Specifies the events that can trigger functions.
               Changing this will create a new trigger resource.
               The valid values are as follows:
               + **ObjectCreated**, **Put**, **Post**, **Copy** and **CompleteMultipartUpload**.
               + **ObjectRemoved**, **Delete** and **DeleteMarkerCreated**.
               
               > **NOTE:** If **ObjectCreated** is configured, **Put**, **Post**, **Copy** and **CompleteMultipartUpload** cannot
               be configured. If **ObjectRemoved** is configured, **Delete** and **DeleteMarkerCreated** cannot be configured.
        :param pulumi.Input[_builtins.str] prefix: Specifies the prefix to limit notifications to objects beginning with this keyword.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] suffix: Specifies the suffix to limit notifications to objects ending with this keyword.
               Changing this will create a new trigger resource.
               
               <a name="fgs_trigger_smn"></a>
               The `smn` block supports:
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "event_notification_name", event_notification_name)
        pulumi.set(__self__, "events", events)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the OBS bucket name.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="eventNotificationName")
    def event_notification_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the event notification name.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "event_notification_name")

    @event_notification_name.setter
    def event_notification_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_notification_name", value)

    @_builtins.property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the events that can trigger functions.
        Changing this will create a new trigger resource.
        The valid values are as follows:
        + **ObjectCreated**, **Put**, **Post**, **Copy** and **CompleteMultipartUpload**.
        + **ObjectRemoved**, **Delete** and **DeleteMarkerCreated**.

        > **NOTE:** If **ObjectCreated** is configured, **Put**, **Post**, **Copy** and **CompleteMultipartUpload** cannot
        be configured. If **ObjectRemoved** is configured, **Delete** and **DeleteMarkerCreated** cannot be configured.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prefix to limit notifications to objects beginning with this keyword.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the suffix to limit notifications to objects ending with this keyword.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_smn"></a>
        The `smn` block supports:
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class TriggerSmnArgsDict(TypedDict):
        topic_urn: pulumi.Input[_builtins.str]
        """
        Specifies the Uniform Resource Name (URN) for SMN topic.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_dis"></a>
        The `dis` block supports:
        """
elif False:
    TriggerSmnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerSmnArgs:
    def __init__(__self__, *,
                 topic_urn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] topic_urn: Specifies the Uniform Resource Name (URN) for SMN topic.
               Changing this will create a new trigger resource.
               
               <a name="fgs_trigger_dis"></a>
               The `dis` block supports:
        """
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Uniform Resource Name (URN) for SMN topic.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_dis"></a>
        The `dis` block supports:
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic_urn", value)


if not MYPY:
    class TriggerTimerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the trigger name, which can contains of `1` to `64` characters.
        The name must start with a letter, only letters, digits, hyphens (-) and underscores (_) are allowed.
        Changing this will create a new trigger resource.
        """
        schedule: pulumi.Input[_builtins.str]
        """
        Specifies the time schedule.
        For the rate type, schedule is composed of time and time unit.
        The time unit supports minutes (m), hours (h) and days (d).
        For the corn expression, please refer to the HuaweiCloud
        [document](https://support.huaweicloud.com/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
        Changing this will create a new trigger resource.
        """
        schedule_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the time schedule.
        The valid values are **Rate** and **Cron**.
        Changing this will create a new trigger resource.
        """
        additional_information: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the event used by the timer to trigger the function.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_obs"></a>
        The `obs` block supports:
        """
elif False:
    TriggerTimerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TriggerTimerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 schedule: pulumi.Input[_builtins.str],
                 schedule_type: pulumi.Input[_builtins.str],
                 additional_information: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the trigger name, which can contains of `1` to `64` characters.
               The name must start with a letter, only letters, digits, hyphens (-) and underscores (_) are allowed.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] schedule: Specifies the time schedule.
               For the rate type, schedule is composed of time and time unit.
               The time unit supports minutes (m), hours (h) and days (d).
               For the corn expression, please refer to the HuaweiCloud
               [document](https://support.huaweicloud.com/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] schedule_type: Specifies the type of the time schedule.
               The valid values are **Rate** and **Cron**.
               Changing this will create a new trigger resource.
        :param pulumi.Input[_builtins.str] additional_information: Specifies the event used by the timer to trigger the function.
               Changing this will create a new trigger resource.
               
               <a name="fgs_trigger_obs"></a>
               The `obs` block supports:
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "schedule_type", schedule_type)
        if additional_information is not None:
            pulumi.set(__self__, "additional_information", additional_information)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the trigger name, which can contains of `1` to `64` characters.
        The name must start with a letter, only letters, digits, hyphens (-) and underscores (_) are allowed.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the time schedule.
        For the rate type, schedule is composed of time and time unit.
        The time unit supports minutes (m), hours (h) and days (d).
        For the corn expression, please refer to the HuaweiCloud
        [document](https://support.huaweicloud.com/en-us/usermanual-functiongraph/functiongraph_01_0908.html).
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schedule", value)

    @_builtins.property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the time schedule.
        The valid values are **Rate** and **Cron**.
        Changing this will create a new trigger resource.
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schedule_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalInformation")
    def additional_information(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the event used by the timer to trigger the function.
        Changing this will create a new trigger resource.

        <a name="fgs_trigger_obs"></a>
        The `obs` block supports:
        """
        return pulumi.get(self, "additional_information")

    @additional_information.setter
    def additional_information(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_information", value)


