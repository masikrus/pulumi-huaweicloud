# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ClusterBackupStrategyArgs',
    'ClusterBackupStrategyArgsDict',
    'ClusterClientNodeConfigArgs',
    'ClusterClientNodeConfigArgsDict',
    'ClusterClientNodeConfigVolumeArgs',
    'ClusterClientNodeConfigVolumeArgsDict',
    'ClusterColdNodeConfigArgs',
    'ClusterColdNodeConfigArgsDict',
    'ClusterColdNodeConfigVolumeArgs',
    'ClusterColdNodeConfigVolumeArgsDict',
    'ClusterEssNodeConfigArgs',
    'ClusterEssNodeConfigArgsDict',
    'ClusterEssNodeConfigVolumeArgs',
    'ClusterEssNodeConfigVolumeArgsDict',
    'ClusterKibanaPublicAccessArgs',
    'ClusterKibanaPublicAccessArgsDict',
    'ClusterMasterNodeConfigArgs',
    'ClusterMasterNodeConfigArgsDict',
    'ClusterMasterNodeConfigVolumeArgs',
    'ClusterMasterNodeConfigVolumeArgsDict',
    'ClusterNodeArgs',
    'ClusterNodeArgsDict',
    'ClusterNodeConfigArgs',
    'ClusterNodeConfigArgsDict',
    'ClusterNodeConfigNetworkInfoArgs',
    'ClusterNodeConfigNetworkInfoArgsDict',
    'ClusterNodeConfigVolumeArgs',
    'ClusterNodeConfigVolumeArgsDict',
    'ClusterPublicAccessArgs',
    'ClusterPublicAccessArgsDict',
    'ClusterV1BackupStrategyArgs',
    'ClusterV1BackupStrategyArgsDict',
    'ClusterV1ClientNodeConfigArgs',
    'ClusterV1ClientNodeConfigArgsDict',
    'ClusterV1ClientNodeConfigVolumeArgs',
    'ClusterV1ClientNodeConfigVolumeArgsDict',
    'ClusterV1ColdNodeConfigArgs',
    'ClusterV1ColdNodeConfigArgsDict',
    'ClusterV1ColdNodeConfigVolumeArgs',
    'ClusterV1ColdNodeConfigVolumeArgsDict',
    'ClusterV1EssNodeConfigArgs',
    'ClusterV1EssNodeConfigArgsDict',
    'ClusterV1EssNodeConfigVolumeArgs',
    'ClusterV1EssNodeConfigVolumeArgsDict',
    'ClusterV1KibanaPublicAccessArgs',
    'ClusterV1KibanaPublicAccessArgsDict',
    'ClusterV1MasterNodeConfigArgs',
    'ClusterV1MasterNodeConfigArgsDict',
    'ClusterV1MasterNodeConfigVolumeArgs',
    'ClusterV1MasterNodeConfigVolumeArgsDict',
    'ClusterV1NodeArgs',
    'ClusterV1NodeArgsDict',
    'ClusterV1NodeConfigArgs',
    'ClusterV1NodeConfigArgsDict',
    'ClusterV1NodeConfigNetworkInfoArgs',
    'ClusterV1NodeConfigNetworkInfoArgsDict',
    'ClusterV1NodeConfigVolumeArgs',
    'ClusterV1NodeConfigVolumeArgsDict',
    'ClusterV1PublicAccessArgs',
    'ClusterV1PublicAccessArgsDict',
    'ClusterV1VpcepEndpointArgs',
    'ClusterV1VpcepEndpointArgsDict',
    'ClusterVpcepEndpointArgs',
    'ClusterVpcepEndpointArgsDict',
    'EsCoreUpgradeUpgradeDetailArgs',
    'EsCoreUpgradeUpgradeDetailArgsDict',
    'EsCoreUpgradeUpgradeDetailDatastoreArgs',
    'EsCoreUpgradeUpgradeDetailDatastoreArgsDict',
    'EsLoadbalancerConfigHealthMonitorArgs',
    'EsLoadbalancerConfigHealthMonitorArgsDict',
    'EsLoadbalancerConfigListenerArgs',
    'EsLoadbalancerConfigListenerArgsDict',
    'EsLoadbalancerConfigListenerIpGroupArgs',
    'EsLoadbalancerConfigListenerIpGroupArgsDict',
    'EsLoadbalancerConfigLoadbalancerArgs',
    'EsLoadbalancerConfigLoadbalancerArgsDict',
    'LogstashClusterNodeArgs',
    'LogstashClusterNodeArgsDict',
    'LogstashClusterNodeConfigArgs',
    'LogstashClusterNodeConfigArgsDict',
    'LogstashClusterNodeConfigVolumeArgs',
    'LogstashClusterNodeConfigVolumeArgsDict',
    'LogstashClusterRouteArgs',
    'LogstashClusterRouteArgsDict',
    'LogstashConfigurationSettingArgs',
    'LogstashConfigurationSettingArgsDict',
    'LogstashConnectivityAddressAndPortArgs',
    'LogstashConnectivityAddressAndPortArgsDict',
    'LogstashConnectivityConnectivityResultArgs',
    'LogstashConnectivityConnectivityResultArgsDict',
    'LogstashPipelinePipelineArgs',
    'LogstashPipelinePipelineArgsDict',
    'LogstashPipelinePipelineEventArgs',
    'LogstashPipelinePipelineEventArgsDict',
    'ScanTaskAlarmArgs',
    'ScanTaskAlarmArgsDict',
    'ScanTaskSummaryArgs',
    'ScanTaskSummaryArgsDict',
    'ScanTaskTaskRiskArgs',
    'ScanTaskTaskRiskArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterBackupStrategyArgsDict(TypedDict):
        start_time: pulumi.Input[_builtins.str]
        """
        Specifies the time when a snapshot is automatically created everyday. Snapshots can
        only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
        format, **HH:mm** refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
        and "01:00 GMT+08:00".
        """
        agency: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IAM agency used to access OBS.

        > **NOTE:**  If the `bucket`, `backup_path`, and `agency` parameters are empty at the same time, the system will
        automatically create an OBS bucket and IAM agent, otherwise the configured parameter values will be used.
        """
        backup_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the storage path of the snapshot in the OBS bucket.
        """
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
        bucket, only the OBS bucket is used and cannot be changed.
        """
        keep_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days to retain the generated snapshots. Snapshots are reserved
        for seven days by default.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the prefix of the snapshot that is automatically created. Defaults to **snapshot**.
        """
elif False:
    ClusterBackupStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterBackupStrategyArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[_builtins.str],
                 agency: Optional[pulumi.Input[_builtins.str]] = None,
                 backup_path: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_days: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] start_time: Specifies the time when a snapshot is automatically created everyday. Snapshots can
               only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
               format, **HH:mm** refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
               and "01:00 GMT+08:00".
        :param pulumi.Input[_builtins.str] agency: Specifies the IAM agency used to access OBS.
               
               > **NOTE:**  If the `bucket`, `backup_path`, and `agency` parameters are empty at the same time, the system will
               automatically create an OBS bucket and IAM agent, otherwise the configured parameter values will be used.
        :param pulumi.Input[_builtins.str] backup_path: Specifies the storage path of the snapshot in the OBS bucket.
        :param pulumi.Input[_builtins.str] bucket: Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
               bucket, only the OBS bucket is used and cannot be changed.
        :param pulumi.Input[_builtins.int] keep_days: Specifies the number of days to retain the generated snapshots. Snapshots are reserved
               for seven days by default.
        :param pulumi.Input[_builtins.str] prefix: Specifies the prefix of the snapshot that is automatically created. Defaults to **snapshot**.
        """
        pulumi.set(__self__, "start_time", start_time)
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if backup_path is not None:
            pulumi.set(__self__, "backup_path", backup_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if keep_days is not None:
            pulumi.set(__self__, "keep_days", keep_days)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the time when a snapshot is automatically created everyday. Snapshots can
        only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
        format, **HH:mm** refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
        and "01:00 GMT+08:00".
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter
    def agency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IAM agency used to access OBS.

        > **NOTE:**  If the `bucket`, `backup_path`, and `agency` parameters are empty at the same time, the system will
        automatically create an OBS bucket and IAM agent, otherwise the configured parameter values will be used.
        """
        return pulumi.get(self, "agency")

    @agency.setter
    def agency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agency", value)

    @_builtins.property
    @pulumi.getter(name="backupPath")
    def backup_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the storage path of the snapshot in the OBS bucket.
        """
        return pulumi.get(self, "backup_path")

    @backup_path.setter
    def backup_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_path", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
        bucket, only the OBS bucket is used and cannot be changed.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="keepDays")
    def keep_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days to retain the generated snapshots. Snapshots are reserved
        for seven days by default.
        """
        return pulumi.get(self, "keep_days")

    @keep_days.setter
    def keep_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_days", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the prefix of the snapshot that is automatically created. Defaults to **snapshot**.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ClusterClientNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor name.
        """
        instance_number: pulumi.Input[_builtins.int]
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        volume: pulumi.Input['ClusterClientNodeConfigVolumeArgsDict']
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
elif False:
    ClusterClientNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 volume: pulumi.Input['ClusterClientNodeConfigVolumeArgs'],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor name.
        :param pulumi.Input[_builtins.int] instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param pulumi.Input['ClusterClientNodeConfigVolumeArgs'] volume: Specifies the information about the volume.
               The volume structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> pulumi.Input['ClusterClientNodeConfigVolumeArgs']:
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['ClusterClientNodeConfigVolumeArgs']):
        pulumi.set(self, "volume", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)


if not MYPY:
    class ClusterClientNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
elif False:
    ClusterClientNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClientNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterColdNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor name.
        """
        instance_number: pulumi.Input[_builtins.int]
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        volume: NotRequired[pulumi.Input['ClusterColdNodeConfigVolumeArgsDict']]
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
elif False:
    ClusterColdNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterColdNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input['ClusterColdNodeConfigVolumeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor name.
        :param pulumi.Input[_builtins.int] instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the instance type.
               The valid values are as follows:
               + **ess**
               + **chinese**
               + **english**
               + **arabic**
               + **tools**
               + **thai**
               + **turkish**
               + **portuguese**
               + **chinese-english**
               + **spanish**
        :param pulumi.Input['ClusterColdNodeConfigVolumeArgs'] volume: Specifies the information about the volume.
               The volume structure is documented below.
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input['ClusterColdNodeConfigVolumeArgs']]:
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input['ClusterColdNodeConfigVolumeArgs']]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterColdNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
elif False:
    ClusterColdNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterColdNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterEssNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor name.
        """
        instance_number: pulumi.Input[_builtins.int]
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        volume: NotRequired[pulumi.Input['ClusterEssNodeConfigVolumeArgsDict']]
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
elif False:
    ClusterEssNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEssNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input['ClusterEssNodeConfigVolumeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor name.
        :param pulumi.Input[_builtins.int] instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the instance type.
               The valid values are as follows:
               + **ess**
               + **chinese**
               + **english**
               + **arabic**
               + **tools**
               + **thai**
               + **turkish**
               + **portuguese**
               + **chinese-english**
               + **spanish**
        :param pulumi.Input['ClusterEssNodeConfigVolumeArgs'] volume: Specifies the information about the volume.
               The volume structure is documented below.
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input['ClusterEssNodeConfigVolumeArgs']]:
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input['ClusterEssNodeConfigVolumeArgs']]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterEssNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
elif False:
    ClusterEssNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEssNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterKibanaPublicAccessArgsDict(TypedDict):
        bandwidth: pulumi.Input[_builtins.int]
        """
        Specifies the public network bandwidth.
        """
        whitelist_enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable the public network access control.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        whitelist: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
elif False:
    ClusterKibanaPublicAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKibanaPublicAccessArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input[_builtins.int],
                 whitelist_enabled: pulumi.Input[_builtins.bool],
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 whitelist: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] bandwidth: Specifies the public network bandwidth.
        :param pulumi.Input[_builtins.bool] whitelist_enabled: Specifies whether to enable the public network access control.
        :param pulumi.Input[_builtins.str] whitelist: Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the public network bandwidth.
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable the public network access control.
        """
        return pulumi.get(self, "whitelist_enabled")

    @whitelist_enabled.setter
    def whitelist_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "whitelist_enabled", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        return pulumi.get(self, "whitelist")

    @whitelist.setter
    def whitelist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "whitelist", value)


if not MYPY:
    class ClusterMasterNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor name.
        """
        instance_number: pulumi.Input[_builtins.int]
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        volume: pulumi.Input['ClusterMasterNodeConfigVolumeArgsDict']
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
elif False:
    ClusterMasterNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 volume: pulumi.Input['ClusterMasterNodeConfigVolumeArgs'],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor name.
        :param pulumi.Input[_builtins.int] instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param pulumi.Input['ClusterMasterNodeConfigVolumeArgs'] volume: Specifies the information about the volume.
               The volume structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> pulumi.Input['ClusterMasterNodeConfigVolumeArgs']:
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['ClusterMasterNodeConfigVolumeArgs']):
        pulumi.set(self, "volume", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)


if not MYPY:
    class ClusterMasterNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
elif False:
    ClusterMasterNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterMasterNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterNodeArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance ID.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance IP address.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cluster name. It contains `4` to `32` characters.
        Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        Changing this parameter will create a new resource.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of this instance.
        """
        spec_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance specification code.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance status.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
elif False:
    ClusterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 spec_code: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: Specifies the availability zone name.
               Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
               than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
               distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
               between node quantity in any two AZs is **1** at most.
        :param pulumi.Input[_builtins.str] id: Instance ID.
        :param pulumi.Input[_builtins.str] ip: Instance IP address.
        :param pulumi.Input[_builtins.str] name: Specifies the cluster name. It contains `4` to `32` characters.
               Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] resource_id: The resource ID of this instance.
        :param pulumi.Input[_builtins.str] spec_code: Instance specification code.
        :param pulumi.Input[_builtins.str] status: Instance status.
        :param pulumi.Input[_builtins.str] type: Specifies the instance type.
               The valid values are as follows:
               + **ess**
               + **chinese**
               + **english**
               + **arabic**
               + **tools**
               + **thai**
               + **turkish**
               + **portuguese**
               + **chinese-english**
               + **spanish**
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if spec_code is not None:
            pulumi.set(__self__, "spec_code", spec_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cluster name. It contains `4` to `32` characters.
        Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of this instance.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance specification code.
        """
        return pulumi.get(self, "spec_code")

    @spec_code.setter
    def spec_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec_code", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterNodeConfigArgsDict(TypedDict):
        availability_zone: pulumi.Input[_builtins.str]
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        """
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor name.
        """
        network_info: pulumi.Input['ClusterNodeConfigNetworkInfoArgsDict']
        volume: pulumi.Input['ClusterNodeConfigVolumeArgsDict']
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
elif False:
    ClusterNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeConfigArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[_builtins.str],
                 flavor: pulumi.Input[_builtins.str],
                 network_info: pulumi.Input['ClusterNodeConfigNetworkInfoArgs'],
                 volume: pulumi.Input['ClusterNodeConfigVolumeArgs']):
        """
        :param pulumi.Input[_builtins.str] availability_zone: Specifies the availability zone name.
               Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
               than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
               distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
               between node quantity in any two AZs is **1** at most.
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor name.
        :param pulumi.Input['ClusterNodeConfigVolumeArgs'] volume: Specifies the information about the volume.
               The volume structure is documented below.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "network_info", network_info)
        pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> pulumi.Input['ClusterNodeConfigNetworkInfoArgs']:
        return pulumi.get(self, "network_info")

    @network_info.setter
    def network_info(self, value: pulumi.Input['ClusterNodeConfigNetworkInfoArgs']):
        pulumi.set(self, "network_info", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> pulumi.Input['ClusterNodeConfigVolumeArgs']:
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['ClusterNodeConfigVolumeArgs']):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterNodeConfigNetworkInfoArgsDict(TypedDict):
        security_group_id: pulumi.Input[_builtins.str]
        """
        Specifies the security group ID.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        Specifies the Subnet ID.
        Changing this parameter will create a new resource.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        Specifies the VPC ID.
        Changing this parameter will create a new resource.
        """
elif False:
    ClusterNodeConfigNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeConfigNetworkInfoArgs:
    def __init__(__self__, *,
                 security_group_id: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] security_group_id: Specifies the security group ID.
        :param pulumi.Input[_builtins.str] subnet_id: Specifies the Subnet ID.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] vpc_id: Specifies the VPC ID.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the Subnet ID.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the VPC ID.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class ClusterNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
elif False:
    ClusterNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterPublicAccessArgsDict(TypedDict):
        bandwidth: pulumi.Input[_builtins.int]
        """
        Specifies the public network bandwidth.
        """
        whitelist_enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable the public network access control.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        whitelist: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
elif False:
    ClusterPublicAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPublicAccessArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input[_builtins.int],
                 whitelist_enabled: pulumi.Input[_builtins.bool],
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 whitelist: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] bandwidth: Specifies the public network bandwidth.
        :param pulumi.Input[_builtins.bool] whitelist_enabled: Specifies whether to enable the public network access control.
        :param pulumi.Input[_builtins.str] whitelist: Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the public network bandwidth.
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable the public network access control.
        """
        return pulumi.get(self, "whitelist_enabled")

    @whitelist_enabled.setter
    def whitelist_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "whitelist_enabled", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        return pulumi.get(self, "whitelist")

    @whitelist.setter
    def whitelist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "whitelist", value)


if not MYPY:
    class ClusterV1BackupStrategyArgsDict(TypedDict):
        start_time: pulumi.Input[_builtins.str]
        agency: NotRequired[pulumi.Input[_builtins.str]]
        backup_path: NotRequired[pulumi.Input[_builtins.str]]
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        keep_days: NotRequired[pulumi.Input[_builtins.int]]
        prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV1BackupStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1BackupStrategyArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[_builtins.str],
                 agency: Optional[pulumi.Input[_builtins.str]] = None,
                 backup_path: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 keep_days: Optional[pulumi.Input[_builtins.int]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "start_time", start_time)
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if backup_path is not None:
            pulumi.set(__self__, "backup_path", backup_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if keep_days is not None:
            pulumi.set(__self__, "keep_days", keep_days)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter
    def agency(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "agency")

    @agency.setter
    def agency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agency", value)

    @_builtins.property
    @pulumi.getter(name="backupPath")
    def backup_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "backup_path")

    @backup_path.setter
    def backup_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_path", value)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="keepDays")
    def keep_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "keep_days")

    @keep_days.setter
    def keep_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_days", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class ClusterV1ClientNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        instance_number: pulumi.Input[_builtins.int]
        volume: pulumi.Input['ClusterV1ClientNodeConfigVolumeArgsDict']
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterV1ClientNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1ClientNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 volume: pulumi.Input['ClusterV1ClientNodeConfigVolumeArgs'],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> pulumi.Input['ClusterV1ClientNodeConfigVolumeArgs']:
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['ClusterV1ClientNodeConfigVolumeArgs']):
        pulumi.set(self, "volume", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)


if not MYPY:
    class ClusterV1ClientNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        volume_type: pulumi.Input[_builtins.str]
elif False:
    ClusterV1ClientNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1ClientNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterV1ColdNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        instance_number: pulumi.Input[_builtins.int]
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        volume: NotRequired[pulumi.Input['ClusterV1ColdNodeConfigVolumeArgsDict']]
elif False:
    ClusterV1ColdNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1ColdNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input['ClusterV1ColdNodeConfigVolumeArgs']] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input['ClusterV1ColdNodeConfigVolumeArgs']]:
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input['ClusterV1ColdNodeConfigVolumeArgs']]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterV1ColdNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        volume_type: pulumi.Input[_builtins.str]
elif False:
    ClusterV1ColdNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1ColdNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterV1EssNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        instance_number: pulumi.Input[_builtins.int]
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        type: NotRequired[pulumi.Input[_builtins.str]]
        volume: NotRequired[pulumi.Input['ClusterV1EssNodeConfigVolumeArgsDict']]
elif False:
    ClusterV1EssNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1EssNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 volume: Optional[pulumi.Input['ClusterV1EssNodeConfigVolumeArgs']] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input['ClusterV1EssNodeConfigVolumeArgs']]:
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input['ClusterV1EssNodeConfigVolumeArgs']]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterV1EssNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        volume_type: pulumi.Input[_builtins.str]
elif False:
    ClusterV1EssNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1EssNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterV1KibanaPublicAccessArgsDict(TypedDict):
        bandwidth: pulumi.Input[_builtins.int]
        whitelist_enabled: pulumi.Input[_builtins.bool]
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        whitelist: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV1KibanaPublicAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1KibanaPublicAccessArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input[_builtins.int],
                 whitelist_enabled: pulumi.Input[_builtins.bool],
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 whitelist: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "whitelist_enabled")

    @whitelist_enabled.setter
    def whitelist_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "whitelist_enabled", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "whitelist")

    @whitelist.setter
    def whitelist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "whitelist", value)


if not MYPY:
    class ClusterV1MasterNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        instance_number: pulumi.Input[_builtins.int]
        volume: pulumi.Input['ClusterV1MasterNodeConfigVolumeArgsDict']
        shrink_node_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterV1MasterNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1MasterNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 volume: pulumi.Input['ClusterV1MasterNodeConfigVolumeArgs'],
                 shrink_node_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> pulumi.Input['ClusterV1MasterNodeConfigVolumeArgs']:
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['ClusterV1MasterNodeConfigVolumeArgs']):
        pulumi.set(self, "volume", value)

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "shrink_node_ids")

    @shrink_node_ids.setter
    def shrink_node_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shrink_node_ids", value)


if not MYPY:
    class ClusterV1MasterNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        volume_type: pulumi.Input[_builtins.str]
elif False:
    ClusterV1MasterNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1MasterNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterV1NodeArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        ip: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        spec_code: NotRequired[pulumi.Input[_builtins.str]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV1NodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1NodeArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 spec_code: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if spec_code is not None:
            pulumi.set(__self__, "spec_code", spec_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "spec_code")

    @spec_code.setter
    def spec_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec_code", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterV1NodeConfigArgsDict(TypedDict):
        availability_zone: pulumi.Input[_builtins.str]
        flavor: pulumi.Input[_builtins.str]
        network_info: pulumi.Input['ClusterV1NodeConfigNetworkInfoArgsDict']
        volume: pulumi.Input['ClusterV1NodeConfigVolumeArgsDict']
elif False:
    ClusterV1NodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1NodeConfigArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[_builtins.str],
                 flavor: pulumi.Input[_builtins.str],
                 network_info: pulumi.Input['ClusterV1NodeConfigNetworkInfoArgs'],
                 volume: pulumi.Input['ClusterV1NodeConfigVolumeArgs']):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "network_info", network_info)
        pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> pulumi.Input['ClusterV1NodeConfigNetworkInfoArgs']:
        return pulumi.get(self, "network_info")

    @network_info.setter
    def network_info(self, value: pulumi.Input['ClusterV1NodeConfigNetworkInfoArgs']):
        pulumi.set(self, "network_info", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> pulumi.Input['ClusterV1NodeConfigVolumeArgs']:
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['ClusterV1NodeConfigVolumeArgs']):
        pulumi.set(self, "volume", value)


if not MYPY:
    class ClusterV1NodeConfigNetworkInfoArgsDict(TypedDict):
        security_group_id: pulumi.Input[_builtins.str]
        subnet_id: pulumi.Input[_builtins.str]
        vpc_id: pulumi.Input[_builtins.str]
elif False:
    ClusterV1NodeConfigNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1NodeConfigNetworkInfoArgs:
    def __init__(__self__, *,
                 security_group_id: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class ClusterV1NodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        volume_type: pulumi.Input[_builtins.str]
elif False:
    ClusterV1NodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1NodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class ClusterV1PublicAccessArgsDict(TypedDict):
        bandwidth: pulumi.Input[_builtins.int]
        whitelist_enabled: pulumi.Input[_builtins.bool]
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        whitelist: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ClusterV1PublicAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1PublicAccessArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input[_builtins.int],
                 whitelist_enabled: pulumi.Input[_builtins.bool],
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 whitelist: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "whitelist_enabled")

    @whitelist_enabled.setter
    def whitelist_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "whitelist_enabled", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "whitelist")

    @whitelist.setter
    def whitelist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "whitelist", value)


if not MYPY:
    class ClusterV1VpcepEndpointArgsDict(TypedDict):
        endpoint_with_dns_name: pulumi.Input[_builtins.bool]
        whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ClusterV1VpcepEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV1VpcepEndpointArgs:
    def __init__(__self__, *,
                 endpoint_with_dns_name: pulumi.Input[_builtins.bool],
                 whitelists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "endpoint_with_dns_name", endpoint_with_dns_name)
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @_builtins.property
    @pulumi.getter(name="endpointWithDnsName")
    def endpoint_with_dns_name(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "endpoint_with_dns_name")

    @endpoint_with_dns_name.setter
    def endpoint_with_dns_name(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "endpoint_with_dns_name", value)

    @_builtins.property
    @pulumi.getter
    def whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "whitelists")

    @whitelists.setter
    def whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "whitelists", value)


if not MYPY:
    class ClusterVpcepEndpointArgsDict(TypedDict):
        endpoint_with_dns_name: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable the private domain name.
        """
        whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
elif False:
    ClusterVpcepEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterVpcepEndpointArgs:
    def __init__(__self__, *,
                 endpoint_with_dns_name: pulumi.Input[_builtins.bool],
                 whitelists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] endpoint_with_dns_name: Specifies whether to enable the private domain name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] whitelists: Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        pulumi.set(__self__, "endpoint_with_dns_name", endpoint_with_dns_name)
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @_builtins.property
    @pulumi.getter(name="endpointWithDnsName")
    def endpoint_with_dns_name(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable the private domain name.
        """
        return pulumi.get(self, "endpoint_with_dns_name")

    @endpoint_with_dns_name.setter
    def endpoint_with_dns_name(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "endpoint_with_dns_name", value)

    @_builtins.property
    @pulumi.getter
    def whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        return pulumi.get(self, "whitelists")

    @whitelists.setter
    def whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "whitelists", value)


if not MYPY:
    class EsCoreUpgradeUpgradeDetailArgsDict(TypedDict):
        agency: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IAM agency used to access CSS.
        """
        datastores: NotRequired[pulumi.Input[Sequence[pulumi.Input['EsCoreUpgradeUpgradeDetailDatastoreArgsDict']]]]
        """
        The data store.
        The datastore structure is documented below.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The end time.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The job ID of the upgrade task.
        """
        retry_times: NotRequired[pulumi.Input[_builtins.str]]
        """
        The retry times.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The start time.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status.
        """
        total_nodes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The all nodes.
        """
elif False:
    EsCoreUpgradeUpgradeDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EsCoreUpgradeUpgradeDetailArgs:
    def __init__(__self__, *,
                 agency: Optional[pulumi.Input[_builtins.str]] = None,
                 datastores: Optional[pulumi.Input[Sequence[pulumi.Input['EsCoreUpgradeUpgradeDetailDatastoreArgs']]]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 retry_times: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 total_nodes: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agency: Specifies the IAM agency used to access CSS.
        :param pulumi.Input[Sequence[pulumi.Input['EsCoreUpgradeUpgradeDetailDatastoreArgs']]] datastores: The data store.
               The datastore structure is documented below.
        :param pulumi.Input[_builtins.str] end_time: The end time.
        :param pulumi.Input[_builtins.str] id: The job ID of the upgrade task.
        :param pulumi.Input[_builtins.str] retry_times: The retry times.
        :param pulumi.Input[_builtins.str] start_time: The start time.
        :param pulumi.Input[_builtins.str] status: The status.
        :param pulumi.Input[_builtins.str] total_nodes: The all nodes.
        """
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if datastores is not None:
            pulumi.set(__self__, "datastores", datastores)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retry_times is not None:
            pulumi.set(__self__, "retry_times", retry_times)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if total_nodes is not None:
            pulumi.set(__self__, "total_nodes", total_nodes)

    @_builtins.property
    @pulumi.getter
    def agency(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IAM agency used to access CSS.
        """
        return pulumi.get(self, "agency")

    @agency.setter
    def agency(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agency", value)

    @_builtins.property
    @pulumi.getter
    def datastores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EsCoreUpgradeUpgradeDetailDatastoreArgs']]]]:
        """
        The data store.
        The datastore structure is documented below.
        """
        return pulumi.get(self, "datastores")

    @datastores.setter
    def datastores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EsCoreUpgradeUpgradeDetailDatastoreArgs']]]]):
        pulumi.set(self, "datastores", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The job ID of the upgrade task.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="retryTimes")
    def retry_times(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The retry times.
        """
        return pulumi.get(self, "retry_times")

    @retry_times.setter
    def retry_times(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retry_times", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="totalNodes")
    def total_nodes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The all nodes.
        """
        return pulumi.get(self, "total_nodes")

    @total_nodes.setter
    def total_nodes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "total_nodes", value)


if not MYPY:
    class EsCoreUpgradeUpgradeDetailDatastoreArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the data store.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the data store.
        """
elif False:
    EsCoreUpgradeUpgradeDetailDatastoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EsCoreUpgradeUpgradeDetailDatastoreArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data store.
        :param pulumi.Input[_builtins.str] version: The version of the data store.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the data store.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the data store.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class EsLoadbalancerConfigHealthMonitorArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address corresponding to the backend server.
        """
        protocol_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the front-end listening port of the listener.
        Changing this creates a new resource.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The health status of the backend cloud server.
        """
elif False:
    EsLoadbalancerConfigHealthMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EsLoadbalancerConfigHealthMonitorArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_port: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: The IP address corresponding to the backend server.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the front-end listening port of the listener.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] status: The health status of the backend cloud server.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if protocol_port is not None:
            pulumi.set(__self__, "protocol_port", protocol_port)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address corresponding to the backend server.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the front-end listening port of the listener.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protocol_port", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The health status of the backend cloud server.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class EsLoadbalancerConfigListenerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the access control group associated with the listener.
        """
        ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['EsLoadbalancerConfigListenerIpGroupArgsDict']]]]
        """
        The ipgroup information in the listener object.
        The ip_group structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The listener name.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The listening protocol of the listener.
        """
        protocol_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the front-end listening port of the listener.
        Changing this creates a new resource.
        """
elif False:
    EsLoadbalancerConfigListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EsLoadbalancerConfigListenerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input['EsLoadbalancerConfigListenerIpGroupArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the access control group associated with the listener.
        :param pulumi.Input[Sequence[pulumi.Input['EsLoadbalancerConfigListenerIpGroupArgs']]] ip_groups: The ipgroup information in the listener object.
               The ip_group structure is documented below.
        :param pulumi.Input[_builtins.str] name: The listener name.
        :param pulumi.Input[_builtins.str] protocol: The listening protocol of the listener.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the front-end listening port of the listener.
               Changing this creates a new resource.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_groups is not None:
            pulumi.set(__self__, "ip_groups", ip_groups)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_port is not None:
            pulumi.set(__self__, "protocol_port", protocol_port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the access control group associated with the listener.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipGroups")
    def ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EsLoadbalancerConfigListenerIpGroupArgs']]]]:
        """
        The ipgroup information in the listener object.
        The ip_group structure is documented below.
        """
        return pulumi.get(self, "ip_groups")

    @ip_groups.setter
    def ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EsLoadbalancerConfigListenerIpGroupArgs']]]]):
        pulumi.set(self, "ip_groups", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The listener name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The listening protocol of the listener.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the front-end listening port of the listener.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "protocol_port", value)


if not MYPY:
    class EsLoadbalancerConfigListenerIpGroupArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The status of the access control group.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the access control group associated with the listener.
        """
elif False:
    EsLoadbalancerConfigListenerIpGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EsLoadbalancerConfigListenerIpGroupArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: The status of the access control group.
        :param pulumi.Input[_builtins.str] id: The ID of the access control group associated with the listener.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The status of the access control group.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the access control group associated with the listener.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class EsLoadbalancerConfigLoadbalancerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the access control group associated with the listener.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address corresponding to the backend server.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The listener name.
        """
        public_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The elastic public IP address.
        """
elif False:
    EsLoadbalancerConfigLoadbalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EsLoadbalancerConfigLoadbalancerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the access control group associated with the listener.
        :param pulumi.Input[_builtins.str] ip: The IP address corresponding to the backend server.
        :param pulumi.Input[_builtins.str] name: The listener name.
        :param pulumi.Input[_builtins.str] public_ip: The elastic public IP address.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the access control group associated with the listener.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address corresponding to the backend server.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The listener name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The elastic public IP address.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_ip", value)


if not MYPY:
    class LogstashClusterNodeArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        Changing this parameter will create a new resource.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance ID.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance IP address.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cluster name. It contains `4` to `32` characters.
        Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of this instance.
        """
        spec_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance specification code.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instance status.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Node type.
        """
elif False:
    LogstashClusterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashClusterNodeArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 spec_code: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: Specifies the availability zone name.
               Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
               than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
               distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
               between node quantity in any two AZs is **1** at most.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] id: Instance ID.
        :param pulumi.Input[_builtins.str] ip: Instance IP address.
        :param pulumi.Input[_builtins.str] name: Specifies the cluster name. It contains `4` to `32` characters.
               Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        :param pulumi.Input[_builtins.str] resource_id: The resource ID of this instance.
        :param pulumi.Input[_builtins.str] spec_code: Instance specification code.
        :param pulumi.Input[_builtins.str] status: Instance status.
        :param pulumi.Input[_builtins.str] type: Node type.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if spec_code is not None:
            pulumi.set(__self__, "spec_code", spec_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cluster name. It contains `4` to `32` characters.
        Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of this instance.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance specification code.
        """
        return pulumi.get(self, "spec_code")

    @spec_code.setter
    def spec_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spec_code", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instance status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Node type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LogstashClusterNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor name. The value options are as follows:
        + **ess.spec-4u8g**: The value range of the flavor is `40` GB to `1,500` GB.
        + **ess.spec-4u16g**: The value range of the flavor is `40` GB to `1,600` GB.
        + **ess.spec-4u32g**: The value range of the flavor is `40` GB to `2,560` GB.
        + **ess.spec-8u16g**: The value range of the flavor is `80` GB to `1,600` GB.
        + **ess.spec-8u32g**: The value range of the flavor is `80` GB to `3,200` GB.
        + **ess.spec-8u64g**: The value range of the flavor is `80` GB to `5,120` GB.
        + **ess.spec-16u32g**: The value range of the flavor is `100` GB to `3,200` GB.
        + **ess.spec-16u64g**: The value range of the flavor is `100` GB to `6,400` GB.
        + **ess.spec-32u64g**: The value range of the flavor is `100` GB to `10,240` GB.
        + **ess.spec-32u128g**: The value range of the flavor is `100` GB to `10,240` GB.
        Changing this parameter will create a new resource.
        """
        instance_number: pulumi.Input[_builtins.int]
        """
        Specifies the number of cluster instances. The value range is `1` to `32`.
        """
        volume: NotRequired[pulumi.Input['LogstashClusterNodeConfigVolumeArgsDict']]
        """
        Specifies the information about the volume.
        The volume structure is documented below. Changing this parameter will create a new resource.

        <a name="Css_volume"></a>
        The `volume` block supports:
        """
elif False:
    LogstashClusterNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashClusterNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 instance_number: pulumi.Input[_builtins.int],
                 volume: Optional[pulumi.Input['LogstashClusterNodeConfigVolumeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor name. The value options are as follows:
               + **ess.spec-4u8g**: The value range of the flavor is `40` GB to `1,500` GB.
               + **ess.spec-4u16g**: The value range of the flavor is `40` GB to `1,600` GB.
               + **ess.spec-4u32g**: The value range of the flavor is `40` GB to `2,560` GB.
               + **ess.spec-8u16g**: The value range of the flavor is `80` GB to `1,600` GB.
               + **ess.spec-8u32g**: The value range of the flavor is `80` GB to `3,200` GB.
               + **ess.spec-8u64g**: The value range of the flavor is `80` GB to `5,120` GB.
               + **ess.spec-16u32g**: The value range of the flavor is `100` GB to `3,200` GB.
               + **ess.spec-16u64g**: The value range of the flavor is `100` GB to `6,400` GB.
               + **ess.spec-32u64g**: The value range of the flavor is `100` GB to `10,240` GB.
               + **ess.spec-32u128g**: The value range of the flavor is `100` GB to `10,240` GB.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] instance_number: Specifies the number of cluster instances. The value range is `1` to `32`.
        :param pulumi.Input['LogstashClusterNodeConfigVolumeArgs'] volume: Specifies the information about the volume.
               The volume structure is documented below. Changing this parameter will create a new resource.
               
               <a name="Css_volume"></a>
               The `volume` block supports:
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor name. The value options are as follows:
        + **ess.spec-4u8g**: The value range of the flavor is `40` GB to `1,500` GB.
        + **ess.spec-4u16g**: The value range of the flavor is `40` GB to `1,600` GB.
        + **ess.spec-4u32g**: The value range of the flavor is `40` GB to `2,560` GB.
        + **ess.spec-8u16g**: The value range of the flavor is `80` GB to `1,600` GB.
        + **ess.spec-8u32g**: The value range of the flavor is `80` GB to `3,200` GB.
        + **ess.spec-8u64g**: The value range of the flavor is `80` GB to `5,120` GB.
        + **ess.spec-16u32g**: The value range of the flavor is `100` GB to `3,200` GB.
        + **ess.spec-16u64g**: The value range of the flavor is `100` GB to `6,400` GB.
        + **ess.spec-32u64g**: The value range of the flavor is `100` GB to `10,240` GB.
        + **ess.spec-32u128g**: The value range of the flavor is `100` GB to `10,240` GB.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of cluster instances. The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional[pulumi.Input['LogstashClusterNodeConfigVolumeArgs']]:
        """
        Specifies the information about the volume.
        The volume structure is documented below. Changing this parameter will create a new resource.

        <a name="Css_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: Optional[pulumi.Input['LogstashClusterNodeConfigVolumeArgs']]):
        pulumi.set(self, "volume", value)


if not MYPY:
    class LogstashClusterNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the volume size in GB, which must be a multiple of `10`.
        Changing this parameter will create a new resource.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the volume type. The value options are as follows:
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
        + **ESSD**: Extreme speed I/O. The SATA disk is used.
        Changing this parameter will create a new resource.

        <a name="Css_route"></a>
        The `routes` block supports:
        """
elif False:
    LogstashClusterNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashClusterNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the volume size in GB, which must be a multiple of `10`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the volume type. The value options are as follows:
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               + **ESSD**: Extreme speed I/O. The SATA disk is used.
               Changing this parameter will create a new resource.
               
               <a name="Css_route"></a>
               The `routes` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the volume size in GB, which must be a multiple of `10`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume type. The value options are as follows:
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
        + **ESSD**: Extreme speed I/O. The SATA disk is used.
        Changing this parameter will create a new resource.

        <a name="Css_route"></a>
        The `routes` block supports:
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class LogstashClusterRouteArgsDict(TypedDict):
        ip_address: pulumi.Input[_builtins.str]
        """
        Specifies the route ip address.
        """
        ip_net_mask: pulumi.Input[_builtins.str]
        """
        Specifies the subnet mask of the route ip address.
        """
elif False:
    LogstashClusterRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashClusterRouteArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str],
                 ip_net_mask: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip_address: Specifies the route ip address.
        :param pulumi.Input[_builtins.str] ip_net_mask: Specifies the subnet mask of the route ip address.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ip_net_mask", ip_net_mask)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the route ip address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipNetMask")
    def ip_net_mask(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the subnet mask of the route ip address.
        """
        return pulumi.get(self, "ip_net_mask")

    @ip_net_mask.setter
    def ip_net_mask(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_net_mask", value)


if not MYPY:
    class LogstashConfigurationSettingArgsDict(TypedDict):
        queue_type: pulumi.Input[_builtins.str]
        """
        Specifies internal queue model for event buffering.
        + **memory:** a traditional memory-based queue.
        + **persisted:** a disk-based ACKed persistence queue.
        """
        batch_delay_ms: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum time in the unit of milliseconds for each event to be
        waited for by pipeline scheduling.
        """
        batch_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of events a single worker thread will collect
        from inputs before attempting to execute its **Filters** and **Outputs**. Larger values ​​are generally more
        efficient but increase memory overhead. Default is `125`.
        """
        queue_check_point_writes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of events to be written before forcing
        a checkpoint when using a persistent queue, default is `1,024`.
        """
        queue_max_bytes_mb: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the total capacity of the persistent queue in megabytes (MB) when
        using a persistent queue. Make sure the disk is larger than this value. The default value is `1,024`.
        """
        workers: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of worker threads in the **Filters** + **Outputs** stage of
        the execution pipeline. The default value is the number of CPU cores.
        """
elif False:
    LogstashConfigurationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashConfigurationSettingArgs:
    def __init__(__self__, *,
                 queue_type: pulumi.Input[_builtins.str],
                 batch_delay_ms: Optional[pulumi.Input[_builtins.int]] = None,
                 batch_size: Optional[pulumi.Input[_builtins.int]] = None,
                 queue_check_point_writes: Optional[pulumi.Input[_builtins.int]] = None,
                 queue_max_bytes_mb: Optional[pulumi.Input[_builtins.int]] = None,
                 workers: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] queue_type: Specifies internal queue model for event buffering.
               + **memory:** a traditional memory-based queue.
               + **persisted:** a disk-based ACKed persistence queue.
        :param pulumi.Input[_builtins.int] batch_delay_ms: Specifies the minimum time in the unit of milliseconds for each event to be
               waited for by pipeline scheduling.
        :param pulumi.Input[_builtins.int] batch_size: Specifies the maximum number of events a single worker thread will collect
               from inputs before attempting to execute its **Filters** and **Outputs**. Larger values ​​are generally more
               efficient but increase memory overhead. Default is `125`.
        :param pulumi.Input[_builtins.int] queue_check_point_writes: Specifies the maximum number of events to be written before forcing
               a checkpoint when using a persistent queue, default is `1,024`.
        :param pulumi.Input[_builtins.int] queue_max_bytes_mb: Specifies the total capacity of the persistent queue in megabytes (MB) when
               using a persistent queue. Make sure the disk is larger than this value. The default value is `1,024`.
        :param pulumi.Input[_builtins.int] workers: Specifies the number of worker threads in the **Filters** + **Outputs** stage of
               the execution pipeline. The default value is the number of CPU cores.
        """
        pulumi.set(__self__, "queue_type", queue_type)
        if batch_delay_ms is not None:
            pulumi.set(__self__, "batch_delay_ms", batch_delay_ms)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if queue_check_point_writes is not None:
            pulumi.set(__self__, "queue_check_point_writes", queue_check_point_writes)
        if queue_max_bytes_mb is not None:
            pulumi.set(__self__, "queue_max_bytes_mb", queue_max_bytes_mb)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter(name="queueType")
    def queue_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies internal queue model for event buffering.
        + **memory:** a traditional memory-based queue.
        + **persisted:** a disk-based ACKed persistence queue.
        """
        return pulumi.get(self, "queue_type")

    @queue_type.setter
    def queue_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue_type", value)

    @_builtins.property
    @pulumi.getter(name="batchDelayMs")
    def batch_delay_ms(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum time in the unit of milliseconds for each event to be
        waited for by pipeline scheduling.
        """
        return pulumi.get(self, "batch_delay_ms")

    @batch_delay_ms.setter
    def batch_delay_ms(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_delay_ms", value)

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of events a single worker thread will collect
        from inputs before attempting to execute its **Filters** and **Outputs**. Larger values ​​are generally more
        efficient but increase memory overhead. Default is `125`.
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "batch_size", value)

    @_builtins.property
    @pulumi.getter(name="queueCheckPointWrites")
    def queue_check_point_writes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of events to be written before forcing
        a checkpoint when using a persistent queue, default is `1,024`.
        """
        return pulumi.get(self, "queue_check_point_writes")

    @queue_check_point_writes.setter
    def queue_check_point_writes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "queue_check_point_writes", value)

    @_builtins.property
    @pulumi.getter(name="queueMaxBytesMb")
    def queue_max_bytes_mb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the total capacity of the persistent queue in megabytes (MB) when
        using a persistent queue. Make sure the disk is larger than this value. The default value is `1,024`.
        """
        return pulumi.get(self, "queue_max_bytes_mb")

    @queue_max_bytes_mb.setter
    def queue_max_bytes_mb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "queue_max_bytes_mb", value)

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of worker threads in the **Filters** + **Outputs** stage of
        the execution pipeline. The default value is the number of CPU cores.
        """
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "workers", value)


if not MYPY:
    class LogstashConnectivityAddressAndPortArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        Specifies the ip address.
        """
        port: pulumi.Input[_builtins.int]
        """
        Specifies the port.
        """
elif False:
    LogstashConnectivityAddressAndPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashConnectivityAddressAndPortArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] address: Specifies the ip address.
        :param pulumi.Input[_builtins.int] port: Specifies the port.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ip address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class LogstashConnectivityConnectivityResultArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ip address.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the port.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The connectivity test result.
        """
elif False:
    LogstashConnectivityConnectivityResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashConnectivityConnectivityResultArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: Specifies the ip address.
        :param pulumi.Input[_builtins.int] port: Specifies the port.
        :param pulumi.Input[_builtins.str] status: The connectivity test result.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ip address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The connectivity test result.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class LogstashPipelinePipelineArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogstashPipelinePipelineEventArgsDict']]]]
        """
        The event of the CSS logstash cluster pipeline.
        The events structure is documented below.
        """
        keep_alive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether keep alive. The value can be **true** and **false**.
        Defaults to **false**. During hot start, the value of keep alive of existing pipelines in the cluster needs to
        be consistent.
        Changing this creates a new resource.

        > **NOTE:** Keepalive can be enabled for long-running services. Enabling it will configure a daemon process
        on each node. If the Logstash service is faulty, the daemon process will rectify the fault and restart the
        service. Do not enable it for short running services, or your migration tasks may fail due to lack of source data.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The configuration file name of the CSS logstash cluster.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the CSS logstash cluster pipeline.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The update time of the CSS logstash cluster pipeline.
        """
elif False:
    LogstashPipelinePipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashPipelinePipelineArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input['LogstashPipelinePipelineEventArgs']]]] = None,
                 keep_alive: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LogstashPipelinePipelineEventArgs']]] events: The event of the CSS logstash cluster pipeline.
               The events structure is documented below.
        :param pulumi.Input[_builtins.bool] keep_alive: Specifies whether keep alive. The value can be **true** and **false**.
               Defaults to **false**. During hot start, the value of keep alive of existing pipelines in the cluster needs to
               be consistent.
               Changing this creates a new resource.
               
               > **NOTE:** Keepalive can be enabled for long-running services. Enabling it will configure a daemon process
               on each node. If the Logstash service is faulty, the daemon process will rectify the fault and restart the
               service. Do not enable it for short running services, or your migration tasks may fail due to lack of source data.
        :param pulumi.Input[_builtins.str] name: The configuration file name of the CSS logstash cluster.
        :param pulumi.Input[_builtins.str] status: The status of the CSS logstash cluster pipeline.
        :param pulumi.Input[_builtins.str] updated_at: The update time of the CSS logstash cluster pipeline.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if keep_alive is not None:
            pulumi.set(__self__, "keep_alive", keep_alive)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogstashPipelinePipelineEventArgs']]]]:
        """
        The event of the CSS logstash cluster pipeline.
        The events structure is documented below.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogstashPipelinePipelineEventArgs']]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether keep alive. The value can be **true** and **false**.
        Defaults to **false**. During hot start, the value of keep alive of existing pipelines in the cluster needs to
        be consistent.
        Changing this creates a new resource.

        > **NOTE:** Keepalive can be enabled for long-running services. Enabling it will configure a daemon process
        on each node. If the Logstash service is faulty, the daemon process will rectify the fault and restart the
        service. Do not enable it for short running services, or your migration tasks may fail due to lack of source data.
        """
        return pulumi.get(self, "keep_alive")

    @keep_alive.setter
    def keep_alive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "keep_alive", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The configuration file name of the CSS logstash cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The update time of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class LogstashPipelinePipelineEventArgsDict(TypedDict):
        filtered: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of data to be filtered.
        """
        in_: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of received data that needs to be processed.
        """
        out: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of output data.
        """
elif False:
    LogstashPipelinePipelineEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogstashPipelinePipelineEventArgs:
    def __init__(__self__, *,
                 filtered: Optional[pulumi.Input[_builtins.int]] = None,
                 in_: Optional[pulumi.Input[_builtins.int]] = None,
                 out: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] filtered: The number of data to be filtered.
        :param pulumi.Input[_builtins.int] in_: The number of received data that needs to be processed.
        :param pulumi.Input[_builtins.int] out: The number of output data.
        """
        if filtered is not None:
            pulumi.set(__self__, "filtered", filtered)
        if in_ is not None:
            pulumi.set(__self__, "in_", in_)
        if out is not None:
            pulumi.set(__self__, "out", out)

    @_builtins.property
    @pulumi.getter
    def filtered(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of data to be filtered.
        """
        return pulumi.get(self, "filtered")

    @filtered.setter
    def filtered(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "filtered", value)

    @_builtins.property
    @pulumi.getter(name="in")
    def in_(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of received data that needs to be processed.
        """
        return pulumi.get(self, "in_")

    @in_.setter
    def in_(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "in_", value)

    @_builtins.property
    @pulumi.getter
    def out(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of output data.
        """
        return pulumi.get(self, "out")

    @out.setter
    def out(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "out", value)


if not MYPY:
    class ScanTaskAlarmArgsDict(TypedDict):
        level: pulumi.Input[_builtins.str]
        """
        Specifies the level of alarm messages found by the cluster scan task.
        The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        """
        smn_topic: pulumi.Input[_builtins.str]
        """
        Specifies the name of the SMN topic.
        """
elif False:
    ScanTaskAlarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScanTaskAlarmArgs:
    def __init__(__self__, *,
                 level: pulumi.Input[_builtins.str],
                 smn_topic: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] level: Specifies the level of alarm messages found by the cluster scan task.
               The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        :param pulumi.Input[_builtins.str] smn_topic: Specifies the name of the SMN topic.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "smn_topic", smn_topic)

    @_builtins.property
    @pulumi.getter
    def level(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the level of alarm messages found by the cluster scan task.
        The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter(name="smnTopic")
    def smn_topic(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the SMN topic.
        """
        return pulumi.get(self, "smn_topic")

    @smn_topic.setter
    def smn_topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "smn_topic", value)


if not MYPY:
    class ScanTaskSummaryArgsDict(TypedDict):
        high_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of high-risk items found by the cluster scan task.
        """
        medium_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of medium-risk items found by the cluster scan task.
        """
        suggestion_num: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of suggestions found by the cluster scan task.
        """
elif False:
    ScanTaskSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScanTaskSummaryArgs:
    def __init__(__self__, *,
                 high_num: Optional[pulumi.Input[_builtins.int]] = None,
                 medium_num: Optional[pulumi.Input[_builtins.int]] = None,
                 suggestion_num: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] high_num: The number of high-risk items found by the cluster scan task.
        :param pulumi.Input[_builtins.int] medium_num: The number of medium-risk items found by the cluster scan task.
        :param pulumi.Input[_builtins.int] suggestion_num: The number of suggestions found by the cluster scan task.
        """
        if high_num is not None:
            pulumi.set(__self__, "high_num", high_num)
        if medium_num is not None:
            pulumi.set(__self__, "medium_num", medium_num)
        if suggestion_num is not None:
            pulumi.set(__self__, "suggestion_num", suggestion_num)

    @_builtins.property
    @pulumi.getter(name="highNum")
    def high_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of high-risk items found by the cluster scan task.
        """
        return pulumi.get(self, "high_num")

    @high_num.setter
    def high_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "high_num", value)

    @_builtins.property
    @pulumi.getter(name="mediumNum")
    def medium_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of medium-risk items found by the cluster scan task.
        """
        return pulumi.get(self, "medium_num")

    @medium_num.setter
    def medium_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "medium_num", value)

    @_builtins.property
    @pulumi.getter(name="suggestionNum")
    def suggestion_num(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of suggestions found by the cluster scan task.
        """
        return pulumi.get(self, "suggestion_num")

    @suggestion_num.setter
    def suggestion_num(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "suggestion_num", value)


if not MYPY:
    class ScanTaskTaskRiskArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of the cluster scan task.
        Changing this creates a new resource.
        """
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the level of alarm messages found by the cluster scan task.
        The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        """
        risk: NotRequired[pulumi.Input[_builtins.str]]
        """
        The risk item.
        """
        suggestion: NotRequired[pulumi.Input[_builtins.str]]
        """
        The suggestion on how to resolve this risk item.
        """
elif False:
    ScanTaskTaskRiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScanTaskTaskRiskArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None,
                 risk: Optional[pulumi.Input[_builtins.str]] = None,
                 suggestion: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Specifies the description of the cluster scan task.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] level: Specifies the level of alarm messages found by the cluster scan task.
               The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        :param pulumi.Input[_builtins.str] risk: The risk item.
        :param pulumi.Input[_builtins.str] suggestion: The suggestion on how to resolve this risk item.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if risk is not None:
            pulumi.set(__self__, "risk", risk)
        if suggestion is not None:
            pulumi.set(__self__, "suggestion", suggestion)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of the cluster scan task.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the level of alarm messages found by the cluster scan task.
        The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def risk(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The risk item.
        """
        return pulumi.get(self, "risk")

    @risk.setter
    def risk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "risk", value)

    @_builtins.property
    @pulumi.getter
    def suggestion(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The suggestion on how to resolve this risk item.
        """
        return pulumi.get(self, "suggestion")

    @suggestion.setter
    def suggestion(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suggestion", value)


