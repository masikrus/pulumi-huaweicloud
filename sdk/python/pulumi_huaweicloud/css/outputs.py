# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ClusterBackupStrategy',
    'ClusterClientNodeConfig',
    'ClusterClientNodeConfigVolume',
    'ClusterColdNodeConfig',
    'ClusterColdNodeConfigVolume',
    'ClusterEssNodeConfig',
    'ClusterEssNodeConfigVolume',
    'ClusterKibanaPublicAccess',
    'ClusterMasterNodeConfig',
    'ClusterMasterNodeConfigVolume',
    'ClusterNode',
    'ClusterNodeConfig',
    'ClusterNodeConfigNetworkInfo',
    'ClusterNodeConfigVolume',
    'ClusterPublicAccess',
    'ClusterV1BackupStrategy',
    'ClusterV1ClientNodeConfig',
    'ClusterV1ClientNodeConfigVolume',
    'ClusterV1ColdNodeConfig',
    'ClusterV1ColdNodeConfigVolume',
    'ClusterV1EssNodeConfig',
    'ClusterV1EssNodeConfigVolume',
    'ClusterV1KibanaPublicAccess',
    'ClusterV1MasterNodeConfig',
    'ClusterV1MasterNodeConfigVolume',
    'ClusterV1Node',
    'ClusterV1NodeConfig',
    'ClusterV1NodeConfigNetworkInfo',
    'ClusterV1NodeConfigVolume',
    'ClusterV1PublicAccess',
    'ClusterV1VpcepEndpoint',
    'ClusterVpcepEndpoint',
    'EsCoreUpgradeUpgradeDetail',
    'EsCoreUpgradeUpgradeDetailDatastore',
    'EsLoadbalancerConfigHealthMonitor',
    'EsLoadbalancerConfigListener',
    'EsLoadbalancerConfigListenerIpGroup',
    'EsLoadbalancerConfigLoadbalancer',
    'LogstashClusterNode',
    'LogstashClusterNodeConfig',
    'LogstashClusterNodeConfigVolume',
    'LogstashClusterRoute',
    'LogstashConfigurationSetting',
    'LogstashConnectivityAddressAndPort',
    'LogstashConnectivityConnectivityResult',
    'LogstashPipelinePipeline',
    'LogstashPipelinePipelineEvent',
    'ScanTaskAlarm',
    'ScanTaskSummary',
    'ScanTaskTaskRisk',
    'GetClustersClusterResult',
    'GetClustersClusterDatastoreResult',
    'GetClustersClusterElbWhiteListResult',
    'GetClustersClusterInstanceResult',
    'GetClustersClusterInstanceVolumeResult',
    'GetClustersClusterPublicKibanaRespResult',
    'GetClustersClusterPublicKibanaRespElbWhiteListRespResult',
    'GetElbLoadbalancersLoadbalancerResult',
    'GetFlavorsFlavorResult',
    'GetLogBackupRecordsRecordResult',
    'GetLogstashCertificatesCertificateResult',
    'GetLogstashConfigurationsConfResult',
    'GetLogstashConfigurationsConfSettingResult',
    'GetLogstashPipelineActionsActionResult',
    'GetLogstashPipelinesPipelineResult',
    'GetLogstashTemplatesCustomTemplateResult',
    'GetLogstashTemplatesSystemTemplateResult',
    'GetScanTasksScanTaskResult',
    'GetScanTasksScanTaskSummaryResult',
    'GetScanTasksScanTaskTaskRiskResult',
    'GetSnapshotsBackupResult',
    'GetSnapshotsBackupDatastoreResult',
    'GetUpgradeTargetImagesImageResult',
]

@pulumi.output_type
class ClusterBackupStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "backupPath":
            suggest = "backup_path"
        elif key == "keepDays":
            suggest = "keep_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBackupStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBackupStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBackupStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: _builtins.str,
                 agency: Optional[_builtins.str] = None,
                 backup_path: Optional[_builtins.str] = None,
                 bucket: Optional[_builtins.str] = None,
                 keep_days: Optional[_builtins.int] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str start_time: Specifies the time when a snapshot is automatically created everyday. Snapshots can
               only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
               format, **HH:mm** refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
               and "01:00 GMT+08:00".
        :param _builtins.str agency: Specifies the IAM agency used to access OBS.
               
               > **NOTE:**  If the `bucket`, `backup_path`, and `agency` parameters are empty at the same time, the system will
               automatically create an OBS bucket and IAM agent, otherwise the configured parameter values will be used.
        :param _builtins.str backup_path: Specifies the storage path of the snapshot in the OBS bucket.
        :param _builtins.str bucket: Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
               bucket, only the OBS bucket is used and cannot be changed.
        :param _builtins.int keep_days: Specifies the number of days to retain the generated snapshots. Snapshots are reserved
               for seven days by default.
        :param _builtins.str prefix: Specifies the prefix of the snapshot that is automatically created. Defaults to **snapshot**.
        """
        pulumi.set(__self__, "start_time", start_time)
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if backup_path is not None:
            pulumi.set(__self__, "backup_path", backup_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if keep_days is not None:
            pulumi.set(__self__, "keep_days", keep_days)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Specifies the time when a snapshot is automatically created everyday. Snapshots can
        only be created on the hour. The time format is the time followed by the time zone, specifically, **HH:mm z**. In the
        format, **HH:mm** refers to the hour time and z refers to the time zone. For example, "00:00 GMT+08:00"
        and "01:00 GMT+08:00".
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def agency(self) -> Optional[_builtins.str]:
        """
        Specifies the IAM agency used to access OBS.

        > **NOTE:**  If the `bucket`, `backup_path`, and `agency` parameters are empty at the same time, the system will
        automatically create an OBS bucket and IAM agent, otherwise the configured parameter values will be used.
        """
        return pulumi.get(self, "agency")

    @_builtins.property
    @pulumi.getter(name="backupPath")
    def backup_path(self) -> Optional[_builtins.str]:
        """
        Specifies the storage path of the snapshot in the OBS bucket.
        """
        return pulumi.get(self, "backup_path")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        """
        Specifies the OBS bucket used for index data backup. If there is snapshot data in an OBS
        bucket, only the OBS bucket is used and cannot be changed.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="keepDays")
    def keep_days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days to retain the generated snapshots. Snapshots are reserved
        for seven days by default.
        """
        return pulumi.get(self, "keep_days")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Specifies the prefix of the snapshot that is automatically created. Defaults to **snapshot**.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ClusterClientNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClientNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClientNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClientNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 volume: 'outputs.ClusterClientNodeConfigVolume',
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str flavor: Specifies the flavor name.
        :param _builtins.int instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param 'ClusterClientNodeConfigVolumeArgs' volume: Specifies the information about the volume.
               The volume structure is documented below.
        :param Sequence[_builtins.str] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> 'outputs.ClusterClientNodeConfigVolume':
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")


@pulumi.output_type
class ClusterClientNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClientNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClientNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClientNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.int size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param _builtins.str volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterColdNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterColdNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterColdNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterColdNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 volume: Optional['outputs.ClusterColdNodeConfigVolume'] = None):
        """
        :param _builtins.str flavor: Specifies the flavor name.
        :param _builtins.int instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param Sequence[_builtins.str] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        :param _builtins.str type: Specifies the instance type.
               The valid values are as follows:
               + **ess**
               + **chinese**
               + **english**
               + **arabic**
               + **tools**
               + **thai**
               + **turkish**
               + **portuguese**
               + **chinese-english**
               + **spanish**
        :param 'ClusterColdNodeConfigVolumeArgs' volume: Specifies the information about the volume.
               The volume structure is documented below.
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.ClusterColdNodeConfigVolume']:
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class ClusterColdNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterColdNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterColdNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterColdNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.int size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param _builtins.str volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterEssNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEssNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEssNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEssNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 volume: Optional['outputs.ClusterEssNodeConfigVolume'] = None):
        """
        :param _builtins.str flavor: Specifies the flavor name.
        :param _builtins.int instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param Sequence[_builtins.str] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        :param _builtins.str type: Specifies the instance type.
               The valid values are as follows:
               + **ess**
               + **chinese**
               + **english**
               + **arabic**
               + **tools**
               + **thai**
               + **turkish**
               + **portuguese**
               + **chinese-english**
               + **spanish**
        :param 'ClusterEssNodeConfigVolumeArgs' volume: Specifies the information about the volume.
               The volume structure is documented below.
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.ClusterEssNodeConfigVolume']:
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class ClusterEssNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEssNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEssNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEssNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.int size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param _builtins.str volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterKibanaPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistEnabled":
            suggest = "whitelist_enabled"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKibanaPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKibanaPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKibanaPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: _builtins.int,
                 whitelist_enabled: _builtins.bool,
                 public_ip: Optional[_builtins.str] = None,
                 whitelist: Optional[_builtins.str] = None):
        """
        :param _builtins.int bandwidth: Specifies the public network bandwidth.
        :param _builtins.bool whitelist_enabled: Specifies whether to enable the public network access control.
        :param _builtins.str whitelist: Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.int:
        """
        Specifies the public network bandwidth.
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable the public network access control.
        """
        return pulumi.get(self, "whitelist_enabled")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[_builtins.str]:
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        return pulumi.get(self, "whitelist")


@pulumi.output_type
class ClusterMasterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 volume: 'outputs.ClusterMasterNodeConfigVolume',
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str flavor: Specifies the flavor name.
        :param _builtins.int instance_number: Specifies the number of cluster instances.
               + When it is `master_node_config`, The value range is `3` to `10`.
               + When it is `client_node_config`, The value range is `1` to `32`.
        :param 'ClusterMasterNodeConfigVolumeArgs' volume: Specifies the information about the volume.
               The volume structure is documented below.
        :param Sequence[_builtins.str] shrink_node_ids: Specifies the node IDs that needs to be scaled down.
               
               <a name="Css_master_or_client_volume"></a>
               The `volume` block supports:
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        """
        Specifies the number of cluster instances.
        + When it is `master_node_config`, The value range is `3` to `10`.
        + When it is `client_node_config`, The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> 'outputs.ClusterMasterNodeConfigVolume':
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the node IDs that needs to be scaled down.

        <a name="Css_master_or_client_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "shrink_node_ids")


@pulumi.output_type
class ClusterMasterNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterMasterNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterMasterNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterMasterNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.int size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param _builtins.str volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "specCode":
            suggest = "spec_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 spec_code: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_zone: Specifies the availability zone name.
               Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
               than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
               distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
               between node quantity in any two AZs is **1** at most.
        :param _builtins.str id: Instance ID.
        :param _builtins.str ip: Instance IP address.
        :param _builtins.str name: Specifies the cluster name. It contains `4` to `32` characters.
               Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
               Changing this parameter will create a new resource.
        :param _builtins.str resource_id: The resource ID of this instance.
        :param _builtins.str spec_code: Instance specification code.
        :param _builtins.str status: Instance status.
        :param _builtins.str type: Specifies the instance type.
               The valid values are as follows:
               + **ess**
               + **chinese**
               + **english**
               + **arabic**
               + **tools**
               + **thai**
               + **turkish**
               + **portuguese**
               + **chinese-english**
               + **spanish**
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if spec_code is not None:
            pulumi.set(__self__, "spec_code", spec_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Instance IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the cluster name. It contains `4` to `32` characters.
        Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The resource ID of this instance.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> Optional[_builtins.str]:
        """
        Instance specification code.
        """
        return pulumi.get(self, "spec_code")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Instance status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the instance type.
        The valid values are as follows:
        + **ess**
        + **chinese**
        + **english**
        + **arabic**
        + **tools**
        + **thai**
        + **turkish**
        + **portuguese**
        + **chinese-english**
        + **spanish**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "networkInfo":
            suggest = "network_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 flavor: _builtins.str,
                 network_info: 'outputs.ClusterNodeConfigNetworkInfo',
                 volume: 'outputs.ClusterNodeConfigVolume'):
        """
        :param _builtins.str availability_zone: Specifies the availability zone name.
               Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
               than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
               distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
               between node quantity in any two AZs is **1** at most.
        :param _builtins.str flavor: Specifies the flavor name.
        :param 'ClusterNodeConfigVolumeArgs' volume: Specifies the information about the volume.
               The volume structure is documented below.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "network_info", network_info)
        pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor name.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> 'outputs.ClusterNodeConfigNetworkInfo':
        return pulumi.get(self, "network_info")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> 'outputs.ClusterNodeConfigVolume':
        """
        Specifies the information about the volume.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class ClusterNodeConfigNetworkInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeConfigNetworkInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeConfigNetworkInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeConfigNetworkInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_id: _builtins.str,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str security_group_id: Specifies the security group ID.
        :param _builtins.str subnet_id: Specifies the Subnet ID.
               Changing this parameter will create a new resource.
        :param _builtins.str vpc_id: Specifies the VPC ID.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        Specifies the security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Specifies the Subnet ID.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Specifies the VPC ID.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ClusterNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.int size: Specifies the volume size in **GB**, which must be a multiple of `10`.
        :param _builtins.str volume_type: Specifies the volume type. Value options are as follows:
               + **COMMON**: Common I/O. The SATA disk is used.
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               
               <a name="Css_public_access"></a>
               The `public_access` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the volume size in **GB**, which must be a multiple of `10`.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the volume type. Value options are as follows:
        + **COMMON**: Common I/O. The SATA disk is used.
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.

        <a name="Css_public_access"></a>
        The `public_access` block supports:
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistEnabled":
            suggest = "whitelist_enabled"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: _builtins.int,
                 whitelist_enabled: _builtins.bool,
                 public_ip: Optional[_builtins.str] = None,
                 whitelist: Optional[_builtins.str] = None):
        """
        :param _builtins.int bandwidth: Specifies the public network bandwidth.
        :param _builtins.bool whitelist_enabled: Specifies whether to enable the public network access control.
        :param _builtins.str whitelist: Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.int:
        """
        Specifies the public network bandwidth.
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> _builtins.bool:
        """
        Specifies whether to enable the public network access control.
        """
        return pulumi.get(self, "whitelist_enabled")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[_builtins.str]:
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        return pulumi.get(self, "whitelist")


@pulumi.output_type
class ClusterV1BackupStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"
        elif key == "backupPath":
            suggest = "backup_path"
        elif key == "keepDays":
            suggest = "keep_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1BackupStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1BackupStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1BackupStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_time: _builtins.str,
                 agency: Optional[_builtins.str] = None,
                 backup_path: Optional[_builtins.str] = None,
                 bucket: Optional[_builtins.str] = None,
                 keep_days: Optional[_builtins.int] = None,
                 prefix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "start_time", start_time)
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if backup_path is not None:
            pulumi.set(__self__, "backup_path", backup_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if keep_days is not None:
            pulumi.set(__self__, "keep_days", keep_days)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def agency(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "agency")

    @_builtins.property
    @pulumi.getter(name="backupPath")
    def backup_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "backup_path")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="keepDays")
    def keep_days(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "keep_days")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ClusterV1ClientNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1ClientNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1ClientNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1ClientNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 volume: 'outputs.ClusterV1ClientNodeConfigVolume',
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> 'outputs.ClusterV1ClientNodeConfigVolume':
        return pulumi.get(self, "volume")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "shrink_node_ids")


@pulumi.output_type
class ClusterV1ClientNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1ClientNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1ClientNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1ClientNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterV1ColdNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1ColdNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1ColdNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1ColdNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 volume: Optional['outputs.ClusterV1ColdNodeConfigVolume'] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "shrink_node_ids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.ClusterV1ColdNodeConfigVolume']:
        return pulumi.get(self, "volume")


@pulumi.output_type
class ClusterV1ColdNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1ColdNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1ColdNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1ColdNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterV1EssNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1EssNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1EssNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1EssNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 volume: Optional['outputs.ClusterV1EssNodeConfigVolume'] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "shrink_node_ids")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.ClusterV1EssNodeConfigVolume']:
        return pulumi.get(self, "volume")


@pulumi.output_type
class ClusterV1EssNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1EssNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1EssNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1EssNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterV1KibanaPublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistEnabled":
            suggest = "whitelist_enabled"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1KibanaPublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1KibanaPublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1KibanaPublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: _builtins.int,
                 whitelist_enabled: _builtins.bool,
                 public_ip: Optional[_builtins.str] = None,
                 whitelist: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.int:
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "whitelist_enabled")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whitelist")


@pulumi.output_type
class ClusterV1MasterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "shrinkNodeIds":
            suggest = "shrink_node_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1MasterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1MasterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1MasterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 volume: 'outputs.ClusterV1MasterNodeConfigVolume',
                 shrink_node_ids: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "volume", volume)
        if shrink_node_ids is not None:
            pulumi.set(__self__, "shrink_node_ids", shrink_node_ids)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> 'outputs.ClusterV1MasterNodeConfigVolume':
        return pulumi.get(self, "volume")

    @_builtins.property
    @pulumi.getter(name="shrinkNodeIds")
    def shrink_node_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "shrink_node_ids")


@pulumi.output_type
class ClusterV1MasterNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1MasterNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1MasterNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1MasterNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterV1Node(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "specCode":
            suggest = "spec_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1Node. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1Node.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1Node.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 spec_code: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if spec_code is not None:
            pulumi.set(__self__, "spec_code", spec_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spec_code")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterV1NodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "networkInfo":
            suggest = "network_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1NodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1NodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1NodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 flavor: _builtins.str,
                 network_info: 'outputs.ClusterV1NodeConfigNetworkInfo',
                 volume: 'outputs.ClusterV1NodeConfigVolume'):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "network_info", network_info)
        pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> 'outputs.ClusterV1NodeConfigNetworkInfo':
        return pulumi.get(self, "network_info")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> 'outputs.ClusterV1NodeConfigVolume':
        return pulumi.get(self, "volume")


@pulumi.output_type
class ClusterV1NodeConfigNetworkInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupId":
            suggest = "security_group_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1NodeConfigNetworkInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1NodeConfigNetworkInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1NodeConfigNetworkInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_id: _builtins.str,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str):
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ClusterV1NodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1NodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1NodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1NodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class ClusterV1PublicAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "whitelistEnabled":
            suggest = "whitelist_enabled"
        elif key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1PublicAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1PublicAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1PublicAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: _builtins.int,
                 whitelist_enabled: _builtins.bool,
                 public_ip: Optional[_builtins.str] = None,
                 whitelist: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "whitelist_enabled", whitelist_enabled)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> _builtins.int:
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="whitelistEnabled")
    def whitelist_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "whitelist_enabled")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def whitelist(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whitelist")


@pulumi.output_type
class ClusterV1VpcepEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointWithDnsName":
            suggest = "endpoint_with_dns_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1VpcepEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1VpcepEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1VpcepEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_with_dns_name: _builtins.bool,
                 whitelists: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "endpoint_with_dns_name", endpoint_with_dns_name)
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @_builtins.property
    @pulumi.getter(name="endpointWithDnsName")
    def endpoint_with_dns_name(self) -> _builtins.bool:
        return pulumi.get(self, "endpoint_with_dns_name")

    @_builtins.property
    @pulumi.getter
    def whitelists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "whitelists")


@pulumi.output_type
class ClusterVpcepEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointWithDnsName":
            suggest = "endpoint_with_dns_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterVpcepEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterVpcepEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterVpcepEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_with_dns_name: _builtins.bool,
                 whitelists: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool endpoint_with_dns_name: Specifies whether to enable the private domain name.
        :param Sequence[_builtins.str] whitelists: Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        pulumi.set(__self__, "endpoint_with_dns_name", endpoint_with_dns_name)
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @_builtins.property
    @pulumi.getter(name="endpointWithDnsName")
    def endpoint_with_dns_name(self) -> _builtins.bool:
        """
        Specifies whether to enable the private domain name.
        """
        return pulumi.get(self, "endpoint_with_dns_name")

    @_builtins.property
    @pulumi.getter
    def whitelists(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the whitelist of access control. The whitelisted account id must be unique.
        """
        return pulumi.get(self, "whitelists")


@pulumi.output_type
class EsCoreUpgradeUpgradeDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "retryTimes":
            suggest = "retry_times"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "totalNodes":
            suggest = "total_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EsCoreUpgradeUpgradeDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EsCoreUpgradeUpgradeDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EsCoreUpgradeUpgradeDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agency: Optional[_builtins.str] = None,
                 datastores: Optional[Sequence['outputs.EsCoreUpgradeUpgradeDetailDatastore']] = None,
                 end_time: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 retry_times: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 total_nodes: Optional[_builtins.str] = None):
        """
        :param _builtins.str agency: Specifies the IAM agency used to access CSS.
        :param Sequence['EsCoreUpgradeUpgradeDetailDatastoreArgs'] datastores: The data store.
               The datastore structure is documented below.
        :param _builtins.str end_time: The end time.
        :param _builtins.str id: The job ID of the upgrade task.
        :param _builtins.str retry_times: The retry times.
        :param _builtins.str start_time: The start time.
        :param _builtins.str status: The status.
        :param _builtins.str total_nodes: The all nodes.
        """
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if datastores is not None:
            pulumi.set(__self__, "datastores", datastores)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retry_times is not None:
            pulumi.set(__self__, "retry_times", retry_times)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if total_nodes is not None:
            pulumi.set(__self__, "total_nodes", total_nodes)

    @_builtins.property
    @pulumi.getter
    def agency(self) -> Optional[_builtins.str]:
        """
        Specifies the IAM agency used to access CSS.
        """
        return pulumi.get(self, "agency")

    @_builtins.property
    @pulumi.getter
    def datastores(self) -> Optional[Sequence['outputs.EsCoreUpgradeUpgradeDetailDatastore']]:
        """
        The data store.
        The datastore structure is documented below.
        """
        return pulumi.get(self, "datastores")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The job ID of the upgrade task.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retryTimes")
    def retry_times(self) -> Optional[_builtins.str]:
        """
        The retry times.
        """
        return pulumi.get(self, "retry_times")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalNodes")
    def total_nodes(self) -> Optional[_builtins.str]:
        """
        The all nodes.
        """
        return pulumi.get(self, "total_nodes")


@pulumi.output_type
class EsCoreUpgradeUpgradeDetailDatastore(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the data store.
        :param _builtins.str version: The version of the data store.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the data store.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the data store.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class EsLoadbalancerConfigHealthMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protocolPort":
            suggest = "protocol_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EsLoadbalancerConfigHealthMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EsLoadbalancerConfigHealthMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EsLoadbalancerConfigHealthMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip: Optional[_builtins.str] = None,
                 protocol_port: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip: The IP address corresponding to the backend server.
        :param _builtins.int protocol_port: Specifies the front-end listening port of the listener.
               Changing this creates a new resource.
        :param _builtins.str status: The health status of the backend cloud server.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if protocol_port is not None:
            pulumi.set(__self__, "protocol_port", protocol_port)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IP address corresponding to the backend server.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> Optional[_builtins.int]:
        """
        Specifies the front-end listening port of the listener.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The health status of the backend cloud server.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class EsLoadbalancerConfigListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipGroups":
            suggest = "ip_groups"
        elif key == "protocolPort":
            suggest = "protocol_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EsLoadbalancerConfigListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EsLoadbalancerConfigListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EsLoadbalancerConfigListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 ip_groups: Optional[Sequence['outputs.EsLoadbalancerConfigListenerIpGroup']] = None,
                 name: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 protocol_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str id: The ID of the access control group associated with the listener.
        :param Sequence['EsLoadbalancerConfigListenerIpGroupArgs'] ip_groups: The ipgroup information in the listener object.
               The ip_group structure is documented below.
        :param _builtins.str name: The listener name.
        :param _builtins.str protocol: The listening protocol of the listener.
        :param _builtins.int protocol_port: Specifies the front-end listening port of the listener.
               Changing this creates a new resource.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_groups is not None:
            pulumi.set(__self__, "ip_groups", ip_groups)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_port is not None:
            pulumi.set(__self__, "protocol_port", protocol_port)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the access control group associated with the listener.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipGroups")
    def ip_groups(self) -> Optional[Sequence['outputs.EsLoadbalancerConfigListenerIpGroup']]:
        """
        The ipgroup information in the listener object.
        The ip_group structure is documented below.
        """
        return pulumi.get(self, "ip_groups")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The listener name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The listening protocol of the listener.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> Optional[_builtins.int]:
        """
        Specifies the front-end listening port of the listener.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "protocol_port")


@pulumi.output_type
class EsLoadbalancerConfigListenerIpGroup(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: The status of the access control group.
        :param _builtins.str id: The ID of the access control group associated with the listener.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        The status of the access control group.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the access control group associated with the listener.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class EsLoadbalancerConfigLoadbalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIp":
            suggest = "public_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EsLoadbalancerConfigLoadbalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EsLoadbalancerConfigLoadbalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EsLoadbalancerConfigLoadbalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 public_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The ID of the access control group associated with the listener.
        :param _builtins.str ip: The IP address corresponding to the backend server.
        :param _builtins.str name: The listener name.
        :param _builtins.str public_ip: The elastic public IP address.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the access control group associated with the listener.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IP address corresponding to the backend server.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The listener name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        """
        The elastic public IP address.
        """
        return pulumi.get(self, "public_ip")


@pulumi.output_type
class LogstashClusterNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "specCode":
            suggest = "spec_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogstashClusterNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogstashClusterNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogstashClusterNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 spec_code: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability_zone: Specifies the availability zone name.
               Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
               than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
               distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
               between node quantity in any two AZs is **1** at most.
               Changing this parameter will create a new resource.
        :param _builtins.str id: Instance ID.
        :param _builtins.str ip: Instance IP address.
        :param _builtins.str name: Specifies the cluster name. It contains `4` to `32` characters.
               Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        :param _builtins.str resource_id: The resource ID of this instance.
        :param _builtins.str spec_code: Instance specification code.
        :param _builtins.str status: Instance status.
        :param _builtins.str type: Node type.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if spec_code is not None:
            pulumi.set(__self__, "spec_code", spec_code)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        Specifies the availability zone name.
        Separate multiple AZs with commas (,), for example, az1,az2. AZs must be unique. The number of nodes must be greater
        than or equal to the number of AZs. If the number of nodes is a multiple of the number of AZs, the nodes are evenly
        distributed to each AZ. If the number of nodes is not a multiple of the number of AZs, the absolute difference
        between node quantity in any two AZs is **1** at most.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        Instance IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the cluster name. It contains `4` to `32` characters.
        Only letters, digits, hyphens (-), and underscores (_) are allowed. The value must start with a letter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The resource ID of this instance.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> Optional[_builtins.str]:
        """
        Instance specification code.
        """
        return pulumi.get(self, "spec_code")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Instance status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Node type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LogstashClusterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogstashClusterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogstashClusterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogstashClusterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: _builtins.str,
                 instance_number: _builtins.int,
                 volume: Optional['outputs.LogstashClusterNodeConfigVolume'] = None):
        """
        :param _builtins.str flavor: Specifies the flavor name. The value options are as follows:
               + **ess.spec-4u8g**: The value range of the flavor is `40` GB to `1,500` GB.
               + **ess.spec-4u16g**: The value range of the flavor is `40` GB to `1,600` GB.
               + **ess.spec-4u32g**: The value range of the flavor is `40` GB to `2,560` GB.
               + **ess.spec-8u16g**: The value range of the flavor is `80` GB to `1,600` GB.
               + **ess.spec-8u32g**: The value range of the flavor is `80` GB to `3,200` GB.
               + **ess.spec-8u64g**: The value range of the flavor is `80` GB to `5,120` GB.
               + **ess.spec-16u32g**: The value range of the flavor is `100` GB to `3,200` GB.
               + **ess.spec-16u64g**: The value range of the flavor is `100` GB to `6,400` GB.
               + **ess.spec-32u64g**: The value range of the flavor is `100` GB to `10,240` GB.
               + **ess.spec-32u128g**: The value range of the flavor is `100` GB to `10,240` GB.
               Changing this parameter will create a new resource.
        :param _builtins.int instance_number: Specifies the number of cluster instances. The value range is `1` to `32`.
        :param 'LogstashClusterNodeConfigVolumeArgs' volume: Specifies the information about the volume.
               The volume structure is documented below. Changing this parameter will create a new resource.
               
               <a name="Css_volume"></a>
               The `volume` block supports:
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "instance_number", instance_number)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor name. The value options are as follows:
        + **ess.spec-4u8g**: The value range of the flavor is `40` GB to `1,500` GB.
        + **ess.spec-4u16g**: The value range of the flavor is `40` GB to `1,600` GB.
        + **ess.spec-4u32g**: The value range of the flavor is `40` GB to `2,560` GB.
        + **ess.spec-8u16g**: The value range of the flavor is `80` GB to `1,600` GB.
        + **ess.spec-8u32g**: The value range of the flavor is `80` GB to `3,200` GB.
        + **ess.spec-8u64g**: The value range of the flavor is `80` GB to `5,120` GB.
        + **ess.spec-16u32g**: The value range of the flavor is `100` GB to `3,200` GB.
        + **ess.spec-16u64g**: The value range of the flavor is `100` GB to `6,400` GB.
        + **ess.spec-32u64g**: The value range of the flavor is `100` GB to `10,240` GB.
        + **ess.spec-32u128g**: The value range of the flavor is `100` GB to `10,240` GB.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        """
        Specifies the number of cluster instances. The value range is `1` to `32`.
        """
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter
    def volume(self) -> Optional['outputs.LogstashClusterNodeConfigVolume']:
        """
        Specifies the information about the volume.
        The volume structure is documented below. Changing this parameter will create a new resource.

        <a name="Css_volume"></a>
        The `volume` block supports:
        """
        return pulumi.get(self, "volume")


@pulumi.output_type
class LogstashClusterNodeConfigVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogstashClusterNodeConfigVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogstashClusterNodeConfigVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogstashClusterNodeConfigVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.int size: Specifies the volume size in GB, which must be a multiple of `10`.
               Changing this parameter will create a new resource.
        :param _builtins.str volume_type: Specifies the volume type. The value options are as follows:
               + **HIGH**: High I/O. The SAS disk is used.
               + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
               + **ESSD**: Extreme speed I/O. The SATA disk is used.
               Changing this parameter will create a new resource.
               
               <a name="Css_route"></a>
               The `routes` block supports:
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the volume size in GB, which must be a multiple of `10`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the volume type. The value options are as follows:
        + **HIGH**: High I/O. The SAS disk is used.
        + **ULTRAHIGH**: Ultra-high I/O. The solid-state drive (SSD) is used.
        + **ESSD**: Extreme speed I/O. The SATA disk is used.
        Changing this parameter will create a new resource.

        <a name="Css_route"></a>
        The `routes` block supports:
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LogstashClusterRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipNetMask":
            suggest = "ip_net_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogstashClusterRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogstashClusterRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogstashClusterRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 ip_net_mask: _builtins.str):
        """
        :param _builtins.str ip_address: Specifies the route ip address.
        :param _builtins.str ip_net_mask: Specifies the subnet mask of the route ip address.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ip_net_mask", ip_net_mask)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        Specifies the route ip address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="ipNetMask")
    def ip_net_mask(self) -> _builtins.str:
        """
        Specifies the subnet mask of the route ip address.
        """
        return pulumi.get(self, "ip_net_mask")


@pulumi.output_type
class LogstashConfigurationSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueType":
            suggest = "queue_type"
        elif key == "batchDelayMs":
            suggest = "batch_delay_ms"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "queueCheckPointWrites":
            suggest = "queue_check_point_writes"
        elif key == "queueMaxBytesMb":
            suggest = "queue_max_bytes_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogstashConfigurationSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogstashConfigurationSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogstashConfigurationSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_type: _builtins.str,
                 batch_delay_ms: Optional[_builtins.int] = None,
                 batch_size: Optional[_builtins.int] = None,
                 queue_check_point_writes: Optional[_builtins.int] = None,
                 queue_max_bytes_mb: Optional[_builtins.int] = None,
                 workers: Optional[_builtins.int] = None):
        """
        :param _builtins.str queue_type: Specifies internal queue model for event buffering.
               + **memory:** a traditional memory-based queue.
               + **persisted:** a disk-based ACKed persistence queue.
        :param _builtins.int batch_delay_ms: Specifies the minimum time in the unit of milliseconds for each event to be
               waited for by pipeline scheduling.
        :param _builtins.int batch_size: Specifies the maximum number of events a single worker thread will collect
               from inputs before attempting to execute its **Filters** and **Outputs**. Larger values ​​are generally more
               efficient but increase memory overhead. Default is `125`.
        :param _builtins.int queue_check_point_writes: Specifies the maximum number of events to be written before forcing
               a checkpoint when using a persistent queue, default is `1,024`.
        :param _builtins.int queue_max_bytes_mb: Specifies the total capacity of the persistent queue in megabytes (MB) when
               using a persistent queue. Make sure the disk is larger than this value. The default value is `1,024`.
        :param _builtins.int workers: Specifies the number of worker threads in the **Filters** + **Outputs** stage of
               the execution pipeline. The default value is the number of CPU cores.
        """
        pulumi.set(__self__, "queue_type", queue_type)
        if batch_delay_ms is not None:
            pulumi.set(__self__, "batch_delay_ms", batch_delay_ms)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if queue_check_point_writes is not None:
            pulumi.set(__self__, "queue_check_point_writes", queue_check_point_writes)
        if queue_max_bytes_mb is not None:
            pulumi.set(__self__, "queue_max_bytes_mb", queue_max_bytes_mb)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter(name="queueType")
    def queue_type(self) -> _builtins.str:
        """
        Specifies internal queue model for event buffering.
        + **memory:** a traditional memory-based queue.
        + **persisted:** a disk-based ACKed persistence queue.
        """
        return pulumi.get(self, "queue_type")

    @_builtins.property
    @pulumi.getter(name="batchDelayMs")
    def batch_delay_ms(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum time in the unit of milliseconds for each event to be
        waited for by pipeline scheduling.
        """
        return pulumi.get(self, "batch_delay_ms")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of events a single worker thread will collect
        from inputs before attempting to execute its **Filters** and **Outputs**. Larger values ​​are generally more
        efficient but increase memory overhead. Default is `125`.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="queueCheckPointWrites")
    def queue_check_point_writes(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of events to be written before forcing
        a checkpoint when using a persistent queue, default is `1,024`.
        """
        return pulumi.get(self, "queue_check_point_writes")

    @_builtins.property
    @pulumi.getter(name="queueMaxBytesMb")
    def queue_max_bytes_mb(self) -> Optional[_builtins.int]:
        """
        Specifies the total capacity of the persistent queue in megabytes (MB) when
        using a persistent queue. Make sure the disk is larger than this value. The default value is `1,024`.
        """
        return pulumi.get(self, "queue_max_bytes_mb")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[_builtins.int]:
        """
        Specifies the number of worker threads in the **Filters** + **Outputs** stage of
        the execution pipeline. The default value is the number of CPU cores.
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class LogstashConnectivityAddressAndPort(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 port: _builtins.int):
        """
        :param _builtins.str address: Specifies the ip address.
        :param _builtins.int port: Specifies the port.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Specifies the ip address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Specifies the port.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class LogstashConnectivityConnectivityResult(dict):
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Specifies the ip address.
        :param _builtins.int port: Specifies the port.
        :param _builtins.str status: The connectivity test result.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Specifies the ip address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Specifies the port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The connectivity test result.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LogstashPipelinePipeline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepAlive":
            suggest = "keep_alive"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogstashPipelinePipeline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogstashPipelinePipeline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogstashPipelinePipeline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events: Optional[Sequence['outputs.LogstashPipelinePipelineEvent']] = None,
                 keep_alive: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param Sequence['LogstashPipelinePipelineEventArgs'] events: The event of the CSS logstash cluster pipeline.
               The events structure is documented below.
        :param _builtins.bool keep_alive: Specifies whether keep alive. The value can be **true** and **false**.
               Defaults to **false**. During hot start, the value of keep alive of existing pipelines in the cluster needs to
               be consistent.
               Changing this creates a new resource.
               
               > **NOTE:** Keepalive can be enabled for long-running services. Enabling it will configure a daemon process
               on each node. If the Logstash service is faulty, the daemon process will rectify the fault and restart the
               service. Do not enable it for short running services, or your migration tasks may fail due to lack of source data.
        :param _builtins.str name: The configuration file name of the CSS logstash cluster.
        :param _builtins.str status: The status of the CSS logstash cluster pipeline.
        :param _builtins.str updated_at: The update time of the CSS logstash cluster pipeline.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if keep_alive is not None:
            pulumi.set(__self__, "keep_alive", keep_alive)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.LogstashPipelinePipelineEvent']]:
        """
        The event of the CSS logstash cluster pipeline.
        The events structure is documented below.
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> Optional[_builtins.bool]:
        """
        Specifies whether keep alive. The value can be **true** and **false**.
        Defaults to **false**. During hot start, the value of keep alive of existing pipelines in the cluster needs to
        be consistent.
        Changing this creates a new resource.

        > **NOTE:** Keepalive can be enabled for long-running services. Enabling it will configure a daemon process
        on each node. If the Logstash service is faulty, the daemon process will rectify the fault and restart the
        service. Do not enable it for short running services, or your migration tasks may fail due to lack of source data.
        """
        return pulumi.get(self, "keep_alive")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The configuration file name of the CSS logstash cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The update time of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class LogstashPipelinePipelineEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "in":
            suggest = "in_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogstashPipelinePipelineEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogstashPipelinePipelineEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogstashPipelinePipelineEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filtered: Optional[_builtins.int] = None,
                 in_: Optional[_builtins.int] = None,
                 out: Optional[_builtins.int] = None):
        """
        :param _builtins.int filtered: The number of data to be filtered.
        :param _builtins.int in_: The number of received data that needs to be processed.
        :param _builtins.int out: The number of output data.
        """
        if filtered is not None:
            pulumi.set(__self__, "filtered", filtered)
        if in_ is not None:
            pulumi.set(__self__, "in_", in_)
        if out is not None:
            pulumi.set(__self__, "out", out)

    @_builtins.property
    @pulumi.getter
    def filtered(self) -> Optional[_builtins.int]:
        """
        The number of data to be filtered.
        """
        return pulumi.get(self, "filtered")

    @_builtins.property
    @pulumi.getter(name="in")
    def in_(self) -> Optional[_builtins.int]:
        """
        The number of received data that needs to be processed.
        """
        return pulumi.get(self, "in_")

    @_builtins.property
    @pulumi.getter
    def out(self) -> Optional[_builtins.int]:
        """
        The number of output data.
        """
        return pulumi.get(self, "out")


@pulumi.output_type
class ScanTaskAlarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smnTopic":
            suggest = "smn_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScanTaskAlarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScanTaskAlarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScanTaskAlarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: _builtins.str,
                 smn_topic: _builtins.str):
        """
        :param _builtins.str level: Specifies the level of alarm messages found by the cluster scan task.
               The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        :param _builtins.str smn_topic: Specifies the name of the SMN topic.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "smn_topic", smn_topic)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        Specifies the level of alarm messages found by the cluster scan task.
        The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="smnTopic")
    def smn_topic(self) -> _builtins.str:
        """
        Specifies the name of the SMN topic.
        """
        return pulumi.get(self, "smn_topic")


@pulumi.output_type
class ScanTaskSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highNum":
            suggest = "high_num"
        elif key == "mediumNum":
            suggest = "medium_num"
        elif key == "suggestionNum":
            suggest = "suggestion_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScanTaskSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScanTaskSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScanTaskSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_num: Optional[_builtins.int] = None,
                 medium_num: Optional[_builtins.int] = None,
                 suggestion_num: Optional[_builtins.int] = None):
        """
        :param _builtins.int high_num: The number of high-risk items found by the cluster scan task.
        :param _builtins.int medium_num: The number of medium-risk items found by the cluster scan task.
        :param _builtins.int suggestion_num: The number of suggestions found by the cluster scan task.
        """
        if high_num is not None:
            pulumi.set(__self__, "high_num", high_num)
        if medium_num is not None:
            pulumi.set(__self__, "medium_num", medium_num)
        if suggestion_num is not None:
            pulumi.set(__self__, "suggestion_num", suggestion_num)

    @_builtins.property
    @pulumi.getter(name="highNum")
    def high_num(self) -> Optional[_builtins.int]:
        """
        The number of high-risk items found by the cluster scan task.
        """
        return pulumi.get(self, "high_num")

    @_builtins.property
    @pulumi.getter(name="mediumNum")
    def medium_num(self) -> Optional[_builtins.int]:
        """
        The number of medium-risk items found by the cluster scan task.
        """
        return pulumi.get(self, "medium_num")

    @_builtins.property
    @pulumi.getter(name="suggestionNum")
    def suggestion_num(self) -> Optional[_builtins.int]:
        """
        The number of suggestions found by the cluster scan task.
        """
        return pulumi.get(self, "suggestion_num")


@pulumi.output_type
class ScanTaskTaskRisk(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None,
                 risk: Optional[_builtins.str] = None,
                 suggestion: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Specifies the description of the cluster scan task.
               Changing this creates a new resource.
        :param _builtins.str level: Specifies the level of alarm messages found by the cluster scan task.
               The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        :param _builtins.str risk: The risk item.
        :param _builtins.str suggestion: The suggestion on how to resolve this risk item.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if risk is not None:
            pulumi.set(__self__, "risk", risk)
        if suggestion is not None:
            pulumi.set(__self__, "suggestion", suggestion)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies the description of the cluster scan task.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        Specifies the level of alarm messages found by the cluster scan task.
        The valid values are **high**, **medium**, **suggestion** and **noRisk**.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def risk(self) -> Optional[_builtins.str]:
        """
        The risk item.
        """
        return pulumi.get(self, "risk")

    @_builtins.property
    @pulumi.getter
    def suggestion(self) -> Optional[_builtins.str]:
        """
        The suggestion on how to resolve this risk item.
        """
        return pulumi.get(self, "suggestion")


@pulumi.output_type
class GetClustersClusterResult(dict):
    def __init__(__self__, *,
                 actions: Sequence[_builtins.str],
                 authority_enable: _builtins.bool,
                 backup_available: _builtins.bool,
                 bandwidth_resource_id: _builtins.str,
                 bandwidth_size: _builtins.int,
                 created_at: _builtins.str,
                 datastores: Sequence['outputs.GetClustersClusterDatastoreResult'],
                 disk_encrypted: _builtins.bool,
                 elb_white_lists: Sequence['outputs.GetClustersClusterElbWhiteListResult'],
                 endpoint: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 https_enable: _builtins.bool,
                 id: _builtins.str,
                 instances: Sequence['outputs.GetClustersClusterInstanceResult'],
                 name: _builtins.str,
                 period: _builtins.bool,
                 public_ip: _builtins.str,
                 public_kibana_resps: Sequence['outputs.GetClustersClusterPublicKibanaRespResult'],
                 security_group_id: _builtins.str,
                 status: _builtins.str,
                 subnet_id: _builtins.str,
                 updated_at: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param Sequence[_builtins.str] actions: The current behavior of a cluster.
               + **REBOOTING** indicates that the cluster is being restarted.
               + **GROWING** indicates that the cluster is being scaled.
               + **RESTORING** indicates that the cluster is being restored.
               + **SNAPSHOTTING** indicates that a snapshot is being created.
        :param _builtins.bool authority_enable: Whether to enable authentication.
               + **true**: Authentication is enabled for the cluster.
               + **false**: Authentication is not enabled for the cluster.
        :param _builtins.bool backup_available: Whether the snapshot function is enabled.
               + **true**: The snapshot function is enabled.
               + **false**: The snapshot function is disabled.
        :param _builtins.str bandwidth_resource_id: The resource id for ES public network access.
        :param _builtins.int bandwidth_size: The public network bandwidth. The unit is Mbit/s.
        :param _builtins.str created_at: The cluster creation time.
               The returned cluster list is sorted by creation time in descending order.
               The latest cluster is displayed at the top.
        :param Sequence['GetClustersClusterDatastoreArgs'] datastores: The cluster data store.
        :param _builtins.bool disk_encrypted: Whether disks are encrypted.
               + **true**: Disks are encrypted.
               + **false**: Disks are not encrypted.
        :param Sequence['GetClustersClusterElbWhiteListArgs'] elb_white_lists: The EIP whitelist.
        :param _builtins.str endpoint: The IP address and port number of the user used to access the VPC.
        :param _builtins.str enterprise_project_id: The ID of the enterprise project that a cluster belongs to.
               If the user of the cluster does not enable the enterprise project,
               the setting of this parameter is not returned.
        :param _builtins.bool https_enable: The communication encryption status.
               + **false**: Communication encryption is not enabled.
               + **true**: Communication encryption is enabled.
        :param _builtins.str id: The cluster instance ID.
        :param Sequence['GetClustersClusterInstanceArgs'] instances: The list of node objects.
        :param _builtins.str name: Specifies the cluster name.
        :param _builtins.bool period: Whether a cluster is billed on the yearly/monthly mode.
               + **true**: The cluster is billed on the yearly/monthly mode.
               + **false**: The cluster is billed on the pay-per-use mode.
        :param _builtins.str public_ip: The public IP address information.
        :param Sequence['GetClustersClusterPublicKibanaRespArgs'] public_kibana_resps: The kibana public network access information.
        :param _builtins.str security_group_id: The security group ID.
        :param _builtins.str status: The node status.
               + **100**: Creating.
               + **200**: Available.
               + **303**: Unavailable, for example, due to a creation failure.
        :param _builtins.str subnet_id: The subnet ID.
        :param _builtins.str updated_at: The last modification time of a cluster.
        :param _builtins.str vpc_id: The ID of a VPC.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "authority_enable", authority_enable)
        pulumi.set(__self__, "backup_available", backup_available)
        pulumi.set(__self__, "bandwidth_resource_id", bandwidth_resource_id)
        pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "datastores", datastores)
        pulumi.set(__self__, "disk_encrypted", disk_encrypted)
        pulumi.set(__self__, "elb_white_lists", elb_white_lists)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "https_enable", https_enable)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "public_kibana_resps", public_kibana_resps)
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence[_builtins.str]:
        """
        The current behavior of a cluster.
        + **REBOOTING** indicates that the cluster is being restarted.
        + **GROWING** indicates that the cluster is being scaled.
        + **RESTORING** indicates that the cluster is being restored.
        + **SNAPSHOTTING** indicates that a snapshot is being created.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="authorityEnable")
    def authority_enable(self) -> _builtins.bool:
        """
        Whether to enable authentication.
        + **true**: Authentication is enabled for the cluster.
        + **false**: Authentication is not enabled for the cluster.
        """
        return pulumi.get(self, "authority_enable")

    @_builtins.property
    @pulumi.getter(name="backupAvailable")
    def backup_available(self) -> _builtins.bool:
        """
        Whether the snapshot function is enabled.
        + **true**: The snapshot function is enabled.
        + **false**: The snapshot function is disabled.
        """
        return pulumi.get(self, "backup_available")

    @_builtins.property
    @pulumi.getter(name="bandwidthResourceId")
    def bandwidth_resource_id(self) -> _builtins.str:
        """
        The resource id for ES public network access.
        """
        return pulumi.get(self, "bandwidth_resource_id")

    @_builtins.property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> _builtins.int:
        """
        The public network bandwidth. The unit is Mbit/s.
        """
        return pulumi.get(self, "bandwidth_size")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The cluster creation time.
        The returned cluster list is sorted by creation time in descending order.
        The latest cluster is displayed at the top.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def datastores(self) -> Sequence['outputs.GetClustersClusterDatastoreResult']:
        """
        The cluster data store.
        """
        return pulumi.get(self, "datastores")

    @_builtins.property
    @pulumi.getter(name="diskEncrypted")
    def disk_encrypted(self) -> _builtins.bool:
        """
        Whether disks are encrypted.
        + **true**: Disks are encrypted.
        + **false**: Disks are not encrypted.
        """
        return pulumi.get(self, "disk_encrypted")

    @_builtins.property
    @pulumi.getter(name="elbWhiteLists")
    def elb_white_lists(self) -> Sequence['outputs.GetClustersClusterElbWhiteListResult']:
        """
        The EIP whitelist.
        """
        return pulumi.get(self, "elb_white_lists")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The IP address and port number of the user used to access the VPC.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        The ID of the enterprise project that a cluster belongs to.
        If the user of the cluster does not enable the enterprise project,
        the setting of this parameter is not returned.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="httpsEnable")
    def https_enable(self) -> _builtins.bool:
        """
        The communication encryption status.
        + **false**: Communication encryption is not enabled.
        + **true**: Communication encryption is enabled.
        """
        return pulumi.get(self, "https_enable")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The cluster instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetClustersClusterInstanceResult']:
        """
        The list of node objects.
        """
        return pulumi.get(self, "instances")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the cluster name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def period(self) -> _builtins.bool:
        """
        Whether a cluster is billed on the yearly/monthly mode.
        + **true**: The cluster is billed on the yearly/monthly mode.
        + **false**: The cluster is billed on the pay-per-use mode.
        """
        return pulumi.get(self, "period")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        """
        The public IP address information.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter(name="publicKibanaResps")
    def public_kibana_resps(self) -> Sequence['outputs.GetClustersClusterPublicKibanaRespResult']:
        """
        The kibana public network access information.
        """
        return pulumi.get(self, "public_kibana_resps")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> _builtins.str:
        """
        The security group ID.
        """
        return pulumi.get(self, "security_group_id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The node status.
        + **100**: Creating.
        + **200**: Available.
        + **303**: Unavailable, for example, due to a creation failure.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The last modification time of a cluster.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of a VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetClustersClusterDatastoreResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str type: The engine type.
        :param _builtins.str version: The version of the CSS cluster engine.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The engine type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the CSS cluster engine.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClustersClusterElbWhiteListResult(dict):
    def __init__(__self__, *,
                 enable_white_list: _builtins.bool,
                 white_list: _builtins.str):
        """
        :param _builtins.bool enable_white_list: Whether the public network access control is enabled.
               + **true**: Public network access control is enabled.
               + **false**: Public network access control is disabled.
        :param _builtins.str white_list: Whitelist for public network access.
        """
        pulumi.set(__self__, "enable_white_list", enable_white_list)
        pulumi.set(__self__, "white_list", white_list)

    @_builtins.property
    @pulumi.getter(name="enableWhiteList")
    def enable_white_list(self) -> _builtins.bool:
        """
        Whether the public network access control is enabled.
        + **true**: Public network access control is enabled.
        + **false**: Public network access control is disabled.
        """
        return pulumi.get(self, "enable_white_list")

    @_builtins.property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> _builtins.str:
        """
        Whitelist for public network access.
        """
        return pulumi.get(self, "white_list")


@pulumi.output_type
class GetClustersClusterInstanceResult(dict):
    def __init__(__self__, *,
                 az_code: _builtins.str,
                 id: _builtins.str,
                 ip: _builtins.str,
                 name: _builtins.str,
                 spec_code: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str,
                 volumes: Sequence['outputs.GetClustersClusterInstanceVolumeResult']):
        """
        :param _builtins.str az_code: The AZ of a node.
        :param _builtins.str id: The cluster instance ID.
        :param _builtins.str ip: The instance IP address.
        :param _builtins.str name: Specifies the cluster name.
        :param _builtins.str spec_code: The node specifications.
        :param _builtins.str status: The node status.
               + **100**: Creating.
               + **200**: Available.
               + **303**: Unavailable, for example, due to a creation failure.
        :param _builtins.str type: The engine type.
        :param Sequence['GetClustersClusterInstanceVolumeArgs'] volumes: The instance volume.
        """
        pulumi.set(__self__, "az_code", az_code)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "spec_code", spec_code)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter(name="azCode")
    def az_code(self) -> _builtins.str:
        """
        The AZ of a node.
        """
        return pulumi.get(self, "az_code")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The cluster instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The instance IP address.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the cluster name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> _builtins.str:
        """
        The node specifications.
        """
        return pulumi.get(self, "spec_code")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The node status.
        + **100**: Creating.
        + **200**: Available.
        + **303**: Unavailable, for example, due to a creation failure.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The engine type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetClustersClusterInstanceVolumeResult']:
        """
        The instance volume.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetClustersClusterInstanceVolumeResult(dict):
    def __init__(__self__, *,
                 size: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int size: The instance volume size.
        :param _builtins.str type: The engine type.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The instance volume size.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The engine type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClustersClusterPublicKibanaRespResult(dict):
    def __init__(__self__, *,
                 bandwidth_resource_id: _builtins.str,
                 eip_size: _builtins.int,
                 elb_white_list_resps: Sequence['outputs.GetClustersClusterPublicKibanaRespElbWhiteListRespResult'],
                 public_kibana_ip: _builtins.str):
        """
        :param _builtins.str bandwidth_resource_id: The resource id for ES public network access.
        :param _builtins.int eip_size: The bandwidth range. The unit is Mbit/s.
        :param Sequence['GetClustersClusterPublicKibanaRespElbWhiteListRespArgs'] elb_white_list_resps: The elb white list of the cluster public kibana.
        :param _builtins.str public_kibana_ip: The IP address for accessing kibana.
        """
        pulumi.set(__self__, "bandwidth_resource_id", bandwidth_resource_id)
        pulumi.set(__self__, "eip_size", eip_size)
        pulumi.set(__self__, "elb_white_list_resps", elb_white_list_resps)
        pulumi.set(__self__, "public_kibana_ip", public_kibana_ip)

    @_builtins.property
    @pulumi.getter(name="bandwidthResourceId")
    def bandwidth_resource_id(self) -> _builtins.str:
        """
        The resource id for ES public network access.
        """
        return pulumi.get(self, "bandwidth_resource_id")

    @_builtins.property
    @pulumi.getter(name="eipSize")
    def eip_size(self) -> _builtins.int:
        """
        The bandwidth range. The unit is Mbit/s.
        """
        return pulumi.get(self, "eip_size")

    @_builtins.property
    @pulumi.getter(name="elbWhiteListResps")
    def elb_white_list_resps(self) -> Sequence['outputs.GetClustersClusterPublicKibanaRespElbWhiteListRespResult']:
        """
        The elb white list of the cluster public kibana.
        """
        return pulumi.get(self, "elb_white_list_resps")

    @_builtins.property
    @pulumi.getter(name="publicKibanaIp")
    def public_kibana_ip(self) -> _builtins.str:
        """
        The IP address for accessing kibana.
        """
        return pulumi.get(self, "public_kibana_ip")


@pulumi.output_type
class GetClustersClusterPublicKibanaRespElbWhiteListRespResult(dict):
    def __init__(__self__, *,
                 enable_white_list: _builtins.bool,
                 white_list: _builtins.str):
        """
        :param _builtins.bool enable_white_list: Whether the public network access control is enabled.
               + **true**: Public network access control is enabled.
               + **false**: Public network access control is disabled.
        :param _builtins.str white_list: Whitelist for public network access.
        """
        pulumi.set(__self__, "enable_white_list", enable_white_list)
        pulumi.set(__self__, "white_list", white_list)

    @_builtins.property
    @pulumi.getter(name="enableWhiteList")
    def enable_white_list(self) -> _builtins.bool:
        """
        Whether the public network access control is enabled.
        + **true**: Public network access control is enabled.
        + **false**: Public network access control is disabled.
        """
        return pulumi.get(self, "enable_white_list")

    @_builtins.property
    @pulumi.getter(name="whiteList")
    def white_list(self) -> _builtins.str:
        """
        Whitelist for public network access.
        """
        return pulumi.get(self, "white_list")


@pulumi.output_type
class GetElbLoadbalancersLoadbalancerResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 ip_target_enable: _builtins.bool,
                 l7_flavor_id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: The loadbalancer ID.
        :param _builtins.bool ip_target_enable: Whether to enable cross-VPC backend.
        :param _builtins.str l7_flavor_id: The layer 7 protocol ID of the loadbalancer.
        :param _builtins.str name: Specifies the name of the loadbalancer.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_target_enable", ip_target_enable)
        pulumi.set(__self__, "l7_flavor_id", l7_flavor_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The loadbalancer ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipTargetEnable")
    def ip_target_enable(self) -> _builtins.bool:
        """
        Whether to enable cross-VPC backend.
        """
        return pulumi.get(self, "ip_target_enable")

    @_builtins.property
    @pulumi.getter(name="l7FlavorId")
    def l7_flavor_id(self) -> _builtins.str:
        """
        The layer 7 protocol ID of the loadbalancer.
        """
        return pulumi.get(self, "l7_flavor_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the loadbalancer.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 availability_zones: _builtins.str,
                 disk_range: _builtins.str,
                 id: _builtins.str,
                 memory: _builtins.int,
                 name: _builtins.str,
                 region: _builtins.str,
                 type: _builtins.str,
                 vcpus: _builtins.int,
                 version: _builtins.str):
        """
        :param _builtins.str availability_zones: The valid availability zones for current flavor.
        :param _builtins.str disk_range: The disk capacity range of an instance, in GB.
        :param _builtins.str id: The ID of CSS flavor.
        :param _builtins.int memory: Specifies the memory size(GB) in the CSS flavor.
        :param _builtins.str name: Specifies the name of the CSS flavor.
        :param _builtins.str region: Specifies the region in which to obtain the CSS flavors. If omitted, the
               provider-level region will be used.
        :param _builtins.str type: Specifies the node instance type. The options are `ess`, `ess-cold`, `ess-master`
               and `ess-client`.
        :param _builtins.int vcpus: Specifies the number of vCPUs in the CSS flavor.
        :param _builtins.str version: Specifies the engine version. The options are `5.5.1`, `6.2.3`, `6.5.4`, `7.1.1`,
               `7.6.2` and `7.9.3`.
        """
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "disk_range", disk_range)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vcpus", vcpus)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> _builtins.str:
        """
        The valid availability zones for current flavor.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="diskRange")
    def disk_range(self) -> _builtins.str:
        """
        The disk capacity range of an instance, in GB.
        """
        return pulumi.get(self, "disk_range")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of CSS flavor.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        Specifies the memory size(GB) in the CSS flavor.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the CSS flavor.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region in which to obtain the CSS flavors. If omitted, the
        provider-level region will be used.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the node instance type. The options are `ess`, `ess-cold`, `ess-master`
        and `ess-client`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> _builtins.int:
        """
        Specifies the number of vCPUs in the CSS flavor.
        """
        return pulumi.get(self, "vcpus")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Specifies the engine version. The options are `5.5.1`, `6.2.3`, `6.5.4`, `7.1.1`,
        `7.6.2` and `7.9.3`.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetLogBackupRecordsRecordResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 create_at: _builtins.str,
                 failed_msg: _builtins.str,
                 finished_at: _builtins.str,
                 id: _builtins.str,
                 log_path: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str cluster_id: Specifies the ID of the CSS cluster.
        :param _builtins.str create_at: The creation time.
        :param _builtins.str failed_msg: The error information.
               If the task did not fail, the value of this parameter is empty.
        :param _builtins.str finished_at: The end time.
               If the creation has not been completed, the end time is empty.
        :param _builtins.str id: The ID of the log backup job.
        :param _builtins.str log_path: The storage path of backed up logs in the OBS bucket.
        :param _builtins.str status: Specifies the status of the log backup job.
        :param _builtins.str type: Specifies the type of the log backup job.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "create_at", create_at)
        pulumi.set(__self__, "failed_msg", failed_msg)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "log_path", log_path)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        Specifies the ID of the CSS cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="createAt")
    def create_at(self) -> _builtins.str:
        """
        The creation time.
        """
        return pulumi.get(self, "create_at")

    @_builtins.property
    @pulumi.getter(name="failedMsg")
    def failed_msg(self) -> _builtins.str:
        """
        The error information.
        If the task did not fail, the value of this parameter is empty.
        """
        return pulumi.get(self, "failed_msg")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        The end time.
        If the creation has not been completed, the end time is empty.
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the log backup job.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="logPath")
    def log_path(self) -> _builtins.str:
        """
        The storage path of backed up logs in the OBS bucket.
        """
        return pulumi.get(self, "log_path")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the log backup job.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the log backup job.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLogstashCertificatesCertificateResult(dict):
    def __init__(__self__, *,
                 file_location: _builtins.str,
                 file_name: _builtins.str,
                 id: _builtins.str,
                 status: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str file_location: The file location of the certificate.
        :param _builtins.str file_name: Specifies the file name of the certificate.
        :param _builtins.str id: The ID of the certificate.
        :param _builtins.str status: Specifies the status of the certificate.
               The values can be **available** and **unavailable**.
        :param _builtins.str updated_at: The upload time of the certificate.
        """
        pulumi.set(__self__, "file_location", file_location)
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="fileLocation")
    def file_location(self) -> _builtins.str:
        """
        The file location of the certificate.
        """
        return pulumi.get(self, "file_location")

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        """
        Specifies the file name of the certificate.
        """
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the certificate.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the certificate.
        The values can be **available** and **unavailable**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The upload time of the certificate.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetLogstashConfigurationsConfResult(dict):
    def __init__(__self__, *,
                 conf_content: _builtins.str,
                 name: _builtins.str,
                 settings: Sequence['outputs.GetLogstashConfigurationsConfSettingResult'],
                 status: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str conf_content: The configuration file content.
        :param _builtins.str name: Specifies the configuration file name.
        :param Sequence['GetLogstashConfigurationsConfSettingArgs'] settings: The configuration file setting information.
        :param _builtins.str status: Specifies the configuration file content check status.
               The values can be **checking**, **available** and **unavailable**.
        :param _builtins.str updated_at: The update time.
        """
        pulumi.set(__self__, "conf_content", conf_content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "settings", settings)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="confContent")
    def conf_content(self) -> _builtins.str:
        """
        The configuration file content.
        """
        return pulumi.get(self, "conf_content")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the configuration file name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Sequence['outputs.GetLogstashConfigurationsConfSettingResult']:
        """
        The configuration file setting information.
        """
        return pulumi.get(self, "settings")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the configuration file content check status.
        The values can be **checking**, **available** and **unavailable**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetLogstashConfigurationsConfSettingResult(dict):
    def __init__(__self__, *,
                 batch_delay_ms: _builtins.int,
                 batch_size: _builtins.int,
                 queue_check_point_writes: _builtins.int,
                 queue_max_bytes_mb: _builtins.int,
                 queue_type: _builtins.str,
                 workers: _builtins.int):
        """
        :param _builtins.int batch_delay_ms: The minimum time for an event to be scheduled to wait.
        :param _builtins.int batch_size: The maximum number of events.
               This event refers to a single worker thread will collect from inputs before attempting
               to execute its **Filters** and **Outputs**.
               Larger values are generally more efficient but increase memory overhead.
        :param _builtins.int queue_check_point_writes: The maximum number of events to be written.
               This refers to before forcing a checkpoint when a persistent queue is used.
        :param _builtins.int queue_max_bytes_mb: The total capacity of the persistent queue.
               The unit is megabytes. The disk is guaranteed to have a maximum capacity of this value.
        :param _builtins.str queue_type: Internal queue model for event buffering.
        :param _builtins.int workers: The number of worker threads.
               that is in the **Filters** + **Outputs** stage of the execution pipeline.
               The default value is the number of CPU cores.
        """
        pulumi.set(__self__, "batch_delay_ms", batch_delay_ms)
        pulumi.set(__self__, "batch_size", batch_size)
        pulumi.set(__self__, "queue_check_point_writes", queue_check_point_writes)
        pulumi.set(__self__, "queue_max_bytes_mb", queue_max_bytes_mb)
        pulumi.set(__self__, "queue_type", queue_type)
        pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter(name="batchDelayMs")
    def batch_delay_ms(self) -> _builtins.int:
        """
        The minimum time for an event to be scheduled to wait.
        """
        return pulumi.get(self, "batch_delay_ms")

    @_builtins.property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> _builtins.int:
        """
        The maximum number of events.
        This event refers to a single worker thread will collect from inputs before attempting
        to execute its **Filters** and **Outputs**.
        Larger values are generally more efficient but increase memory overhead.
        """
        return pulumi.get(self, "batch_size")

    @_builtins.property
    @pulumi.getter(name="queueCheckPointWrites")
    def queue_check_point_writes(self) -> _builtins.int:
        """
        The maximum number of events to be written.
        This refers to before forcing a checkpoint when a persistent queue is used.
        """
        return pulumi.get(self, "queue_check_point_writes")

    @_builtins.property
    @pulumi.getter(name="queueMaxBytesMb")
    def queue_max_bytes_mb(self) -> _builtins.int:
        """
        The total capacity of the persistent queue.
        The unit is megabytes. The disk is guaranteed to have a maximum capacity of this value.
        """
        return pulumi.get(self, "queue_max_bytes_mb")

    @_builtins.property
    @pulumi.getter(name="queueType")
    def queue_type(self) -> _builtins.str:
        """
        Internal queue model for event buffering.
        """
        return pulumi.get(self, "queue_type")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> _builtins.int:
        """
        The number of worker threads.
        that is in the **Filters** + **Outputs** stage of the execution pipeline.
        The default value is the number of CPU cores.
        """
        return pulumi.get(self, "workers")


@pulumi.output_type
class GetLogstashPipelineActionsActionResult(dict):
    def __init__(__self__, *,
                 conf_content: _builtins.str,
                 error_msg: _builtins.str,
                 id: _builtins.str,
                 message: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str conf_content: The configuration file content.
        :param _builtins.str error_msg: The error message of the action.
        :param _builtins.str id: The ID of the action.
        :param _builtins.str message: The message of the action.
        :param _builtins.str status: Specifies the status of the action.
               The values can be **running**, **success** and **failed**.
        :param _builtins.str type: Specifies the type of the action.
               The values can be **start**, **hotStart**, **hotStop** and **stop**.
        :param _builtins.str updated_at: The update time.
        """
        pulumi.set(__self__, "conf_content", conf_content)
        pulumi.set(__self__, "error_msg", error_msg)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="confContent")
    def conf_content(self) -> _builtins.str:
        """
        The configuration file content.
        """
        return pulumi.get(self, "conf_content")

    @_builtins.property
    @pulumi.getter(name="errorMsg")
    def error_msg(self) -> _builtins.str:
        """
        The error message of the action.
        """
        return pulumi.get(self, "error_msg")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the action.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The message of the action.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the action.
        The values can be **running**, **success** and **failed**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the action.
        The values can be **start**, **hotStart**, **hotStop** and **stop**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetLogstashPipelinesPipelineResult(dict):
    def __init__(__self__, *,
                 events: Mapping[str, _builtins.str],
                 keep_alive: _builtins.bool,
                 name: _builtins.str,
                 status: _builtins.str,
                 update_at: _builtins.str):
        """
        :param Mapping[str, _builtins.str] events: The event of the CSS logstash cluster pipeline.
        :param _builtins.bool keep_alive: Whether keep alive.
        :param _builtins.str name: Specifies the configuration file names of the CSS logstash cluster pipeline.
        :param _builtins.str status: The status of the CSS logstash cluster pipeline.
        :param _builtins.str update_at: The update time of the CSS logstash cluster pipeline.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "keep_alive", keep_alive)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_at", update_at)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Mapping[str, _builtins.str]:
        """
        The event of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> _builtins.bool:
        """
        Whether keep alive.
        """
        return pulumi.get(self, "keep_alive")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the configuration file names of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> _builtins.str:
        """
        The update time of the CSS logstash cluster pipeline.
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLogstashTemplatesCustomTemplateResult(dict):
    def __init__(__self__, *,
                 conf_content: _builtins.str,
                 desc: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str conf_content: The configuration file content of the custom template.
        :param _builtins.str desc: The description of the custom template.
        :param _builtins.str id: The ID of the custom template.
        :param _builtins.str name: Specifies the name of the template.
        """
        pulumi.set(__self__, "conf_content", conf_content)
        pulumi.set(__self__, "desc", desc)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="confContent")
    def conf_content(self) -> _builtins.str:
        """
        The configuration file content of the custom template.
        """
        return pulumi.get(self, "conf_content")

    @_builtins.property
    @pulumi.getter
    def desc(self) -> _builtins.str:
        """
        The description of the custom template.
        """
        return pulumi.get(self, "desc")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the custom template.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the template.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetLogstashTemplatesSystemTemplateResult(dict):
    def __init__(__self__, *,
                 conf_content: _builtins.str,
                 desc: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str conf_content: The configuration file content of the custom template.
        :param _builtins.str desc: The description of the custom template.
        :param _builtins.str id: The ID of the custom template.
        :param _builtins.str name: Specifies the name of the template.
        """
        pulumi.set(__self__, "conf_content", conf_content)
        pulumi.set(__self__, "desc", desc)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="confContent")
    def conf_content(self) -> _builtins.str:
        """
        The configuration file content of the custom template.
        """
        return pulumi.get(self, "conf_content")

    @_builtins.property
    @pulumi.getter
    def desc(self) -> _builtins.str:
        """
        The description of the custom template.
        """
        return pulumi.get(self, "desc")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the custom template.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the template.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetScanTasksScanTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 smn_fail_reason: _builtins.str,
                 smn_status: _builtins.str,
                 status: _builtins.int,
                 summaries: Sequence['outputs.GetScanTasksScanTaskSummaryResult'],
                 task_risks: Sequence['outputs.GetScanTasksScanTaskTaskRiskResult']):
        """
        :param _builtins.str created_at: The scan task creation time.
        :param _builtins.str description: The description of the risk item.
        :param _builtins.str id: The scan task ID.
        :param _builtins.str name: The scan task name.
        :param _builtins.str smn_fail_reason: The reason for failure in sending SMN alarm.
        :param _builtins.str smn_status: The SMN alarm sending status after the cluster scan task is completed.
        :param _builtins.int status: The execution status of the cluster scan task.
        :param Sequence['GetScanTasksScanTaskSummaryArgs'] summaries: The risk summary after the cluster scan task is completed.
        :param Sequence['GetScanTasksScanTaskTaskRiskArgs'] task_risks: The risk found by the cluster scan task.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "smn_fail_reason", smn_fail_reason)
        pulumi.set(__self__, "smn_status", smn_status)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "summaries", summaries)
        pulumi.set(__self__, "task_risks", task_risks)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The scan task creation time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the risk item.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The scan task ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The scan task name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="smnFailReason")
    def smn_fail_reason(self) -> _builtins.str:
        """
        The reason for failure in sending SMN alarm.
        """
        return pulumi.get(self, "smn_fail_reason")

    @_builtins.property
    @pulumi.getter(name="smnStatus")
    def smn_status(self) -> _builtins.str:
        """
        The SMN alarm sending status after the cluster scan task is completed.
        """
        return pulumi.get(self, "smn_status")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        The execution status of the cluster scan task.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def summaries(self) -> Sequence['outputs.GetScanTasksScanTaskSummaryResult']:
        """
        The risk summary after the cluster scan task is completed.
        """
        return pulumi.get(self, "summaries")

    @_builtins.property
    @pulumi.getter(name="taskRisks")
    def task_risks(self) -> Sequence['outputs.GetScanTasksScanTaskTaskRiskResult']:
        """
        The risk found by the cluster scan task.
        """
        return pulumi.get(self, "task_risks")


@pulumi.output_type
class GetScanTasksScanTaskSummaryResult(dict):
    def __init__(__self__, *,
                 high: _builtins.int,
                 medium: _builtins.int,
                 suggestion: _builtins.int):
        """
        :param _builtins.int high: The number of high-risk items found by the cluster scan task.
        :param _builtins.int medium: The number of medium-risk items found by the cluster scan task.
        :param _builtins.int suggestion: The number of suggestions found by the cluster scan task.
        """
        pulumi.set(__self__, "high", high)
        pulumi.set(__self__, "medium", medium)
        pulumi.set(__self__, "suggestion", suggestion)

    @_builtins.property
    @pulumi.getter
    def high(self) -> _builtins.int:
        """
        The number of high-risk items found by the cluster scan task.
        """
        return pulumi.get(self, "high")

    @_builtins.property
    @pulumi.getter
    def medium(self) -> _builtins.int:
        """
        The number of medium-risk items found by the cluster scan task.
        """
        return pulumi.get(self, "medium")

    @_builtins.property
    @pulumi.getter
    def suggestion(self) -> _builtins.int:
        """
        The number of suggestions found by the cluster scan task.
        """
        return pulumi.get(self, "suggestion")


@pulumi.output_type
class GetScanTasksScanTaskTaskRiskResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 level: _builtins.str,
                 risk: _builtins.str,
                 suggestion: _builtins.str):
        """
        :param _builtins.str description: The description of the risk item.
        :param _builtins.str level: The level of the risk item.
        :param _builtins.str risk: The risk item.
        :param _builtins.str suggestion: The number of suggestions found by the cluster scan task.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "risk", risk)
        pulumi.set(__self__, "suggestion", suggestion)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the risk item.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The level of the risk item.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def risk(self) -> _builtins.str:
        """
        The risk item.
        """
        return pulumi.get(self, "risk")

    @_builtins.property
    @pulumi.getter
    def suggestion(self) -> _builtins.str:
        """
        The number of suggestions found by the cluster scan task.
        """
        return pulumi.get(self, "suggestion")


@pulumi.output_type
class GetSnapshotsBackupResult(dict):
    def __init__(__self__, *,
                 backup_expected_start_time: _builtins.str,
                 backup_keep_day: _builtins.int,
                 backup_method: _builtins.str,
                 backup_period: _builtins.str,
                 backup_type: _builtins.str,
                 bucket_name: _builtins.str,
                 cluster_id: _builtins.str,
                 cluster_name: _builtins.str,
                 created_at: _builtins.str,
                 datastores: Sequence['outputs.GetSnapshotsBackupDatastoreResult'],
                 description: _builtins.str,
                 end_time: _builtins.str,
                 failed_shards: _builtins.int,
                 id: _builtins.str,
                 indices: _builtins.str,
                 name: _builtins.str,
                 restore_status: _builtins.str,
                 start_time: _builtins.str,
                 status: _builtins.str,
                 total_shards: _builtins.int,
                 updated_at: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str backup_expected_start_time: The snapshot start time.
        :param _builtins.int backup_keep_day: The snapshot retention period.
        :param _builtins.str backup_method: The snapshot creation mode.
        :param _builtins.str backup_period: The time when a snapshot is created every day.
        :param _builtins.str backup_type: The snapshot creation type.
               The options are as follows:
               + **0**: Automatic creation.
               + **1**: Manual creation.
        :param _builtins.str bucket_name: The name of the bucket that stores snapshot data.
        :param _builtins.str cluster_id: Specifies the ID of the cluster.
        :param _builtins.str cluster_name: The cluster name.
        :param _builtins.str created_at: The snapshot creation time.
        :param Sequence['GetSnapshotsBackupDatastoreArgs'] datastores: The datastore of the cluster snapshot.
        :param _builtins.str description: The snapshot description.
        :param _builtins.str end_time: The snapshot end time.
        :param _builtins.int failed_shards: The number of shards that fail to be backed up.
        :param _builtins.str id: The snapshot ID.
        :param _builtins.str indices: The index of the back up.
        :param _builtins.str name: The snapshot name.
        :param _builtins.str restore_status: The snapshot restoration status.
        :param _builtins.str start_time: The snapshot start time.
        :param _builtins.str status: The snapshot status.
        :param _builtins.int total_shards: The total number of shards of the back up index.
        :param _builtins.str updated_at: The time when the snapshot was updated.
        :param _builtins.str version: The elastic search engine version.
        """
        pulumi.set(__self__, "backup_expected_start_time", backup_expected_start_time)
        pulumi.set(__self__, "backup_keep_day", backup_keep_day)
        pulumi.set(__self__, "backup_method", backup_method)
        pulumi.set(__self__, "backup_period", backup_period)
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "datastores", datastores)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "failed_shards", failed_shards)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "indices", indices)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "restore_status", restore_status)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "total_shards", total_shards)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="backupExpectedStartTime")
    def backup_expected_start_time(self) -> _builtins.str:
        """
        The snapshot start time.
        """
        return pulumi.get(self, "backup_expected_start_time")

    @_builtins.property
    @pulumi.getter(name="backupKeepDay")
    def backup_keep_day(self) -> _builtins.int:
        """
        The snapshot retention period.
        """
        return pulumi.get(self, "backup_keep_day")

    @_builtins.property
    @pulumi.getter(name="backupMethod")
    def backup_method(self) -> _builtins.str:
        """
        The snapshot creation mode.
        """
        return pulumi.get(self, "backup_method")

    @_builtins.property
    @pulumi.getter(name="backupPeriod")
    def backup_period(self) -> _builtins.str:
        """
        The time when a snapshot is created every day.
        """
        return pulumi.get(self, "backup_period")

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> _builtins.str:
        """
        The snapshot creation type.
        The options are as follows:
        + **0**: Automatic creation.
        + **1**: Manual creation.
        """
        return pulumi.get(self, "backup_type")

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        The name of the bucket that stores snapshot data.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        Specifies the ID of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        The cluster name.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The snapshot creation time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def datastores(self) -> Sequence['outputs.GetSnapshotsBackupDatastoreResult']:
        """
        The datastore of the cluster snapshot.
        """
        return pulumi.get(self, "datastores")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The snapshot description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The snapshot end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="failedShards")
    def failed_shards(self) -> _builtins.int:
        """
        The number of shards that fail to be backed up.
        """
        return pulumi.get(self, "failed_shards")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The snapshot ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def indices(self) -> _builtins.str:
        """
        The index of the back up.
        """
        return pulumi.get(self, "indices")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The snapshot name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="restoreStatus")
    def restore_status(self) -> _builtins.str:
        """
        The snapshot restoration status.
        """
        return pulumi.get(self, "restore_status")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The snapshot start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The snapshot status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="totalShards")
    def total_shards(self) -> _builtins.int:
        """
        The total number of shards of the back up index.
        """
        return pulumi.get(self, "total_shards")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The time when the snapshot was updated.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The elastic search engine version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSnapshotsBackupDatastoreResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str type: The engine type.
        :param _builtins.str version: The elastic search engine version.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The engine type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The elastic search engine version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetUpgradeTargetImagesImageResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 engine_type: _builtins.str,
                 engine_version: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 priority: _builtins.int):
        """
        :param _builtins.str description: The image description information.
        :param _builtins.str engine_type: Specifies the datastore type of the target image.
        :param _builtins.str engine_version: Specifies the datastore version of the target image.
        :param _builtins.str id: The target image ID that can be upgraded.
        :param _builtins.str name: The name of the target image that can be upgraded.
        :param _builtins.int priority: The target image priority.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "engine_type", engine_type)
        pulumi.set(__self__, "engine_version", engine_version)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The image description information.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> _builtins.str:
        """
        Specifies the datastore type of the target image.
        """
        return pulumi.get(self, "engine_type")

    @_builtins.property
    @pulumi.getter(name="engineVersion")
    def engine_version(self) -> _builtins.str:
        """
        Specifies the datastore version of the target image.
        """
        return pulumi.get(self, "engine_version")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The target image ID that can be upgraded.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the target image that can be upgraded.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The target image priority.
        """
        return pulumi.get(self, "priority")


