# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ChannelEncoderSetting',
    'ChannelEncoderSettingsExpand',
    'ChannelEncoderSettingsExpandAudioDescription',
    'ChannelEndpoint',
    'ChannelEndpointDashPackage',
    'ChannelEndpointDashPackageEncryption',
    'ChannelEndpointDashPackageEncryptionHttpHeader',
    'ChannelEndpointDashPackageRequestArgs',
    'ChannelEndpointDashPackageRequestArgsLife',
    'ChannelEndpointDashPackageRequestArgsRecord',
    'ChannelEndpointDashPackageRequestArgsTimeshift',
    'ChannelEndpointDashPackageStreamSelection',
    'ChannelEndpointHlsPackage',
    'ChannelEndpointHlsPackageEncryption',
    'ChannelEndpointHlsPackageEncryptionHttpHeader',
    'ChannelEndpointHlsPackageRequestArgs',
    'ChannelEndpointHlsPackageRequestArgsLife',
    'ChannelEndpointHlsPackageRequestArgsRecord',
    'ChannelEndpointHlsPackageRequestArgsTimeshift',
    'ChannelEndpointHlsPackageStreamSelection',
    'ChannelEndpointMssPackage',
    'ChannelEndpointMssPackageEncryption',
    'ChannelEndpointMssPackageEncryptionHttpHeader',
    'ChannelEndpointMssPackageRequestArgs',
    'ChannelEndpointMssPackageRequestArgsLife',
    'ChannelEndpointMssPackageRequestArgsRecord',
    'ChannelEndpointMssPackageRequestArgsTimeshift',
    'ChannelEndpointMssPackageStreamSelection',
    'ChannelInput',
    'ChannelInputAudioSelector',
    'ChannelInputAudioSelectorSelectorSettings',
    'ChannelInputAudioSelectorSelectorSettingsAudioHlsSelection',
    'ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelection',
    'ChannelInputAudioSelectorSelectorSettingsAudioPidSelection',
    'ChannelInputFailoverConditions',
    'ChannelInputSecondarySource',
    'ChannelInputSource',
    'ChannelRecordSettings',
    'HlsConfigurationApplication',
    'HttpsCertificateGmCertificate',
    'HttpsCertificateTlsCertificate',
    'RecordingFlv',
    'RecordingHls',
    'RecordingMp4',
    'RecordingObs',
    'TranscodingTemplate',
    'GetCdnIpsCdnIpResult',
    'GetChannelsChannelResult',
    'GetChannelsChannelEncoderSettingResult',
    'GetChannelsChannelEncoderSettingsExpandResult',
    'GetChannelsChannelEncoderSettingsExpandAudioDescriptionResult',
    'GetChannelsChannelEndpointResult',
    'GetChannelsChannelEndpointDashPackageResult',
    'GetChannelsChannelEndpointDashPackageEncryptionResult',
    'GetChannelsChannelEndpointDashPackageEncryptionHttpHeaderResult',
    'GetChannelsChannelEndpointDashPackageRequestArgResult',
    'GetChannelsChannelEndpointDashPackageRequestArgLifeResult',
    'GetChannelsChannelEndpointDashPackageRequestArgRecordResult',
    'GetChannelsChannelEndpointDashPackageRequestArgTimeshiftResult',
    'GetChannelsChannelEndpointDashPackageStreamSelectionResult',
    'GetChannelsChannelEndpointHlsPackageResult',
    'GetChannelsChannelEndpointHlsPackageEncryptionResult',
    'GetChannelsChannelEndpointHlsPackageEncryptionHttpHeaderResult',
    'GetChannelsChannelEndpointHlsPackageRequestArgResult',
    'GetChannelsChannelEndpointHlsPackageRequestArgLifeResult',
    'GetChannelsChannelEndpointHlsPackageRequestArgRecordResult',
    'GetChannelsChannelEndpointHlsPackageRequestArgTimeshiftResult',
    'GetChannelsChannelEndpointHlsPackageStreamSelectionResult',
    'GetChannelsChannelEndpointMssPackageResult',
    'GetChannelsChannelEndpointMssPackageEncryptionResult',
    'GetChannelsChannelEndpointMssPackageEncryptionHttpHeaderResult',
    'GetChannelsChannelEndpointMssPackageRequestArgResult',
    'GetChannelsChannelEndpointMssPackageRequestArgLifeResult',
    'GetChannelsChannelEndpointMssPackageRequestArgRecordResult',
    'GetChannelsChannelEndpointMssPackageRequestArgTimeshiftResult',
    'GetChannelsChannelEndpointMssPackageStreamSelectionResult',
    'GetChannelsChannelInputResult',
    'GetChannelsChannelInputAudioSelectorResult',
    'GetChannelsChannelInputAudioSelectorSelectorSettingResult',
    'GetChannelsChannelInputAudioSelectorSelectorSettingAudioHlsSelectionResult',
    'GetChannelsChannelInputAudioSelectorSelectorSettingAudioLanguageSelectionResult',
    'GetChannelsChannelInputAudioSelectorSelectorSettingAudioPidSelectionResult',
    'GetChannelsChannelInputFailoverConditionResult',
    'GetChannelsChannelInputSecondarySourceResult',
    'GetChannelsChannelInputSourceResult',
    'GetChannelsChannelRecordSettingResult',
    'GetDisablePushStreamsBlockResult',
    'GetDomainsDomainResult',
    'GetGeoBlockingsAppResult',
    'GetRecordCallbacksCallbackResult',
    'GetRecordingsRuleResult',
    'GetRecordingsRuleDefaultRecordConfigResult',
    'GetRecordingsRuleDefaultRecordConfigFlvResult',
    'GetRecordingsRuleDefaultRecordConfigHlResult',
    'GetRecordingsRuleDefaultRecordConfigMp4Result',
    'GetRecordingsRuleDefaultRecordConfigObResult',
    'GetSnapshotsSnapshotResult',
    'GetTranscodingsTemplateResult',
    'GetTranscodingsTemplateQualityInfoResult',
]

@pulumi.output_type
class ChannelEncoderSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateId":
            suggest = "template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str template_id: Specifies the transcoding template ID.
        """
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[_builtins.str]:
        """
        Specifies the transcoding template ID.
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class ChannelEncoderSettingsExpand(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioDescriptions":
            suggest = "audio_descriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsExpand. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsExpand.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsExpand.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_descriptions: Optional[Sequence['outputs.ChannelEncoderSettingsExpandAudioDescription']] = None):
        """
        :param Sequence['ChannelEncoderSettingsExpandAudioDescriptionArgs'] audio_descriptions: Specifies the description of the audio output configuration.
               The audio_descriptions structure is documented below.
               
               <a name="LiveChannel_AudioDescriptions"></a>
               The `audio_descriptions` block supports:
        """
        if audio_descriptions is not None:
            pulumi.set(__self__, "audio_descriptions", audio_descriptions)

    @_builtins.property
    @pulumi.getter(name="audioDescriptions")
    def audio_descriptions(self) -> Optional[Sequence['outputs.ChannelEncoderSettingsExpandAudioDescription']]:
        """
        Specifies the description of the audio output configuration.
        The audio_descriptions structure is documented below.

        <a name="LiveChannel_AudioDescriptions"></a>
        The `audio_descriptions` block supports:
        """
        return pulumi.get(self, "audio_descriptions")


@pulumi.output_type
class ChannelEncoderSettingsExpandAudioDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSelectorName":
            suggest = "audio_selector_name"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "languageCodeControl":
            suggest = "language_code_control"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettingsExpandAudioDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettingsExpandAudioDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettingsExpandAudioDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_selector_name: _builtins.str,
                 name: _builtins.str,
                 language_code: Optional[_builtins.str] = None,
                 language_code_control: Optional[_builtins.str] = None,
                 stream_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str audio_selector_name: Specifies the audio selector name.
        :param _builtins.str name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param _builtins.str language_code: Specifies the language code. The value could be `2` or `3` lowercase letters.
        :param _builtins.str language_code_control: Specifies the language code control configuration.
               The settings here will not change the actual language of the audio, but only the language in which the audio is
               displayed externally. Valid values are:
               + **FOLLOW_INPUT**: If the output audio corresponding to the selected audio selector has a language, it will be
               consistent with it, otherwise it will be backed up by the language code and stream name configured here.
               The current option is recommended and is the default value.
               + **USE_CONFIGURED**: Users can customize the language and stream name of the output audio based on actual conditions.
        :param _builtins.str stream_name: Specifies the stream name.
               
               <a name="LiveChannel_EncoderSettings"></a>
               The `encoder_settings` block supports:
        """
        pulumi.set(__self__, "audio_selector_name", audio_selector_name)
        pulumi.set(__self__, "name", name)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if language_code_control is not None:
            pulumi.set(__self__, "language_code_control", language_code_control)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> _builtins.str:
        """
        Specifies the audio selector name.
        """
        return pulumi.get(self, "audio_selector_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[_builtins.str]:
        """
        Specifies the language code. The value could be `2` or `3` lowercase letters.
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="languageCodeControl")
    def language_code_control(self) -> Optional[_builtins.str]:
        """
        Specifies the language code control configuration.
        The settings here will not change the actual language of the audio, but only the language in which the audio is
        displayed externally. Valid values are:
        + **FOLLOW_INPUT**: If the output audio corresponding to the selected audio selector has a language, it will be
        consistent with it, otherwise it will be backed up by the language code and stream name configured here.
        The current option is recommended and is the default value.
        + **USE_CONFIGURED**: Users can customize the language and stream name of the output audio based on actual conditions.
        """
        return pulumi.get(self, "language_code_control")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[_builtins.str]:
        """
        Specifies the stream name.

        <a name="LiveChannel_EncoderSettings"></a>
        The `encoder_settings` block supports:
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class ChannelEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashPackages":
            suggest = "dash_packages"
        elif key == "hlsPackages":
            suggest = "hls_packages"
        elif key == "mssPackages":
            suggest = "mss_packages"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dash_packages: Optional[Sequence['outputs.ChannelEndpointDashPackage']] = None,
                 hls_packages: Optional[Sequence['outputs.ChannelEndpointHlsPackage']] = None,
                 mss_packages: Optional[Sequence['outputs.ChannelEndpointMssPackage']] = None):
        """
        :param Sequence['ChannelEndpointDashPackageArgs'] dash_packages: Specifies the DASH packaging information.
               The dash_package structure is documented below.
        :param Sequence['ChannelEndpointHlsPackageArgs'] hls_packages: Specifies the HLS packaging information.
               The hls_package structure is documented below.
        :param Sequence['ChannelEndpointMssPackageArgs'] mss_packages: Specifies the MSS packaging information.
               The mss_package structure is documented below.
               
               <a name="LiveChannel_HlsPackage"></a>
               The `hls_package` block supports:
        """
        if dash_packages is not None:
            pulumi.set(__self__, "dash_packages", dash_packages)
        if hls_packages is not None:
            pulumi.set(__self__, "hls_packages", hls_packages)
        if mss_packages is not None:
            pulumi.set(__self__, "mss_packages", mss_packages)

    @_builtins.property
    @pulumi.getter(name="dashPackages")
    def dash_packages(self) -> Optional[Sequence['outputs.ChannelEndpointDashPackage']]:
        """
        Specifies the DASH packaging information.
        The dash_package structure is documented below.
        """
        return pulumi.get(self, "dash_packages")

    @_builtins.property
    @pulumi.getter(name="hlsPackages")
    def hls_packages(self) -> Optional[Sequence['outputs.ChannelEndpointHlsPackage']]:
        """
        Specifies the HLS packaging information.
        The hls_package structure is documented below.
        """
        return pulumi.get(self, "hls_packages")

    @_builtins.property
    @pulumi.getter(name="mssPackages")
    def mss_packages(self) -> Optional[Sequence['outputs.ChannelEndpointMssPackage']]:
        """
        Specifies the MSS packaging information.
        The mss_package structure is documented below.

        <a name="LiveChannel_HlsPackage"></a>
        The `hls_package` block supports:
        """
        return pulumi.get(self, "mss_packages")


@pulumi.output_type
class ChannelEndpointDashPackage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "segmentDurationSeconds":
            suggest = "segment_duration_seconds"
        elif key == "adMarker":
            suggest = "ad_marker"
        elif key == "playlistWindowSeconds":
            suggest = "playlist_window_seconds"
        elif key == "requestArgs":
            suggest = "request_args"
        elif key == "streamSelections":
            suggest = "stream_selections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointDashPackage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointDashPackage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointDashPackage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 segment_duration_seconds: _builtins.int,
                 url: _builtins.str,
                 ad_marker: Optional[_builtins.str] = None,
                 encryption: Optional['outputs.ChannelEndpointDashPackageEncryption'] = None,
                 playlist_window_seconds: Optional[_builtins.int] = None,
                 request_args: Optional['outputs.ChannelEndpointDashPackageRequestArgs'] = None,
                 stream_selections: Optional[Sequence['outputs.ChannelEndpointDashPackageStreamSelection']] = None):
        """
        :param _builtins.int segment_duration_seconds: Specifies the duration of the channel output segment. The unit is second.
               Value ranges from `1` to `10`.
               
               > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
               modify with caution!
        :param _builtins.str url: Specifies the DRM address of the key.
        :param _builtins.str ad_marker: Specifies the advertising marker. The DASH value is **xml+bin**.
               
               <a name="LiveChannel_MssPackage"></a>
               The `mss_package` block supports:
        :param 'ChannelEndpointDashPackageEncryptionArgs' encryption: Specifies the encrypted information.
               The encryption structure is documented below.
        :param _builtins.int playlist_window_seconds: Specifies the window length of the channel live broadcast return shard.
               The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
               The unit is second. Value ranges from `0` to `86,400`.
        :param 'ChannelEndpointDashPackageRequestArgsArgs' request_args: Specifies the play related configuration.
               The request_args structure is documented below.
               
               <a name="LiveChannel_StreamSelection"></a>
               The `stream_selection` block supports:
        :param Sequence['ChannelEndpointDashPackageStreamSelectionArgs'] stream_selections: Specifies the stream selection. Filter out the specified range of streams from
               the full stream.
               The stream_selection structure is documented below.
        """
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "url", url)
        if ad_marker is not None:
            pulumi.set(__self__, "ad_marker", ad_marker)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if playlist_window_seconds is not None:
            pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        if request_args is not None:
            pulumi.set(__self__, "request_args", request_args)
        if stream_selections is not None:
            pulumi.set(__self__, "stream_selections", stream_selections)

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> _builtins.int:
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        return pulumi.get(self, "segment_duration_seconds")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="adMarker")
    def ad_marker(self) -> Optional[_builtins.str]:
        """
        Specifies the advertising marker. The DASH value is **xml+bin**.

        <a name="LiveChannel_MssPackage"></a>
        The `mss_package` block supports:
        """
        return pulumi.get(self, "ad_marker")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.ChannelEndpointDashPackageEncryption']:
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Optional['outputs.ChannelEndpointDashPackageRequestArgs']:
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        return pulumi.get(self, "request_args")

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Optional[Sequence['outputs.ChannelEndpointDashPackageStreamSelection']]:
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")


@pulumi.output_type
class ChannelEndpointDashPackageEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestMode":
            suggest = "request_mode"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "spekeVersion":
            suggest = "speke_version"
        elif key == "systemIds":
            suggest = "system_ids"
        elif key == "encryptionMethod":
            suggest = "encryption_method"
        elif key == "httpHeaders":
            suggest = "http_headers"
        elif key == "keyRotationIntervalSeconds":
            suggest = "key_rotation_interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointDashPackageEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointDashPackageEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointDashPackageEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_mode: _builtins.str,
                 resource_id: _builtins.str,
                 speke_version: _builtins.str,
                 system_ids: Sequence[_builtins.str],
                 url: _builtins.str,
                 encryption_method: Optional[_builtins.str] = None,
                 http_headers: Optional[Sequence['outputs.ChannelEndpointDashPackageEncryptionHttpHeader']] = None,
                 key_rotation_interval_seconds: Optional[_builtins.int] = None,
                 level: Optional[_builtins.str] = None,
                 urn: Optional[_builtins.str] = None):
        """
        :param _builtins.str request_mode: Specifies the request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param _builtins.str resource_id: Specifies the customer-generated DRM content ID.
        :param _builtins.str speke_version: Specifies the DRM spec version number. Currently, only supports **1.0**.
        :param Sequence[_builtins.str] system_ids: Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param _builtins.str url: Specifies the DRM address of the key.
        :param _builtins.str encryption_method: schema: Internal; Specifies the encryption method.
        :param Sequence['ChannelEndpointDashPackageEncryptionHttpHeaderArgs'] http_headers: Specifies the authentication information that needs to be added to the DRM request header.
               Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
               The http_headers structure is documented below.
        :param _builtins.int key_rotation_interval_seconds: schema: Internal; Specifies the key rotation interval seconds.
        :param _builtins.str level: Specifies the level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
               
               Defaults to **content**.
        :param _builtins.str urn: Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
               the function graph's urn to be provided.
               
               <a name="LiveChannel_HttpHeader"></a>
               The `http_headers` block supports:
        """
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        if encryption_method is not None:
            pulumi.set(__self__, "encryption_method", encryption_method)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if key_rotation_interval_seconds is not None:
            pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> _builtins.str:
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Specifies the customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> _builtins.str:
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        return pulumi.get(self, "speke_version")

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> Sequence[_builtins.str]:
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> Optional[_builtins.str]:
        """
        schema: Internal; Specifies the encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.ChannelEndpointDashPackageEncryptionHttpHeader']]:
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> Optional[_builtins.int]:
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[_builtins.str]:
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class ChannelEndpointDashPackageEncryptionHttpHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key field name in the request header.
        :param _builtins.str value: Specifies the value corresponding to the key in the request header.
               
               <a name="LiveChannel_RequestArgs"></a>
               The `request_args` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ChannelEndpointDashPackageRequestArgs(dict):
    def __init__(__self__, *,
                 lives: Optional[Sequence['outputs.ChannelEndpointDashPackageRequestArgsLife']] = None,
                 records: Optional[Sequence['outputs.ChannelEndpointDashPackageRequestArgsRecord']] = None,
                 timeshifts: Optional[Sequence['outputs.ChannelEndpointDashPackageRequestArgsTimeshift']] = None):
        """
        :param Sequence['ChannelEndpointDashPackageRequestArgsLifeArgs'] lives: Specifies the live broadcast configuration.
               The live structure is documented below.
               
               <a name="LiveChannel_RequestArgsRecord"></a>
               The `record` block supports:
        :param Sequence['ChannelEndpointDashPackageRequestArgsRecordArgs'] records: Specifies the recording and playback related configuration.
               The record structure is documented below.
        :param Sequence['ChannelEndpointDashPackageRequestArgsTimeshiftArgs'] timeshifts: Specifies the time-shift playback configuration.
               The timeshift structure is documented below.
        """
        if lives is not None:
            pulumi.set(__self__, "lives", lives)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if timeshifts is not None:
            pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Optional[Sequence['outputs.ChannelEndpointDashPackageRequestArgsLife']]:
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        return pulumi.get(self, "lives")

    @_builtins.property
    @pulumi.getter
    def records(self) -> Optional[Sequence['outputs.ChannelEndpointDashPackageRequestArgsRecord']]:
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Optional[Sequence['outputs.ChannelEndpointDashPackageRequestArgsTimeshift']]:
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")


@pulumi.output_type
class ChannelEndpointDashPackageRequestArgsLife(dict):
    def __init__(__self__, *,
                 delay: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str delay: Specifies the delay field.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[_builtins.str]:
        """
        Specifies the delay field.
        """
        return pulumi.get(self, "delay")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointDashPackageRequestArgsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointDashPackageRequestArgsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointDashPackageRequestArgsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointDashPackageRequestArgsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_time: Specifies the end time.
        :param _builtins.str format: Specifies the format.
        :param _builtins.str start_time: Specifies the start time.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Specifies the end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Specifies the format.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Specifies the start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointDashPackageRequestArgsTimeshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backTime":
            suggest = "back_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointDashPackageRequestArgsTimeshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointDashPackageRequestArgsTimeshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointDashPackageRequestArgsTimeshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 back_time: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str back_time: Specifies the time shift duration field name.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if back_time is not None:
            pulumi.set(__self__, "back_time", back_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> Optional[_builtins.str]:
        """
        Specifies the time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointDashPackageStreamSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBandwidth":
            suggest = "max_bandwidth"
        elif key == "minBandwidth":
            suggest = "min_bandwidth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointDashPackageStreamSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointDashPackageStreamSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointDashPackageStreamSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 max_bandwidth: Optional[_builtins.int] = None,
                 min_bandwidth: Optional[_builtins.int] = None):
        """
        :param _builtins.str key: Specifies the key field name in the request header.
        :param _builtins.int max_bandwidth: Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        :param _builtins.int min_bandwidth: Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
               
               <a name="LiveChannel_Encryption"></a>
               The `encryption` block supports:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "max_bandwidth")

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
        return pulumi.get(self, "min_bandwidth")


@pulumi.output_type
class ChannelEndpointHlsPackage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "segmentDurationSeconds":
            suggest = "segment_duration_seconds"
        elif key == "adMarkers":
            suggest = "ad_markers"
        elif key == "hlsVersion":
            suggest = "hls_version"
        elif key == "playlistWindowSeconds":
            suggest = "playlist_window_seconds"
        elif key == "requestArgs":
            suggest = "request_args"
        elif key == "streamSelections":
            suggest = "stream_selections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointHlsPackage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointHlsPackage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointHlsPackage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 segment_duration_seconds: _builtins.int,
                 url: _builtins.str,
                 ad_markers: Optional[Sequence[_builtins.str]] = None,
                 encryption: Optional['outputs.ChannelEndpointHlsPackageEncryption'] = None,
                 hls_version: Optional[_builtins.str] = None,
                 playlist_window_seconds: Optional[_builtins.int] = None,
                 request_args: Optional['outputs.ChannelEndpointHlsPackageRequestArgs'] = None,
                 stream_selections: Optional[Sequence['outputs.ChannelEndpointHlsPackageStreamSelection']] = None):
        """
        :param _builtins.int segment_duration_seconds: Specifies the duration of the channel output segment. The unit is second.
               Value ranges from `1` to `10`.
               
               > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
               modify with caution!
        :param _builtins.str url: Specifies the DRM address of the key.
        :param Sequence[_builtins.str] ad_markers: Specifies the advertising marker. The DASH value is **xml+bin**.
               
               <a name="LiveChannel_MssPackage"></a>
               The `mss_package` block supports:
        :param 'ChannelEndpointHlsPackageEncryptionArgs' encryption: Specifies the encrypted information.
               The encryption structure is documented below.
        :param _builtins.str hls_version: Specifies the HLS version.
        :param _builtins.int playlist_window_seconds: Specifies the window length of the channel live broadcast return shard.
               The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
               The unit is second. Value ranges from `0` to `86,400`.
        :param 'ChannelEndpointHlsPackageRequestArgsArgs' request_args: Specifies the play related configuration.
               The request_args structure is documented below.
               
               <a name="LiveChannel_StreamSelection"></a>
               The `stream_selection` block supports:
        :param Sequence['ChannelEndpointHlsPackageStreamSelectionArgs'] stream_selections: Specifies the stream selection. Filter out the specified range of streams from
               the full stream.
               The stream_selection structure is documented below.
        """
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "url", url)
        if ad_markers is not None:
            pulumi.set(__self__, "ad_markers", ad_markers)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if hls_version is not None:
            pulumi.set(__self__, "hls_version", hls_version)
        if playlist_window_seconds is not None:
            pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        if request_args is not None:
            pulumi.set(__self__, "request_args", request_args)
        if stream_selections is not None:
            pulumi.set(__self__, "stream_selections", stream_selections)

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> _builtins.int:
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        return pulumi.get(self, "segment_duration_seconds")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the advertising marker. The DASH value is **xml+bin**.

        <a name="LiveChannel_MssPackage"></a>
        The `mss_package` block supports:
        """
        return pulumi.get(self, "ad_markers")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.ChannelEndpointHlsPackageEncryption']:
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter(name="hlsVersion")
    def hls_version(self) -> Optional[_builtins.str]:
        """
        Specifies the HLS version.
        """
        return pulumi.get(self, "hls_version")

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Optional['outputs.ChannelEndpointHlsPackageRequestArgs']:
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        return pulumi.get(self, "request_args")

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Optional[Sequence['outputs.ChannelEndpointHlsPackageStreamSelection']]:
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")


@pulumi.output_type
class ChannelEndpointHlsPackageEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestMode":
            suggest = "request_mode"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "spekeVersion":
            suggest = "speke_version"
        elif key == "systemIds":
            suggest = "system_ids"
        elif key == "encryptionMethod":
            suggest = "encryption_method"
        elif key == "httpHeaders":
            suggest = "http_headers"
        elif key == "keyRotationIntervalSeconds":
            suggest = "key_rotation_interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointHlsPackageEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointHlsPackageEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointHlsPackageEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_mode: _builtins.str,
                 resource_id: _builtins.str,
                 speke_version: _builtins.str,
                 system_ids: Sequence[_builtins.str],
                 url: _builtins.str,
                 encryption_method: Optional[_builtins.str] = None,
                 http_headers: Optional[Sequence['outputs.ChannelEndpointHlsPackageEncryptionHttpHeader']] = None,
                 key_rotation_interval_seconds: Optional[_builtins.int] = None,
                 level: Optional[_builtins.str] = None,
                 urn: Optional[_builtins.str] = None):
        """
        :param _builtins.str request_mode: Specifies the request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param _builtins.str resource_id: Specifies the customer-generated DRM content ID.
        :param _builtins.str speke_version: Specifies the DRM spec version number. Currently, only supports **1.0**.
        :param Sequence[_builtins.str] system_ids: Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param _builtins.str url: Specifies the DRM address of the key.
        :param _builtins.str encryption_method: schema: Internal; Specifies the encryption method.
        :param Sequence['ChannelEndpointHlsPackageEncryptionHttpHeaderArgs'] http_headers: Specifies the authentication information that needs to be added to the DRM request header.
               Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
               The http_headers structure is documented below.
        :param _builtins.int key_rotation_interval_seconds: schema: Internal; Specifies the key rotation interval seconds.
        :param _builtins.str level: Specifies the level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
               
               Defaults to **content**.
        :param _builtins.str urn: Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
               the function graph's urn to be provided.
               
               <a name="LiveChannel_HttpHeader"></a>
               The `http_headers` block supports:
        """
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        if encryption_method is not None:
            pulumi.set(__self__, "encryption_method", encryption_method)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if key_rotation_interval_seconds is not None:
            pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> _builtins.str:
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Specifies the customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> _builtins.str:
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        return pulumi.get(self, "speke_version")

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> Sequence[_builtins.str]:
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> Optional[_builtins.str]:
        """
        schema: Internal; Specifies the encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.ChannelEndpointHlsPackageEncryptionHttpHeader']]:
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> Optional[_builtins.int]:
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[_builtins.str]:
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class ChannelEndpointHlsPackageEncryptionHttpHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key field name in the request header.
        :param _builtins.str value: Specifies the value corresponding to the key in the request header.
               
               <a name="LiveChannel_RequestArgs"></a>
               The `request_args` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ChannelEndpointHlsPackageRequestArgs(dict):
    def __init__(__self__, *,
                 lives: Optional[Sequence['outputs.ChannelEndpointHlsPackageRequestArgsLife']] = None,
                 records: Optional[Sequence['outputs.ChannelEndpointHlsPackageRequestArgsRecord']] = None,
                 timeshifts: Optional[Sequence['outputs.ChannelEndpointHlsPackageRequestArgsTimeshift']] = None):
        """
        :param Sequence['ChannelEndpointHlsPackageRequestArgsLifeArgs'] lives: Specifies the live broadcast configuration.
               The live structure is documented below.
               
               <a name="LiveChannel_RequestArgsRecord"></a>
               The `record` block supports:
        :param Sequence['ChannelEndpointHlsPackageRequestArgsRecordArgs'] records: Specifies the recording and playback related configuration.
               The record structure is documented below.
        :param Sequence['ChannelEndpointHlsPackageRequestArgsTimeshiftArgs'] timeshifts: Specifies the time-shift playback configuration.
               The timeshift structure is documented below.
        """
        if lives is not None:
            pulumi.set(__self__, "lives", lives)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if timeshifts is not None:
            pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Optional[Sequence['outputs.ChannelEndpointHlsPackageRequestArgsLife']]:
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        return pulumi.get(self, "lives")

    @_builtins.property
    @pulumi.getter
    def records(self) -> Optional[Sequence['outputs.ChannelEndpointHlsPackageRequestArgsRecord']]:
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Optional[Sequence['outputs.ChannelEndpointHlsPackageRequestArgsTimeshift']]:
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")


@pulumi.output_type
class ChannelEndpointHlsPackageRequestArgsLife(dict):
    def __init__(__self__, *,
                 delay: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str delay: Specifies the delay field.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[_builtins.str]:
        """
        Specifies the delay field.
        """
        return pulumi.get(self, "delay")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointHlsPackageRequestArgsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointHlsPackageRequestArgsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointHlsPackageRequestArgsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointHlsPackageRequestArgsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_time: Specifies the end time.
        :param _builtins.str format: Specifies the format.
        :param _builtins.str start_time: Specifies the start time.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Specifies the end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Specifies the format.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Specifies the start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointHlsPackageRequestArgsTimeshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backTime":
            suggest = "back_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointHlsPackageRequestArgsTimeshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointHlsPackageRequestArgsTimeshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointHlsPackageRequestArgsTimeshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 back_time: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str back_time: Specifies the time shift duration field name.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if back_time is not None:
            pulumi.set(__self__, "back_time", back_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> Optional[_builtins.str]:
        """
        Specifies the time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointHlsPackageStreamSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBandwidth":
            suggest = "max_bandwidth"
        elif key == "minBandwidth":
            suggest = "min_bandwidth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointHlsPackageStreamSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointHlsPackageStreamSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointHlsPackageStreamSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 max_bandwidth: Optional[_builtins.int] = None,
                 min_bandwidth: Optional[_builtins.int] = None):
        """
        :param _builtins.str key: Specifies the key field name in the request header.
        :param _builtins.int max_bandwidth: Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        :param _builtins.int min_bandwidth: Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
               
               <a name="LiveChannel_Encryption"></a>
               The `encryption` block supports:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "max_bandwidth")

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
        return pulumi.get(self, "min_bandwidth")


@pulumi.output_type
class ChannelEndpointMssPackage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "segmentDurationSeconds":
            suggest = "segment_duration_seconds"
        elif key == "delaySegment":
            suggest = "delay_segment"
        elif key == "playlistWindowSeconds":
            suggest = "playlist_window_seconds"
        elif key == "requestArgs":
            suggest = "request_args"
        elif key == "streamSelections":
            suggest = "stream_selections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointMssPackage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointMssPackage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointMssPackage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 segment_duration_seconds: _builtins.int,
                 url: _builtins.str,
                 delay_segment: Optional[_builtins.int] = None,
                 encryption: Optional['outputs.ChannelEndpointMssPackageEncryption'] = None,
                 playlist_window_seconds: Optional[_builtins.int] = None,
                 request_args: Optional['outputs.ChannelEndpointMssPackageRequestArgs'] = None,
                 stream_selections: Optional[Sequence['outputs.ChannelEndpointMssPackageStreamSelection']] = None):
        """
        :param _builtins.int segment_duration_seconds: Specifies the duration of the channel output segment. The unit is second.
               Value ranges from `1` to `10`.
               
               > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
               modify with caution!
        :param _builtins.str url: Specifies the DRM address of the key.
        :param _builtins.int delay_segment: Specifies the delayed playback time. The unit is second.
        :param 'ChannelEndpointMssPackageEncryptionArgs' encryption: Specifies the encrypted information.
               The encryption structure is documented below.
        :param _builtins.int playlist_window_seconds: Specifies the window length of the channel live broadcast return shard.
               The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
               The unit is second. Value ranges from `0` to `86,400`.
        :param 'ChannelEndpointMssPackageRequestArgsArgs' request_args: Specifies the play related configuration.
               The request_args structure is documented below.
               
               <a name="LiveChannel_StreamSelection"></a>
               The `stream_selection` block supports:
        :param Sequence['ChannelEndpointMssPackageStreamSelectionArgs'] stream_selections: Specifies the stream selection. Filter out the specified range of streams from
               the full stream.
               The stream_selection structure is documented below.
        """
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "url", url)
        if delay_segment is not None:
            pulumi.set(__self__, "delay_segment", delay_segment)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if playlist_window_seconds is not None:
            pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        if request_args is not None:
            pulumi.set(__self__, "request_args", request_args)
        if stream_selections is not None:
            pulumi.set(__self__, "stream_selections", stream_selections)

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> _builtins.int:
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        return pulumi.get(self, "segment_duration_seconds")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="delaySegment")
    def delay_segment(self) -> Optional[_builtins.int]:
        """
        Specifies the delayed playback time. The unit is second.
        """
        return pulumi.get(self, "delay_segment")

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.ChannelEndpointMssPackageEncryption']:
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryption")

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> Optional[_builtins.int]:
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Optional['outputs.ChannelEndpointMssPackageRequestArgs']:
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        return pulumi.get(self, "request_args")

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Optional[Sequence['outputs.ChannelEndpointMssPackageStreamSelection']]:
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")


@pulumi.output_type
class ChannelEndpointMssPackageEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestMode":
            suggest = "request_mode"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "spekeVersion":
            suggest = "speke_version"
        elif key == "systemIds":
            suggest = "system_ids"
        elif key == "encryptionMethod":
            suggest = "encryption_method"
        elif key == "httpHeaders":
            suggest = "http_headers"
        elif key == "keyRotationIntervalSeconds":
            suggest = "key_rotation_interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointMssPackageEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointMssPackageEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointMssPackageEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_mode: _builtins.str,
                 resource_id: _builtins.str,
                 speke_version: _builtins.str,
                 system_ids: Sequence[_builtins.str],
                 url: _builtins.str,
                 encryption_method: Optional[_builtins.str] = None,
                 http_headers: Optional[Sequence['outputs.ChannelEndpointMssPackageEncryptionHttpHeader']] = None,
                 key_rotation_interval_seconds: Optional[_builtins.int] = None,
                 level: Optional[_builtins.str] = None,
                 urn: Optional[_builtins.str] = None):
        """
        :param _builtins.str request_mode: Specifies the request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param _builtins.str resource_id: Specifies the customer-generated DRM content ID.
        :param _builtins.str speke_version: Specifies the DRM spec version number. Currently, only supports **1.0**.
        :param Sequence[_builtins.str] system_ids: Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param _builtins.str url: Specifies the DRM address of the key.
        :param _builtins.str encryption_method: schema: Internal; Specifies the encryption method.
        :param Sequence['ChannelEndpointMssPackageEncryptionHttpHeaderArgs'] http_headers: Specifies the authentication information that needs to be added to the DRM request header.
               Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
               The http_headers structure is documented below.
        :param _builtins.int key_rotation_interval_seconds: schema: Internal; Specifies the key rotation interval seconds.
        :param _builtins.str level: Specifies the level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
               
               Defaults to **content**.
        :param _builtins.str urn: Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
               the function graph's urn to be provided.
               
               <a name="LiveChannel_HttpHeader"></a>
               The `http_headers` block supports:
        """
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        if encryption_method is not None:
            pulumi.set(__self__, "encryption_method", encryption_method)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if key_rotation_interval_seconds is not None:
            pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> _builtins.str:
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Specifies the customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> _builtins.str:
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        return pulumi.get(self, "speke_version")

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> Sequence[_builtins.str]:
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> Optional[_builtins.str]:
        """
        schema: Internal; Specifies the encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.ChannelEndpointMssPackageEncryptionHttpHeader']]:
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> Optional[_builtins.int]:
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[_builtins.str]:
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class ChannelEndpointMssPackageEncryptionHttpHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key field name in the request header.
        :param _builtins.str value: Specifies the value corresponding to the key in the request header.
               
               <a name="LiveChannel_RequestArgs"></a>
               The `request_args` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ChannelEndpointMssPackageRequestArgs(dict):
    def __init__(__self__, *,
                 lives: Optional[Sequence['outputs.ChannelEndpointMssPackageRequestArgsLife']] = None,
                 records: Optional[Sequence['outputs.ChannelEndpointMssPackageRequestArgsRecord']] = None,
                 timeshifts: Optional[Sequence['outputs.ChannelEndpointMssPackageRequestArgsTimeshift']] = None):
        """
        :param Sequence['ChannelEndpointMssPackageRequestArgsLifeArgs'] lives: Specifies the live broadcast configuration.
               The live structure is documented below.
               
               <a name="LiveChannel_RequestArgsRecord"></a>
               The `record` block supports:
        :param Sequence['ChannelEndpointMssPackageRequestArgsRecordArgs'] records: Specifies the recording and playback related configuration.
               The record structure is documented below.
        :param Sequence['ChannelEndpointMssPackageRequestArgsTimeshiftArgs'] timeshifts: Specifies the time-shift playback configuration.
               The timeshift structure is documented below.
        """
        if lives is not None:
            pulumi.set(__self__, "lives", lives)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if timeshifts is not None:
            pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Optional[Sequence['outputs.ChannelEndpointMssPackageRequestArgsLife']]:
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        return pulumi.get(self, "lives")

    @_builtins.property
    @pulumi.getter
    def records(self) -> Optional[Sequence['outputs.ChannelEndpointMssPackageRequestArgsRecord']]:
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Optional[Sequence['outputs.ChannelEndpointMssPackageRequestArgsTimeshift']]:
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")


@pulumi.output_type
class ChannelEndpointMssPackageRequestArgsLife(dict):
    def __init__(__self__, *,
                 delay: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str delay: Specifies the delay field.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[_builtins.str]:
        """
        Specifies the delay field.
        """
        return pulumi.get(self, "delay")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointMssPackageRequestArgsRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointMssPackageRequestArgsRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointMssPackageRequestArgsRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointMssPackageRequestArgsRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_time: Specifies the end time.
        :param _builtins.str format: Specifies the format.
        :param _builtins.str start_time: Specifies the start time.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Specifies the end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Specifies the format.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Specifies the start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointMssPackageRequestArgsTimeshift(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backTime":
            suggest = "back_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointMssPackageRequestArgsTimeshift. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointMssPackageRequestArgsTimeshift.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointMssPackageRequestArgsTimeshift.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 back_time: Optional[_builtins.str] = None,
                 unit: Optional[_builtins.str] = None):
        """
        :param _builtins.str back_time: Specifies the time shift duration field name.
        :param _builtins.str unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if back_time is not None:
            pulumi.set(__self__, "back_time", back_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> Optional[_builtins.str]:
        """
        Specifies the time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[_builtins.str]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class ChannelEndpointMssPackageStreamSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBandwidth":
            suggest = "max_bandwidth"
        elif key == "minBandwidth":
            suggest = "min_bandwidth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEndpointMssPackageStreamSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEndpointMssPackageStreamSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEndpointMssPackageStreamSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 max_bandwidth: Optional[_builtins.int] = None,
                 min_bandwidth: Optional[_builtins.int] = None):
        """
        :param _builtins.str key: Specifies the key field name in the request header.
        :param _builtins.int max_bandwidth: Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        :param _builtins.int min_bandwidth: Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
               
               <a name="LiveChannel_Encryption"></a>
               The `encryption` block supports:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "max_bandwidth")

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[_builtins.int]:
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
        return pulumi.get(self, "min_bandwidth")


@pulumi.output_type
class ChannelInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputProtocol":
            suggest = "input_protocol"
        elif key == "adTriggers":
            suggest = "ad_triggers"
        elif key == "audioSelectors":
            suggest = "audio_selectors"
        elif key == "failoverConditions":
            suggest = "failover_conditions"
        elif key == "ipPortMode":
            suggest = "ip_port_mode"
        elif key == "ipWhitelist":
            suggest = "ip_whitelist"
        elif key == "maxBandwidthLimit":
            suggest = "max_bandwidth_limit"
        elif key == "scte35Source":
            suggest = "scte35_source"
        elif key == "secondarySources":
            suggest = "secondary_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_protocol: _builtins.str,
                 ad_triggers: Optional[Sequence[_builtins.str]] = None,
                 audio_selectors: Optional[Sequence['outputs.ChannelInputAudioSelector']] = None,
                 failover_conditions: Optional['outputs.ChannelInputFailoverConditions'] = None,
                 ip_port_mode: Optional[_builtins.bool] = None,
                 ip_whitelist: Optional[_builtins.str] = None,
                 max_bandwidth_limit: Optional[_builtins.int] = None,
                 scte35_source: Optional[_builtins.str] = None,
                 secondary_sources: Optional[Sequence['outputs.ChannelInputSecondarySource']] = None,
                 sources: Optional[Sequence['outputs.ChannelInputSource']] = None):
        """
        :param _builtins.str input_protocol: Specifies the channel input protocol. Valid values are:
               + **FLV_PULL**.
               + **RTMP_PUSH**.
               + **HLS_PULL**.
               + **SRT_PULL**.
               + **SRT_PUSH**.
               
               Changing this parameter will create a new resource.
        :param Sequence[_builtins.str] ad_triggers: Specifies the ad trigger configuration list. Valid Values are:
               + **Splice insert**.
               + **Provider advertisement**.
               + **Distributor advertisement**.
               + **Provider placement opportunity**.
               + **Distributor placement opportunity**.
        :param Sequence['ChannelInputAudioSelectorArgs'] audio_selectors: Specifies the audio selector configuration. Set up to `8` audio selectors.
               The audio_selectors structure is documented below.
               
               <a name="LiveChannel_Sources"></a>
               The `sources` block supports:
        :param 'ChannelInputFailoverConditionsArgs' failover_conditions: Specifies the configuration of switching between primary and backup audio
               and video stream URLs.
               The failover_conditions structure is documented below.
        :param _builtins.bool ip_port_mode: Specifies the IP port mode.
               
               > When the stream push protocol is **SRT_PUSH** and streams are pushed to the origin server, set this parameter
               to **true**.
        :param _builtins.str ip_whitelist: Specifies the IP whitelist when protocol is **SRT_PUSH**.
        :param _builtins.int max_bandwidth_limit: Specifies the maximum bandwidth that needs to be configured when the inbound
               protocol is **HLS_PULL**. The unit is **bps**.
               
               > In the streaming URL provided by the user, the bandwidth parameter "BANDWIDTH" will be carried for audio and video
               with different bit rates.<br/>1. If the maximum bandwidth is configured here, when the media live broadcast service
               pulls the stream from the URL, it will select the audio and video stream with a smaller bandwidth and the highest bit
               rate and push it to the source station.<br/>2. If the maximum bandwidth is not configured here, when the media live
               broadcast service pulls the stream from the URL, it will select the audio and video stream with the highest "BANDWIDTH"
               by default and push the stream to the source station.
        :param _builtins.str scte35_source: Specifies the advertisement scte35 signal source. This configuration is only
               supported for **HLS_PULL** channels, and currently only supports **SEGMENTS**.
        :param Sequence['ChannelInputSecondarySourceArgs'] secondary_sources: Specifies the prepared stream array. If this parameter is configured, ensure
               that the number of channels, codec, and resolution of the primary and standby input streams are the same.
               This field does not need to be configured when the stream input protocol is **RTMP_PUSH**.
               The secondary_sources structure is documented below.
        :param Sequence['ChannelInputSourceArgs'] sources: Specifies the channel main source stream information. This parameter is optional
               when the stream input protocol is **RTMP_PUSH** or **SRT_PUSH**. In other cases, this parameter is mandatory.
               The sources structure is documented below.
        """
        pulumi.set(__self__, "input_protocol", input_protocol)
        if ad_triggers is not None:
            pulumi.set(__self__, "ad_triggers", ad_triggers)
        if audio_selectors is not None:
            pulumi.set(__self__, "audio_selectors", audio_selectors)
        if failover_conditions is not None:
            pulumi.set(__self__, "failover_conditions", failover_conditions)
        if ip_port_mode is not None:
            pulumi.set(__self__, "ip_port_mode", ip_port_mode)
        if ip_whitelist is not None:
            pulumi.set(__self__, "ip_whitelist", ip_whitelist)
        if max_bandwidth_limit is not None:
            pulumi.set(__self__, "max_bandwidth_limit", max_bandwidth_limit)
        if scte35_source is not None:
            pulumi.set(__self__, "scte35_source", scte35_source)
        if secondary_sources is not None:
            pulumi.set(__self__, "secondary_sources", secondary_sources)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter(name="inputProtocol")
    def input_protocol(self) -> _builtins.str:
        """
        Specifies the channel input protocol. Valid values are:
        + **FLV_PULL**.
        + **RTMP_PUSH**.
        + **HLS_PULL**.
        + **SRT_PULL**.
        + **SRT_PUSH**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "input_protocol")

    @_builtins.property
    @pulumi.getter(name="adTriggers")
    def ad_triggers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the ad trigger configuration list. Valid Values are:
        + **Splice insert**.
        + **Provider advertisement**.
        + **Distributor advertisement**.
        + **Provider placement opportunity**.
        + **Distributor placement opportunity**.
        """
        return pulumi.get(self, "ad_triggers")

    @_builtins.property
    @pulumi.getter(name="audioSelectors")
    def audio_selectors(self) -> Optional[Sequence['outputs.ChannelInputAudioSelector']]:
        """
        Specifies the audio selector configuration. Set up to `8` audio selectors.
        The audio_selectors structure is documented below.

        <a name="LiveChannel_Sources"></a>
        The `sources` block supports:
        """
        return pulumi.get(self, "audio_selectors")

    @_builtins.property
    @pulumi.getter(name="failoverConditions")
    def failover_conditions(self) -> Optional['outputs.ChannelInputFailoverConditions']:
        """
        Specifies the configuration of switching between primary and backup audio
        and video stream URLs.
        The failover_conditions structure is documented below.
        """
        return pulumi.get(self, "failover_conditions")

    @_builtins.property
    @pulumi.getter(name="ipPortMode")
    def ip_port_mode(self) -> Optional[_builtins.bool]:
        """
        Specifies the IP port mode.

        > When the stream push protocol is **SRT_PUSH** and streams are pushed to the origin server, set this parameter
        to **true**.
        """
        return pulumi.get(self, "ip_port_mode")

    @_builtins.property
    @pulumi.getter(name="ipWhitelist")
    def ip_whitelist(self) -> Optional[_builtins.str]:
        """
        Specifies the IP whitelist when protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "ip_whitelist")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthLimit")
    def max_bandwidth_limit(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum bandwidth that needs to be configured when the inbound
        protocol is **HLS_PULL**. The unit is **bps**.

        > In the streaming URL provided by the user, the bandwidth parameter "BANDWIDTH" will be carried for audio and video
        with different bit rates.<br/>1. If the maximum bandwidth is configured here, when the media live broadcast service
        pulls the stream from the URL, it will select the audio and video stream with a smaller bandwidth and the highest bit
        rate and push it to the source station.<br/>2. If the maximum bandwidth is not configured here, when the media live
        broadcast service pulls the stream from the URL, it will select the audio and video stream with the highest "BANDWIDTH"
        by default and push the stream to the source station.
        """
        return pulumi.get(self, "max_bandwidth_limit")

    @_builtins.property
    @pulumi.getter(name="scte35Source")
    def scte35_source(self) -> Optional[_builtins.str]:
        """
        Specifies the advertisement scte35 signal source. This configuration is only
        supported for **HLS_PULL** channels, and currently only supports **SEGMENTS**.
        """
        return pulumi.get(self, "scte35_source")

    @_builtins.property
    @pulumi.getter(name="secondarySources")
    def secondary_sources(self) -> Optional[Sequence['outputs.ChannelInputSecondarySource']]:
        """
        Specifies the prepared stream array. If this parameter is configured, ensure
        that the number of channels, codec, and resolution of the primary and standby input streams are the same.
        This field does not need to be configured when the stream input protocol is **RTMP_PUSH**.
        The secondary_sources structure is documented below.
        """
        return pulumi.get(self, "secondary_sources")

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.ChannelInputSource']]:
        """
        Specifies the channel main source stream information. This parameter is optional
        when the stream input protocol is **RTMP_PUSH** or **SRT_PUSH**. In other cases, this parameter is mandatory.
        The sources structure is documented below.
        """
        return pulumi.get(self, "sources")


@pulumi.output_type
class ChannelInputAudioSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectorSettings":
            suggest = "selector_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAudioSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAudioSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAudioSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 selector_settings: Optional['outputs.ChannelInputAudioSelectorSelectorSettings'] = None):
        """
        :param _builtins.str name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param 'ChannelInputAudioSelectorSelectorSettingsArgs' selector_settings: Specifies the audio selector configuration.
               The selector_settings structure is documented below.
               
               <a name="LiveChannel_SelectorSettings"></a>
               The `selector_settings` block supports:
        """
        pulumi.set(__self__, "name", name)
        if selector_settings is not None:
            pulumi.set(__self__, "selector_settings", selector_settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional['outputs.ChannelInputAudioSelectorSelectorSettings']:
        """
        Specifies the audio selector configuration.
        The selector_settings structure is documented below.

        <a name="LiveChannel_SelectorSettings"></a>
        The `selector_settings` block supports:
        """
        return pulumi.get(self, "selector_settings")


@pulumi.output_type
class ChannelInputAudioSelectorSelectorSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioHlsSelection":
            suggest = "audio_hls_selection"
        elif key == "audioLanguageSelection":
            suggest = "audio_language_selection"
        elif key == "audioPidSelection":
            suggest = "audio_pid_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAudioSelectorSelectorSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAudioSelectorSelectorSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAudioSelectorSelectorSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_hls_selection: Optional['outputs.ChannelInputAudioSelectorSelectorSettingsAudioHlsSelection'] = None,
                 audio_language_selection: Optional['outputs.ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelection'] = None,
                 audio_pid_selection: Optional['outputs.ChannelInputAudioSelectorSelectorSettingsAudioPidSelection'] = None):
        """
        :param 'ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgs' audio_hls_selection: Specifies the HLS selector configuration.
               The audio_hls_selection structure is documented below.
               
               <a name="LiveChannel_AudioLanguageSelection"></a>
               The `audio_language_selection` block supports:
        :param 'ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgs' audio_language_selection: Specifies the language selector configuration.
               The audio_language_selection structure is documented below.
        :param 'ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgs' audio_pid_selection: Specifies the PID selector configuration.
               The audio_pid_selection structure is documented below.
        """
        if audio_hls_selection is not None:
            pulumi.set(__self__, "audio_hls_selection", audio_hls_selection)
        if audio_language_selection is not None:
            pulumi.set(__self__, "audio_language_selection", audio_language_selection)
        if audio_pid_selection is not None:
            pulumi.set(__self__, "audio_pid_selection", audio_pid_selection)

    @_builtins.property
    @pulumi.getter(name="audioHlsSelection")
    def audio_hls_selection(self) -> Optional['outputs.ChannelInputAudioSelectorSelectorSettingsAudioHlsSelection']:
        """
        Specifies the HLS selector configuration.
        The audio_hls_selection structure is documented below.

        <a name="LiveChannel_AudioLanguageSelection"></a>
        The `audio_language_selection` block supports:
        """
        return pulumi.get(self, "audio_hls_selection")

    @_builtins.property
    @pulumi.getter(name="audioLanguageSelection")
    def audio_language_selection(self) -> Optional['outputs.ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelection']:
        """
        Specifies the language selector configuration.
        The audio_language_selection structure is documented below.
        """
        return pulumi.get(self, "audio_language_selection")

    @_builtins.property
    @pulumi.getter(name="audioPidSelection")
    def audio_pid_selection(self) -> Optional['outputs.ChannelInputAudioSelectorSelectorSettingsAudioPidSelection']:
        """
        Specifies the PID selector configuration.
        The audio_pid_selection structure is documented below.
        """
        return pulumi.get(self, "audio_pid_selection")


@pulumi.output_type
class ChannelInputAudioSelectorSelectorSettingsAudioHlsSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAudioSelectorSelectorSettingsAudioHlsSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAudioSelectorSelectorSettingsAudioHlsSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAudioSelectorSelectorSettingsAudioHlsSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str group_id: Specifies the HLS audio selector gid.
               
               <a name="LiveChannel_RecordSettings"></a>
               The `record_settings` block supports:
        :param _builtins.str name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Specifies the HLS audio selector gid.

        <a name="LiveChannel_RecordSettings"></a>
        The `record_settings` block supports:
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"
        elif key == "languageSelectionPolicy":
            suggest = "language_selection_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language_code: _builtins.str,
                 language_selection_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str language_code: Specifies the language code. The value could be `2` or `3` lowercase letters.
        :param _builtins.str language_selection_policy: Specifies the language output strategy. Valid values are:
               + **LOOSE**: Loose matching. For example, "eng" will prioritize matching tracks with English as the language in the
               source stream. If no match is found, the track with the smallest PID will be selected.
               + **STRICT**: Strict matching. For example, "eng" will strictly match the audio track in the source stream whose
               language is English. If no match is found, the media live broadcast service will automatically fill in a silent
               segment. When the terminal uses this audio selector to play the video, it will be played silently.
               
               <a name="LiveChannel_AudioPidSelection"></a>
               The `audio_pid_selection` block supports:
        """
        pulumi.set(__self__, "language_code", language_code)
        if language_selection_policy is not None:
            pulumi.set(__self__, "language_selection_policy", language_selection_policy)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        Specifies the language code. The value could be `2` or `3` lowercase letters.
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="languageSelectionPolicy")
    def language_selection_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the language output strategy. Valid values are:
        + **LOOSE**: Loose matching. For example, "eng" will prioritize matching tracks with English as the language in the
        source stream. If no match is found, the track with the smallest PID will be selected.
        + **STRICT**: Strict matching. For example, "eng" will strictly match the audio track in the source stream whose
        language is English. If no match is found, the media live broadcast service will automatically fill in a silent
        segment. When the terminal uses this audio selector to play the video, it will be played silently.

        <a name="LiveChannel_AudioPidSelection"></a>
        The `audio_pid_selection` block supports:
        """
        return pulumi.get(self, "language_selection_policy")


@pulumi.output_type
class ChannelInputAudioSelectorSelectorSettingsAudioPidSelection(dict):
    def __init__(__self__, *,
                 pid: _builtins.int):
        """
        :param _builtins.int pid: Specifies the value of PID.
               
               <a name="LiveChannel_AudioHlsSelection"></a>
               The `audio_hls_selection` block supports:
        """
        pulumi.set(__self__, "pid", pid)

    @_builtins.property
    @pulumi.getter
    def pid(self) -> _builtins.int:
        """
        Specifies the value of PID.

        <a name="LiveChannel_AudioHlsSelection"></a>
        The `audio_hls_selection` block supports:
        """
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelInputFailoverConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputLossThresholdMsec":
            suggest = "input_loss_threshold_msec"
        elif key == "inputPreference":
            suggest = "input_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputFailoverConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputFailoverConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputFailoverConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_loss_threshold_msec: Optional[_builtins.int] = None,
                 input_preference: Optional[_builtins.str] = None):
        """
        :param _builtins.int input_loss_threshold_msec: Specifies the duration threshold of inflow stop.
               When this threshold is reached, the active/standby switchover is automatically triggered. The unit is millisecond.
               Value ranges from `0` to `3,600,000`. Defaults to `2,000` ms.
        :param _builtins.str input_preference: Specifies the input preference type. Valid values are:
               + **PRIMARY**: The main incoming URL is the first priority.
               + **EQUAL**: Equal switching between primary and backup URLs.
               
               Defaults to **EQUAL**.
               
               > If equal switching is used and the backup URL is used, it will not automatically switch to the primary URL.
               
               <a name="LiveChannel_AudioSelectors"></a>
               The `audio_selectors` block supports:
        """
        if input_loss_threshold_msec is not None:
            pulumi.set(__self__, "input_loss_threshold_msec", input_loss_threshold_msec)
        if input_preference is not None:
            pulumi.set(__self__, "input_preference", input_preference)

    @_builtins.property
    @pulumi.getter(name="inputLossThresholdMsec")
    def input_loss_threshold_msec(self) -> Optional[_builtins.int]:
        """
        Specifies the duration threshold of inflow stop.
        When this threshold is reached, the active/standby switchover is automatically triggered. The unit is millisecond.
        Value ranges from `0` to `3,600,000`. Defaults to `2,000` ms.
        """
        return pulumi.get(self, "input_loss_threshold_msec")

    @_builtins.property
    @pulumi.getter(name="inputPreference")
    def input_preference(self) -> Optional[_builtins.str]:
        """
        Specifies the input preference type. Valid values are:
        + **PRIMARY**: The main incoming URL is the first priority.
        + **EQUAL**: Equal switching between primary and backup URLs.

        Defaults to **EQUAL**.

        > If equal switching is used and the backup URL is used, it will not automatically switch to the primary URL.

        <a name="LiveChannel_AudioSelectors"></a>
        The `audio_selectors` block supports:
        """
        return pulumi.get(self, "input_preference")


@pulumi.output_type
class ChannelInputSecondarySource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupUrls":
            suggest = "backup_urls"
        elif key == "bitrateFor3u8":
            suggest = "bitrate_for3u8"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputSecondarySource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputSecondarySource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputSecondarySource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_urls: Optional[Sequence[_builtins.str]] = None,
                 bitrate: Optional[_builtins.int] = None,
                 bitrate_for3u8: Optional[_builtins.bool] = None,
                 height: Optional[_builtins.int] = None,
                 latency: Optional[_builtins.int] = None,
                 passphrase: Optional[_builtins.str] = None,
                 stream_id: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 width: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] backup_urls: Specifies the list of backup stream addresses.
        :param _builtins.int bitrate: Specifies the bitrate. This parameter is required when live transcoding is not required.
               The unit is **bps**. Value ranges from `0` to `104,857,600`.
        :param _builtins.bool bitrate_for3u8: Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        :param _builtins.int height: Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        :param _builtins.int latency: Specifies the streaming delay when the channel type is **SRT_PULL**.
               
               <a name="LiveChannel_FailoverConditions"></a>
               The `failover_conditions` block supports:
        :param _builtins.str passphrase: Specifies the encrypted information when the protocol is **SRT_PUSH**.
        :param _builtins.str stream_id: Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        :param _builtins.str url: Specifies the DRM address of the key.
        :param _builtins.int width: Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        if backup_urls is not None:
            pulumi.set(__self__, "backup_urls", backup_urls)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if bitrate_for3u8 is not None:
            pulumi.set(__self__, "bitrate_for3u8", bitrate_for3u8)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter(name="backupUrls")
    def backup_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of backup stream addresses.
        """
        return pulumi.get(self, "backup_urls")

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> Optional[_builtins.int]:
        """
        Specifies the bitrate. This parameter is required when live transcoding is not required.
        The unit is **bps**. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "bitrate")

    @_builtins.property
    @pulumi.getter(name="bitrateFor3u8")
    def bitrate_for3u8(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        """
        return pulumi.get(self, "bitrate_for3u8")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.int]:
        """
        Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[_builtins.int]:
        """
        Specifies the streaming delay when the channel type is **SRT_PULL**.

        <a name="LiveChannel_FailoverConditions"></a>
        The `failover_conditions` block supports:
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        Specifies the encrypted information when the protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[_builtins.str]:
        """
        Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.int]:
        """
        Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class ChannelInputSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupUrls":
            suggest = "backup_urls"
        elif key == "bitrateFor3u8":
            suggest = "bitrate_for3u8"
        elif key == "enableSnapshot":
            suggest = "enable_snapshot"
        elif key == "streamId":
            suggest = "stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_urls: Optional[Sequence[_builtins.str]] = None,
                 bitrate: Optional[_builtins.int] = None,
                 bitrate_for3u8: Optional[_builtins.bool] = None,
                 enable_snapshot: Optional[_builtins.bool] = None,
                 height: Optional[_builtins.int] = None,
                 latency: Optional[_builtins.int] = None,
                 passphrase: Optional[_builtins.str] = None,
                 stream_id: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 width: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] backup_urls: Specifies the list of backup stream addresses.
        :param _builtins.int bitrate: Specifies the bitrate. This parameter is required when live transcoding is not required.
               The unit is **bps**. Value ranges from `0` to `104,857,600`.
        :param _builtins.bool bitrate_for3u8: Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        :param _builtins.bool enable_snapshot: Specifies whether to use this stream to take screenshots.
        :param _builtins.int height: Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        :param _builtins.int latency: Specifies the streaming delay when the channel type is **SRT_PULL**.
               
               <a name="LiveChannel_FailoverConditions"></a>
               The `failover_conditions` block supports:
        :param _builtins.str passphrase: Specifies the encrypted information when the protocol is **SRT_PUSH**.
        :param _builtins.str stream_id: Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        :param _builtins.str url: Specifies the DRM address of the key.
        :param _builtins.int width: Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        if backup_urls is not None:
            pulumi.set(__self__, "backup_urls", backup_urls)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if bitrate_for3u8 is not None:
            pulumi.set(__self__, "bitrate_for3u8", bitrate_for3u8)
        if enable_snapshot is not None:
            pulumi.set(__self__, "enable_snapshot", enable_snapshot)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter(name="backupUrls")
    def backup_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of backup stream addresses.
        """
        return pulumi.get(self, "backup_urls")

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> Optional[_builtins.int]:
        """
        Specifies the bitrate. This parameter is required when live transcoding is not required.
        The unit is **bps**. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "bitrate")

    @_builtins.property
    @pulumi.getter(name="bitrateFor3u8")
    def bitrate_for3u8(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        """
        return pulumi.get(self, "bitrate_for3u8")

    @_builtins.property
    @pulumi.getter(name="enableSnapshot")
    def enable_snapshot(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to use this stream to take screenshots.
        """
        return pulumi.get(self, "enable_snapshot")

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[_builtins.int]:
        """
        Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[_builtins.int]:
        """
        Specifies the streaming delay when the channel type is **SRT_PULL**.

        <a name="LiveChannel_FailoverConditions"></a>
        The `failover_conditions` block supports:
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        Specifies the encrypted information when the protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[_builtins.str]:
        """
        Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[_builtins.int]:
        """
        Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class ChannelRecordSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingbufferDuration":
            suggest = "rollingbuffer_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelRecordSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelRecordSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelRecordSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rollingbuffer_duration: _builtins.int):
        """
        :param _builtins.int rollingbuffer_duration: Specifies the maximum playback recording time. During this time period,
               the recording will continue. The unit is second.
               When the value is `0`, it means that recording is not supported. The maximum supported recording period is `14` days.
               
               <a name="LiveChannel_Endpoints"></a>
               The `endpoints` block supports:
        """
        pulumi.set(__self__, "rollingbuffer_duration", rollingbuffer_duration)

    @_builtins.property
    @pulumi.getter(name="rollingbufferDuration")
    def rollingbuffer_duration(self) -> _builtins.int:
        """
        Specifies the maximum playback recording time. During this time period,
        the recording will continue. The unit is second.
        When the value is `0`, it means that recording is not supported. The maximum supported recording period is `14` days.

        <a name="LiveChannel_Endpoints"></a>
        The `endpoints` block supports:
        """
        return pulumi.get(self, "rollingbuffer_duration")


@pulumi.output_type
class HlsConfigurationApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hlsFragment":
            suggest = "hls_fragment"
        elif key == "hlsMinFrags":
            suggest = "hls_min_frags"
        elif key == "hlsTsCount":
            suggest = "hls_ts_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HlsConfigurationApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HlsConfigurationApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HlsConfigurationApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hls_fragment: _builtins.int,
                 hls_min_frags: _builtins.int,
                 hls_ts_count: _builtins.int,
                 name: _builtins.str):
        """
        :param _builtins.int hls_fragment: Specifies the HLS slice duration in seconds.
        :param _builtins.int hls_min_frags: Specifies the minimum number of ts shards in each M3U8 file.
        :param _builtins.int hls_ts_count: Specifies the number of ts slices in each M3U8 file.
        :param _builtins.str name: Specifies the application name.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "hls_fragment", hls_fragment)
        pulumi.set(__self__, "hls_min_frags", hls_min_frags)
        pulumi.set(__self__, "hls_ts_count", hls_ts_count)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="hlsFragment")
    def hls_fragment(self) -> _builtins.int:
        """
        Specifies the HLS slice duration in seconds.
        """
        return pulumi.get(self, "hls_fragment")

    @_builtins.property
    @pulumi.getter(name="hlsMinFrags")
    def hls_min_frags(self) -> _builtins.int:
        """
        Specifies the minimum number of ts shards in each M3U8 file.
        """
        return pulumi.get(self, "hls_min_frags")

    @_builtins.property
    @pulumi.getter(name="hlsTsCount")
    def hls_ts_count(self) -> _builtins.int:
        """
        Specifies the number of ts slices in each M3U8 file.
        """
        return pulumi.get(self, "hls_ts_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the application name.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class HttpsCertificateGmCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certId":
            suggest = "cert_id"
        elif key == "certName":
            suggest = "cert_name"
        elif key == "encCertificate":
            suggest = "enc_certificate"
        elif key == "encCertificateKey":
            suggest = "enc_certificate_key"
        elif key == "signCertificate":
            suggest = "sign_certificate"
        elif key == "signCertificateKey":
            suggest = "sign_certificate_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpsCertificateGmCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpsCertificateGmCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpsCertificateGmCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_id: Optional[_builtins.str] = None,
                 cert_name: Optional[_builtins.str] = None,
                 enc_certificate: Optional[_builtins.str] = None,
                 enc_certificate_key: Optional[_builtins.str] = None,
                 sign_certificate: Optional[_builtins.str] = None,
                 sign_certificate_key: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str cert_id: Specifies the SCM certificate ID.
        :param _builtins.str cert_name: Specifies the SCM certificate name.
        :param _builtins.str enc_certificate: Specifies the Chinese (SM) encryption certificate body
        :param _builtins.str enc_certificate_key: Specifies the Chinese (SM) encryption private key
        :param _builtins.str sign_certificate: Specifies the Chinese (SM) signature certificate body
        :param _builtins.str sign_certificate_key: Specifies the Chinese (SM) signature private key
        :param _builtins.str source: Specifies the certificate source.
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if cert_name is not None:
            pulumi.set(__self__, "cert_name", cert_name)
        if enc_certificate is not None:
            pulumi.set(__self__, "enc_certificate", enc_certificate)
        if enc_certificate_key is not None:
            pulumi.set(__self__, "enc_certificate_key", enc_certificate_key)
        if sign_certificate is not None:
            pulumi.set(__self__, "sign_certificate", sign_certificate)
        if sign_certificate_key is not None:
            pulumi.set(__self__, "sign_certificate_key", sign_certificate_key)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[_builtins.str]:
        """
        Specifies the SCM certificate ID.
        """
        return pulumi.get(self, "cert_id")

    @_builtins.property
    @pulumi.getter(name="certName")
    def cert_name(self) -> Optional[_builtins.str]:
        """
        Specifies the SCM certificate name.
        """
        return pulumi.get(self, "cert_name")

    @_builtins.property
    @pulumi.getter(name="encCertificate")
    def enc_certificate(self) -> Optional[_builtins.str]:
        """
        Specifies the Chinese (SM) encryption certificate body
        """
        return pulumi.get(self, "enc_certificate")

    @_builtins.property
    @pulumi.getter(name="encCertificateKey")
    def enc_certificate_key(self) -> Optional[_builtins.str]:
        """
        Specifies the Chinese (SM) encryption private key
        """
        return pulumi.get(self, "enc_certificate_key")

    @_builtins.property
    @pulumi.getter(name="signCertificate")
    def sign_certificate(self) -> Optional[_builtins.str]:
        """
        Specifies the Chinese (SM) signature certificate body
        """
        return pulumi.get(self, "sign_certificate")

    @_builtins.property
    @pulumi.getter(name="signCertificateKey")
    def sign_certificate_key(self) -> Optional[_builtins.str]:
        """
        Specifies the Chinese (SM) signature private key
        """
        return pulumi.get(self, "sign_certificate_key")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Specifies the certificate source.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class HttpsCertificateTlsCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certId":
            suggest = "cert_id"
        elif key == "certName":
            suggest = "cert_name"
        elif key == "certificateKey":
            suggest = "certificate_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpsCertificateTlsCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpsCertificateTlsCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpsCertificateTlsCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_id: Optional[_builtins.str] = None,
                 cert_name: Optional[_builtins.str] = None,
                 certificate: Optional[_builtins.str] = None,
                 certificate_key: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str cert_id: Specifies the SCM certificate ID.
        :param _builtins.str cert_name: Specifies the SCM certificate name.
        :param _builtins.str certificate: Specifies the certificate body.
        :param _builtins.str certificate_key: Specifies the private key.
        :param _builtins.str source: Specifies the certificate source.
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if cert_name is not None:
            pulumi.set(__self__, "cert_name", cert_name)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_key is not None:
            pulumi.set(__self__, "certificate_key", certificate_key)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[_builtins.str]:
        """
        Specifies the SCM certificate ID.
        """
        return pulumi.get(self, "cert_id")

    @_builtins.property
    @pulumi.getter(name="certName")
    def cert_name(self) -> Optional[_builtins.str]:
        """
        Specifies the SCM certificate name.
        """
        return pulumi.get(self, "cert_name")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[_builtins.str]:
        """
        Specifies the certificate body.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="certificateKey")
    def certificate_key(self) -> Optional[_builtins.str]:
        """
        Specifies the private key.
        """
        return pulumi.get(self, "certificate_key")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Specifies the certificate source.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class RecordingFlv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingLength":
            suggest = "recording_length"
        elif key == "fileNaming":
            suggest = "file_naming"
        elif key == "maxStreamPauseLength":
            suggest = "max_stream_pause_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingFlv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingFlv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingFlv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recording_length: _builtins.int,
                 file_naming: Optional[_builtins.str] = None,
                 max_stream_pause_length: Optional[_builtins.int] = None):
        """
        :param _builtins.int recording_length: Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
               A stream exceeding the recording length will generate a new recording.
        :param _builtins.str file_naming: Specifies the path and file name prefix of a recording file. The default value is
               `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        :param _builtins.int max_stream_pause_length: Specifies the interval threshold for combining recording chunks. If the
               stream pause length exceeds the value of this parameter, a new recording is generated.
               Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
               If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        pulumi.set(__self__, "recording_length", recording_length)
        if file_naming is not None:
            pulumi.set(__self__, "file_naming", file_naming)
        if max_stream_pause_length is not None:
            pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> _builtins.int:
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        return pulumi.get(self, "recording_length")

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> Optional[_builtins.str]:
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        return pulumi.get(self, "file_naming")

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> Optional[_builtins.int]:
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        return pulumi.get(self, "max_stream_pause_length")


@pulumi.output_type
class RecordingHls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingLength":
            suggest = "recording_length"
        elif key == "fileNaming":
            suggest = "file_naming"
        elif key == "maxStreamPauseLength":
            suggest = "max_stream_pause_length"
        elif key == "recordSliceDuration":
            suggest = "record_slice_duration"
        elif key == "tsFileNaming":
            suggest = "ts_file_naming"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingHls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingHls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingHls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recording_length: _builtins.int,
                 file_naming: Optional[_builtins.str] = None,
                 max_stream_pause_length: Optional[_builtins.int] = None,
                 record_slice_duration: Optional[_builtins.int] = None,
                 ts_file_naming: Optional[_builtins.str] = None):
        """
        :param _builtins.int recording_length: Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
               A stream exceeding the recording length will generate a new recording.
        :param _builtins.str file_naming: Specifies the path and file name prefix of a recording file. The default value is
               `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        :param _builtins.int max_stream_pause_length: Specifies the interval threshold for combining recording chunks. If the
               stream pause length exceeds the value of this parameter, a new recording is generated.
               Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
               If the value is set to `0`, a new file will be generated once the stream is interrupted.
        :param _builtins.int record_slice_duration: Specifies the TS slice duration for HLS recording.
               Value range: `2` ~ `60`, unit: `second`. Defaults to `10`.
        :param _builtins.str ts_file_naming: Specifies TS file name prefix.
               The default value is `{file_start_time_unix}_{file_end_time_unix}_{ts_sequence_number}`.
        """
        pulumi.set(__self__, "recording_length", recording_length)
        if file_naming is not None:
            pulumi.set(__self__, "file_naming", file_naming)
        if max_stream_pause_length is not None:
            pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)
        if record_slice_duration is not None:
            pulumi.set(__self__, "record_slice_duration", record_slice_duration)
        if ts_file_naming is not None:
            pulumi.set(__self__, "ts_file_naming", ts_file_naming)

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> _builtins.int:
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        return pulumi.get(self, "recording_length")

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> Optional[_builtins.str]:
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        return pulumi.get(self, "file_naming")

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> Optional[_builtins.int]:
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        return pulumi.get(self, "max_stream_pause_length")

    @_builtins.property
    @pulumi.getter(name="recordSliceDuration")
    def record_slice_duration(self) -> Optional[_builtins.int]:
        """
        Specifies the TS slice duration for HLS recording.
        Value range: `2` ~ `60`, unit: `second`. Defaults to `10`.
        """
        return pulumi.get(self, "record_slice_duration")

    @_builtins.property
    @pulumi.getter(name="tsFileNaming")
    def ts_file_naming(self) -> Optional[_builtins.str]:
        """
        Specifies TS file name prefix.
        The default value is `{file_start_time_unix}_{file_end_time_unix}_{ts_sequence_number}`.
        """
        return pulumi.get(self, "ts_file_naming")


@pulumi.output_type
class RecordingMp4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingLength":
            suggest = "recording_length"
        elif key == "fileNaming":
            suggest = "file_naming"
        elif key == "maxStreamPauseLength":
            suggest = "max_stream_pause_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingMp4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingMp4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingMp4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recording_length: _builtins.int,
                 file_naming: Optional[_builtins.str] = None,
                 max_stream_pause_length: Optional[_builtins.int] = None):
        """
        :param _builtins.int recording_length: Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
               A stream exceeding the recording length will generate a new recording.
        :param _builtins.str file_naming: Specifies the path and file name prefix of a recording file. The default value is
               `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        :param _builtins.int max_stream_pause_length: Specifies the interval threshold for combining recording chunks. If the
               stream pause length exceeds the value of this parameter, a new recording is generated.
               Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
               If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        pulumi.set(__self__, "recording_length", recording_length)
        if file_naming is not None:
            pulumi.set(__self__, "file_naming", file_naming)
        if max_stream_pause_length is not None:
            pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> _builtins.int:
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        return pulumi.get(self, "recording_length")

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> Optional[_builtins.str]:
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        return pulumi.get(self, "file_naming")

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> Optional[_builtins.int]:
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        return pulumi.get(self, "max_stream_pause_length")


@pulumi.output_type
class RecordingObs(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 region: _builtins.str,
                 object: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: Specifies OBS bucket.
        :param _builtins.str region: Specifies the region of OBS.
        :param _builtins.str object: Specifies OBS object path. If omitted, recordings will be saved to the root directory.
               
               <a name="recording_HLS"></a>
               The `hls` block supports:
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "region", region)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Specifies OBS bucket.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region of OBS.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[_builtins.str]:
        """
        Specifies OBS object path. If omitted, recordings will be saved to the root directory.

        <a name="recording_HLS"></a>
        The `hls` block supports:
        """
        return pulumi.get(self, "object")


@pulumi.output_type
class TranscodingTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bitrateAdaptive":
            suggest = "bitrate_adaptive"
        elif key == "frameRate":
            suggest = "frame_rate"
        elif key == "iFrameInterval":
            suggest = "i_frame_interval"
        elif key == "iFramePolicy":
            suggest = "i_frame_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TranscodingTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TranscodingTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TranscodingTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: _builtins.int,
                 height: _builtins.int,
                 name: _builtins.str,
                 width: _builtins.int,
                 bitrate_adaptive: Optional[_builtins.str] = None,
                 frame_rate: Optional[_builtins.int] = None,
                 gop: Optional[_builtins.str] = None,
                 i_frame_interval: Optional[_builtins.str] = None,
                 i_frame_policy: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.int bitrate: Specifies the bitrate of a transcoded video, in kbit/s. Value range: `40` ~ `30,000`.
        :param _builtins.int height: Specifies video height (unit: pixel).
               + **When the video encoding is H264**, value range: `32` ~ `2,160` and must be a multiple of `2`.
               + **When the video encoding is H265**, value range: `240` ~ `2,160` and must be a multiple of `4`.
        :param _builtins.str name: Specifies the template name. The name can contain a maximum of 64 characters, and only
               contains letters, digits and hyphens (-).
        :param _builtins.int width: Specifies video width (unit: pixel).
               + **When the video encoding is H264**, value range: `32` ~ `3,840` and must be a multiple of `2`.
               + **When the video encoding is H265**, value range: `320` ~ `3,840` and must be a multiple of `4`.
        :param _builtins.str bitrate_adaptive: Specifies the adaptive bitrate.
               The valid values are as follows:
               + **off**: Disable rate adaptation and output the target rate according to the set rate.
               + **minimum**: Output the target bitrate based on the minimum value of the set bitrate and source file bitrate.
               + **adaptive**: Adaptive output of target bitrate based on source file bitrate.
               
               Defaults to **off**.
        :param _builtins.int frame_rate: Specifies the frame rate of the transcoded video, in fps. Value range: `0` ~ `30`.
               Value `0` indicates that the frame rate remains unchanged.
        :param _builtins.str gop: Specifies the interval time for I-frames, in seconds.
               The value ranges from `0` to `10`, includes `0` and `10`. Defaults to `2`.
               
               > When `gop` is not `0`, the i-frame interval is set with the `gop` parameter, and the `i_frame_interval` field does
               not take effect.
        :param _builtins.str i_frame_interval: Specifies the maximum I-frame interval in frames.
               The value ranges from `0` to `500`, includes `0` and `500`. Defaults to `50`.
               
               > If you want to set the i-frame interval through `i_frame_interval`, please set the `gop` to `0` or do not pass the
               `gop` parameter.
        :param _builtins.str i_frame_policy: Specifies the encoding output I-frame strategy.
               The valid values are as follows:
               + **auto**: I-frame output according to the set `gop` duration.
               + **strictSync**: The encoded output I-frame is completely consistent with the source, and the `gop` parameter is
               invalid after setting this value.
               
               Defaults to **auto**.
               
               > In multi bitrate scenarios, it is recommended to enable I-frame random source to ensure alignment of multi bitrate
               I-frames.
        :param _builtins.str protocol: Specifies the protocol type supported for transcoding output.
               The valid value is **RTMP**. Defaults to **RTMP**.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "width", width)
        if bitrate_adaptive is not None:
            pulumi.set(__self__, "bitrate_adaptive", bitrate_adaptive)
        if frame_rate is not None:
            pulumi.set(__self__, "frame_rate", frame_rate)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if i_frame_interval is not None:
            pulumi.set(__self__, "i_frame_interval", i_frame_interval)
        if i_frame_policy is not None:
            pulumi.set(__self__, "i_frame_policy", i_frame_policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> _builtins.int:
        """
        Specifies the bitrate of a transcoded video, in kbit/s. Value range: `40` ~ `30,000`.
        """
        return pulumi.get(self, "bitrate")

    @_builtins.property
    @pulumi.getter
    def height(self) -> _builtins.int:
        """
        Specifies video height (unit: pixel).
        + **When the video encoding is H264**, value range: `32` ~ `2,160` and must be a multiple of `2`.
        + **When the video encoding is H265**, value range: `240` ~ `2,160` and must be a multiple of `4`.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the template name. The name can contain a maximum of 64 characters, and only
        contains letters, digits and hyphens (-).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def width(self) -> _builtins.int:
        """
        Specifies video width (unit: pixel).
        + **When the video encoding is H264**, value range: `32` ~ `3,840` and must be a multiple of `2`.
        + **When the video encoding is H265**, value range: `320` ~ `3,840` and must be a multiple of `4`.
        """
        return pulumi.get(self, "width")

    @_builtins.property
    @pulumi.getter(name="bitrateAdaptive")
    def bitrate_adaptive(self) -> Optional[_builtins.str]:
        """
        Specifies the adaptive bitrate.
        The valid values are as follows:
        + **off**: Disable rate adaptation and output the target rate according to the set rate.
        + **minimum**: Output the target bitrate based on the minimum value of the set bitrate and source file bitrate.
        + **adaptive**: Adaptive output of target bitrate based on source file bitrate.

        Defaults to **off**.
        """
        return pulumi.get(self, "bitrate_adaptive")

    @_builtins.property
    @pulumi.getter(name="frameRate")
    def frame_rate(self) -> Optional[_builtins.int]:
        """
        Specifies the frame rate of the transcoded video, in fps. Value range: `0` ~ `30`.
        Value `0` indicates that the frame rate remains unchanged.
        """
        return pulumi.get(self, "frame_rate")

    @_builtins.property
    @pulumi.getter
    def gop(self) -> Optional[_builtins.str]:
        """
        Specifies the interval time for I-frames, in seconds.
        The value ranges from `0` to `10`, includes `0` and `10`. Defaults to `2`.

        > When `gop` is not `0`, the i-frame interval is set with the `gop` parameter, and the `i_frame_interval` field does
        not take effect.
        """
        return pulumi.get(self, "gop")

    @_builtins.property
    @pulumi.getter(name="iFrameInterval")
    def i_frame_interval(self) -> Optional[_builtins.str]:
        """
        Specifies the maximum I-frame interval in frames.
        The value ranges from `0` to `500`, includes `0` and `500`. Defaults to `50`.

        > If you want to set the i-frame interval through `i_frame_interval`, please set the `gop` to `0` or do not pass the
        `gop` parameter.
        """
        return pulumi.get(self, "i_frame_interval")

    @_builtins.property
    @pulumi.getter(name="iFramePolicy")
    def i_frame_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the encoding output I-frame strategy.
        The valid values are as follows:
        + **auto**: I-frame output according to the set `gop` duration.
        + **strictSync**: The encoded output I-frame is completely consistent with the source, and the `gop` parameter is
        invalid after setting this value.

        Defaults to **auto**.

        > In multi bitrate scenarios, it is recommended to enable I-frame random source to ensure alignment of multi bitrate
        I-frames.
        """
        return pulumi.get(self, "i_frame_policy")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Specifies the protocol type supported for transcoding output.
        The valid value is **RTMP**. Defaults to **RTMP**.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetCdnIpsCdnIpResult(dict):
    def __init__(__self__, *,
                 belongs: _builtins.bool,
                 ip_address: _builtins.str,
                 isp: _builtins.str,
                 platform: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.bool belongs: Whether the IP address is a HuaweiCloud CDN node.
        :param _builtins.str ip_address: The IP address to be queried.
        :param _builtins.str isp: The carrier name.
        :param _builtins.str platform: The platform name.
        :param _builtins.str region: Specifies the region in which to query the resource.
               If omitted, the provider-level region will be used.
        """
        pulumi.set(__self__, "belongs", belongs)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "isp", isp)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def belongs(self) -> _builtins.bool:
        """
        Whether the IP address is a HuaweiCloud CDN node.
        """
        return pulumi.get(self, "belongs")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        The IP address to be queried.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def isp(self) -> _builtins.str:
        """
        The carrier name.
        """
        return pulumi.get(self, "isp")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> _builtins.str:
        """
        The platform name.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region in which to query the resource.
        If omitted, the provider-level region will be used.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetChannelsChannelResult(dict):
    def __init__(__self__, *,
                 app_name: _builtins.str,
                 domain_name: _builtins.str,
                 encoder_settings: Sequence['outputs.GetChannelsChannelEncoderSettingResult'],
                 encoder_settings_expands: Sequence['outputs.GetChannelsChannelEncoderSettingsExpandResult'],
                 endpoints: Sequence['outputs.GetChannelsChannelEndpointResult'],
                 id: _builtins.str,
                 inputs: Sequence['outputs.GetChannelsChannelInputResult'],
                 name: _builtins.str,
                 record_settings: Sequence['outputs.GetChannelsChannelRecordSettingResult'],
                 state: _builtins.str):
        """
        :param _builtins.str app_name: Specifies the group name or application name.
        :param _builtins.str domain_name: Specifies the channel streaming domain name.
        :param Sequence['GetChannelsChannelEncoderSettingArgs'] encoder_settings: The transcoding template configuration.
               The encoder_settings structure is documented below.
        :param Sequence['GetChannelsChannelEncoderSettingsExpandArgs'] encoder_settings_expands: The audio output configuration.
               The encoder_settings_expand structure is documented below.
        :param Sequence['GetChannelsChannelEndpointArgs'] endpoints: The channel outflow information.
               The endpoints structure is documented below.
        :param _builtins.str id: The channel ID.
        :param Sequence['GetChannelsChannelInputArgs'] inputs: The channel input information.
               The input structure is documented below.
        :param _builtins.str name: The name of the audio output configuration.
        :param Sequence['GetChannelsChannelRecordSettingArgs'] record_settings: The configuration for replaying a recording.
               The record_settings structure is documented below.
        :param _builtins.str state: The channel status. Valid values are:
               + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
               + **OFF**: Only the channel information is saved but the channel is not started.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "encoder_settings", encoder_settings)
        pulumi.set(__self__, "encoder_settings_expands", encoder_settings_expands)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "record_settings", record_settings)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Specifies the group name or application name.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Specifies the channel streaming domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="encoderSettings")
    def encoder_settings(self) -> Sequence['outputs.GetChannelsChannelEncoderSettingResult']:
        """
        The transcoding template configuration.
        The encoder_settings structure is documented below.
        """
        return pulumi.get(self, "encoder_settings")

    @_builtins.property
    @pulumi.getter(name="encoderSettingsExpands")
    def encoder_settings_expands(self) -> Sequence['outputs.GetChannelsChannelEncoderSettingsExpandResult']:
        """
        The audio output configuration.
        The encoder_settings_expand structure is documented below.
        """
        return pulumi.get(self, "encoder_settings_expands")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetChannelsChannelEndpointResult']:
        """
        The channel outflow information.
        The endpoints structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The channel ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Sequence['outputs.GetChannelsChannelInputResult']:
        """
        The channel input information.
        The input structure is documented below.
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the audio output configuration.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="recordSettings")
    def record_settings(self) -> Sequence['outputs.GetChannelsChannelRecordSettingResult']:
        """
        The configuration for replaying a recording.
        The record_settings structure is documented below.
        """
        return pulumi.get(self, "record_settings")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The channel status. Valid values are:
        + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
        + **OFF**: Only the channel information is saved but the channel is not started.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetChannelsChannelEncoderSettingResult(dict):
    def __init__(__self__, *,
                 template_id: _builtins.str):
        """
        :param _builtins.str template_id: The transcoding template ID.
        """
        pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        """
        The transcoding template ID.
        """
        return pulumi.get(self, "template_id")


@pulumi.output_type
class GetChannelsChannelEncoderSettingsExpandResult(dict):
    def __init__(__self__, *,
                 audio_descriptions: Sequence['outputs.GetChannelsChannelEncoderSettingsExpandAudioDescriptionResult']):
        """
        :param Sequence['GetChannelsChannelEncoderSettingsExpandAudioDescriptionArgs'] audio_descriptions: The description of the audio output configuration.
               The audio_descriptions structure is documented below.
        """
        pulumi.set(__self__, "audio_descriptions", audio_descriptions)

    @_builtins.property
    @pulumi.getter(name="audioDescriptions")
    def audio_descriptions(self) -> Sequence['outputs.GetChannelsChannelEncoderSettingsExpandAudioDescriptionResult']:
        """
        The description of the audio output configuration.
        The audio_descriptions structure is documented below.
        """
        return pulumi.get(self, "audio_descriptions")


@pulumi.output_type
class GetChannelsChannelEncoderSettingsExpandAudioDescriptionResult(dict):
    def __init__(__self__, *,
                 audio_selector_name: _builtins.str,
                 language_code: _builtins.str,
                 language_code_control: _builtins.str,
                 name: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str audio_selector_name: The audio selector name.
        :param _builtins.str language_code: The language code.
        :param _builtins.str language_code_control: The language code control configuration. Valid values are:
               + **FOLLOW_INPUT**: If the output audio corresponding to the selected audio selector has a language, it will be
               consistent with it, otherwise it will be backed up by the language code and stream name configured here.
               The current option is recommended and is the default value.
               + **USE_CONFIGURED**: Users can customize the language and stream name of the output audio based on actual conditions.
        :param _builtins.str name: The name of the audio output configuration.
        :param _builtins.str stream_name: The stream name.
        """
        pulumi.set(__self__, "audio_selector_name", audio_selector_name)
        pulumi.set(__self__, "language_code", language_code)
        pulumi.set(__self__, "language_code_control", language_code_control)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> _builtins.str:
        """
        The audio selector name.
        """
        return pulumi.get(self, "audio_selector_name")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        The language code.
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="languageCodeControl")
    def language_code_control(self) -> _builtins.str:
        """
        The language code control configuration. Valid values are:
        + **FOLLOW_INPUT**: If the output audio corresponding to the selected audio selector has a language, it will be
        consistent with it, otherwise it will be backed up by the language code and stream name configured here.
        The current option is recommended and is the default value.
        + **USE_CONFIGURED**: Users can customize the language and stream name of the output audio based on actual conditions.
        """
        return pulumi.get(self, "language_code_control")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the audio output configuration.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        The stream name.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class GetChannelsChannelEndpointResult(dict):
    def __init__(__self__, *,
                 dash_packages: Sequence['outputs.GetChannelsChannelEndpointDashPackageResult'],
                 hls_packages: Sequence['outputs.GetChannelsChannelEndpointHlsPackageResult'],
                 mss_packages: Sequence['outputs.GetChannelsChannelEndpointMssPackageResult']):
        """
        :param Sequence['GetChannelsChannelEndpointDashPackageArgs'] dash_packages: The DASH packaging information.
               The dash_package structure is documented below.
        :param Sequence['GetChannelsChannelEndpointHlsPackageArgs'] hls_packages: The HLS packaging information.
               The hls_package structure is documented below.
        :param Sequence['GetChannelsChannelEndpointMssPackageArgs'] mss_packages: The MSS packaging information.
               The mss_package structure is documented below.
        """
        pulumi.set(__self__, "dash_packages", dash_packages)
        pulumi.set(__self__, "hls_packages", hls_packages)
        pulumi.set(__self__, "mss_packages", mss_packages)

    @_builtins.property
    @pulumi.getter(name="dashPackages")
    def dash_packages(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageResult']:
        """
        The DASH packaging information.
        The dash_package structure is documented below.
        """
        return pulumi.get(self, "dash_packages")

    @_builtins.property
    @pulumi.getter(name="hlsPackages")
    def hls_packages(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageResult']:
        """
        The HLS packaging information.
        The hls_package structure is documented below.
        """
        return pulumi.get(self, "hls_packages")

    @_builtins.property
    @pulumi.getter(name="mssPackages")
    def mss_packages(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageResult']:
        """
        The MSS packaging information.
        The mss_package structure is documented below.
        """
        return pulumi.get(self, "mss_packages")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageResult(dict):
    def __init__(__self__, *,
                 ad_marker: _builtins.str,
                 encryptions: Sequence['outputs.GetChannelsChannelEndpointDashPackageEncryptionResult'],
                 playlist_window_seconds: _builtins.int,
                 request_args: Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgResult'],
                 segment_duration_seconds: _builtins.int,
                 stream_selections: Sequence['outputs.GetChannelsChannelEndpointDashPackageStreamSelectionResult'],
                 url: _builtins.str):
        """
        :param _builtins.str ad_marker: The advertising marker.
        :param Sequence['GetChannelsChannelEndpointDashPackageEncryptionArgs'] encryptions: The encrypted information.
               The encryption structure is documented below.
        :param _builtins.int playlist_window_seconds: The window length of the channel live broadcast return shard. The unit is second.
        :param Sequence['GetChannelsChannelEndpointDashPackageRequestArgArgs'] request_args: The play related configuration.
               The request_args structure is documented below.
        :param _builtins.int segment_duration_seconds: The duration of the channel output segment. The unit is second.
        :param Sequence['GetChannelsChannelEndpointDashPackageStreamSelectionArgs'] stream_selections: The stream selection. Filter out the specified range of streams from the full stream.
               The stream_selection structure is documented below.
        :param _builtins.str url: The DRM address of the key.
        """
        pulumi.set(__self__, "ad_marker", ad_marker)
        pulumi.set(__self__, "encryptions", encryptions)
        pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        pulumi.set(__self__, "request_args", request_args)
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "stream_selections", stream_selections)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="adMarker")
    def ad_marker(self) -> _builtins.str:
        """
        The advertising marker.
        """
        return pulumi.get(self, "ad_marker")

    @_builtins.property
    @pulumi.getter
    def encryptions(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageEncryptionResult']:
        """
        The encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryptions")

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> _builtins.int:
        """
        The window length of the channel live broadcast return shard. The unit is second.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgResult']:
        """
        The play related configuration.
        The request_args structure is documented below.
        """
        return pulumi.get(self, "request_args")

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> _builtins.int:
        """
        The duration of the channel output segment. The unit is second.
        """
        return pulumi.get(self, "segment_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageStreamSelectionResult']:
        """
        The stream selection. Filter out the specified range of streams from the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageEncryptionResult(dict):
    def __init__(__self__, *,
                 encryption_method: _builtins.str,
                 http_headers: Sequence['outputs.GetChannelsChannelEndpointDashPackageEncryptionHttpHeaderResult'],
                 key_rotation_interval_seconds: _builtins.int,
                 level: _builtins.str,
                 request_mode: _builtins.str,
                 resource_id: _builtins.str,
                 speke_version: _builtins.str,
                 system_ids: Sequence[_builtins.str],
                 url: _builtins.str,
                 urn: _builtins.str):
        """
        :param _builtins.str encryption_method: The encryption method.
        :param Sequence['GetChannelsChannelEndpointDashPackageEncryptionHttpHeaderArgs'] http_headers: The authentication information that needs to be added to the DRM request header.
               The http_headers structure is documented below.
        :param _builtins.int key_rotation_interval_seconds: The key rotation interval seconds.
        :param _builtins.str level: The level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
        :param _builtins.str request_mode: The request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param _builtins.str resource_id: The customer-generated DRM content ID.
        :param _builtins.str speke_version: The DRM spec version number.
        :param Sequence[_builtins.str] system_ids: The system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param _builtins.str url: The DRM address of the key.
        :param _builtins.str urn: The URN of the function graph.
        """
        pulumi.set(__self__, "encryption_method", encryption_method)
        pulumi.set(__self__, "http_headers", http_headers)
        pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> _builtins.str:
        """
        The encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageEncryptionHttpHeaderResult']:
        """
        The authentication information that needs to be added to the DRM request header.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> _builtins.int:
        """
        The key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> _builtins.str:
        """
        The request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> _builtins.str:
        """
        The DRM spec version number.
        """
        return pulumi.get(self, "speke_version")

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> Sequence[_builtins.str]:
        """
        The system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        The URN of the function graph.
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageEncryptionHttpHeaderResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key field name in the request header.
        :param _builtins.str value: The value corresponding to the key in the request header.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value corresponding to the key in the request header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageRequestArgResult(dict):
    def __init__(__self__, *,
                 lives: Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgLifeResult'],
                 records: Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgRecordResult'],
                 timeshifts: Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgTimeshiftResult']):
        """
        :param Sequence['GetChannelsChannelEndpointDashPackageRequestArgLifeArgs'] lives: The live broadcast configuration.
               The live structure is documented below.
        :param Sequence['GetChannelsChannelEndpointDashPackageRequestArgRecordArgs'] records: The recording and playback related configuration.
               The record structure is documented below.
        :param Sequence['GetChannelsChannelEndpointDashPackageRequestArgTimeshiftArgs'] timeshifts: The time-shift playback configuration.
               The timeshift structure is documented below.
        """
        pulumi.set(__self__, "lives", lives)
        pulumi.set(__self__, "records", records)
        pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgLifeResult']:
        """
        The live broadcast configuration.
        The live structure is documented below.
        """
        return pulumi.get(self, "lives")

    @_builtins.property
    @pulumi.getter
    def records(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgRecordResult']:
        """
        The recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Sequence['outputs.GetChannelsChannelEndpointDashPackageRequestArgTimeshiftResult']:
        """
        The time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageRequestArgLifeResult(dict):
    def __init__(__self__, *,
                 delay: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str delay: The delay field.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        The delay field.
        """
        return pulumi.get(self, "delay")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageRequestArgRecordResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 format: _builtins.str,
                 start_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str end_time: The end time.
        :param _builtins.str format: The format.
        :param _builtins.str start_time: The start time.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        The format.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageRequestArgTimeshiftResult(dict):
    def __init__(__self__, *,
                 back_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str back_time: The time shift duration field name.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "back_time", back_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> _builtins.str:
        """
        The time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointDashPackageStreamSelectionResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 max_bandwidth: _builtins.int,
                 min_bandwidth: _builtins.int):
        """
        :param _builtins.str key: The key field name in the request header.
        :param _builtins.int max_bandwidth: The maximum code rate. The unit is bps.
        :param _builtins.int min_bandwidth: The minimum code rate. The unit is bps.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> _builtins.int:
        """
        The maximum code rate. The unit is bps.
        """
        return pulumi.get(self, "max_bandwidth")

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> _builtins.int:
        """
        The minimum code rate. The unit is bps.
        """
        return pulumi.get(self, "min_bandwidth")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageResult(dict):
    def __init__(__self__, *,
                 ad_markers: Sequence[_builtins.str],
                 encryptions: Sequence['outputs.GetChannelsChannelEndpointHlsPackageEncryptionResult'],
                 hls_version: _builtins.str,
                 playlist_window_seconds: _builtins.int,
                 request_args: Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgResult'],
                 segment_duration_seconds: _builtins.int,
                 stream_selections: Sequence['outputs.GetChannelsChannelEndpointHlsPackageStreamSelectionResult'],
                 url: _builtins.str):
        """
        :param Sequence[_builtins.str] ad_markers: The advertising marker.
        :param Sequence['GetChannelsChannelEndpointHlsPackageEncryptionArgs'] encryptions: The encrypted information.
               The encryption structure is documented below.
        :param _builtins.str hls_version: The HLS version.
        :param _builtins.int playlist_window_seconds: The window length of the channel live broadcast return shard. The unit is second.
        :param Sequence['GetChannelsChannelEndpointHlsPackageRequestArgArgs'] request_args: The play related configuration.
               The request_args structure is documented below.
        :param _builtins.int segment_duration_seconds: The duration of the channel output segment. The unit is second.
        :param Sequence['GetChannelsChannelEndpointHlsPackageStreamSelectionArgs'] stream_selections: The stream selection. Filter out the specified range of streams from the full stream.
               The stream_selection structure is documented below.
        :param _builtins.str url: The DRM address of the key.
        """
        pulumi.set(__self__, "ad_markers", ad_markers)
        pulumi.set(__self__, "encryptions", encryptions)
        pulumi.set(__self__, "hls_version", hls_version)
        pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        pulumi.set(__self__, "request_args", request_args)
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "stream_selections", stream_selections)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Sequence[_builtins.str]:
        """
        The advertising marker.
        """
        return pulumi.get(self, "ad_markers")

    @_builtins.property
    @pulumi.getter
    def encryptions(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageEncryptionResult']:
        """
        The encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryptions")

    @_builtins.property
    @pulumi.getter(name="hlsVersion")
    def hls_version(self) -> _builtins.str:
        """
        The HLS version.
        """
        return pulumi.get(self, "hls_version")

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> _builtins.int:
        """
        The window length of the channel live broadcast return shard. The unit is second.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgResult']:
        """
        The play related configuration.
        The request_args structure is documented below.
        """
        return pulumi.get(self, "request_args")

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> _builtins.int:
        """
        The duration of the channel output segment. The unit is second.
        """
        return pulumi.get(self, "segment_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageStreamSelectionResult']:
        """
        The stream selection. Filter out the specified range of streams from the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageEncryptionResult(dict):
    def __init__(__self__, *,
                 encryption_method: _builtins.str,
                 http_headers: Sequence['outputs.GetChannelsChannelEndpointHlsPackageEncryptionHttpHeaderResult'],
                 key_rotation_interval_seconds: _builtins.int,
                 level: _builtins.str,
                 request_mode: _builtins.str,
                 resource_id: _builtins.str,
                 speke_version: _builtins.str,
                 system_ids: Sequence[_builtins.str],
                 url: _builtins.str,
                 urn: _builtins.str):
        """
        :param _builtins.str encryption_method: The encryption method.
        :param Sequence['GetChannelsChannelEndpointHlsPackageEncryptionHttpHeaderArgs'] http_headers: The authentication information that needs to be added to the DRM request header.
               The http_headers structure is documented below.
        :param _builtins.int key_rotation_interval_seconds: The key rotation interval seconds.
        :param _builtins.str level: The level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
        :param _builtins.str request_mode: The request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param _builtins.str resource_id: The customer-generated DRM content ID.
        :param _builtins.str speke_version: The DRM spec version number.
        :param Sequence[_builtins.str] system_ids: The system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param _builtins.str url: The DRM address of the key.
        :param _builtins.str urn: The URN of the function graph.
        """
        pulumi.set(__self__, "encryption_method", encryption_method)
        pulumi.set(__self__, "http_headers", http_headers)
        pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> _builtins.str:
        """
        The encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageEncryptionHttpHeaderResult']:
        """
        The authentication information that needs to be added to the DRM request header.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> _builtins.int:
        """
        The key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> _builtins.str:
        """
        The request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> _builtins.str:
        """
        The DRM spec version number.
        """
        return pulumi.get(self, "speke_version")

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> Sequence[_builtins.str]:
        """
        The system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        The URN of the function graph.
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageEncryptionHttpHeaderResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key field name in the request header.
        :param _builtins.str value: The value corresponding to the key in the request header.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value corresponding to the key in the request header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageRequestArgResult(dict):
    def __init__(__self__, *,
                 lives: Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgLifeResult'],
                 records: Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgRecordResult'],
                 timeshifts: Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgTimeshiftResult']):
        """
        :param Sequence['GetChannelsChannelEndpointHlsPackageRequestArgLifeArgs'] lives: The live broadcast configuration.
               The live structure is documented below.
        :param Sequence['GetChannelsChannelEndpointHlsPackageRequestArgRecordArgs'] records: The recording and playback related configuration.
               The record structure is documented below.
        :param Sequence['GetChannelsChannelEndpointHlsPackageRequestArgTimeshiftArgs'] timeshifts: The time-shift playback configuration.
               The timeshift structure is documented below.
        """
        pulumi.set(__self__, "lives", lives)
        pulumi.set(__self__, "records", records)
        pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgLifeResult']:
        """
        The live broadcast configuration.
        The live structure is documented below.
        """
        return pulumi.get(self, "lives")

    @_builtins.property
    @pulumi.getter
    def records(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgRecordResult']:
        """
        The recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Sequence['outputs.GetChannelsChannelEndpointHlsPackageRequestArgTimeshiftResult']:
        """
        The time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageRequestArgLifeResult(dict):
    def __init__(__self__, *,
                 delay: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str delay: The delay field.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        The delay field.
        """
        return pulumi.get(self, "delay")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageRequestArgRecordResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 format: _builtins.str,
                 start_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str end_time: The end time.
        :param _builtins.str format: The format.
        :param _builtins.str start_time: The start time.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        The format.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageRequestArgTimeshiftResult(dict):
    def __init__(__self__, *,
                 back_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str back_time: The time shift duration field name.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "back_time", back_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> _builtins.str:
        """
        The time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointHlsPackageStreamSelectionResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 max_bandwidth: _builtins.int,
                 min_bandwidth: _builtins.int):
        """
        :param _builtins.str key: The key field name in the request header.
        :param _builtins.int max_bandwidth: The maximum code rate. The unit is bps.
        :param _builtins.int min_bandwidth: The minimum code rate. The unit is bps.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> _builtins.int:
        """
        The maximum code rate. The unit is bps.
        """
        return pulumi.get(self, "max_bandwidth")

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> _builtins.int:
        """
        The minimum code rate. The unit is bps.
        """
        return pulumi.get(self, "min_bandwidth")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageResult(dict):
    def __init__(__self__, *,
                 delay_segment: _builtins.int,
                 encryptions: Sequence['outputs.GetChannelsChannelEndpointMssPackageEncryptionResult'],
                 playlist_window_seconds: _builtins.int,
                 request_args: Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgResult'],
                 segment_duration_seconds: _builtins.int,
                 stream_selections: Sequence['outputs.GetChannelsChannelEndpointMssPackageStreamSelectionResult'],
                 url: _builtins.str):
        """
        :param _builtins.int delay_segment: The delayed playback time. The unit is second.
        :param Sequence['GetChannelsChannelEndpointMssPackageEncryptionArgs'] encryptions: The encrypted information.
               The encryption structure is documented below.
        :param _builtins.int playlist_window_seconds: The window length of the channel live broadcast return shard. The unit is second.
        :param Sequence['GetChannelsChannelEndpointMssPackageRequestArgArgs'] request_args: The play related configuration.
               The request_args structure is documented below.
        :param _builtins.int segment_duration_seconds: The duration of the channel output segment. The unit is second.
        :param Sequence['GetChannelsChannelEndpointMssPackageStreamSelectionArgs'] stream_selections: The stream selection. Filter out the specified range of streams from the full stream.
               The stream_selection structure is documented below.
        :param _builtins.str url: The DRM address of the key.
        """
        pulumi.set(__self__, "delay_segment", delay_segment)
        pulumi.set(__self__, "encryptions", encryptions)
        pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        pulumi.set(__self__, "request_args", request_args)
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "stream_selections", stream_selections)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="delaySegment")
    def delay_segment(self) -> _builtins.int:
        """
        The delayed playback time. The unit is second.
        """
        return pulumi.get(self, "delay_segment")

    @_builtins.property
    @pulumi.getter
    def encryptions(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageEncryptionResult']:
        """
        The encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryptions")

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> _builtins.int:
        """
        The window length of the channel live broadcast return shard. The unit is second.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgResult']:
        """
        The play related configuration.
        The request_args structure is documented below.
        """
        return pulumi.get(self, "request_args")

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> _builtins.int:
        """
        The duration of the channel output segment. The unit is second.
        """
        return pulumi.get(self, "segment_duration_seconds")

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageStreamSelectionResult']:
        """
        The stream selection. Filter out the specified range of streams from the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageEncryptionResult(dict):
    def __init__(__self__, *,
                 encryption_method: _builtins.str,
                 http_headers: Sequence['outputs.GetChannelsChannelEndpointMssPackageEncryptionHttpHeaderResult'],
                 key_rotation_interval_seconds: _builtins.int,
                 level: _builtins.str,
                 request_mode: _builtins.str,
                 resource_id: _builtins.str,
                 speke_version: _builtins.str,
                 system_ids: Sequence[_builtins.str],
                 url: _builtins.str,
                 urn: _builtins.str):
        """
        :param _builtins.str encryption_method: The encryption method.
        :param Sequence['GetChannelsChannelEndpointMssPackageEncryptionHttpHeaderArgs'] http_headers: The authentication information that needs to be added to the DRM request header.
               The http_headers structure is documented below.
        :param _builtins.int key_rotation_interval_seconds: The key rotation interval seconds.
        :param _builtins.str level: The level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
        :param _builtins.str request_mode: The request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param _builtins.str resource_id: The customer-generated DRM content ID.
        :param _builtins.str speke_version: The DRM spec version number.
        :param Sequence[_builtins.str] system_ids: The system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param _builtins.str url: The DRM address of the key.
        :param _builtins.str urn: The URN of the function graph.
        """
        pulumi.set(__self__, "encryption_method", encryption_method)
        pulumi.set(__self__, "http_headers", http_headers)
        pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> _builtins.str:
        """
        The encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageEncryptionHttpHeaderResult']:
        """
        The authentication information that needs to be added to the DRM request header.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> _builtins.int:
        """
        The key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> _builtins.str:
        """
        The request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> _builtins.str:
        """
        The DRM spec version number.
        """
        return pulumi.get(self, "speke_version")

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> Sequence[_builtins.str]:
        """
        The system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        The URN of the function graph.
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageEncryptionHttpHeaderResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key field name in the request header.
        :param _builtins.str value: The value corresponding to the key in the request header.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value corresponding to the key in the request header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageRequestArgResult(dict):
    def __init__(__self__, *,
                 lives: Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgLifeResult'],
                 records: Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgRecordResult'],
                 timeshifts: Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgTimeshiftResult']):
        """
        :param Sequence['GetChannelsChannelEndpointMssPackageRequestArgLifeArgs'] lives: The live broadcast configuration.
               The live structure is documented below.
        :param Sequence['GetChannelsChannelEndpointMssPackageRequestArgRecordArgs'] records: The recording and playback related configuration.
               The record structure is documented below.
        :param Sequence['GetChannelsChannelEndpointMssPackageRequestArgTimeshiftArgs'] timeshifts: The time-shift playback configuration.
               The timeshift structure is documented below.
        """
        pulumi.set(__self__, "lives", lives)
        pulumi.set(__self__, "records", records)
        pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgLifeResult']:
        """
        The live broadcast configuration.
        The live structure is documented below.
        """
        return pulumi.get(self, "lives")

    @_builtins.property
    @pulumi.getter
    def records(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgRecordResult']:
        """
        The recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Sequence['outputs.GetChannelsChannelEndpointMssPackageRequestArgTimeshiftResult']:
        """
        The time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageRequestArgLifeResult(dict):
    def __init__(__self__, *,
                 delay: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str delay: The delay field.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> _builtins.str:
        """
        The delay field.
        """
        return pulumi.get(self, "delay")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageRequestArgRecordResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 format: _builtins.str,
                 start_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str end_time: The end time.
        :param _builtins.str format: The format.
        :param _builtins.str start_time: The start time.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        """
        The format.
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageRequestArgTimeshiftResult(dict):
    def __init__(__self__, *,
                 back_time: _builtins.str,
                 unit: _builtins.str):
        """
        :param _builtins.str back_time: The time shift duration field name.
        :param _builtins.str unit: The unit.
        """
        pulumi.set(__self__, "back_time", back_time)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> _builtins.str:
        """
        The time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetChannelsChannelEndpointMssPackageStreamSelectionResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 max_bandwidth: _builtins.int,
                 min_bandwidth: _builtins.int):
        """
        :param _builtins.str key: The key field name in the request header.
        :param _builtins.int max_bandwidth: The maximum code rate. The unit is bps.
        :param _builtins.int min_bandwidth: The minimum code rate. The unit is bps.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field name in the request header.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> _builtins.int:
        """
        The maximum code rate. The unit is bps.
        """
        return pulumi.get(self, "max_bandwidth")

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> _builtins.int:
        """
        The minimum code rate. The unit is bps.
        """
        return pulumi.get(self, "min_bandwidth")


@pulumi.output_type
class GetChannelsChannelInputResult(dict):
    def __init__(__self__, *,
                 ad_triggers: Sequence[_builtins.str],
                 audio_selectors: Sequence['outputs.GetChannelsChannelInputAudioSelectorResult'],
                 failover_conditions: Sequence['outputs.GetChannelsChannelInputFailoverConditionResult'],
                 input_protocol: _builtins.str,
                 ip_port_mode: _builtins.bool,
                 ip_whitelist: _builtins.str,
                 max_bandwidth_limit: _builtins.int,
                 scte35_source: _builtins.str,
                 secondary_sources: Sequence['outputs.GetChannelsChannelInputSecondarySourceResult'],
                 sources: Sequence['outputs.GetChannelsChannelInputSourceResult']):
        """
        :param Sequence[_builtins.str] ad_triggers: The ad trigger configuration list. Valid Values are:
               + **Splice insert**.
               + **Provider advertisement**.
               + **Distributor advertisement**.
               + **Provider placement opportunity**.
               + **Distributor placement opportunity**.
        :param Sequence['GetChannelsChannelInputAudioSelectorArgs'] audio_selectors: The audio selector configuration.
               The audio_selectors structure is documented below.
        :param Sequence['GetChannelsChannelInputFailoverConditionArgs'] failover_conditions: The configuration of switching between primary and backup audio and video stream URLs.
               The failover_conditions structure is documented below.
        :param _builtins.str input_protocol: The channel input protocol. Valid values are:
               + **FLV_PULL**.
               + **RTMP_PUSH**.
               + **HLS_PULL**.
               + **SRT_PULL**.
               + **SRT_PUSH**.
        :param _builtins.bool ip_port_mode: The IP port mode.
        :param _builtins.str ip_whitelist: The IP whitelist when protocol is **SRT_PUSH**.
        :param _builtins.int max_bandwidth_limit: The maximum bandwidth that needs to be configured when the inbound protocol is **HLS_PULL**.
               The unit is **bps**.
        :param _builtins.str scte35_source: The advertisement scte35 signal source.
        :param Sequence['GetChannelsChannelInputSecondarySourceArgs'] secondary_sources: The prepared stream array.
               The secondary_sources structure is documented below.
        :param Sequence['GetChannelsChannelInputSourceArgs'] sources: The channel main source stream information.
               The sources structure is documented below.
        """
        pulumi.set(__self__, "ad_triggers", ad_triggers)
        pulumi.set(__self__, "audio_selectors", audio_selectors)
        pulumi.set(__self__, "failover_conditions", failover_conditions)
        pulumi.set(__self__, "input_protocol", input_protocol)
        pulumi.set(__self__, "ip_port_mode", ip_port_mode)
        pulumi.set(__self__, "ip_whitelist", ip_whitelist)
        pulumi.set(__self__, "max_bandwidth_limit", max_bandwidth_limit)
        pulumi.set(__self__, "scte35_source", scte35_source)
        pulumi.set(__self__, "secondary_sources", secondary_sources)
        pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter(name="adTriggers")
    def ad_triggers(self) -> Sequence[_builtins.str]:
        """
        The ad trigger configuration list. Valid Values are:
        + **Splice insert**.
        + **Provider advertisement**.
        + **Distributor advertisement**.
        + **Provider placement opportunity**.
        + **Distributor placement opportunity**.
        """
        return pulumi.get(self, "ad_triggers")

    @_builtins.property
    @pulumi.getter(name="audioSelectors")
    def audio_selectors(self) -> Sequence['outputs.GetChannelsChannelInputAudioSelectorResult']:
        """
        The audio selector configuration.
        The audio_selectors structure is documented below.
        """
        return pulumi.get(self, "audio_selectors")

    @_builtins.property
    @pulumi.getter(name="failoverConditions")
    def failover_conditions(self) -> Sequence['outputs.GetChannelsChannelInputFailoverConditionResult']:
        """
        The configuration of switching between primary and backup audio and video stream URLs.
        The failover_conditions structure is documented below.
        """
        return pulumi.get(self, "failover_conditions")

    @_builtins.property
    @pulumi.getter(name="inputProtocol")
    def input_protocol(self) -> _builtins.str:
        """
        The channel input protocol. Valid values are:
        + **FLV_PULL**.
        + **RTMP_PUSH**.
        + **HLS_PULL**.
        + **SRT_PULL**.
        + **SRT_PUSH**.
        """
        return pulumi.get(self, "input_protocol")

    @_builtins.property
    @pulumi.getter(name="ipPortMode")
    def ip_port_mode(self) -> _builtins.bool:
        """
        The IP port mode.
        """
        return pulumi.get(self, "ip_port_mode")

    @_builtins.property
    @pulumi.getter(name="ipWhitelist")
    def ip_whitelist(self) -> _builtins.str:
        """
        The IP whitelist when protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "ip_whitelist")

    @_builtins.property
    @pulumi.getter(name="maxBandwidthLimit")
    def max_bandwidth_limit(self) -> _builtins.int:
        """
        The maximum bandwidth that needs to be configured when the inbound protocol is **HLS_PULL**.
        The unit is **bps**.
        """
        return pulumi.get(self, "max_bandwidth_limit")

    @_builtins.property
    @pulumi.getter(name="scte35Source")
    def scte35_source(self) -> _builtins.str:
        """
        The advertisement scte35 signal source.
        """
        return pulumi.get(self, "scte35_source")

    @_builtins.property
    @pulumi.getter(name="secondarySources")
    def secondary_sources(self) -> Sequence['outputs.GetChannelsChannelInputSecondarySourceResult']:
        """
        The prepared stream array.
        The secondary_sources structure is documented below.
        """
        return pulumi.get(self, "secondary_sources")

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetChannelsChannelInputSourceResult']:
        """
        The channel main source stream information.
        The sources structure is documented below.
        """
        return pulumi.get(self, "sources")


@pulumi.output_type
class GetChannelsChannelInputAudioSelectorResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 selector_settings: Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingResult']):
        """
        :param _builtins.str name: The name of the audio output configuration.
        :param Sequence['GetChannelsChannelInputAudioSelectorSelectorSettingArgs'] selector_settings: The audio selector configuration.
               The selector_settings structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_settings", selector_settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the audio output configuration.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingResult']:
        """
        The audio selector configuration.
        The selector_settings structure is documented below.
        """
        return pulumi.get(self, "selector_settings")


@pulumi.output_type
class GetChannelsChannelInputAudioSelectorSelectorSettingResult(dict):
    def __init__(__self__, *,
                 audio_hls_selections: Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingAudioHlsSelectionResult'],
                 audio_language_selections: Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingAudioLanguageSelectionResult'],
                 audio_pid_selections: Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingAudioPidSelectionResult']):
        """
        :param Sequence['GetChannelsChannelInputAudioSelectorSelectorSettingAudioHlsSelectionArgs'] audio_hls_selections: The HLS selector configuration.
               The audio_hls_selection structure is documented below.
        :param Sequence['GetChannelsChannelInputAudioSelectorSelectorSettingAudioLanguageSelectionArgs'] audio_language_selections: The language selector configuration.
               The audio_language_selection structure is documented below.
        :param Sequence['GetChannelsChannelInputAudioSelectorSelectorSettingAudioPidSelectionArgs'] audio_pid_selections: The PID selector configuration.
               The audio_pid_selection structure is documented below.
        """
        pulumi.set(__self__, "audio_hls_selections", audio_hls_selections)
        pulumi.set(__self__, "audio_language_selections", audio_language_selections)
        pulumi.set(__self__, "audio_pid_selections", audio_pid_selections)

    @_builtins.property
    @pulumi.getter(name="audioHlsSelections")
    def audio_hls_selections(self) -> Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingAudioHlsSelectionResult']:
        """
        The HLS selector configuration.
        The audio_hls_selection structure is documented below.
        """
        return pulumi.get(self, "audio_hls_selections")

    @_builtins.property
    @pulumi.getter(name="audioLanguageSelections")
    def audio_language_selections(self) -> Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingAudioLanguageSelectionResult']:
        """
        The language selector configuration.
        The audio_language_selection structure is documented below.
        """
        return pulumi.get(self, "audio_language_selections")

    @_builtins.property
    @pulumi.getter(name="audioPidSelections")
    def audio_pid_selections(self) -> Sequence['outputs.GetChannelsChannelInputAudioSelectorSelectorSettingAudioPidSelectionResult']:
        """
        The PID selector configuration.
        The audio_pid_selection structure is documented below.
        """
        return pulumi.get(self, "audio_pid_selections")


@pulumi.output_type
class GetChannelsChannelInputAudioSelectorSelectorSettingAudioHlsSelectionResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str group_id: The HLS audio selector gid.
        :param _builtins.str name: The name of the audio output configuration.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        The HLS audio selector gid.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the audio output configuration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetChannelsChannelInputAudioSelectorSelectorSettingAudioLanguageSelectionResult(dict):
    def __init__(__self__, *,
                 language_code: _builtins.str,
                 language_selection_policy: _builtins.str):
        """
        :param _builtins.str language_code: The language code.
        :param _builtins.str language_selection_policy: The language output strategy. Valid values are:
               + **LOOSE**: Loose matching. For example, "eng" will prioritize matching tracks with English as the language in the
               source stream. If no match is found, the track with the smallest PID will be selected.
               + **STRICT**: Strict matching. For example, "eng" will strictly match the audio track in the source stream whose
               language is English. If no match is found, the media live broadcast service will automatically fill in a silent
               segment. When the terminal uses this audio selector to play the video, it will be played silently.
        """
        pulumi.set(__self__, "language_code", language_code)
        pulumi.set(__self__, "language_selection_policy", language_selection_policy)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        The language code.
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="languageSelectionPolicy")
    def language_selection_policy(self) -> _builtins.str:
        """
        The language output strategy. Valid values are:
        + **LOOSE**: Loose matching. For example, "eng" will prioritize matching tracks with English as the language in the
        source stream. If no match is found, the track with the smallest PID will be selected.
        + **STRICT**: Strict matching. For example, "eng" will strictly match the audio track in the source stream whose
        language is English. If no match is found, the media live broadcast service will automatically fill in a silent
        segment. When the terminal uses this audio selector to play the video, it will be played silently.
        """
        return pulumi.get(self, "language_selection_policy")


@pulumi.output_type
class GetChannelsChannelInputAudioSelectorSelectorSettingAudioPidSelectionResult(dict):
    def __init__(__self__, *,
                 pid: _builtins.int):
        """
        :param _builtins.int pid: The value of PID.
        """
        pulumi.set(__self__, "pid", pid)

    @_builtins.property
    @pulumi.getter
    def pid(self) -> _builtins.int:
        """
        The value of PID.
        """
        return pulumi.get(self, "pid")


@pulumi.output_type
class GetChannelsChannelInputFailoverConditionResult(dict):
    def __init__(__self__, *,
                 input_loss_threshold_msec: _builtins.int,
                 input_preference: _builtins.str):
        """
        :param _builtins.int input_loss_threshold_msec: The duration threshold of inflow stop. The unit is millisecond.
        :param _builtins.str input_preference: The input preference type. Valid values are:
               + **PRIMARY**: The main incoming URL is the first priority.
               + **EQUAL**: Equal switching between primary and backup URLs.
        """
        pulumi.set(__self__, "input_loss_threshold_msec", input_loss_threshold_msec)
        pulumi.set(__self__, "input_preference", input_preference)

    @_builtins.property
    @pulumi.getter(name="inputLossThresholdMsec")
    def input_loss_threshold_msec(self) -> _builtins.int:
        """
        The duration threshold of inflow stop. The unit is millisecond.
        """
        return pulumi.get(self, "input_loss_threshold_msec")

    @_builtins.property
    @pulumi.getter(name="inputPreference")
    def input_preference(self) -> _builtins.str:
        """
        The input preference type. Valid values are:
        + **PRIMARY**: The main incoming URL is the first priority.
        + **EQUAL**: Equal switching between primary and backup URLs.
        """
        return pulumi.get(self, "input_preference")


@pulumi.output_type
class GetChannelsChannelInputSecondarySourceResult(dict):
    def __init__(__self__, *,
                 backup_urls: Sequence[_builtins.str],
                 bitrate: _builtins.int,
                 bitrate_for3u8: _builtins.bool,
                 height: _builtins.int,
                 latency: _builtins.int,
                 passphrase: _builtins.str,
                 stream_id: _builtins.str,
                 url: _builtins.str,
                 width: _builtins.int):
        """
        :param Sequence[_builtins.str] backup_urls: The list of backup stream addresses.
        :param _builtins.int bitrate: The bitrate. The unit is **bps**.
        :param _builtins.bool bitrate_for3u8: Whether to use bitrate to fix the bitrate.
        :param _builtins.int height: The resolution corresponds to the high value.
        :param _builtins.int latency: The streaming delay when the channel type is **SRT_PULL**.
        :param _builtins.str passphrase: The encrypted information when the protocol is **SRT_PUSH**.
        :param _builtins.str stream_id: The stream ID of the stream pull address when the channel type is **SRT_PULL**.
        :param _builtins.str url: The DRM address of the key.
        :param _builtins.int width: The resolution corresponds to the width value.
        """
        pulumi.set(__self__, "backup_urls", backup_urls)
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "bitrate_for3u8", bitrate_for3u8)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "latency", latency)
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter(name="backupUrls")
    def backup_urls(self) -> Sequence[_builtins.str]:
        """
        The list of backup stream addresses.
        """
        return pulumi.get(self, "backup_urls")

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> _builtins.int:
        """
        The bitrate. The unit is **bps**.
        """
        return pulumi.get(self, "bitrate")

    @_builtins.property
    @pulumi.getter(name="bitrateFor3u8")
    def bitrate_for3u8(self) -> _builtins.bool:
        """
        Whether to use bitrate to fix the bitrate.
        """
        return pulumi.get(self, "bitrate_for3u8")

    @_builtins.property
    @pulumi.getter
    def height(self) -> _builtins.int:
        """
        The resolution corresponds to the high value.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> _builtins.int:
        """
        The streaming delay when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        """
        The encrypted information when the protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> _builtins.str:
        """
        The stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def width(self) -> _builtins.int:
        """
        The resolution corresponds to the width value.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetChannelsChannelInputSourceResult(dict):
    def __init__(__self__, *,
                 backup_urls: Sequence[_builtins.str],
                 bitrate: _builtins.int,
                 bitrate_for3u8: _builtins.bool,
                 enable_snapshot: _builtins.bool,
                 height: _builtins.int,
                 latency: _builtins.int,
                 passphrase: _builtins.str,
                 stream_id: _builtins.str,
                 url: _builtins.str,
                 width: _builtins.int):
        """
        :param Sequence[_builtins.str] backup_urls: The list of backup stream addresses.
        :param _builtins.int bitrate: The bitrate. The unit is **bps**.
        :param _builtins.bool bitrate_for3u8: Whether to use bitrate to fix the bitrate.
        :param _builtins.bool enable_snapshot: Whether to use this stream to take screenshots.
        :param _builtins.int height: The resolution corresponds to the high value.
        :param _builtins.int latency: The streaming delay when the channel type is **SRT_PULL**.
        :param _builtins.str passphrase: The encrypted information when the protocol is **SRT_PUSH**.
        :param _builtins.str stream_id: The stream ID of the stream pull address when the channel type is **SRT_PULL**.
        :param _builtins.str url: The DRM address of the key.
        :param _builtins.int width: The resolution corresponds to the width value.
        """
        pulumi.set(__self__, "backup_urls", backup_urls)
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "bitrate_for3u8", bitrate_for3u8)
        pulumi.set(__self__, "enable_snapshot", enable_snapshot)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "latency", latency)
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "stream_id", stream_id)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter(name="backupUrls")
    def backup_urls(self) -> Sequence[_builtins.str]:
        """
        The list of backup stream addresses.
        """
        return pulumi.get(self, "backup_urls")

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> _builtins.int:
        """
        The bitrate. The unit is **bps**.
        """
        return pulumi.get(self, "bitrate")

    @_builtins.property
    @pulumi.getter(name="bitrateFor3u8")
    def bitrate_for3u8(self) -> _builtins.bool:
        """
        Whether to use bitrate to fix the bitrate.
        """
        return pulumi.get(self, "bitrate_for3u8")

    @_builtins.property
    @pulumi.getter(name="enableSnapshot")
    def enable_snapshot(self) -> _builtins.bool:
        """
        Whether to use this stream to take screenshots.
        """
        return pulumi.get(self, "enable_snapshot")

    @_builtins.property
    @pulumi.getter
    def height(self) -> _builtins.int:
        """
        The resolution corresponds to the high value.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> _builtins.int:
        """
        The streaming delay when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        """
        The encrypted information when the protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> _builtins.str:
        """
        The stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "stream_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The DRM address of the key.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def width(self) -> _builtins.int:
        """
        The resolution corresponds to the width value.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class GetChannelsChannelRecordSettingResult(dict):
    def __init__(__self__, *,
                 rollingbuffer_duration: _builtins.int):
        """
        :param _builtins.int rollingbuffer_duration: The maximum playback recording time. During this time period, the recording will continue.
               The unit is second.
        """
        pulumi.set(__self__, "rollingbuffer_duration", rollingbuffer_duration)

    @_builtins.property
    @pulumi.getter(name="rollingbufferDuration")
    def rollingbuffer_duration(self) -> _builtins.int:
        """
        The maximum playback recording time. During this time period, the recording will continue.
        The unit is second.
        """
        return pulumi.get(self, "rollingbuffer_duration")


@pulumi.output_type
class GetDisablePushStreamsBlockResult(dict):
    def __init__(__self__, *,
                 app_name: _builtins.str,
                 resume_time: _builtins.str,
                 stream_name: _builtins.str):
        """
        :param _builtins.str app_name: Specifies the application name of the disabling push stream.
        :param _builtins.str resume_time: The time of the resuming push stream.
               The format is **yyyy-mm-ddThh:mm:ssZ**. e.g. **2024-09-01T15:30:20Z**.
        :param _builtins.str stream_name: Specifies the stream name of the disabling push stream.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "resume_time", resume_time)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Specifies the application name of the disabling push stream.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="resumeTime")
    def resume_time(self) -> _builtins.str:
        """
        The time of the resuming push stream.
        The format is **yyyy-mm-ddThh:mm:ssZ**. e.g. **2024-09-01T15:30:20Z**.
        """
        return pulumi.get(self, "resume_time")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Specifies the stream name of the disabling push stream.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class GetDomainsDomainResult(dict):
    def __init__(__self__, *,
                 cname: _builtins.str,
                 created_at: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 ingest_domain_name: _builtins.str,
                 is_ipv6: _builtins.bool,
                 name: _builtins.str,
                 region: _builtins.str,
                 service_area: _builtins.str,
                 status: _builtins.str,
                 status_describe: _builtins.str,
                 type: _builtins.str,
                 vendor: _builtins.str):
        """
        :param _builtins.str cname: The CNAME of the domain name.
        :param _builtins.str created_at: The time when the domain name was created.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID.
               If omitted, all domain names will be queried.
        :param _builtins.str ingest_domain_name: The ingest domain name associated with the streaming domain name.
        :param _builtins.bool is_ipv6: Whether the IPv6 function is enabled.
               + **true**: Indicates that IPv6 is enabled.
               + **false**: Indicates that IPv6 is disabled
        :param _builtins.str name: Specifies the domain name.
        :param _builtins.str region: Specifies the region in which to query the resource.
               If omitted, the provider-level region will be used.
        :param _builtins.str service_area: The domain name acceleration region. Valid values are:
               + **mainland_china**: Chinese mainland.
               + **outside_mainland_china**: Outside the Chinese mainland.
               + **global**: Global acceleration.
        :param _builtins.str status: The status of the domain name.
        :param _builtins.str status_describe: The status description.
        :param _builtins.str type: The domain name type.
        :param _builtins.str vendor: The CDN vendor.
        """
        pulumi.set(__self__, "cname", cname)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "ingest_domain_name", ingest_domain_name)
        pulumi.set(__self__, "is_ipv6", is_ipv6)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service_area", service_area)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_describe", status_describe)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def cname(self) -> _builtins.str:
        """
        The CNAME of the domain name.
        """
        return pulumi.get(self, "cname")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The time when the domain name was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID.
        If omitted, all domain names will be queried.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="ingestDomainName")
    def ingest_domain_name(self) -> _builtins.str:
        """
        The ingest domain name associated with the streaming domain name.
        """
        return pulumi.get(self, "ingest_domain_name")

    @_builtins.property
    @pulumi.getter(name="isIpv6")
    def is_ipv6(self) -> _builtins.bool:
        """
        Whether the IPv6 function is enabled.
        + **true**: Indicates that IPv6 is enabled.
        + **false**: Indicates that IPv6 is disabled
        """
        return pulumi.get(self, "is_ipv6")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the domain name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region in which to query the resource.
        If omitted, the provider-level region will be used.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="serviceArea")
    def service_area(self) -> _builtins.str:
        """
        The domain name acceleration region. Valid values are:
        + **mainland_china**: Chinese mainland.
        + **outside_mainland_china**: Outside the Chinese mainland.
        + **global**: Global acceleration.
        """
        return pulumi.get(self, "service_area")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the domain name.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusDescribe")
    def status_describe(self) -> _builtins.str:
        """
        The status description.
        """
        return pulumi.get(self, "status_describe")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The domain name type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> _builtins.str:
        """
        The CDN vendor.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GetGeoBlockingsAppResult(dict):
    def __init__(__self__, *,
                 app_name: _builtins.str,
                 area_whitelists: Sequence[_builtins.str]):
        """
        :param _builtins.str app_name: The application name.
        :param Sequence[_builtins.str] area_whitelists: The restricted area list, an empty list indicates no restrictions.
               Except for China, codes for other regions are capitalized with `2` letters.
               Some valid values are as follows:
               + **CN-IN**: Chinese Mainland.
               + **CN-HK**: Hong Kong, China.
               + **CN-MO**: Macao, China.
               + **CN-TW**: Taiwan, China.
               + **BR**: Brazil.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "area_whitelists", area_whitelists)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        The application name.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="areaWhitelists")
    def area_whitelists(self) -> Sequence[_builtins.str]:
        """
        The restricted area list, an empty list indicates no restrictions.
        Except for China, codes for other regions are capitalized with `2` letters.
        Some valid values are as follows:
        + **CN-IN**: Chinese Mainland.
        + **CN-HK**: Hong Kong, China.
        + **CN-MO**: Macao, China.
        + **CN-TW**: Taiwan, China.
        + **BR**: Brazil.
        """
        return pulumi.get(self, "area_whitelists")


@pulumi.output_type
class GetRecordCallbacksCallbackResult(dict):
    def __init__(__self__, *,
                 app_name: _builtins.str,
                 created_at: _builtins.str,
                 domain_name: _builtins.str,
                 id: _builtins.str,
                 sign_type: _builtins.str,
                 types: Sequence[_builtins.str],
                 updated_at: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str app_name: Specifies the application name.
               To match all applications, set this parameter to a wildcard character *****.
               Exact application matching is preferred. If no application is matched, all applications will be matched.
        :param _builtins.str created_at: The creation time in the format of **yyyy-mm-ddThh:mm:ssZ** (UTC time).
        :param _builtins.str domain_name: Specifies the ingest domain name.
        :param _builtins.str id: The recording callback ID.
        :param _builtins.str sign_type: The encryption type. Contains the following values:
               + **HMACSHA256**
               + **MD5**
        :param Sequence[_builtins.str] types: The types of recording notifications. Contains the following values:
               + **RECORD_NEW_FILE_START**: Recording started.
               + **RECORD_FILE_COMPLETE**: Recording file generated.
               + **RECORD_OVER**: Recording completed.
               + **RECORD_FAILED**: Recording failed.
        :param _builtins.str updated_at: The latest modification time in the format of **yyyy-mm-ddThh:mm:ssZ** (UTC time).
        :param _builtins.str url: The callback URL for sending recording notifications.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "sign_type", sign_type)
        pulumi.set(__self__, "types", types)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Specifies the application name.
        To match all applications, set this parameter to a wildcard character *****.
        Exact application matching is preferred. If no application is matched, all applications will be matched.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time in the format of **yyyy-mm-ddThh:mm:ssZ** (UTC time).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Specifies the ingest domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The recording callback ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="signType")
    def sign_type(self) -> _builtins.str:
        """
        The encryption type. Contains the following values:
        + **HMACSHA256**
        + **MD5**
        """
        return pulumi.get(self, "sign_type")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Sequence[_builtins.str]:
        """
        The types of recording notifications. Contains the following values:
        + **RECORD_NEW_FILE_START**: Recording started.
        + **RECORD_FILE_COMPLETE**: Recording file generated.
        + **RECORD_OVER**: Recording completed.
        + **RECORD_FAILED**: Recording failed.
        """
        return pulumi.get(self, "types")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The latest modification time in the format of **yyyy-mm-ddThh:mm:ssZ** (UTC time).
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The callback URL for sending recording notifications.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetRecordingsRuleResult(dict):
    def __init__(__self__, *,
                 app_name: _builtins.str,
                 created_at: _builtins.str,
                 default_record_configs: Sequence['outputs.GetRecordingsRuleDefaultRecordConfigResult'],
                 domain_name: _builtins.str,
                 id: _builtins.str,
                 stream_name: _builtins.str,
                 type: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str app_name: Specifies the application name of the recording rule.
        :param _builtins.str created_at: The creation time of the recording rule.
               The format is **yyyy-mm-ddThh:mm:ssZ**. e.g. **2024-09-01T15:30:20Z**.
        :param Sequence['GetRecordingsRuleDefaultRecordConfigArgs'] default_record_configs: The default recording configuration rule.
        :param _builtins.str domain_name: Specifies the ingest domain name to which the recording rules belong.
        :param _builtins.str id: The recording rule ID.
        :param _builtins.str stream_name: Specifies the stream name of the recording rule.
        :param _builtins.str type: Specifies the recording type of the recording rule.
               The valid values are as follows:
               + **CONTINUOUS_RECORD**: Indicates continuous recording.
               + **COMMAND_RECORD**: Indicates command recording.
        :param _builtins.str updated_at: The lasted update time of the recording rule.
               The format is **yyyy-mm-ddThh:mm:ssZ**. e.g. **2024-09-01T15:30:20Z**.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "default_record_configs", default_record_configs)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "stream_name", stream_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Specifies the application name of the recording rule.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the recording rule.
        The format is **yyyy-mm-ddThh:mm:ssZ**. e.g. **2024-09-01T15:30:20Z**.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="defaultRecordConfigs")
    def default_record_configs(self) -> Sequence['outputs.GetRecordingsRuleDefaultRecordConfigResult']:
        """
        The default recording configuration rule.
        """
        return pulumi.get(self, "default_record_configs")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Specifies the ingest domain name to which the recording rules belong.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The recording rule ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        Specifies the stream name of the recording rule.
        """
        return pulumi.get(self, "stream_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the recording type of the recording rule.
        The valid values are as follows:
        + **CONTINUOUS_RECORD**: Indicates continuous recording.
        + **COMMAND_RECORD**: Indicates command recording.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The lasted update time of the recording rule.
        The format is **yyyy-mm-ddThh:mm:ssZ**. e.g. **2024-09-01T15:30:20Z**.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetRecordingsRuleDefaultRecordConfigResult(dict):
    def __init__(__self__, *,
                 flvs: Sequence['outputs.GetRecordingsRuleDefaultRecordConfigFlvResult'],
                 hls: Sequence['outputs.GetRecordingsRuleDefaultRecordConfigHlResult'],
                 mp4s: Sequence['outputs.GetRecordingsRuleDefaultRecordConfigMp4Result'],
                 obs: Sequence['outputs.GetRecordingsRuleDefaultRecordConfigObResult'],
                 record_formats: Sequence[_builtins.str]):
        """
        :param Sequence['GetRecordingsRuleDefaultRecordConfigFlvArgs'] flvs: The FLV configuration rule.
        :param Sequence['GetRecordingsRuleDefaultRecordConfigHlArgs'] hls: The HLS configuration rule.
        :param Sequence['GetRecordingsRuleDefaultRecordConfigMp4Args'] mp4s: The MP4 configuration rule.
        :param Sequence['GetRecordingsRuleDefaultRecordConfigObArgs'] obs: The OBS bucket information for storing recordings.
        :param Sequence[_builtins.str] record_formats: The recording format.
               The valid values are **HLS**, **FLV** and **MP4**.
        """
        pulumi.set(__self__, "flvs", flvs)
        pulumi.set(__self__, "hls", hls)
        pulumi.set(__self__, "mp4s", mp4s)
        pulumi.set(__self__, "obs", obs)
        pulumi.set(__self__, "record_formats", record_formats)

    @_builtins.property
    @pulumi.getter
    def flvs(self) -> Sequence['outputs.GetRecordingsRuleDefaultRecordConfigFlvResult']:
        """
        The FLV configuration rule.
        """
        return pulumi.get(self, "flvs")

    @_builtins.property
    @pulumi.getter
    def hls(self) -> Sequence['outputs.GetRecordingsRuleDefaultRecordConfigHlResult']:
        """
        The HLS configuration rule.
        """
        return pulumi.get(self, "hls")

    @_builtins.property
    @pulumi.getter
    def mp4s(self) -> Sequence['outputs.GetRecordingsRuleDefaultRecordConfigMp4Result']:
        """
        The MP4 configuration rule.
        """
        return pulumi.get(self, "mp4s")

    @_builtins.property
    @pulumi.getter
    def obs(self) -> Sequence['outputs.GetRecordingsRuleDefaultRecordConfigObResult']:
        """
        The OBS bucket information for storing recordings.
        """
        return pulumi.get(self, "obs")

    @_builtins.property
    @pulumi.getter(name="recordFormats")
    def record_formats(self) -> Sequence[_builtins.str]:
        """
        The recording format.
        The valid values are **HLS**, **FLV** and **MP4**.
        """
        return pulumi.get(self, "record_formats")


@pulumi.output_type
class GetRecordingsRuleDefaultRecordConfigFlvResult(dict):
    def __init__(__self__, *,
                 file_naming: _builtins.str,
                 max_stream_pause_length: _builtins.int,
                 recording_length: _builtins.int):
        """
        :param _builtins.str file_naming: The file path and file name prefix of the recorded MP4 file.
        :param _builtins.int max_stream_pause_length: The recording MP4 file concatenation duration, in seconds.
        :param _builtins.int recording_length: The periodic recording duration, in seconds.
        """
        pulumi.set(__self__, "file_naming", file_naming)
        pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)
        pulumi.set(__self__, "recording_length", recording_length)

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> _builtins.str:
        """
        The file path and file name prefix of the recorded MP4 file.
        """
        return pulumi.get(self, "file_naming")

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> _builtins.int:
        """
        The recording MP4 file concatenation duration, in seconds.
        """
        return pulumi.get(self, "max_stream_pause_length")

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> _builtins.int:
        """
        The periodic recording duration, in seconds.
        """
        return pulumi.get(self, "recording_length")


@pulumi.output_type
class GetRecordingsRuleDefaultRecordConfigHlResult(dict):
    def __init__(__self__, *,
                 file_naming: _builtins.str,
                 max_stream_pause_length: _builtins.int,
                 record_slice_duration: _builtins.int,
                 recording_length: _builtins.int,
                 ts_file_naming: _builtins.str):
        """
        :param _builtins.str file_naming: The file path and file name prefix of the recorded MP4 file.
        :param _builtins.int max_stream_pause_length: The recording MP4 file concatenation duration, in seconds.
        :param _builtins.int record_slice_duration: The TS slicing duration during HLS recording, in seconds.
        :param _builtins.int recording_length: The periodic recording duration, in seconds.
        :param _builtins.str ts_file_naming: The file name prefix of recorded TS file.
        """
        pulumi.set(__self__, "file_naming", file_naming)
        pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)
        pulumi.set(__self__, "record_slice_duration", record_slice_duration)
        pulumi.set(__self__, "recording_length", recording_length)
        pulumi.set(__self__, "ts_file_naming", ts_file_naming)

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> _builtins.str:
        """
        The file path and file name prefix of the recorded MP4 file.
        """
        return pulumi.get(self, "file_naming")

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> _builtins.int:
        """
        The recording MP4 file concatenation duration, in seconds.
        """
        return pulumi.get(self, "max_stream_pause_length")

    @_builtins.property
    @pulumi.getter(name="recordSliceDuration")
    def record_slice_duration(self) -> _builtins.int:
        """
        The TS slicing duration during HLS recording, in seconds.
        """
        return pulumi.get(self, "record_slice_duration")

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> _builtins.int:
        """
        The periodic recording duration, in seconds.
        """
        return pulumi.get(self, "recording_length")

    @_builtins.property
    @pulumi.getter(name="tsFileNaming")
    def ts_file_naming(self) -> _builtins.str:
        """
        The file name prefix of recorded TS file.
        """
        return pulumi.get(self, "ts_file_naming")


@pulumi.output_type
class GetRecordingsRuleDefaultRecordConfigMp4Result(dict):
    def __init__(__self__, *,
                 file_naming: _builtins.str,
                 max_stream_pause_length: _builtins.int,
                 recording_length: _builtins.int):
        """
        :param _builtins.str file_naming: The file path and file name prefix of the recorded MP4 file.
        :param _builtins.int max_stream_pause_length: The recording MP4 file concatenation duration, in seconds.
        :param _builtins.int recording_length: The periodic recording duration, in seconds.
        """
        pulumi.set(__self__, "file_naming", file_naming)
        pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)
        pulumi.set(__self__, "recording_length", recording_length)

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> _builtins.str:
        """
        The file path and file name prefix of the recorded MP4 file.
        """
        return pulumi.get(self, "file_naming")

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> _builtins.int:
        """
        The recording MP4 file concatenation duration, in seconds.
        """
        return pulumi.get(self, "max_stream_pause_length")

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> _builtins.int:
        """
        The periodic recording duration, in seconds.
        """
        return pulumi.get(self, "recording_length")


@pulumi.output_type
class GetRecordingsRuleDefaultRecordConfigObResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 object: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str bucket: The OBS bucket name.
        :param _builtins.str object: The OBS object storage path.
        :param _builtins.str region: Specifies the region in which to query the resource.
               If omitted, the provider-level region will be used.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The OBS bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def object(self) -> _builtins.str:
        """
        The OBS object storage path.
        """
        return pulumi.get(self, "object")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Specifies the region in which to query the resource.
        If omitted, the provider-level region will be used.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetSnapshotsSnapshotResult(dict):
    def __init__(__self__, *,
                 app_name: _builtins.str,
                 call_back_auth_key: _builtins.str,
                 call_back_enabled: _builtins.str,
                 call_back_url: _builtins.str,
                 domain_name: _builtins.str,
                 frequency: _builtins.int,
                 storage_bucket: _builtins.str,
                 storage_location: _builtins.str,
                 storage_mode: _builtins.int,
                 storage_path: _builtins.str):
        """
        :param _builtins.str app_name: Specifies the application name.
        :param _builtins.str call_back_auth_key: The callback authentication key value.
        :param _builtins.str call_back_enabled: Whether to enable callback notification.
               + **on**: Enabled.
               + **off**: Disabled.
        :param _builtins.str call_back_url: The address of the server for receiving callback notifications.
        :param _builtins.str domain_name: Specifies the domain name.
        :param _builtins.int frequency: The snapshot capturing frequency.
        :param _builtins.str storage_bucket: The OBS bucket name.
        :param _builtins.str storage_location: The region where the OBS bucket is located.
        :param _builtins.int storage_mode: The method for storing snapshots in an OBS bucket.
        :param _builtins.str storage_path: The OBS object path.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "call_back_auth_key", call_back_auth_key)
        pulumi.set(__self__, "call_back_enabled", call_back_enabled)
        pulumi.set(__self__, "call_back_url", call_back_url)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "storage_bucket", storage_bucket)
        pulumi.set(__self__, "storage_location", storage_location)
        pulumi.set(__self__, "storage_mode", storage_mode)
        pulumi.set(__self__, "storage_path", storage_path)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Specifies the application name.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="callBackAuthKey")
    def call_back_auth_key(self) -> _builtins.str:
        """
        The callback authentication key value.
        """
        return pulumi.get(self, "call_back_auth_key")

    @_builtins.property
    @pulumi.getter(name="callBackEnabled")
    def call_back_enabled(self) -> _builtins.str:
        """
        Whether to enable callback notification.
        + **on**: Enabled.
        + **off**: Disabled.
        """
        return pulumi.get(self, "call_back_enabled")

    @_builtins.property
    @pulumi.getter(name="callBackUrl")
    def call_back_url(self) -> _builtins.str:
        """
        The address of the server for receiving callback notifications.
        """
        return pulumi.get(self, "call_back_url")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        """
        Specifies the domain name.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.int:
        """
        The snapshot capturing frequency.
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="storageBucket")
    def storage_bucket(self) -> _builtins.str:
        """
        The OBS bucket name.
        """
        return pulumi.get(self, "storage_bucket")

    @_builtins.property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> _builtins.str:
        """
        The region where the OBS bucket is located.
        """
        return pulumi.get(self, "storage_location")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> _builtins.int:
        """
        The method for storing snapshots in an OBS bucket.
        """
        return pulumi.get(self, "storage_mode")

    @_builtins.property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> _builtins.str:
        """
        The OBS object path.
        """
        return pulumi.get(self, "storage_path")


@pulumi.output_type
class GetTranscodingsTemplateResult(dict):
    def __init__(__self__, *,
                 app_name: _builtins.str,
                 quality_infos: Sequence['outputs.GetTranscodingsTemplateQualityInfoResult']):
        """
        :param _builtins.str app_name: Specifies the application name of the transcoding template.
        :param Sequence['GetTranscodingsTemplateQualityInfoArgs'] quality_infos: The video quality information.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "quality_infos", quality_infos)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> _builtins.str:
        """
        Specifies the application name of the transcoding template.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="qualityInfos")
    def quality_infos(self) -> Sequence['outputs.GetTranscodingsTemplateQualityInfoResult']:
        """
        The video quality information.
        """
        return pulumi.get(self, "quality_infos")


@pulumi.output_type
class GetTranscodingsTemplateQualityInfoResult(dict):
    def __init__(__self__, *,
                 bitrate: _builtins.int,
                 bitrate_adaptive: _builtins.str,
                 frame_rate: _builtins.int,
                 gop: _builtins.int,
                 height: _builtins.int,
                 i_frame_interval: _builtins.int,
                 i_frame_policy: _builtins.str,
                 low_bitrate_hd: _builtins.str,
                 name: _builtins.str,
                 protocol: _builtins.str,
                 quality: _builtins.str,
                 video_encoding: _builtins.str,
                 width: _builtins.int):
        """
        :param _builtins.int bitrate: The bitrate of the transcoding video, in Kbps.
        :param _builtins.str bitrate_adaptive: The adaptive bitrate.
               The valid values are as follows:
               + **off**: Turn off rate adaptation and output the target rate at the set rate.
               + **minimum**: The target bitrate is output at the minimum value of the set bitrate and the source file bitrate.
               + **adaptive**: The target bitrate is adaptively output based on source file bitrate.
        :param _builtins.int frame_rate: The frame rate of transcoding video, in fps.
        :param _builtins.int gop: The I frame interval, in seconds.
        :param _builtins.int height: The video short edge (horizontal screen height, vertical screen width), in pixels.
        :param _builtins.int i_frame_interval: The maximum I frame interval, in frame.
        :param _builtins.str i_frame_policy: The encoding output I frame policy.
               The valid values are as follows:
               + **auto**: The I frame output according to the set `gop` duration.
               + **strictSync**: The encoding output I frame is completely consistent with the source.
        :param _builtins.str low_bitrate_hd: Whether to enable high-definition and low bitrate.
               The value can be **on** or **off**.
        :param _builtins.str name: The transcoding template name.
        :param _builtins.str protocol: The protocol type of transcoding output.
               The value can be **RTMP**.
        :param _builtins.str quality: The video quality.
               The valid values are as follows:
               + **lud**: Indicates ultra high definition.
               + **lhd**: Indicates high definition.
               + **lsd**: Indicates standard definition.
               + **lld**: Indicates smooth.
               + **userdefine**: Indicates customization of video quality.
        :param _builtins.str video_encoding: The video encoding format.
               The value can be **H264** or **H265**.
        :param _builtins.int width: The video long edge (width of horizontal screen, height of vertical screen), in pixels.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "bitrate_adaptive", bitrate_adaptive)
        pulumi.set(__self__, "frame_rate", frame_rate)
        pulumi.set(__self__, "gop", gop)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "i_frame_interval", i_frame_interval)
        pulumi.set(__self__, "i_frame_policy", i_frame_policy)
        pulumi.set(__self__, "low_bitrate_hd", low_bitrate_hd)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "quality", quality)
        pulumi.set(__self__, "video_encoding", video_encoding)
        pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> _builtins.int:
        """
        The bitrate of the transcoding video, in Kbps.
        """
        return pulumi.get(self, "bitrate")

    @_builtins.property
    @pulumi.getter(name="bitrateAdaptive")
    def bitrate_adaptive(self) -> _builtins.str:
        """
        The adaptive bitrate.
        The valid values are as follows:
        + **off**: Turn off rate adaptation and output the target rate at the set rate.
        + **minimum**: The target bitrate is output at the minimum value of the set bitrate and the source file bitrate.
        + **adaptive**: The target bitrate is adaptively output based on source file bitrate.
        """
        return pulumi.get(self, "bitrate_adaptive")

    @_builtins.property
    @pulumi.getter(name="frameRate")
    def frame_rate(self) -> _builtins.int:
        """
        The frame rate of transcoding video, in fps.
        """
        return pulumi.get(self, "frame_rate")

    @_builtins.property
    @pulumi.getter
    def gop(self) -> _builtins.int:
        """
        The I frame interval, in seconds.
        """
        return pulumi.get(self, "gop")

    @_builtins.property
    @pulumi.getter
    def height(self) -> _builtins.int:
        """
        The video short edge (horizontal screen height, vertical screen width), in pixels.
        """
        return pulumi.get(self, "height")

    @_builtins.property
    @pulumi.getter(name="iFrameInterval")
    def i_frame_interval(self) -> _builtins.int:
        """
        The maximum I frame interval, in frame.
        """
        return pulumi.get(self, "i_frame_interval")

    @_builtins.property
    @pulumi.getter(name="iFramePolicy")
    def i_frame_policy(self) -> _builtins.str:
        """
        The encoding output I frame policy.
        The valid values are as follows:
        + **auto**: The I frame output according to the set `gop` duration.
        + **strictSync**: The encoding output I frame is completely consistent with the source.
        """
        return pulumi.get(self, "i_frame_policy")

    @_builtins.property
    @pulumi.getter(name="lowBitrateHd")
    def low_bitrate_hd(self) -> _builtins.str:
        """
        Whether to enable high-definition and low bitrate.
        The value can be **on** or **off**.
        """
        return pulumi.get(self, "low_bitrate_hd")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The transcoding template name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol type of transcoding output.
        The value can be **RTMP**.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def quality(self) -> _builtins.str:
        """
        The video quality.
        The valid values are as follows:
        + **lud**: Indicates ultra high definition.
        + **lhd**: Indicates high definition.
        + **lsd**: Indicates standard definition.
        + **lld**: Indicates smooth.
        + **userdefine**: Indicates customization of video quality.
        """
        return pulumi.get(self, "quality")

    @_builtins.property
    @pulumi.getter(name="videoEncoding")
    def video_encoding(self) -> _builtins.str:
        """
        The video encoding format.
        The value can be **H264** or **H265**.
        """
        return pulumi.get(self, "video_encoding")

    @_builtins.property
    @pulumi.getter
    def width(self) -> _builtins.int:
        """
        The video long edge (width of horizontal screen, height of vertical screen), in pixels.
        """
        return pulumi.get(self, "width")


