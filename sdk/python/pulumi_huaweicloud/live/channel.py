# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ChannelArgs', 'Channel']

@pulumi.input_type
class ChannelArgs:
    def __init__(__self__, *,
                 app_name: pulumi.Input[_builtins.str],
                 domain_name: pulumi.Input[_builtins.str],
                 endpoints: pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]],
                 input: pulumi.Input['ChannelInputArgs'],
                 record_settings: pulumi.Input['ChannelRecordSettingsArgs'],
                 state: pulumi.Input[_builtins.str],
                 channel_id: Optional[pulumi.Input[_builtins.str]] = None,
                 encoder_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]]] = None,
                 encoder_settings_expand: Optional[pulumi.Input['ChannelEncoderSettingsExpandArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a Channel resource.
        :param pulumi.Input[_builtins.str] app_name: Specifies the group name or application name. Currently, only supports **live**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] domain_name: Specifies the channel streaming domain name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]] endpoints: Specifies the channel outflow information.
               The endpoints structure is documented below.
        :param pulumi.Input['ChannelInputArgs'] input: Specifies the channel input information.
               The input structure is documented below.
        :param pulumi.Input['ChannelRecordSettingsArgs'] record_settings: Specifies the configuration for replaying a recording.
               The record_settings structure is documented below.
        :param pulumi.Input[_builtins.str] state: Specifies the channel status. Valid values are:
               + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
               + **OFF**: Only the channel information is saved but the channel is not started.
        :param pulumi.Input[_builtins.str] channel_id: Specifies the unique channel ID.
               
               Changing this parameter will create a new resource.
               
               > If this field is configured, it will be used as the unique channel ID. Otherwise, a randomly generated string
               will be used as the unique ID.
               
               <a name="LiveChannel_Input"></a>
               The `input` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]] encoder_settings: Specifies the transcoding template configuration.
               The encoder_settings structure is documented below.
        :param pulumi.Input['ChannelEncoderSettingsExpandArgs'] encoder_settings_expand: Specifies the audio output configuration.
               The encoder_settings_expand structure is documented below.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used. Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "record_settings", record_settings)
        pulumi.set(__self__, "state", state)
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if encoder_settings is not None:
            pulumi.set(__self__, "encoder_settings", encoder_settings)
        if encoder_settings_expand is not None:
            pulumi.set(__self__, "encoder_settings_expand", encoder_settings_expand)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the group name or application name. Currently, only supports **live**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "app_name", value)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the channel streaming domain name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]]:
        """
        Specifies the channel outflow information.
        The endpoints structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]]):
        pulumi.set(self, "endpoints", value)

    @_builtins.property
    @pulumi.getter
    def input(self) -> pulumi.Input['ChannelInputArgs']:
        """
        Specifies the channel input information.
        The input structure is documented below.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: pulumi.Input['ChannelInputArgs']):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter(name="recordSettings")
    def record_settings(self) -> pulumi.Input['ChannelRecordSettingsArgs']:
        """
        Specifies the configuration for replaying a recording.
        The record_settings structure is documented below.
        """
        return pulumi.get(self, "record_settings")

    @record_settings.setter
    def record_settings(self, value: pulumi.Input['ChannelRecordSettingsArgs']):
        pulumi.set(self, "record_settings", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the channel status. Valid values are:
        + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
        + **OFF**: Only the channel information is saved but the channel is not started.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unique channel ID.

        Changing this parameter will create a new resource.

        > If this field is configured, it will be used as the unique channel ID. Otherwise, a randomly generated string
        will be used as the unique ID.

        <a name="LiveChannel_Input"></a>
        The `input` block supports:
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_id", value)

    @_builtins.property
    @pulumi.getter(name="encoderSettings")
    def encoder_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]]]:
        """
        Specifies the transcoding template configuration.
        The encoder_settings structure is documented below.
        """
        return pulumi.get(self, "encoder_settings")

    @encoder_settings.setter
    def encoder_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]]]):
        pulumi.set(self, "encoder_settings", value)

    @_builtins.property
    @pulumi.getter(name="encoderSettingsExpand")
    def encoder_settings_expand(self) -> Optional[pulumi.Input['ChannelEncoderSettingsExpandArgs']]:
        """
        Specifies the audio output configuration.
        The encoder_settings_expand structure is documented below.
        """
        return pulumi.get(self, "encoder_settings_expand")

    @encoder_settings_expand.setter
    def encoder_settings_expand(self, value: Optional[pulumi.Input['ChannelEncoderSettingsExpandArgs']]):
        pulumi.set(self, "encoder_settings_expand", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the resource.
        If omitted, the provider-level region will be used. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class _ChannelState:
    def __init__(__self__, *,
                 app_name: Optional[pulumi.Input[_builtins.str]] = None,
                 channel_id: Optional[pulumi.Input[_builtins.str]] = None,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 encoder_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]]] = None,
                 encoder_settings_expand: Optional[pulumi.Input['ChannelEncoderSettingsExpandArgs']] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]]] = None,
                 input: Optional[pulumi.Input['ChannelInputArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 record_settings: Optional[pulumi.Input['ChannelRecordSettingsArgs']] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering Channel resources.
        :param pulumi.Input[_builtins.str] app_name: Specifies the group name or application name. Currently, only supports **live**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] channel_id: Specifies the unique channel ID.
               
               Changing this parameter will create a new resource.
               
               > If this field is configured, it will be used as the unique channel ID. Otherwise, a randomly generated string
               will be used as the unique ID.
               
               <a name="LiveChannel_Input"></a>
               The `input` block supports:
        :param pulumi.Input[_builtins.str] domain_name: Specifies the channel streaming domain name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]] encoder_settings: Specifies the transcoding template configuration.
               The encoder_settings structure is documented below.
        :param pulumi.Input['ChannelEncoderSettingsExpandArgs'] encoder_settings_expand: Specifies the audio output configuration.
               The encoder_settings_expand structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]] endpoints: Specifies the channel outflow information.
               The endpoints structure is documented below.
        :param pulumi.Input['ChannelInputArgs'] input: Specifies the channel input information.
               The input structure is documented below.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param pulumi.Input['ChannelRecordSettingsArgs'] record_settings: Specifies the configuration for replaying a recording.
               The record_settings structure is documented below.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] state: Specifies the channel status. Valid values are:
               + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
               + **OFF**: Only the channel information is saved but the channel is not started.
        """
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if encoder_settings is not None:
            pulumi.set(__self__, "encoder_settings", encoder_settings)
        if encoder_settings_expand is not None:
            pulumi.set(__self__, "encoder_settings_expand", encoder_settings_expand)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if record_settings is not None:
            pulumi.set(__self__, "record_settings", record_settings)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the group name or application name. Currently, only supports **live**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_name", value)

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unique channel ID.

        Changing this parameter will create a new resource.

        > If this field is configured, it will be used as the unique channel ID. Otherwise, a randomly generated string
        will be used as the unique ID.

        <a name="LiveChannel_Input"></a>
        The `input` block supports:
        """
        return pulumi.get(self, "channel_id")

    @channel_id.setter
    def channel_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_id", value)

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the channel streaming domain name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @_builtins.property
    @pulumi.getter(name="encoderSettings")
    def encoder_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]]]:
        """
        Specifies the transcoding template configuration.
        The encoder_settings structure is documented below.
        """
        return pulumi.get(self, "encoder_settings")

    @encoder_settings.setter
    def encoder_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingArgs']]]]):
        pulumi.set(self, "encoder_settings", value)

    @_builtins.property
    @pulumi.getter(name="encoderSettingsExpand")
    def encoder_settings_expand(self) -> Optional[pulumi.Input['ChannelEncoderSettingsExpandArgs']]:
        """
        Specifies the audio output configuration.
        The encoder_settings_expand structure is documented below.
        """
        return pulumi.get(self, "encoder_settings_expand")

    @encoder_settings_expand.setter
    def encoder_settings_expand(self, value: Optional[pulumi.Input['ChannelEncoderSettingsExpandArgs']]):
        pulumi.set(self, "encoder_settings_expand", value)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]]]:
        """
        Specifies the channel outflow information.
        The endpoints structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input['ChannelInputArgs']]:
        """
        Specifies the channel input information.
        The input structure is documented below.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input['ChannelInputArgs']]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="recordSettings")
    def record_settings(self) -> Optional[pulumi.Input['ChannelRecordSettingsArgs']]:
        """
        Specifies the configuration for replaying a recording.
        The record_settings structure is documented below.
        """
        return pulumi.get(self, "record_settings")

    @record_settings.setter
    def record_settings(self, value: Optional[pulumi.Input['ChannelRecordSettingsArgs']]):
        pulumi.set(self, "record_settings", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region in which to create the resource.
        If omitted, the provider-level region will be used. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the channel status. Valid values are:
        + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
        + **OFF**: Only the channel information is saved but the channel is not started.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


@pulumi.type_token("huaweicloud:Live/channel:Channel")
class Channel(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 app_name: Optional[pulumi.Input[_builtins.str]] = None,
                 channel_id: Optional[pulumi.Input[_builtins.str]] = None,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 encoder_settings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ChannelEncoderSettingArgs', 'ChannelEncoderSettingArgsDict']]]]] = None,
                 encoder_settings_expand: Optional[pulumi.Input[Union['ChannelEncoderSettingsExpandArgs', 'ChannelEncoderSettingsExpandArgsDict']]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ChannelEndpointArgs', 'ChannelEndpointArgsDict']]]]] = None,
                 input: Optional[pulumi.Input[Union['ChannelInputArgs', 'ChannelInputArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 record_settings: Optional[pulumi.Input[Union['ChannelRecordSettingsArgs', 'ChannelRecordSettingsArgsDict']]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        Manages a Live channel resource within HuaweiCloud.

        ## Example Usage

        ### Create a Live channel with RTMP_PUSH protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        hls_package_encryption_url = config.require_object("hlsPackageEncryptionUrl")
        hls_package_encryption_urn = config.require_object("hlsPackageEncryptionUrn")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 24,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "profile",
                        "request_mode": "functiongraph_proxy",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": hls_package_encryption_url,
                        "urn": hls_package_encryption_urn,
                        "system_ids": ["FairPlay"],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 42,
                    "segment_duration_seconds": 4,
                    "url": mss_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "https://test-url.cd",
                        "system_ids": ["PlayReady"],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "RTMP_PUSH",
                "sources": [{
                    "bitrate": 100,
                }],
            },
            record_settings={
                "rollingbuffer_duration": 20,
            })
        ```

        ### Create a Live channel with FLV_PULL protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        dash_package_url = config.require_object("dashPackageUrl")
        hls_package_url = config.require_object("hlsPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "dash_packages": [{
                    "playlist_window_seconds": 24,
                    "segment_duration_seconds": 4,
                    "url": dash_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 8,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "http://xxx.sp",
                        "system_ids": ["FairPlay"],
                        "http_headers": [
                            {
                                "key": "aaa",
                                "value": "sss",
                            },
                            {
                                "key": "www",
                                "value": "qqq",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "FLV_PULL",
                "failover_conditions": {
                    "input_loss_threshold_msec": 4000,
                    "input_preference": "EQUAL",
                },
                "secondary_sources": [{
                    "bitrate": 100,
                    "url": "https://hgf.vv",
                }],
                "sources": [{
                    "bitrate": 100,
                    "url": "https://qwe.cc",
                }],
            },
            record_settings={
                "rollingbuffer_duration": 12,
            })
        ```

        ### Create a Live channel with HLS_PULL protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        hls_package_encryption_url = config.require_object("hlsPackageEncryptionUrl")
        hls_package_encryption_urn = config.require_object("hlsPackageEncryptionUrn")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 4,
                    "segment_duration_seconds": 2,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "functiongraph_proxy",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": hls_package_encryption_url,
                        "urn": hls_package_encryption_urn,
                        "system_ids": ["FairPlay"],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 8,
                    "segment_duration_seconds": 2,
                    "url": mss_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "dfge",
                        "speke_version": "1.0",
                        "url": "https://ssc.cd",
                        "system_ids": ["PlayReady"],
                        "http_headers": [
                            {
                                "key": "aa",
                                "value": "ss",
                            },
                            {
                                "key": "gg",
                                "value": "ff",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "HLS_PULL",
                "max_bandwidth_limit": 200,
                "failover_conditions": {
                    "input_loss_threshold_msec": 2000,
                    "input_preference": "PRIMARY",
                },
                "secondary_sources": [{
                    "bitrate": 100,
                    "url": "https://qqwe.dd",
                }],
                "sources": [{
                    "bitrate": 100,
                    "url": "https://ssa.qw",
                }],
            },
            record_settings={
                "rollingbuffer_duration": 3,
            })
        ```

        ### Create a Live channel with SRT_PUSH protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 4,
                    "segment_duration_seconds": 2,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "https://qqq.co",
                        "system_ids": ["FairPlay"],
                        "http_headers": [
                            {
                                "key": "aa",
                                "value": "sss",
                            },
                            {
                                "key": "dd",
                                "value": "sss",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 8,
                    "segment_duration_seconds": 2,
                    "url": mss_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "SRT_PUSH",
                "ip_whitelist": "192.168.0.1/16,192.168.1.1/16,192.168.2.1/16",
                "audio_selectors": [
                    {
                        "name": "test-audio-selectors1",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 2,
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors2",
                        "selector_settings": {
                            "audio_language_selection": {
                                "language_code": "ch",
                                "language_selection_policy": "LOOSE",
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors3",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 0,
                            },
                        },
                    },
                ],
                "sources": [{
                    "bitrate": 100,
                }],
            },
            record_settings={
                "rollingbuffer_duration": 2,
            })
        ```

        ### Create a Live channel with SRT_PULL protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 16,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "https://sss.cc",
                        "system_ids": ["FairPlay"],
                        "http_headers": [
                            {
                                "key": "aa",
                                "value": "ss",
                            },
                            {
                                "key": "ff",
                                "value": "dd",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 24,
                    "segment_duration_seconds": 4,
                    "url": mss_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "SRT_PULL",
                "audio_selectors": [
                    {
                        "name": "test-audio-selectors1",
                        "selector_settings": {
                            "audio_language_selection": {
                                "language_code": "dfg",
                                "language_selection_policy": "LOOSE",
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors2",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 13,
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors3",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 0,
                            },
                        },
                    },
                ],
                "failover_conditions": {
                    "input_loss_threshold_msec": 2000,
                    "input_preference": "EQUAL",
                },
                "secondary_sources": [{
                    "bitrate": 100,
                    "latency": 1000,
                    "stream_id": "vcbeer",
                    "url": "srt://192.168.1.215:9001",
                }],
                "sources": [{
                    "bitrate": 100,
                    "latency": 2000,
                    "stream_id": "dfawerw",
                    "url": "srt://192.168.1.216:9001",
                }],
            },
            record_settings={
                "rollingbuffer_duration": 4,
            })
        ```

        ### Create a Live channel with custom channel ID

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        channel_id = config.require_object("channelId")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            state="OFF",
            channel_id=channel_id,
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 40,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "RTMP_PUSH",
                "sources": [{
                    "bitrate": 100,
                }],
            },
            record_settings={
                "rollingbuffer_duration": 0,
            })
        ```

        ## Import

        The live channel can be imported using the `id`, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Live/channel:Channel test <id>
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] app_name: Specifies the group name or application name. Currently, only supports **live**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] channel_id: Specifies the unique channel ID.
               
               Changing this parameter will create a new resource.
               
               > If this field is configured, it will be used as the unique channel ID. Otherwise, a randomly generated string
               will be used as the unique ID.
               
               <a name="LiveChannel_Input"></a>
               The `input` block supports:
        :param pulumi.Input[_builtins.str] domain_name: Specifies the channel streaming domain name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ChannelEncoderSettingArgs', 'ChannelEncoderSettingArgsDict']]]] encoder_settings: Specifies the transcoding template configuration.
               The encoder_settings structure is documented below.
        :param pulumi.Input[Union['ChannelEncoderSettingsExpandArgs', 'ChannelEncoderSettingsExpandArgsDict']] encoder_settings_expand: Specifies the audio output configuration.
               The encoder_settings_expand structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ChannelEndpointArgs', 'ChannelEndpointArgsDict']]]] endpoints: Specifies the channel outflow information.
               The endpoints structure is documented below.
        :param pulumi.Input[Union['ChannelInputArgs', 'ChannelInputArgsDict']] input: Specifies the channel input information.
               The input structure is documented below.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param pulumi.Input[Union['ChannelRecordSettingsArgs', 'ChannelRecordSettingsArgsDict']] record_settings: Specifies the configuration for replaying a recording.
               The record_settings structure is documented below.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] state: Specifies the channel status. Valid values are:
               + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
               + **OFF**: Only the channel information is saved but the channel is not started.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ChannelArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Manages a Live channel resource within HuaweiCloud.

        ## Example Usage

        ### Create a Live channel with RTMP_PUSH protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        hls_package_encryption_url = config.require_object("hlsPackageEncryptionUrl")
        hls_package_encryption_urn = config.require_object("hlsPackageEncryptionUrn")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 24,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "profile",
                        "request_mode": "functiongraph_proxy",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": hls_package_encryption_url,
                        "urn": hls_package_encryption_urn,
                        "system_ids": ["FairPlay"],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 42,
                    "segment_duration_seconds": 4,
                    "url": mss_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "https://test-url.cd",
                        "system_ids": ["PlayReady"],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "RTMP_PUSH",
                "sources": [{
                    "bitrate": 100,
                }],
            },
            record_settings={
                "rollingbuffer_duration": 20,
            })
        ```

        ### Create a Live channel with FLV_PULL protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        dash_package_url = config.require_object("dashPackageUrl")
        hls_package_url = config.require_object("hlsPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "dash_packages": [{
                    "playlist_window_seconds": 24,
                    "segment_duration_seconds": 4,
                    "url": dash_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 8,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "http://xxx.sp",
                        "system_ids": ["FairPlay"],
                        "http_headers": [
                            {
                                "key": "aaa",
                                "value": "sss",
                            },
                            {
                                "key": "www",
                                "value": "qqq",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "FLV_PULL",
                "failover_conditions": {
                    "input_loss_threshold_msec": 4000,
                    "input_preference": "EQUAL",
                },
                "secondary_sources": [{
                    "bitrate": 100,
                    "url": "https://hgf.vv",
                }],
                "sources": [{
                    "bitrate": 100,
                    "url": "https://qwe.cc",
                }],
            },
            record_settings={
                "rollingbuffer_duration": 12,
            })
        ```

        ### Create a Live channel with HLS_PULL protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        hls_package_encryption_url = config.require_object("hlsPackageEncryptionUrl")
        hls_package_encryption_urn = config.require_object("hlsPackageEncryptionUrn")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 4,
                    "segment_duration_seconds": 2,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "functiongraph_proxy",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": hls_package_encryption_url,
                        "urn": hls_package_encryption_urn,
                        "system_ids": ["FairPlay"],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 8,
                    "segment_duration_seconds": 2,
                    "url": mss_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "dfge",
                        "speke_version": "1.0",
                        "url": "https://ssc.cd",
                        "system_ids": ["PlayReady"],
                        "http_headers": [
                            {
                                "key": "aa",
                                "value": "ss",
                            },
                            {
                                "key": "gg",
                                "value": "ff",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "HLS_PULL",
                "max_bandwidth_limit": 200,
                "failover_conditions": {
                    "input_loss_threshold_msec": 2000,
                    "input_preference": "PRIMARY",
                },
                "secondary_sources": [{
                    "bitrate": 100,
                    "url": "https://qqwe.dd",
                }],
                "sources": [{
                    "bitrate": 100,
                    "url": "https://ssa.qw",
                }],
            },
            record_settings={
                "rollingbuffer_duration": 3,
            })
        ```

        ### Create a Live channel with SRT_PUSH protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 4,
                    "segment_duration_seconds": 2,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "https://qqq.co",
                        "system_ids": ["FairPlay"],
                        "http_headers": [
                            {
                                "key": "aa",
                                "value": "sss",
                            },
                            {
                                "key": "dd",
                                "value": "sss",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 8,
                    "segment_duration_seconds": 2,
                    "url": mss_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "SRT_PUSH",
                "ip_whitelist": "192.168.0.1/16,192.168.1.1/16,192.168.2.1/16",
                "audio_selectors": [
                    {
                        "name": "test-audio-selectors1",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 2,
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors2",
                        "selector_settings": {
                            "audio_language_selection": {
                                "language_code": "ch",
                                "language_selection_policy": "LOOSE",
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors3",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 0,
                            },
                        },
                    },
                ],
                "sources": [{
                    "bitrate": 100,
                }],
            },
            record_settings={
                "rollingbuffer_duration": 2,
            })
        ```

        ### Create a Live channel with SRT_PULL protocol

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        mss_package_url = config.require_object("mssPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            name="test-name",
            state="ON",
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 16,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "encryption": {
                        "level": "content",
                        "request_mode": "direct_http",
                        "resource_id": "test-resource-id",
                        "speke_version": "1.0",
                        "url": "https://sss.cc",
                        "system_ids": ["FairPlay"],
                        "http_headers": [
                            {
                                "key": "aa",
                                "value": "ss",
                            },
                            {
                                "key": "ff",
                                "value": "dd",
                            },
                        ],
                    },
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
                "mss_packages": [{
                    "playlist_window_seconds": 24,
                    "segment_duration_seconds": 4,
                    "url": mss_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "SRT_PULL",
                "audio_selectors": [
                    {
                        "name": "test-audio-selectors1",
                        "selector_settings": {
                            "audio_language_selection": {
                                "language_code": "dfg",
                                "language_selection_policy": "LOOSE",
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors2",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 13,
                            },
                        },
                    },
                    {
                        "name": "test-audio-selectors3",
                        "selector_settings": {
                            "audio_pid_selection": {
                                "pid": 0,
                            },
                        },
                    },
                ],
                "failover_conditions": {
                    "input_loss_threshold_msec": 2000,
                    "input_preference": "EQUAL",
                },
                "secondary_sources": [{
                    "bitrate": 100,
                    "latency": 1000,
                    "stream_id": "vcbeer",
                    "url": "srt://192.168.1.215:9001",
                }],
                "sources": [{
                    "bitrate": 100,
                    "latency": 2000,
                    "stream_id": "dfawerw",
                    "url": "srt://192.168.1.216:9001",
                }],
            },
            record_settings={
                "rollingbuffer_duration": 4,
            })
        ```

        ### Create a Live channel with custom channel ID

        ```python
        import pulumi
        import pulumi_huaweicloud as huaweicloud

        config = pulumi.Config()
        domain_name = config.require_object("domainName")
        channel_id = config.require_object("channelId")
        template_id = config.require_object("templateId")
        hls_package_url = config.require_object("hlsPackageUrl")
        test = huaweicloud.live.Channel("test",
            app_name="live",
            domain_name=domain_name,
            state="OFF",
            channel_id=channel_id,
            encoder_settings=[{
                "template_id": template_id,
            }],
            endpoints=[{
                "hls_packages": [{
                    "hls_version": "v3",
                    "playlist_window_seconds": 40,
                    "segment_duration_seconds": 4,
                    "url": hls_package_url,
                    "request_args": {
                        "records": [{
                            "end_time": "end",
                            "format": "timestamp",
                            "start_time": "begin",
                            "unit": "second",
                        }],
                        "timeshifts": [{
                            "back_time": "delay",
                            "unit": "second",
                        }],
                    },
                }],
            }],
            input={
                "input_protocol": "RTMP_PUSH",
                "sources": [{
                    "bitrate": 100,
                }],
            },
            record_settings={
                "rollingbuffer_duration": 0,
            })
        ```

        ## Import

        The live channel can be imported using the `id`, e.g.

        bash

        ```sh
        $ pulumi import huaweicloud:Live/channel:Channel test <id>
        ```

        :param str resource_name: The name of the resource.
        :param ChannelArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ChannelArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 app_name: Optional[pulumi.Input[_builtins.str]] = None,
                 channel_id: Optional[pulumi.Input[_builtins.str]] = None,
                 domain_name: Optional[pulumi.Input[_builtins.str]] = None,
                 encoder_settings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ChannelEncoderSettingArgs', 'ChannelEncoderSettingArgsDict']]]]] = None,
                 encoder_settings_expand: Optional[pulumi.Input[Union['ChannelEncoderSettingsExpandArgs', 'ChannelEncoderSettingsExpandArgsDict']]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ChannelEndpointArgs', 'ChannelEndpointArgsDict']]]]] = None,
                 input: Optional[pulumi.Input[Union['ChannelInputArgs', 'ChannelInputArgsDict']]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 record_settings: Optional[pulumi.Input[Union['ChannelRecordSettingsArgs', 'ChannelRecordSettingsArgsDict']]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ChannelArgs.__new__(ChannelArgs)

            if app_name is None and not opts.urn:
                raise TypeError("Missing required property 'app_name'")
            __props__.__dict__["app_name"] = app_name
            __props__.__dict__["channel_id"] = channel_id
            if domain_name is None and not opts.urn:
                raise TypeError("Missing required property 'domain_name'")
            __props__.__dict__["domain_name"] = domain_name
            __props__.__dict__["encoder_settings"] = encoder_settings
            __props__.__dict__["encoder_settings_expand"] = encoder_settings_expand
            if endpoints is None and not opts.urn:
                raise TypeError("Missing required property 'endpoints'")
            __props__.__dict__["endpoints"] = endpoints
            if input is None and not opts.urn:
                raise TypeError("Missing required property 'input'")
            __props__.__dict__["input"] = input
            __props__.__dict__["name"] = name
            if record_settings is None and not opts.urn:
                raise TypeError("Missing required property 'record_settings'")
            __props__.__dict__["record_settings"] = record_settings
            __props__.__dict__["region"] = region
            if state is None and not opts.urn:
                raise TypeError("Missing required property 'state'")
            __props__.__dict__["state"] = state
        super(Channel, __self__).__init__(
            'huaweicloud:Live/channel:Channel',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            app_name: Optional[pulumi.Input[_builtins.str]] = None,
            channel_id: Optional[pulumi.Input[_builtins.str]] = None,
            domain_name: Optional[pulumi.Input[_builtins.str]] = None,
            encoder_settings: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ChannelEncoderSettingArgs', 'ChannelEncoderSettingArgsDict']]]]] = None,
            encoder_settings_expand: Optional[pulumi.Input[Union['ChannelEncoderSettingsExpandArgs', 'ChannelEncoderSettingsExpandArgsDict']]] = None,
            endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ChannelEndpointArgs', 'ChannelEndpointArgsDict']]]]] = None,
            input: Optional[pulumi.Input[Union['ChannelInputArgs', 'ChannelInputArgsDict']]] = None,
            name: Optional[pulumi.Input[_builtins.str]] = None,
            record_settings: Optional[pulumi.Input[Union['ChannelRecordSettingsArgs', 'ChannelRecordSettingsArgsDict']]] = None,
            region: Optional[pulumi.Input[_builtins.str]] = None,
            state: Optional[pulumi.Input[_builtins.str]] = None) -> 'Channel':
        """
        Get an existing Channel resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] app_name: Specifies the group name or application name. Currently, only supports **live**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] channel_id: Specifies the unique channel ID.
               
               Changing this parameter will create a new resource.
               
               > If this field is configured, it will be used as the unique channel ID. Otherwise, a randomly generated string
               will be used as the unique ID.
               
               <a name="LiveChannel_Input"></a>
               The `input` block supports:
        :param pulumi.Input[_builtins.str] domain_name: Specifies the channel streaming domain name.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ChannelEncoderSettingArgs', 'ChannelEncoderSettingArgsDict']]]] encoder_settings: Specifies the transcoding template configuration.
               The encoder_settings structure is documented below.
        :param pulumi.Input[Union['ChannelEncoderSettingsExpandArgs', 'ChannelEncoderSettingsExpandArgsDict']] encoder_settings_expand: Specifies the audio output configuration.
               The encoder_settings_expand structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ChannelEndpointArgs', 'ChannelEndpointArgsDict']]]] endpoints: Specifies the channel outflow information.
               The endpoints structure is documented below.
        :param pulumi.Input[Union['ChannelInputArgs', 'ChannelInputArgsDict']] input: Specifies the channel input information.
               The input structure is documented below.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param pulumi.Input[Union['ChannelRecordSettingsArgs', 'ChannelRecordSettingsArgsDict']] record_settings: Specifies the configuration for replaying a recording.
               The record_settings structure is documented below.
        :param pulumi.Input[_builtins.str] region: Specifies the region in which to create the resource.
               If omitted, the provider-level region will be used. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] state: Specifies the channel status. Valid values are:
               + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
               + **OFF**: Only the channel information is saved but the channel is not started.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ChannelState.__new__(_ChannelState)

        __props__.__dict__["app_name"] = app_name
        __props__.__dict__["channel_id"] = channel_id
        __props__.__dict__["domain_name"] = domain_name
        __props__.__dict__["encoder_settings"] = encoder_settings
        __props__.__dict__["encoder_settings_expand"] = encoder_settings_expand
        __props__.__dict__["endpoints"] = endpoints
        __props__.__dict__["input"] = input
        __props__.__dict__["name"] = name
        __props__.__dict__["record_settings"] = record_settings
        __props__.__dict__["region"] = region
        __props__.__dict__["state"] = state
        return Channel(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="appName")
    def app_name(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the group name or application name. Currently, only supports **live**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "app_name")

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the unique channel ID.

        Changing this parameter will create a new resource.

        > If this field is configured, it will be used as the unique channel ID. Otherwise, a randomly generated string
        will be used as the unique ID.

        <a name="LiveChannel_Input"></a>
        The `input` block supports:
        """
        return pulumi.get(self, "channel_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the channel streaming domain name.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="encoderSettings")
    def encoder_settings(self) -> pulumi.Output[Optional[Sequence['outputs.ChannelEncoderSetting']]]:
        """
        Specifies the transcoding template configuration.
        The encoder_settings structure is documented below.
        """
        return pulumi.get(self, "encoder_settings")

    @_builtins.property
    @pulumi.getter(name="encoderSettingsExpand")
    def encoder_settings_expand(self) -> pulumi.Output[Optional['outputs.ChannelEncoderSettingsExpand']]:
        """
        Specifies the audio output configuration.
        The encoder_settings_expand structure is documented below.
        """
        return pulumi.get(self, "encoder_settings_expand")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> pulumi.Output[Sequence['outputs.ChannelEndpoint']]:
        """
        Specifies the channel outflow information.
        The endpoints structure is documented below.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def input(self) -> pulumi.Output['outputs.ChannelInput']:
        """
        Specifies the channel input information.
        The input structure is documented below.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="recordSettings")
    def record_settings(self) -> pulumi.Output['outputs.ChannelRecordSettings']:
        """
        Specifies the configuration for replaying a recording.
        The record_settings structure is documented below.
        """
        return pulumi.get(self, "record_settings")

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the region in which to create the resource.
        If omitted, the provider-level region will be used. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Output[_builtins.str]:
        """
        Specifies the channel status. Valid values are:
        + **ON**: After a channel is delivered, functions such as stream pull, transcoding, and recording are automatically enabled.
        + **OFF**: Only the channel information is saved but the channel is not started.
        """
        return pulumi.get(self, "state")

