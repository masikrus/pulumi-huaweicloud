# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ChannelEncoderSettingArgs',
    'ChannelEncoderSettingArgsDict',
    'ChannelEncoderSettingsExpandArgs',
    'ChannelEncoderSettingsExpandArgsDict',
    'ChannelEncoderSettingsExpandAudioDescriptionArgs',
    'ChannelEncoderSettingsExpandAudioDescriptionArgsDict',
    'ChannelEndpointArgs',
    'ChannelEndpointArgsDict',
    'ChannelEndpointDashPackageArgs',
    'ChannelEndpointDashPackageArgsDict',
    'ChannelEndpointDashPackageEncryptionArgs',
    'ChannelEndpointDashPackageEncryptionArgsDict',
    'ChannelEndpointDashPackageEncryptionHttpHeaderArgs',
    'ChannelEndpointDashPackageEncryptionHttpHeaderArgsDict',
    'ChannelEndpointDashPackageRequestArgsArgs',
    'ChannelEndpointDashPackageRequestArgsArgsDict',
    'ChannelEndpointDashPackageRequestArgsLifeArgs',
    'ChannelEndpointDashPackageRequestArgsLifeArgsDict',
    'ChannelEndpointDashPackageRequestArgsRecordArgs',
    'ChannelEndpointDashPackageRequestArgsRecordArgsDict',
    'ChannelEndpointDashPackageRequestArgsTimeshiftArgs',
    'ChannelEndpointDashPackageRequestArgsTimeshiftArgsDict',
    'ChannelEndpointDashPackageStreamSelectionArgs',
    'ChannelEndpointDashPackageStreamSelectionArgsDict',
    'ChannelEndpointHlsPackageArgs',
    'ChannelEndpointHlsPackageArgsDict',
    'ChannelEndpointHlsPackageEncryptionArgs',
    'ChannelEndpointHlsPackageEncryptionArgsDict',
    'ChannelEndpointHlsPackageEncryptionHttpHeaderArgs',
    'ChannelEndpointHlsPackageEncryptionHttpHeaderArgsDict',
    'ChannelEndpointHlsPackageRequestArgsArgs',
    'ChannelEndpointHlsPackageRequestArgsArgsDict',
    'ChannelEndpointHlsPackageRequestArgsLifeArgs',
    'ChannelEndpointHlsPackageRequestArgsLifeArgsDict',
    'ChannelEndpointHlsPackageRequestArgsRecordArgs',
    'ChannelEndpointHlsPackageRequestArgsRecordArgsDict',
    'ChannelEndpointHlsPackageRequestArgsTimeshiftArgs',
    'ChannelEndpointHlsPackageRequestArgsTimeshiftArgsDict',
    'ChannelEndpointHlsPackageStreamSelectionArgs',
    'ChannelEndpointHlsPackageStreamSelectionArgsDict',
    'ChannelEndpointMssPackageArgs',
    'ChannelEndpointMssPackageArgsDict',
    'ChannelEndpointMssPackageEncryptionArgs',
    'ChannelEndpointMssPackageEncryptionArgsDict',
    'ChannelEndpointMssPackageEncryptionHttpHeaderArgs',
    'ChannelEndpointMssPackageEncryptionHttpHeaderArgsDict',
    'ChannelEndpointMssPackageRequestArgsArgs',
    'ChannelEndpointMssPackageRequestArgsArgsDict',
    'ChannelEndpointMssPackageRequestArgsLifeArgs',
    'ChannelEndpointMssPackageRequestArgsLifeArgsDict',
    'ChannelEndpointMssPackageRequestArgsRecordArgs',
    'ChannelEndpointMssPackageRequestArgsRecordArgsDict',
    'ChannelEndpointMssPackageRequestArgsTimeshiftArgs',
    'ChannelEndpointMssPackageRequestArgsTimeshiftArgsDict',
    'ChannelEndpointMssPackageStreamSelectionArgs',
    'ChannelEndpointMssPackageStreamSelectionArgsDict',
    'ChannelInputArgs',
    'ChannelInputArgsDict',
    'ChannelInputAudioSelectorArgs',
    'ChannelInputAudioSelectorArgsDict',
    'ChannelInputAudioSelectorSelectorSettingsArgs',
    'ChannelInputAudioSelectorSelectorSettingsArgsDict',
    'ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgs',
    'ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgsDict',
    'ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgs',
    'ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgsDict',
    'ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgs',
    'ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgsDict',
    'ChannelInputFailoverConditionsArgs',
    'ChannelInputFailoverConditionsArgsDict',
    'ChannelInputSecondarySourceArgs',
    'ChannelInputSecondarySourceArgsDict',
    'ChannelInputSourceArgs',
    'ChannelInputSourceArgsDict',
    'ChannelRecordSettingsArgs',
    'ChannelRecordSettingsArgsDict',
    'HlsConfigurationApplicationArgs',
    'HlsConfigurationApplicationArgsDict',
    'HttpsCertificateGmCertificateArgs',
    'HttpsCertificateGmCertificateArgsDict',
    'HttpsCertificateTlsCertificateArgs',
    'HttpsCertificateTlsCertificateArgsDict',
    'RecordingFlvArgs',
    'RecordingFlvArgsDict',
    'RecordingHlsArgs',
    'RecordingHlsArgsDict',
    'RecordingMp4Args',
    'RecordingMp4ArgsDict',
    'RecordingObsArgs',
    'RecordingObsArgsDict',
    'TranscodingTemplateArgs',
    'TranscodingTemplateArgsDict',
]

MYPY = False

if not MYPY:
    class ChannelEncoderSettingArgsDict(TypedDict):
        template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the transcoding template ID.
        """
elif False:
    ChannelEncoderSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEncoderSettingArgs:
    def __init__(__self__, *,
                 template_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] template_id: Specifies the transcoding template ID.
        """
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the transcoding template ID.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class ChannelEncoderSettingsExpandArgsDict(TypedDict):
        audio_descriptions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsExpandAudioDescriptionArgsDict']]]]
        """
        Specifies the description of the audio output configuration.
        The audio_descriptions structure is documented below.

        <a name="LiveChannel_AudioDescriptions"></a>
        The `audio_descriptions` block supports:
        """
elif False:
    ChannelEncoderSettingsExpandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEncoderSettingsExpandArgs:
    def __init__(__self__, *,
                 audio_descriptions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsExpandAudioDescriptionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsExpandAudioDescriptionArgs']]] audio_descriptions: Specifies the description of the audio output configuration.
               The audio_descriptions structure is documented below.
               
               <a name="LiveChannel_AudioDescriptions"></a>
               The `audio_descriptions` block supports:
        """
        if audio_descriptions is not None:
            pulumi.set(__self__, "audio_descriptions", audio_descriptions)

    @_builtins.property
    @pulumi.getter(name="audioDescriptions")
    def audio_descriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsExpandAudioDescriptionArgs']]]]:
        """
        Specifies the description of the audio output configuration.
        The audio_descriptions structure is documented below.

        <a name="LiveChannel_AudioDescriptions"></a>
        The `audio_descriptions` block supports:
        """
        return pulumi.get(self, "audio_descriptions")

    @audio_descriptions.setter
    def audio_descriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEncoderSettingsExpandAudioDescriptionArgs']]]]):
        pulumi.set(self, "audio_descriptions", value)


if not MYPY:
    class ChannelEncoderSettingsExpandAudioDescriptionArgsDict(TypedDict):
        audio_selector_name: pulumi.Input[_builtins.str]
        """
        Specifies the audio selector name.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the language code. The value could be `2` or `3` lowercase letters.
        """
        language_code_control: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the language code control configuration.
        The settings here will not change the actual language of the audio, but only the language in which the audio is
        displayed externally. Valid values are:
        + **FOLLOW_INPUT**: If the output audio corresponding to the selected audio selector has a language, it will be
        consistent with it, otherwise it will be backed up by the language code and stream name configured here.
        The current option is recommended and is the default value.
        + **USE_CONFIGURED**: Users can customize the language and stream name of the output audio based on actual conditions.
        """
        stream_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the stream name.

        <a name="LiveChannel_EncoderSettings"></a>
        The `encoder_settings` block supports:
        """
elif False:
    ChannelEncoderSettingsExpandAudioDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEncoderSettingsExpandAudioDescriptionArgs:
    def __init__(__self__, *,
                 audio_selector_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 language_code_control: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_selector_name: Specifies the audio selector name.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param pulumi.Input[_builtins.str] language_code: Specifies the language code. The value could be `2` or `3` lowercase letters.
        :param pulumi.Input[_builtins.str] language_code_control: Specifies the language code control configuration.
               The settings here will not change the actual language of the audio, but only the language in which the audio is
               displayed externally. Valid values are:
               + **FOLLOW_INPUT**: If the output audio corresponding to the selected audio selector has a language, it will be
               consistent with it, otherwise it will be backed up by the language code and stream name configured here.
               The current option is recommended and is the default value.
               + **USE_CONFIGURED**: Users can customize the language and stream name of the output audio based on actual conditions.
        :param pulumi.Input[_builtins.str] stream_name: Specifies the stream name.
               
               <a name="LiveChannel_EncoderSettings"></a>
               The `encoder_settings` block supports:
        """
        pulumi.set(__self__, "audio_selector_name", audio_selector_name)
        pulumi.set(__self__, "name", name)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if language_code_control is not None:
            pulumi.set(__self__, "language_code_control", language_code_control)
        if stream_name is not None:
            pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the audio selector name.
        """
        return pulumi.get(self, "audio_selector_name")

    @audio_selector_name.setter
    def audio_selector_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_selector_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the language code. The value could be `2` or `3` lowercase letters.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter(name="languageCodeControl")
    def language_code_control(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the language code control configuration.
        The settings here will not change the actual language of the audio, but only the language in which the audio is
        displayed externally. Valid values are:
        + **FOLLOW_INPUT**: If the output audio corresponding to the selected audio selector has a language, it will be
        consistent with it, otherwise it will be backed up by the language code and stream name configured here.
        The current option is recommended and is the default value.
        + **USE_CONFIGURED**: Users can customize the language and stream name of the output audio based on actual conditions.
        """
        return pulumi.get(self, "language_code_control")

    @language_code_control.setter
    def language_code_control(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language_code_control", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the stream name.

        <a name="LiveChannel_EncoderSettings"></a>
        The `encoder_settings` block supports:
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class ChannelEndpointArgsDict(TypedDict):
        dash_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageArgsDict']]]]
        """
        Specifies the DASH packaging information.
        The dash_package structure is documented below.
        """
        hls_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageArgsDict']]]]
        """
        Specifies the HLS packaging information.
        The hls_package structure is documented below.
        """
        mss_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageArgsDict']]]]
        """
        Specifies the MSS packaging information.
        The mss_package structure is documented below.

        <a name="LiveChannel_HlsPackage"></a>
        The `hls_package` block supports:
        """
elif False:
    ChannelEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointArgs:
    def __init__(__self__, *,
                 dash_packages: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageArgs']]]] = None,
                 hls_packages: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageArgs']]]] = None,
                 mss_packages: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageArgs']]] dash_packages: Specifies the DASH packaging information.
               The dash_package structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageArgs']]] hls_packages: Specifies the HLS packaging information.
               The hls_package structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageArgs']]] mss_packages: Specifies the MSS packaging information.
               The mss_package structure is documented below.
               
               <a name="LiveChannel_HlsPackage"></a>
               The `hls_package` block supports:
        """
        if dash_packages is not None:
            pulumi.set(__self__, "dash_packages", dash_packages)
        if hls_packages is not None:
            pulumi.set(__self__, "hls_packages", hls_packages)
        if mss_packages is not None:
            pulumi.set(__self__, "mss_packages", mss_packages)

    @_builtins.property
    @pulumi.getter(name="dashPackages")
    def dash_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageArgs']]]]:
        """
        Specifies the DASH packaging information.
        The dash_package structure is documented below.
        """
        return pulumi.get(self, "dash_packages")

    @dash_packages.setter
    def dash_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageArgs']]]]):
        pulumi.set(self, "dash_packages", value)

    @_builtins.property
    @pulumi.getter(name="hlsPackages")
    def hls_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageArgs']]]]:
        """
        Specifies the HLS packaging information.
        The hls_package structure is documented below.
        """
        return pulumi.get(self, "hls_packages")

    @hls_packages.setter
    def hls_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageArgs']]]]):
        pulumi.set(self, "hls_packages", value)

    @_builtins.property
    @pulumi.getter(name="mssPackages")
    def mss_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageArgs']]]]:
        """
        Specifies the MSS packaging information.
        The mss_package structure is documented below.

        <a name="LiveChannel_HlsPackage"></a>
        The `hls_package` block supports:
        """
        return pulumi.get(self, "mss_packages")

    @mss_packages.setter
    def mss_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageArgs']]]]):
        pulumi.set(self, "mss_packages", value)


if not MYPY:
    class ChannelEndpointDashPackageArgsDict(TypedDict):
        segment_duration_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        url: pulumi.Input[_builtins.str]
        """
        Specifies the DRM address of the key.
        """
        ad_marker: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the advertising marker. The DASH value is **xml+bin**.

        <a name="LiveChannel_MssPackage"></a>
        The `mss_package` block supports:
        """
        encryption: NotRequired[pulumi.Input['ChannelEndpointDashPackageEncryptionArgsDict']]
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        playlist_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        request_args: NotRequired[pulumi.Input['ChannelEndpointDashPackageRequestArgsArgsDict']]
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        stream_selections: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageStreamSelectionArgsDict']]]]
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
elif False:
    ChannelEndpointDashPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageArgs:
    def __init__(__self__, *,
                 segment_duration_seconds: pulumi.Input[_builtins.int],
                 url: pulumi.Input[_builtins.str],
                 ad_marker: Optional[pulumi.Input[_builtins.str]] = None,
                 encryption: Optional[pulumi.Input['ChannelEndpointDashPackageEncryptionArgs']] = None,
                 playlist_window_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 request_args: Optional[pulumi.Input['ChannelEndpointDashPackageRequestArgsArgs']] = None,
                 stream_selections: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageStreamSelectionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] segment_duration_seconds: Specifies the duration of the channel output segment. The unit is second.
               Value ranges from `1` to `10`.
               
               > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
               modify with caution!
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[_builtins.str] ad_marker: Specifies the advertising marker. The DASH value is **xml+bin**.
               
               <a name="LiveChannel_MssPackage"></a>
               The `mss_package` block supports:
        :param pulumi.Input['ChannelEndpointDashPackageEncryptionArgs'] encryption: Specifies the encrypted information.
               The encryption structure is documented below.
        :param pulumi.Input[_builtins.int] playlist_window_seconds: Specifies the window length of the channel live broadcast return shard.
               The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
               The unit is second. Value ranges from `0` to `86,400`.
        :param pulumi.Input['ChannelEndpointDashPackageRequestArgsArgs'] request_args: Specifies the play related configuration.
               The request_args structure is documented below.
               
               <a name="LiveChannel_StreamSelection"></a>
               The `stream_selection` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageStreamSelectionArgs']]] stream_selections: Specifies the stream selection. Filter out the specified range of streams from
               the full stream.
               The stream_selection structure is documented below.
        """
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "url", url)
        if ad_marker is not None:
            pulumi.set(__self__, "ad_marker", ad_marker)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if playlist_window_seconds is not None:
            pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        if request_args is not None:
            pulumi.set(__self__, "request_args", request_args)
        if stream_selections is not None:
            pulumi.set(__self__, "stream_selections", stream_selections)

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        return pulumi.get(self, "segment_duration_seconds")

    @segment_duration_seconds.setter
    def segment_duration_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "segment_duration_seconds", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="adMarker")
    def ad_marker(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the advertising marker. The DASH value is **xml+bin**.

        <a name="LiveChannel_MssPackage"></a>
        The `mss_package` block supports:
        """
        return pulumi.get(self, "ad_marker")

    @ad_marker.setter
    def ad_marker(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ad_marker", value)

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['ChannelEndpointDashPackageEncryptionArgs']]:
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['ChannelEndpointDashPackageEncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @playlist_window_seconds.setter
    def playlist_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "playlist_window_seconds", value)

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Optional[pulumi.Input['ChannelEndpointDashPackageRequestArgsArgs']]:
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        return pulumi.get(self, "request_args")

    @request_args.setter
    def request_args(self, value: Optional[pulumi.Input['ChannelEndpointDashPackageRequestArgsArgs']]):
        pulumi.set(self, "request_args", value)

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageStreamSelectionArgs']]]]:
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")

    @stream_selections.setter
    def stream_selections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageStreamSelectionArgs']]]]):
        pulumi.set(self, "stream_selections", value)


if not MYPY:
    class ChannelEndpointDashPackageEncryptionArgsDict(TypedDict):
        request_mode: pulumi.Input[_builtins.str]
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        Specifies the customer-generated DRM content ID.
        """
        speke_version: pulumi.Input[_builtins.str]
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        system_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        url: pulumi.Input[_builtins.str]
        """
        Specifies the DRM address of the key.
        """
        encryption_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Internal; Specifies the encryption method.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageEncryptionHttpHeaderArgsDict']]]]
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        key_rotation_interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        urn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
elif False:
    ChannelEndpointDashPackageEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageEncryptionArgs:
    def __init__(__self__, *,
                 request_mode: pulumi.Input[_builtins.str],
                 resource_id: pulumi.Input[_builtins.str],
                 speke_version: pulumi.Input[_builtins.str],
                 system_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 url: pulumi.Input[_builtins.str],
                 encryption_method: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageEncryptionHttpHeaderArgs']]]] = None,
                 key_rotation_interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None,
                 urn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] request_mode: Specifies the request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param pulumi.Input[_builtins.str] resource_id: Specifies the customer-generated DRM content ID.
        :param pulumi.Input[_builtins.str] speke_version: Specifies the DRM spec version number. Currently, only supports **1.0**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] system_ids: Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[_builtins.str] encryption_method: schema: Internal; Specifies the encryption method.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageEncryptionHttpHeaderArgs']]] http_headers: Specifies the authentication information that needs to be added to the DRM request header.
               Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
               The http_headers structure is documented below.
        :param pulumi.Input[_builtins.int] key_rotation_interval_seconds: schema: Internal; Specifies the key rotation interval seconds.
        :param pulumi.Input[_builtins.str] level: Specifies the level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
               
               Defaults to **content**.
        :param pulumi.Input[_builtins.str] urn: Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
               the function graph's urn to be provided.
               
               <a name="LiveChannel_HttpHeader"></a>
               The `http_headers` block supports:
        """
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        if encryption_method is not None:
            pulumi.set(__self__, "encryption_method", encryption_method)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if key_rotation_interval_seconds is not None:
            pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @request_mode.setter
    def request_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_mode", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        return pulumi.get(self, "speke_version")

    @speke_version.setter
    def speke_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "speke_version", value)

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @system_ids.setter
    def system_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "system_ids", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Internal; Specifies the encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @encryption_method.setter
    def encryption_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_method", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageEncryptionHttpHeaderArgs']]]]:
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageEncryptionHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @key_rotation_interval_seconds.setter
    def key_rotation_interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_seconds", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
        return pulumi.get(self, "urn")

    @urn.setter
    def urn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "urn", value)


if not MYPY:
    class ChannelEndpointDashPackageEncryptionHttpHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key field name in the request header.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
elif False:
    ChannelEndpointDashPackageEncryptionHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageEncryptionHttpHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key field name in the request header.
        :param pulumi.Input[_builtins.str] value: Specifies the value corresponding to the key in the request header.
               
               <a name="LiveChannel_RequestArgs"></a>
               The `request_args` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ChannelEndpointDashPackageRequestArgsArgsDict(TypedDict):
        lives: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsLifeArgsDict']]]]
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsRecordArgsDict']]]]
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        timeshifts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsTimeshiftArgsDict']]]]
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
elif False:
    ChannelEndpointDashPackageRequestArgsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageRequestArgsArgs:
    def __init__(__self__, *,
                 lives: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsLifeArgs']]]] = None,
                 records: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsRecordArgs']]]] = None,
                 timeshifts: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsTimeshiftArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsLifeArgs']]] lives: Specifies the live broadcast configuration.
               The live structure is documented below.
               
               <a name="LiveChannel_RequestArgsRecord"></a>
               The `record` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsRecordArgs']]] records: Specifies the recording and playback related configuration.
               The record structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsTimeshiftArgs']]] timeshifts: Specifies the time-shift playback configuration.
               The timeshift structure is documented below.
        """
        if lives is not None:
            pulumi.set(__self__, "lives", lives)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if timeshifts is not None:
            pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsLifeArgs']]]]:
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        return pulumi.get(self, "lives")

    @lives.setter
    def lives(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsLifeArgs']]]]):
        pulumi.set(self, "lives", value)

    @_builtins.property
    @pulumi.getter
    def records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsRecordArgs']]]]:
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @records.setter
    def records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsRecordArgs']]]]):
        pulumi.set(self, "records", value)

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsTimeshiftArgs']]]]:
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")

    @timeshifts.setter
    def timeshifts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointDashPackageRequestArgsTimeshiftArgs']]]]):
        pulumi.set(self, "timeshifts", value)


if not MYPY:
    class ChannelEndpointDashPackageRequestArgsLifeArgsDict(TypedDict):
        delay: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the delay field.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointDashPackageRequestArgsLifeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageRequestArgsLifeArgs:
    def __init__(__self__, *,
                 delay: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delay: Specifies the delay field.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the delay field.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delay", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointDashPackageRequestArgsRecordArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the end time.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the format.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the start time.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointDashPackageRequestArgsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageRequestArgsRecordArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time.
        :param pulumi.Input[_builtins.str] format: Specifies the format.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the end time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointDashPackageRequestArgsTimeshiftArgsDict(TypedDict):
        back_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time shift duration field name.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointDashPackageRequestArgsTimeshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageRequestArgsTimeshiftArgs:
    def __init__(__self__, *,
                 back_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] back_time: Specifies the time shift duration field name.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if back_time is not None:
            pulumi.set(__self__, "back_time", back_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @back_time.setter
    def back_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "back_time", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointDashPackageStreamSelectionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the key field name in the request header.
        """
        max_bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        min_bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
elif False:
    ChannelEndpointDashPackageStreamSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointDashPackageStreamSelectionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key field name in the request header.
        :param pulumi.Input[_builtins.int] max_bandwidth: Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        :param pulumi.Input[_builtins.int] min_bandwidth: Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
               
               <a name="LiveChannel_Encryption"></a>
               The `encryption` block supports:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "max_bandwidth")

    @max_bandwidth.setter
    def max_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
        return pulumi.get(self, "min_bandwidth")

    @min_bandwidth.setter
    def min_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bandwidth", value)


if not MYPY:
    class ChannelEndpointHlsPackageArgsDict(TypedDict):
        segment_duration_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        url: pulumi.Input[_builtins.str]
        """
        Specifies the DRM address of the key.
        """
        ad_markers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the advertising marker. The DASH value is **xml+bin**.

        <a name="LiveChannel_MssPackage"></a>
        The `mss_package` block supports:
        """
        encryption: NotRequired[pulumi.Input['ChannelEndpointHlsPackageEncryptionArgsDict']]
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        hls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HLS version.
        """
        playlist_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        request_args: NotRequired[pulumi.Input['ChannelEndpointHlsPackageRequestArgsArgsDict']]
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        stream_selections: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageStreamSelectionArgsDict']]]]
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
elif False:
    ChannelEndpointHlsPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageArgs:
    def __init__(__self__, *,
                 segment_duration_seconds: pulumi.Input[_builtins.int],
                 url: pulumi.Input[_builtins.str],
                 ad_markers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 encryption: Optional[pulumi.Input['ChannelEndpointHlsPackageEncryptionArgs']] = None,
                 hls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 playlist_window_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 request_args: Optional[pulumi.Input['ChannelEndpointHlsPackageRequestArgsArgs']] = None,
                 stream_selections: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageStreamSelectionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] segment_duration_seconds: Specifies the duration of the channel output segment. The unit is second.
               Value ranges from `1` to `10`.
               
               > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
               modify with caution!
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ad_markers: Specifies the advertising marker. The DASH value is **xml+bin**.
               
               <a name="LiveChannel_MssPackage"></a>
               The `mss_package` block supports:
        :param pulumi.Input['ChannelEndpointHlsPackageEncryptionArgs'] encryption: Specifies the encrypted information.
               The encryption structure is documented below.
        :param pulumi.Input[_builtins.str] hls_version: Specifies the HLS version.
        :param pulumi.Input[_builtins.int] playlist_window_seconds: Specifies the window length of the channel live broadcast return shard.
               The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
               The unit is second. Value ranges from `0` to `86,400`.
        :param pulumi.Input['ChannelEndpointHlsPackageRequestArgsArgs'] request_args: Specifies the play related configuration.
               The request_args structure is documented below.
               
               <a name="LiveChannel_StreamSelection"></a>
               The `stream_selection` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageStreamSelectionArgs']]] stream_selections: Specifies the stream selection. Filter out the specified range of streams from
               the full stream.
               The stream_selection structure is documented below.
        """
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "url", url)
        if ad_markers is not None:
            pulumi.set(__self__, "ad_markers", ad_markers)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if hls_version is not None:
            pulumi.set(__self__, "hls_version", hls_version)
        if playlist_window_seconds is not None:
            pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        if request_args is not None:
            pulumi.set(__self__, "request_args", request_args)
        if stream_selections is not None:
            pulumi.set(__self__, "stream_selections", stream_selections)

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        return pulumi.get(self, "segment_duration_seconds")

    @segment_duration_seconds.setter
    def segment_duration_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "segment_duration_seconds", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the advertising marker. The DASH value is **xml+bin**.

        <a name="LiveChannel_MssPackage"></a>
        The `mss_package` block supports:
        """
        return pulumi.get(self, "ad_markers")

    @ad_markers.setter
    def ad_markers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ad_markers", value)

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['ChannelEndpointHlsPackageEncryptionArgs']]:
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['ChannelEndpointHlsPackageEncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @_builtins.property
    @pulumi.getter(name="hlsVersion")
    def hls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HLS version.
        """
        return pulumi.get(self, "hls_version")

    @hls_version.setter
    def hls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hls_version", value)

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @playlist_window_seconds.setter
    def playlist_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "playlist_window_seconds", value)

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Optional[pulumi.Input['ChannelEndpointHlsPackageRequestArgsArgs']]:
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        return pulumi.get(self, "request_args")

    @request_args.setter
    def request_args(self, value: Optional[pulumi.Input['ChannelEndpointHlsPackageRequestArgsArgs']]):
        pulumi.set(self, "request_args", value)

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageStreamSelectionArgs']]]]:
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")

    @stream_selections.setter
    def stream_selections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageStreamSelectionArgs']]]]):
        pulumi.set(self, "stream_selections", value)


if not MYPY:
    class ChannelEndpointHlsPackageEncryptionArgsDict(TypedDict):
        request_mode: pulumi.Input[_builtins.str]
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        Specifies the customer-generated DRM content ID.
        """
        speke_version: pulumi.Input[_builtins.str]
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        system_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        url: pulumi.Input[_builtins.str]
        """
        Specifies the DRM address of the key.
        """
        encryption_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Internal; Specifies the encryption method.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageEncryptionHttpHeaderArgsDict']]]]
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        key_rotation_interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        urn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
elif False:
    ChannelEndpointHlsPackageEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageEncryptionArgs:
    def __init__(__self__, *,
                 request_mode: pulumi.Input[_builtins.str],
                 resource_id: pulumi.Input[_builtins.str],
                 speke_version: pulumi.Input[_builtins.str],
                 system_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 url: pulumi.Input[_builtins.str],
                 encryption_method: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageEncryptionHttpHeaderArgs']]]] = None,
                 key_rotation_interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None,
                 urn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] request_mode: Specifies the request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param pulumi.Input[_builtins.str] resource_id: Specifies the customer-generated DRM content ID.
        :param pulumi.Input[_builtins.str] speke_version: Specifies the DRM spec version number. Currently, only supports **1.0**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] system_ids: Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[_builtins.str] encryption_method: schema: Internal; Specifies the encryption method.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageEncryptionHttpHeaderArgs']]] http_headers: Specifies the authentication information that needs to be added to the DRM request header.
               Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
               The http_headers structure is documented below.
        :param pulumi.Input[_builtins.int] key_rotation_interval_seconds: schema: Internal; Specifies the key rotation interval seconds.
        :param pulumi.Input[_builtins.str] level: Specifies the level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
               
               Defaults to **content**.
        :param pulumi.Input[_builtins.str] urn: Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
               the function graph's urn to be provided.
               
               <a name="LiveChannel_HttpHeader"></a>
               The `http_headers` block supports:
        """
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        if encryption_method is not None:
            pulumi.set(__self__, "encryption_method", encryption_method)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if key_rotation_interval_seconds is not None:
            pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @request_mode.setter
    def request_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_mode", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        return pulumi.get(self, "speke_version")

    @speke_version.setter
    def speke_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "speke_version", value)

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @system_ids.setter
    def system_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "system_ids", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Internal; Specifies the encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @encryption_method.setter
    def encryption_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_method", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageEncryptionHttpHeaderArgs']]]]:
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageEncryptionHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @key_rotation_interval_seconds.setter
    def key_rotation_interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_seconds", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
        return pulumi.get(self, "urn")

    @urn.setter
    def urn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "urn", value)


if not MYPY:
    class ChannelEndpointHlsPackageEncryptionHttpHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key field name in the request header.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
elif False:
    ChannelEndpointHlsPackageEncryptionHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageEncryptionHttpHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key field name in the request header.
        :param pulumi.Input[_builtins.str] value: Specifies the value corresponding to the key in the request header.
               
               <a name="LiveChannel_RequestArgs"></a>
               The `request_args` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ChannelEndpointHlsPackageRequestArgsArgsDict(TypedDict):
        lives: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsLifeArgsDict']]]]
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsRecordArgsDict']]]]
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        timeshifts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsTimeshiftArgsDict']]]]
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
elif False:
    ChannelEndpointHlsPackageRequestArgsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageRequestArgsArgs:
    def __init__(__self__, *,
                 lives: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsLifeArgs']]]] = None,
                 records: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsRecordArgs']]]] = None,
                 timeshifts: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsTimeshiftArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsLifeArgs']]] lives: Specifies the live broadcast configuration.
               The live structure is documented below.
               
               <a name="LiveChannel_RequestArgsRecord"></a>
               The `record` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsRecordArgs']]] records: Specifies the recording and playback related configuration.
               The record structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsTimeshiftArgs']]] timeshifts: Specifies the time-shift playback configuration.
               The timeshift structure is documented below.
        """
        if lives is not None:
            pulumi.set(__self__, "lives", lives)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if timeshifts is not None:
            pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsLifeArgs']]]]:
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        return pulumi.get(self, "lives")

    @lives.setter
    def lives(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsLifeArgs']]]]):
        pulumi.set(self, "lives", value)

    @_builtins.property
    @pulumi.getter
    def records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsRecordArgs']]]]:
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @records.setter
    def records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsRecordArgs']]]]):
        pulumi.set(self, "records", value)

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsTimeshiftArgs']]]]:
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")

    @timeshifts.setter
    def timeshifts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointHlsPackageRequestArgsTimeshiftArgs']]]]):
        pulumi.set(self, "timeshifts", value)


if not MYPY:
    class ChannelEndpointHlsPackageRequestArgsLifeArgsDict(TypedDict):
        delay: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the delay field.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointHlsPackageRequestArgsLifeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageRequestArgsLifeArgs:
    def __init__(__self__, *,
                 delay: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delay: Specifies the delay field.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the delay field.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delay", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointHlsPackageRequestArgsRecordArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the end time.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the format.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the start time.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointHlsPackageRequestArgsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageRequestArgsRecordArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time.
        :param pulumi.Input[_builtins.str] format: Specifies the format.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the end time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointHlsPackageRequestArgsTimeshiftArgsDict(TypedDict):
        back_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time shift duration field name.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointHlsPackageRequestArgsTimeshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageRequestArgsTimeshiftArgs:
    def __init__(__self__, *,
                 back_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] back_time: Specifies the time shift duration field name.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if back_time is not None:
            pulumi.set(__self__, "back_time", back_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @back_time.setter
    def back_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "back_time", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointHlsPackageStreamSelectionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the key field name in the request header.
        """
        max_bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        min_bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
elif False:
    ChannelEndpointHlsPackageStreamSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointHlsPackageStreamSelectionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key field name in the request header.
        :param pulumi.Input[_builtins.int] max_bandwidth: Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        :param pulumi.Input[_builtins.int] min_bandwidth: Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
               
               <a name="LiveChannel_Encryption"></a>
               The `encryption` block supports:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "max_bandwidth")

    @max_bandwidth.setter
    def max_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
        return pulumi.get(self, "min_bandwidth")

    @min_bandwidth.setter
    def min_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bandwidth", value)


if not MYPY:
    class ChannelEndpointMssPackageArgsDict(TypedDict):
        segment_duration_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        url: pulumi.Input[_builtins.str]
        """
        Specifies the DRM address of the key.
        """
        delay_segment: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the delayed playback time. The unit is second.
        """
        encryption: NotRequired[pulumi.Input['ChannelEndpointMssPackageEncryptionArgsDict']]
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        playlist_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        request_args: NotRequired[pulumi.Input['ChannelEndpointMssPackageRequestArgsArgsDict']]
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        stream_selections: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageStreamSelectionArgsDict']]]]
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
elif False:
    ChannelEndpointMssPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageArgs:
    def __init__(__self__, *,
                 segment_duration_seconds: pulumi.Input[_builtins.int],
                 url: pulumi.Input[_builtins.str],
                 delay_segment: Optional[pulumi.Input[_builtins.int]] = None,
                 encryption: Optional[pulumi.Input['ChannelEndpointMssPackageEncryptionArgs']] = None,
                 playlist_window_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 request_args: Optional[pulumi.Input['ChannelEndpointMssPackageRequestArgsArgs']] = None,
                 stream_selections: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageStreamSelectionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] segment_duration_seconds: Specifies the duration of the channel output segment. The unit is second.
               Value ranges from `1` to `10`.
               
               > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
               modify with caution!
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[_builtins.int] delay_segment: Specifies the delayed playback time. The unit is second.
        :param pulumi.Input['ChannelEndpointMssPackageEncryptionArgs'] encryption: Specifies the encrypted information.
               The encryption structure is documented below.
        :param pulumi.Input[_builtins.int] playlist_window_seconds: Specifies the window length of the channel live broadcast return shard.
               The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
               The unit is second. Value ranges from `0` to `86,400`.
        :param pulumi.Input['ChannelEndpointMssPackageRequestArgsArgs'] request_args: Specifies the play related configuration.
               The request_args structure is documented below.
               
               <a name="LiveChannel_StreamSelection"></a>
               The `stream_selection` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageStreamSelectionArgs']]] stream_selections: Specifies the stream selection. Filter out the specified range of streams from
               the full stream.
               The stream_selection structure is documented below.
        """
        pulumi.set(__self__, "segment_duration_seconds", segment_duration_seconds)
        pulumi.set(__self__, "url", url)
        if delay_segment is not None:
            pulumi.set(__self__, "delay_segment", delay_segment)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if playlist_window_seconds is not None:
            pulumi.set(__self__, "playlist_window_seconds", playlist_window_seconds)
        if request_args is not None:
            pulumi.set(__self__, "request_args", request_args)
        if stream_selections is not None:
            pulumi.set(__self__, "stream_selections", stream_selections)

    @_builtins.property
    @pulumi.getter(name="segmentDurationSeconds")
    def segment_duration_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the duration of the channel output segment. The unit is second.
        Value ranges from `1` to `10`.

        > Modifying the segment duration will affect the time-shift and playback services of the recorded content, so please
        modify with caution!
        """
        return pulumi.get(self, "segment_duration_seconds")

    @segment_duration_seconds.setter
    def segment_duration_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "segment_duration_seconds", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="delaySegment")
    def delay_segment(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the delayed playback time. The unit is second.
        """
        return pulumi.get(self, "delay_segment")

    @delay_segment.setter
    def delay_segment(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay_segment", value)

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['ChannelEndpointMssPackageEncryptionArgs']]:
        """
        Specifies the encrypted information.
        The encryption structure is documented below.
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['ChannelEndpointMssPackageEncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @_builtins.property
    @pulumi.getter(name="playlistWindowSeconds")
    def playlist_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the window length of the channel live broadcast return shard.
        The value is the output segment duration multiplied by the number of segments. There are at least three returned segments.
        The unit is second. Value ranges from `0` to `86,400`.
        """
        return pulumi.get(self, "playlist_window_seconds")

    @playlist_window_seconds.setter
    def playlist_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "playlist_window_seconds", value)

    @_builtins.property
    @pulumi.getter(name="requestArgs")
    def request_args(self) -> Optional[pulumi.Input['ChannelEndpointMssPackageRequestArgsArgs']]:
        """
        Specifies the play related configuration.
        The request_args structure is documented below.

        <a name="LiveChannel_StreamSelection"></a>
        The `stream_selection` block supports:
        """
        return pulumi.get(self, "request_args")

    @request_args.setter
    def request_args(self, value: Optional[pulumi.Input['ChannelEndpointMssPackageRequestArgsArgs']]):
        pulumi.set(self, "request_args", value)

    @_builtins.property
    @pulumi.getter(name="streamSelections")
    def stream_selections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageStreamSelectionArgs']]]]:
        """
        Specifies the stream selection. Filter out the specified range of streams from
        the full stream.
        The stream_selection structure is documented below.
        """
        return pulumi.get(self, "stream_selections")

    @stream_selections.setter
    def stream_selections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageStreamSelectionArgs']]]]):
        pulumi.set(self, "stream_selections", value)


if not MYPY:
    class ChannelEndpointMssPackageEncryptionArgsDict(TypedDict):
        request_mode: pulumi.Input[_builtins.str]
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        Specifies the customer-generated DRM content ID.
        """
        speke_version: pulumi.Input[_builtins.str]
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        system_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        url: pulumi.Input[_builtins.str]
        """
        Specifies the DRM address of the key.
        """
        encryption_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Internal; Specifies the encryption method.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageEncryptionHttpHeaderArgsDict']]]]
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        key_rotation_interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        urn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
elif False:
    ChannelEndpointMssPackageEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageEncryptionArgs:
    def __init__(__self__, *,
                 request_mode: pulumi.Input[_builtins.str],
                 resource_id: pulumi.Input[_builtins.str],
                 speke_version: pulumi.Input[_builtins.str],
                 system_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 url: pulumi.Input[_builtins.str],
                 encryption_method: Optional[pulumi.Input[_builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageEncryptionHttpHeaderArgs']]]] = None,
                 key_rotation_interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 level: Optional[pulumi.Input[_builtins.str]] = None,
                 urn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] request_mode: Specifies the request mode. Valid values are:
               + **direct_http**: HTTP(S) direct access to DRM.
               + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        :param pulumi.Input[_builtins.str] resource_id: Specifies the customer-generated DRM content ID.
        :param pulumi.Input[_builtins.str] speke_version: Specifies the DRM spec version number. Currently, only supports **1.0**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] system_ids: Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
               **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[_builtins.str] encryption_method: schema: Internal; Specifies the encryption method.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageEncryptionHttpHeaderArgs']]] http_headers: Specifies the authentication information that needs to be added to the DRM request header.
               Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
               The http_headers structure is documented below.
        :param pulumi.Input[_builtins.int] key_rotation_interval_seconds: schema: Internal; Specifies the key rotation interval seconds.
        :param pulumi.Input[_builtins.str] level: Specifies the level. Valid values are:
               + **content**: One channel corresponds to one key.
               + **profile**: One code rate corresponds to one key.
               
               Defaults to **content**.
        :param pulumi.Input[_builtins.str] urn: Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
               the function graph's urn to be provided.
               
               <a name="LiveChannel_HttpHeader"></a>
               The `http_headers` block supports:
        """
        pulumi.set(__self__, "request_mode", request_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "speke_version", speke_version)
        pulumi.set(__self__, "system_ids", system_ids)
        pulumi.set(__self__, "url", url)
        if encryption_method is not None:
            pulumi.set(__self__, "encryption_method", encryption_method)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if key_rotation_interval_seconds is not None:
            pulumi.set(__self__, "key_rotation_interval_seconds", key_rotation_interval_seconds)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if urn is not None:
            pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="requestMode")
    def request_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the request mode. Valid values are:
        + **direct_http**: HTTP(S) direct access to DRM.
        + **functiongraph_proxy**: FunctionGraph proxy access to DRM.
        """
        return pulumi.get(self, "request_mode")

    @request_mode.setter
    def request_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_mode", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the customer-generated DRM content ID.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="spekeVersion")
    def speke_version(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM spec version number. Currently, only supports **1.0**.
        """
        return pulumi.get(self, "speke_version")

    @speke_version.setter
    def speke_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "speke_version", value)

    @_builtins.property
    @pulumi.getter(name="systemIds")
    def system_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the system ID enumeration values. Valid values are **FairPlay** (HLS),
        **Widevine** (DASH), **PlayReady** (DASH), and **PlayReady** (MSS).
        """
        return pulumi.get(self, "system_ids")

    @system_ids.setter
    def system_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "system_ids", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="encryptionMethod")
    def encryption_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Internal; Specifies the encryption method.
        """
        return pulumi.get(self, "encryption_method")

    @encryption_method.setter
    def encryption_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_method", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageEncryptionHttpHeaderArgs']]]]:
        """
        Specifies the authentication information that needs to be added to the DRM request header.
        Supports up to `5` configurations. Only the **direct_http** request mode supports configuring this field.
        The http_headers structure is documented below.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageEncryptionHttpHeaderArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter(name="keyRotationIntervalSeconds")
    def key_rotation_interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Internal; Specifies the key rotation interval seconds.
        """
        return pulumi.get(self, "key_rotation_interval_seconds")

    @key_rotation_interval_seconds.setter
    def key_rotation_interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "key_rotation_interval_seconds", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the level. Valid values are:
        + **content**: One channel corresponds to one key.
        + **profile**: One code rate corresponds to one key.

        Defaults to **content**.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "level", value)

    @_builtins.property
    @pulumi.getter
    def urn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URN of the function graph. The **functiongraph_proxy** request mode requires
        the function graph's urn to be provided.

        <a name="LiveChannel_HttpHeader"></a>
        The `http_headers` block supports:
        """
        return pulumi.get(self, "urn")

    @urn.setter
    def urn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "urn", value)


if not MYPY:
    class ChannelEndpointMssPackageEncryptionHttpHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key field name in the request header.
        """
        value: pulumi.Input[_builtins.str]
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
elif False:
    ChannelEndpointMssPackageEncryptionHttpHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageEncryptionHttpHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key field name in the request header.
        :param pulumi.Input[_builtins.str] value: Specifies the value corresponding to the key in the request header.
               
               <a name="LiveChannel_RequestArgs"></a>
               The `request_args` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the value corresponding to the key in the request header.

        <a name="LiveChannel_RequestArgs"></a>
        The `request_args` block supports:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ChannelEndpointMssPackageRequestArgsArgsDict(TypedDict):
        lives: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsLifeArgsDict']]]]
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        records: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsRecordArgsDict']]]]
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        timeshifts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsTimeshiftArgsDict']]]]
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
elif False:
    ChannelEndpointMssPackageRequestArgsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageRequestArgsArgs:
    def __init__(__self__, *,
                 lives: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsLifeArgs']]]] = None,
                 records: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsRecordArgs']]]] = None,
                 timeshifts: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsTimeshiftArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsLifeArgs']]] lives: Specifies the live broadcast configuration.
               The live structure is documented below.
               
               <a name="LiveChannel_RequestArgsRecord"></a>
               The `record` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsRecordArgs']]] records: Specifies the recording and playback related configuration.
               The record structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsTimeshiftArgs']]] timeshifts: Specifies the time-shift playback configuration.
               The timeshift structure is documented below.
        """
        if lives is not None:
            pulumi.set(__self__, "lives", lives)
        if records is not None:
            pulumi.set(__self__, "records", records)
        if timeshifts is not None:
            pulumi.set(__self__, "timeshifts", timeshifts)

    @_builtins.property
    @pulumi.getter
    def lives(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsLifeArgs']]]]:
        """
        Specifies the live broadcast configuration.
        The live structure is documented below.

        <a name="LiveChannel_RequestArgsRecord"></a>
        The `record` block supports:
        """
        return pulumi.get(self, "lives")

    @lives.setter
    def lives(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsLifeArgs']]]]):
        pulumi.set(self, "lives", value)

    @_builtins.property
    @pulumi.getter
    def records(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsRecordArgs']]]]:
        """
        Specifies the recording and playback related configuration.
        The record structure is documented below.
        """
        return pulumi.get(self, "records")

    @records.setter
    def records(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsRecordArgs']]]]):
        pulumi.set(self, "records", value)

    @_builtins.property
    @pulumi.getter
    def timeshifts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsTimeshiftArgs']]]]:
        """
        Specifies the time-shift playback configuration.
        The timeshift structure is documented below.
        """
        return pulumi.get(self, "timeshifts")

    @timeshifts.setter
    def timeshifts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelEndpointMssPackageRequestArgsTimeshiftArgs']]]]):
        pulumi.set(self, "timeshifts", value)


if not MYPY:
    class ChannelEndpointMssPackageRequestArgsLifeArgsDict(TypedDict):
        delay: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the delay field.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointMssPackageRequestArgsLifeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageRequestArgsLifeArgs:
    def __init__(__self__, *,
                 delay: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delay: Specifies the delay field.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the delay field.
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delay", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointMssPackageRequestArgsRecordArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the end time.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the format.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the start time.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointMssPackageRequestArgsRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageRequestArgsRecordArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time.
        :param pulumi.Input[_builtins.str] format: Specifies the format.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the end time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointMssPackageRequestArgsTimeshiftArgsDict(TypedDict):
        back_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the time shift duration field name.
        """
        unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
elif False:
    ChannelEndpointMssPackageRequestArgsTimeshiftArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageRequestArgsTimeshiftArgs:
    def __init__(__self__, *,
                 back_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] back_time: Specifies the time shift duration field name.
        :param pulumi.Input[_builtins.str] unit: Specifies the unit.
               
               <a name="LiveChannel_EncoderSettingsExpand"></a>
               The `encoder_settings_expand` block supports:
        """
        if back_time is not None:
            pulumi.set(__self__, "back_time", back_time)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="backTime")
    def back_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the time shift duration field name.
        """
        return pulumi.get(self, "back_time")

    @back_time.setter
    def back_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "back_time", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the unit.

        <a name="LiveChannel_EncoderSettingsExpand"></a>
        The `encoder_settings_expand` block supports:
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ChannelEndpointMssPackageStreamSelectionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the key field name in the request header.
        """
        max_bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        min_bandwidth: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
elif False:
    ChannelEndpointMssPackageStreamSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelEndpointMssPackageStreamSelectionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 max_bandwidth: Optional[pulumi.Input[_builtins.int]] = None,
                 min_bandwidth: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Specifies the key field name in the request header.
        :param pulumi.Input[_builtins.int] max_bandwidth: Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        :param pulumi.Input[_builtins.int] min_bandwidth: Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
               
               <a name="LiveChannel_Encryption"></a>
               The `encryption` block supports:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if max_bandwidth is not None:
            pulumi.set(__self__, "max_bandwidth", max_bandwidth)
        if min_bandwidth is not None:
            pulumi.set(__self__, "min_bandwidth", min_bandwidth)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the key field name in the request header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="maxBandwidth")
    def max_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "max_bandwidth")

    @max_bandwidth.setter
    def max_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="minBandwidth")
    def min_bandwidth(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the minimum code rate. The unit is bps. Value ranges from `0` to `104,857,600`.

        <a name="LiveChannel_Encryption"></a>
        The `encryption` block supports:
        """
        return pulumi.get(self, "min_bandwidth")

    @min_bandwidth.setter
    def min_bandwidth(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_bandwidth", value)


if not MYPY:
    class ChannelInputArgsDict(TypedDict):
        input_protocol: pulumi.Input[_builtins.str]
        """
        Specifies the channel input protocol. Valid values are:
        + **FLV_PULL**.
        + **RTMP_PUSH**.
        + **HLS_PULL**.
        + **SRT_PULL**.
        + **SRT_PUSH**.

        Changing this parameter will create a new resource.
        """
        ad_triggers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the ad trigger configuration list. Valid Values are:
        + **Splice insert**.
        + **Provider advertisement**.
        + **Distributor advertisement**.
        + **Provider placement opportunity**.
        + **Distributor placement opportunity**.
        """
        audio_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelInputAudioSelectorArgsDict']]]]
        """
        Specifies the audio selector configuration. Set up to `8` audio selectors.
        The audio_selectors structure is documented below.

        <a name="LiveChannel_Sources"></a>
        The `sources` block supports:
        """
        failover_conditions: NotRequired[pulumi.Input['ChannelInputFailoverConditionsArgsDict']]
        """
        Specifies the configuration of switching between primary and backup audio
        and video stream URLs.
        The failover_conditions structure is documented below.
        """
        ip_port_mode: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies the IP port mode.

        > When the stream push protocol is **SRT_PUSH** and streams are pushed to the origin server, set this parameter
        to **true**.
        """
        ip_whitelist: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP whitelist when protocol is **SRT_PUSH**.
        """
        max_bandwidth_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum bandwidth that needs to be configured when the inbound
        protocol is **HLS_PULL**. The unit is **bps**.

        > In the streaming URL provided by the user, the bandwidth parameter "BANDWIDTH" will be carried for audio and video
        with different bit rates.<br/>1. If the maximum bandwidth is configured here, when the media live broadcast service
        pulls the stream from the URL, it will select the audio and video stream with a smaller bandwidth and the highest bit
        rate and push it to the source station.<br/>2. If the maximum bandwidth is not configured here, when the media live
        broadcast service pulls the stream from the URL, it will select the audio and video stream with the highest "BANDWIDTH"
        by default and push the stream to the source station.
        """
        scte35_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the advertisement scte35 signal source. This configuration is only
        supported for **HLS_PULL** channels, and currently only supports **SEGMENTS**.
        """
        secondary_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelInputSecondarySourceArgsDict']]]]
        """
        Specifies the prepared stream array. If this parameter is configured, ensure
        that the number of channels, codec, and resolution of the primary and standby input streams are the same.
        This field does not need to be configured when the stream input protocol is **RTMP_PUSH**.
        The secondary_sources structure is documented below.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ChannelInputSourceArgsDict']]]]
        """
        Specifies the channel main source stream information. This parameter is optional
        when the stream input protocol is **RTMP_PUSH** or **SRT_PUSH**. In other cases, this parameter is mandatory.
        The sources structure is documented below.
        """
elif False:
    ChannelInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputArgs:
    def __init__(__self__, *,
                 input_protocol: pulumi.Input[_builtins.str],
                 ad_triggers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 audio_selectors: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAudioSelectorArgs']]]] = None,
                 failover_conditions: Optional[pulumi.Input['ChannelInputFailoverConditionsArgs']] = None,
                 ip_port_mode: Optional[pulumi.Input[_builtins.bool]] = None,
                 ip_whitelist: Optional[pulumi.Input[_builtins.str]] = None,
                 max_bandwidth_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 scte35_source: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_sources: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputSecondarySourceArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputSourceArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] input_protocol: Specifies the channel input protocol. Valid values are:
               + **FLV_PULL**.
               + **RTMP_PUSH**.
               + **HLS_PULL**.
               + **SRT_PULL**.
               + **SRT_PUSH**.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ad_triggers: Specifies the ad trigger configuration list. Valid Values are:
               + **Splice insert**.
               + **Provider advertisement**.
               + **Distributor advertisement**.
               + **Provider placement opportunity**.
               + **Distributor placement opportunity**.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelInputAudioSelectorArgs']]] audio_selectors: Specifies the audio selector configuration. Set up to `8` audio selectors.
               The audio_selectors structure is documented below.
               
               <a name="LiveChannel_Sources"></a>
               The `sources` block supports:
        :param pulumi.Input['ChannelInputFailoverConditionsArgs'] failover_conditions: Specifies the configuration of switching between primary and backup audio
               and video stream URLs.
               The failover_conditions structure is documented below.
        :param pulumi.Input[_builtins.bool] ip_port_mode: Specifies the IP port mode.
               
               > When the stream push protocol is **SRT_PUSH** and streams are pushed to the origin server, set this parameter
               to **true**.
        :param pulumi.Input[_builtins.str] ip_whitelist: Specifies the IP whitelist when protocol is **SRT_PUSH**.
        :param pulumi.Input[_builtins.int] max_bandwidth_limit: Specifies the maximum bandwidth that needs to be configured when the inbound
               protocol is **HLS_PULL**. The unit is **bps**.
               
               > In the streaming URL provided by the user, the bandwidth parameter "BANDWIDTH" will be carried for audio and video
               with different bit rates.<br/>1. If the maximum bandwidth is configured here, when the media live broadcast service
               pulls the stream from the URL, it will select the audio and video stream with a smaller bandwidth and the highest bit
               rate and push it to the source station.<br/>2. If the maximum bandwidth is not configured here, when the media live
               broadcast service pulls the stream from the URL, it will select the audio and video stream with the highest "BANDWIDTH"
               by default and push the stream to the source station.
        :param pulumi.Input[_builtins.str] scte35_source: Specifies the advertisement scte35 signal source. This configuration is only
               supported for **HLS_PULL** channels, and currently only supports **SEGMENTS**.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelInputSecondarySourceArgs']]] secondary_sources: Specifies the prepared stream array. If this parameter is configured, ensure
               that the number of channels, codec, and resolution of the primary and standby input streams are the same.
               This field does not need to be configured when the stream input protocol is **RTMP_PUSH**.
               The secondary_sources structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelInputSourceArgs']]] sources: Specifies the channel main source stream information. This parameter is optional
               when the stream input protocol is **RTMP_PUSH** or **SRT_PUSH**. In other cases, this parameter is mandatory.
               The sources structure is documented below.
        """
        pulumi.set(__self__, "input_protocol", input_protocol)
        if ad_triggers is not None:
            pulumi.set(__self__, "ad_triggers", ad_triggers)
        if audio_selectors is not None:
            pulumi.set(__self__, "audio_selectors", audio_selectors)
        if failover_conditions is not None:
            pulumi.set(__self__, "failover_conditions", failover_conditions)
        if ip_port_mode is not None:
            pulumi.set(__self__, "ip_port_mode", ip_port_mode)
        if ip_whitelist is not None:
            pulumi.set(__self__, "ip_whitelist", ip_whitelist)
        if max_bandwidth_limit is not None:
            pulumi.set(__self__, "max_bandwidth_limit", max_bandwidth_limit)
        if scte35_source is not None:
            pulumi.set(__self__, "scte35_source", scte35_source)
        if secondary_sources is not None:
            pulumi.set(__self__, "secondary_sources", secondary_sources)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter(name="inputProtocol")
    def input_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the channel input protocol. Valid values are:
        + **FLV_PULL**.
        + **RTMP_PUSH**.
        + **HLS_PULL**.
        + **SRT_PULL**.
        + **SRT_PUSH**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "input_protocol")

    @input_protocol.setter
    def input_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_protocol", value)

    @_builtins.property
    @pulumi.getter(name="adTriggers")
    def ad_triggers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the ad trigger configuration list. Valid Values are:
        + **Splice insert**.
        + **Provider advertisement**.
        + **Distributor advertisement**.
        + **Provider placement opportunity**.
        + **Distributor placement opportunity**.
        """
        return pulumi.get(self, "ad_triggers")

    @ad_triggers.setter
    def ad_triggers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ad_triggers", value)

    @_builtins.property
    @pulumi.getter(name="audioSelectors")
    def audio_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAudioSelectorArgs']]]]:
        """
        Specifies the audio selector configuration. Set up to `8` audio selectors.
        The audio_selectors structure is documented below.

        <a name="LiveChannel_Sources"></a>
        The `sources` block supports:
        """
        return pulumi.get(self, "audio_selectors")

    @audio_selectors.setter
    def audio_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputAudioSelectorArgs']]]]):
        pulumi.set(self, "audio_selectors", value)

    @_builtins.property
    @pulumi.getter(name="failoverConditions")
    def failover_conditions(self) -> Optional[pulumi.Input['ChannelInputFailoverConditionsArgs']]:
        """
        Specifies the configuration of switching between primary and backup audio
        and video stream URLs.
        The failover_conditions structure is documented below.
        """
        return pulumi.get(self, "failover_conditions")

    @failover_conditions.setter
    def failover_conditions(self, value: Optional[pulumi.Input['ChannelInputFailoverConditionsArgs']]):
        pulumi.set(self, "failover_conditions", value)

    @_builtins.property
    @pulumi.getter(name="ipPortMode")
    def ip_port_mode(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies the IP port mode.

        > When the stream push protocol is **SRT_PUSH** and streams are pushed to the origin server, set this parameter
        to **true**.
        """
        return pulumi.get(self, "ip_port_mode")

    @ip_port_mode.setter
    def ip_port_mode(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ip_port_mode", value)

    @_builtins.property
    @pulumi.getter(name="ipWhitelist")
    def ip_whitelist(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP whitelist when protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "ip_whitelist")

    @ip_whitelist.setter
    def ip_whitelist(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_whitelist", value)

    @_builtins.property
    @pulumi.getter(name="maxBandwidthLimit")
    def max_bandwidth_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum bandwidth that needs to be configured when the inbound
        protocol is **HLS_PULL**. The unit is **bps**.

        > In the streaming URL provided by the user, the bandwidth parameter "BANDWIDTH" will be carried for audio and video
        with different bit rates.<br/>1. If the maximum bandwidth is configured here, when the media live broadcast service
        pulls the stream from the URL, it will select the audio and video stream with a smaller bandwidth and the highest bit
        rate and push it to the source station.<br/>2. If the maximum bandwidth is not configured here, when the media live
        broadcast service pulls the stream from the URL, it will select the audio and video stream with the highest "BANDWIDTH"
        by default and push the stream to the source station.
        """
        return pulumi.get(self, "max_bandwidth_limit")

    @max_bandwidth_limit.setter
    def max_bandwidth_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bandwidth_limit", value)

    @_builtins.property
    @pulumi.getter(name="scte35Source")
    def scte35_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the advertisement scte35 signal source. This configuration is only
        supported for **HLS_PULL** channels, and currently only supports **SEGMENTS**.
        """
        return pulumi.get(self, "scte35_source")

    @scte35_source.setter
    def scte35_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scte35_source", value)

    @_builtins.property
    @pulumi.getter(name="secondarySources")
    def secondary_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputSecondarySourceArgs']]]]:
        """
        Specifies the prepared stream array. If this parameter is configured, ensure
        that the number of channels, codec, and resolution of the primary and standby input streams are the same.
        This field does not need to be configured when the stream input protocol is **RTMP_PUSH**.
        The secondary_sources structure is documented below.
        """
        return pulumi.get(self, "secondary_sources")

    @secondary_sources.setter
    def secondary_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputSecondarySourceArgs']]]]):
        pulumi.set(self, "secondary_sources", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputSourceArgs']]]]:
        """
        Specifies the channel main source stream information. This parameter is optional
        when the stream input protocol is **RTMP_PUSH** or **SRT_PUSH**. In other cases, this parameter is mandatory.
        The sources structure is documented below.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelInputSourceArgs']]]]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class ChannelInputAudioSelectorArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        selector_settings: NotRequired[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsArgsDict']]
        """
        Specifies the audio selector configuration.
        The selector_settings structure is documented below.

        <a name="LiveChannel_SelectorSettings"></a>
        The `selector_settings` block supports:
        """
elif False:
    ChannelInputAudioSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputAudioSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 selector_settings: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        :param pulumi.Input['ChannelInputAudioSelectorSelectorSettingsArgs'] selector_settings: Specifies the audio selector configuration.
               The selector_settings structure is documented below.
               
               <a name="LiveChannel_SelectorSettings"></a>
               The `selector_settings` block supports:
        """
        pulumi.set(__self__, "name", name)
        if selector_settings is not None:
            pulumi.set(__self__, "selector_settings", selector_settings)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsArgs']]:
        """
        Specifies the audio selector configuration.
        The selector_settings structure is documented below.

        <a name="LiveChannel_SelectorSettings"></a>
        The `selector_settings` block supports:
        """
        return pulumi.get(self, "selector_settings")

    @selector_settings.setter
    def selector_settings(self, value: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsArgs']]):
        pulumi.set(self, "selector_settings", value)


if not MYPY:
    class ChannelInputAudioSelectorSelectorSettingsArgsDict(TypedDict):
        audio_hls_selection: NotRequired[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgsDict']]
        """
        Specifies the HLS selector configuration.
        The audio_hls_selection structure is documented below.

        <a name="LiveChannel_AudioLanguageSelection"></a>
        The `audio_language_selection` block supports:
        """
        audio_language_selection: NotRequired[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgsDict']]
        """
        Specifies the language selector configuration.
        The audio_language_selection structure is documented below.
        """
        audio_pid_selection: NotRequired[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgsDict']]
        """
        Specifies the PID selector configuration.
        The audio_pid_selection structure is documented below.
        """
elif False:
    ChannelInputAudioSelectorSelectorSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputAudioSelectorSelectorSettingsArgs:
    def __init__(__self__, *,
                 audio_hls_selection: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgs']] = None,
                 audio_language_selection: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgs']] = None,
                 audio_pid_selection: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgs']] = None):
        """
        :param pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgs'] audio_hls_selection: Specifies the HLS selector configuration.
               The audio_hls_selection structure is documented below.
               
               <a name="LiveChannel_AudioLanguageSelection"></a>
               The `audio_language_selection` block supports:
        :param pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgs'] audio_language_selection: Specifies the language selector configuration.
               The audio_language_selection structure is documented below.
        :param pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgs'] audio_pid_selection: Specifies the PID selector configuration.
               The audio_pid_selection structure is documented below.
        """
        if audio_hls_selection is not None:
            pulumi.set(__self__, "audio_hls_selection", audio_hls_selection)
        if audio_language_selection is not None:
            pulumi.set(__self__, "audio_language_selection", audio_language_selection)
        if audio_pid_selection is not None:
            pulumi.set(__self__, "audio_pid_selection", audio_pid_selection)

    @_builtins.property
    @pulumi.getter(name="audioHlsSelection")
    def audio_hls_selection(self) -> Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgs']]:
        """
        Specifies the HLS selector configuration.
        The audio_hls_selection structure is documented below.

        <a name="LiveChannel_AudioLanguageSelection"></a>
        The `audio_language_selection` block supports:
        """
        return pulumi.get(self, "audio_hls_selection")

    @audio_hls_selection.setter
    def audio_hls_selection(self, value: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgs']]):
        pulumi.set(self, "audio_hls_selection", value)

    @_builtins.property
    @pulumi.getter(name="audioLanguageSelection")
    def audio_language_selection(self) -> Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgs']]:
        """
        Specifies the language selector configuration.
        The audio_language_selection structure is documented below.
        """
        return pulumi.get(self, "audio_language_selection")

    @audio_language_selection.setter
    def audio_language_selection(self, value: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgs']]):
        pulumi.set(self, "audio_language_selection", value)

    @_builtins.property
    @pulumi.getter(name="audioPidSelection")
    def audio_pid_selection(self) -> Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgs']]:
        """
        Specifies the PID selector configuration.
        The audio_pid_selection structure is documented below.
        """
        return pulumi.get(self, "audio_pid_selection")

    @audio_pid_selection.setter
    def audio_pid_selection(self, value: Optional[pulumi.Input['ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgs']]):
        pulumi.set(self, "audio_pid_selection", value)


if not MYPY:
    class ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgsDict(TypedDict):
        group_id: pulumi.Input[_builtins.str]
        """
        Specifies the HLS audio selector gid.

        <a name="LiveChannel_RecordSettings"></a>
        The `record_settings` block supports:
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
elif False:
    ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputAudioSelectorSelectorSettingsAudioHlsSelectionArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] group_id: Specifies the HLS audio selector gid.
               
               <a name="LiveChannel_RecordSettings"></a>
               The `record_settings` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
               numbers, hyphens (-), and underscores (_) are supported.
               Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the HLS audio selector gid.

        <a name="LiveChannel_RecordSettings"></a>
        The `record_settings` block supports:
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the audio output configuration. Only uppercase and lowercase letters,
        numbers, hyphens (-), and underscores (_) are supported.
        Different audio output configuration names for the same channel are not allowed to be duplicated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgsDict(TypedDict):
        language_code: pulumi.Input[_builtins.str]
        """
        Specifies the language code. The value could be `2` or `3` lowercase letters.
        """
        language_selection_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the language output strategy. Valid values are:
        + **LOOSE**: Loose matching. For example, "eng" will prioritize matching tracks with English as the language in the
        source stream. If no match is found, the track with the smallest PID will be selected.
        + **STRICT**: Strict matching. For example, "eng" will strictly match the audio track in the source stream whose
        language is English. If no match is found, the media live broadcast service will automatically fill in a silent
        segment. When the terminal uses this audio selector to play the video, it will be played silently.

        <a name="LiveChannel_AudioPidSelection"></a>
        The `audio_pid_selection` block supports:
        """
elif False:
    ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputAudioSelectorSelectorSettingsAudioLanguageSelectionArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[_builtins.str],
                 language_selection_policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] language_code: Specifies the language code. The value could be `2` or `3` lowercase letters.
        :param pulumi.Input[_builtins.str] language_selection_policy: Specifies the language output strategy. Valid values are:
               + **LOOSE**: Loose matching. For example, "eng" will prioritize matching tracks with English as the language in the
               source stream. If no match is found, the track with the smallest PID will be selected.
               + **STRICT**: Strict matching. For example, "eng" will strictly match the audio track in the source stream whose
               language is English. If no match is found, the media live broadcast service will automatically fill in a silent
               segment. When the terminal uses this audio selector to play the video, it will be played silently.
               
               <a name="LiveChannel_AudioPidSelection"></a>
               The `audio_pid_selection` block supports:
        """
        pulumi.set(__self__, "language_code", language_code)
        if language_selection_policy is not None:
            pulumi.set(__self__, "language_selection_policy", language_selection_policy)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the language code. The value could be `2` or `3` lowercase letters.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter(name="languageSelectionPolicy")
    def language_selection_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the language output strategy. Valid values are:
        + **LOOSE**: Loose matching. For example, "eng" will prioritize matching tracks with English as the language in the
        source stream. If no match is found, the track with the smallest PID will be selected.
        + **STRICT**: Strict matching. For example, "eng" will strictly match the audio track in the source stream whose
        language is English. If no match is found, the media live broadcast service will automatically fill in a silent
        segment. When the terminal uses this audio selector to play the video, it will be played silently.

        <a name="LiveChannel_AudioPidSelection"></a>
        The `audio_pid_selection` block supports:
        """
        return pulumi.get(self, "language_selection_policy")

    @language_selection_policy.setter
    def language_selection_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language_selection_policy", value)


if not MYPY:
    class ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgsDict(TypedDict):
        pid: pulumi.Input[_builtins.int]
        """
        Specifies the value of PID.

        <a name="LiveChannel_AudioHlsSelection"></a>
        The `audio_hls_selection` block supports:
        """
elif False:
    ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputAudioSelectorSelectorSettingsAudioPidSelectionArgs:
    def __init__(__self__, *,
                 pid: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] pid: Specifies the value of PID.
               
               <a name="LiveChannel_AudioHlsSelection"></a>
               The `audio_hls_selection` block supports:
        """
        pulumi.set(__self__, "pid", pid)

    @_builtins.property
    @pulumi.getter
    def pid(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the value of PID.

        <a name="LiveChannel_AudioHlsSelection"></a>
        The `audio_hls_selection` block supports:
        """
        return pulumi.get(self, "pid")

    @pid.setter
    def pid(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "pid", value)


if not MYPY:
    class ChannelInputFailoverConditionsArgsDict(TypedDict):
        input_loss_threshold_msec: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the duration threshold of inflow stop.
        When this threshold is reached, the active/standby switchover is automatically triggered. The unit is millisecond.
        Value ranges from `0` to `3,600,000`. Defaults to `2,000` ms.
        """
        input_preference: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the input preference type. Valid values are:
        + **PRIMARY**: The main incoming URL is the first priority.
        + **EQUAL**: Equal switching between primary and backup URLs.

        Defaults to **EQUAL**.

        > If equal switching is used and the backup URL is used, it will not automatically switch to the primary URL.

        <a name="LiveChannel_AudioSelectors"></a>
        The `audio_selectors` block supports:
        """
elif False:
    ChannelInputFailoverConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputFailoverConditionsArgs:
    def __init__(__self__, *,
                 input_loss_threshold_msec: Optional[pulumi.Input[_builtins.int]] = None,
                 input_preference: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] input_loss_threshold_msec: Specifies the duration threshold of inflow stop.
               When this threshold is reached, the active/standby switchover is automatically triggered. The unit is millisecond.
               Value ranges from `0` to `3,600,000`. Defaults to `2,000` ms.
        :param pulumi.Input[_builtins.str] input_preference: Specifies the input preference type. Valid values are:
               + **PRIMARY**: The main incoming URL is the first priority.
               + **EQUAL**: Equal switching between primary and backup URLs.
               
               Defaults to **EQUAL**.
               
               > If equal switching is used and the backup URL is used, it will not automatically switch to the primary URL.
               
               <a name="LiveChannel_AudioSelectors"></a>
               The `audio_selectors` block supports:
        """
        if input_loss_threshold_msec is not None:
            pulumi.set(__self__, "input_loss_threshold_msec", input_loss_threshold_msec)
        if input_preference is not None:
            pulumi.set(__self__, "input_preference", input_preference)

    @_builtins.property
    @pulumi.getter(name="inputLossThresholdMsec")
    def input_loss_threshold_msec(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the duration threshold of inflow stop.
        When this threshold is reached, the active/standby switchover is automatically triggered. The unit is millisecond.
        Value ranges from `0` to `3,600,000`. Defaults to `2,000` ms.
        """
        return pulumi.get(self, "input_loss_threshold_msec")

    @input_loss_threshold_msec.setter
    def input_loss_threshold_msec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "input_loss_threshold_msec", value)

    @_builtins.property
    @pulumi.getter(name="inputPreference")
    def input_preference(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the input preference type. Valid values are:
        + **PRIMARY**: The main incoming URL is the first priority.
        + **EQUAL**: Equal switching between primary and backup URLs.

        Defaults to **EQUAL**.

        > If equal switching is used and the backup URL is used, it will not automatically switch to the primary URL.

        <a name="LiveChannel_AudioSelectors"></a>
        The `audio_selectors` block supports:
        """
        return pulumi.get(self, "input_preference")

    @input_preference.setter
    def input_preference(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_preference", value)


if not MYPY:
    class ChannelInputSecondarySourceArgsDict(TypedDict):
        backup_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of backup stream addresses.
        """
        bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the bitrate. This parameter is required when live transcoding is not required.
        The unit is **bps**. Value ranges from `0` to `104,857,600`.
        """
        bitrate_for3u8: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        """
        height: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        """
        latency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the streaming delay when the channel type is **SRT_PULL**.

        <a name="LiveChannel_FailoverConditions"></a>
        The `failover_conditions` block supports:
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the encrypted information when the protocol is **SRT_PUSH**.
        """
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the DRM address of the key.
        """
        width: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
elif False:
    ChannelInputSecondarySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputSecondarySourceArgs:
    def __init__(__self__, *,
                 backup_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 bitrate_for3u8: Optional[pulumi.Input[_builtins.bool]] = None,
                 height: Optional[pulumi.Input[_builtins.int]] = None,
                 latency: Optional[pulumi.Input[_builtins.int]] = None,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 width: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] backup_urls: Specifies the list of backup stream addresses.
        :param pulumi.Input[_builtins.int] bitrate: Specifies the bitrate. This parameter is required when live transcoding is not required.
               The unit is **bps**. Value ranges from `0` to `104,857,600`.
        :param pulumi.Input[_builtins.bool] bitrate_for3u8: Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        :param pulumi.Input[_builtins.int] height: Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        :param pulumi.Input[_builtins.int] latency: Specifies the streaming delay when the channel type is **SRT_PULL**.
               
               <a name="LiveChannel_FailoverConditions"></a>
               The `failover_conditions` block supports:
        :param pulumi.Input[_builtins.str] passphrase: Specifies the encrypted information when the protocol is **SRT_PUSH**.
        :param pulumi.Input[_builtins.str] stream_id: Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[_builtins.int] width: Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        if backup_urls is not None:
            pulumi.set(__self__, "backup_urls", backup_urls)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if bitrate_for3u8 is not None:
            pulumi.set(__self__, "bitrate_for3u8", bitrate_for3u8)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter(name="backupUrls")
    def backup_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of backup stream addresses.
        """
        return pulumi.get(self, "backup_urls")

    @backup_urls.setter
    def backup_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "backup_urls", value)

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the bitrate. This parameter is required when live transcoding is not required.
        The unit is **bps**. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bitrate", value)

    @_builtins.property
    @pulumi.getter(name="bitrateFor3u8")
    def bitrate_for3u8(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        """
        return pulumi.get(self, "bitrate_for3u8")

    @bitrate_for3u8.setter
    def bitrate_for3u8(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bitrate_for3u8", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the streaming delay when the channel type is **SRT_PULL**.

        <a name="LiveChannel_FailoverConditions"></a>
        The `failover_conditions` block supports:
        """
        return pulumi.get(self, "latency")

    @latency.setter
    def latency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "latency", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the encrypted information when the protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class ChannelInputSourceArgsDict(TypedDict):
        backup_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of backup stream addresses.
        """
        bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the bitrate. This parameter is required when live transcoding is not required.
        The unit is **bps**. Value ranges from `0` to `104,857,600`.
        """
        bitrate_for3u8: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        """
        enable_snapshot: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to use this stream to take screenshots.
        """
        height: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        """
        latency: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the streaming delay when the channel type is **SRT_PULL**.

        <a name="LiveChannel_FailoverConditions"></a>
        The `failover_conditions` block supports:
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the encrypted information when the protocol is **SRT_PUSH**.
        """
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the DRM address of the key.
        """
        width: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
elif False:
    ChannelInputSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelInputSourceArgs:
    def __init__(__self__, *,
                 backup_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 bitrate_for3u8: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_snapshot: Optional[pulumi.Input[_builtins.bool]] = None,
                 height: Optional[pulumi.Input[_builtins.int]] = None,
                 latency: Optional[pulumi.Input[_builtins.int]] = None,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 width: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] backup_urls: Specifies the list of backup stream addresses.
        :param pulumi.Input[_builtins.int] bitrate: Specifies the bitrate. This parameter is required when live transcoding is not required.
               The unit is **bps**. Value ranges from `0` to `104,857,600`.
        :param pulumi.Input[_builtins.bool] bitrate_for3u8: Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        :param pulumi.Input[_builtins.bool] enable_snapshot: Specifies whether to use this stream to take screenshots.
        :param pulumi.Input[_builtins.int] height: Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        :param pulumi.Input[_builtins.int] latency: Specifies the streaming delay when the channel type is **SRT_PULL**.
               
               <a name="LiveChannel_FailoverConditions"></a>
               The `failover_conditions` block supports:
        :param pulumi.Input[_builtins.str] passphrase: Specifies the encrypted information when the protocol is **SRT_PUSH**.
        :param pulumi.Input[_builtins.str] stream_id: Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        :param pulumi.Input[_builtins.str] url: Specifies the DRM address of the key.
        :param pulumi.Input[_builtins.int] width: Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        if backup_urls is not None:
            pulumi.set(__self__, "backup_urls", backup_urls)
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if bitrate_for3u8 is not None:
            pulumi.set(__self__, "bitrate_for3u8", bitrate_for3u8)
        if enable_snapshot is not None:
            pulumi.set(__self__, "enable_snapshot", enable_snapshot)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter(name="backupUrls")
    def backup_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of backup stream addresses.
        """
        return pulumi.get(self, "backup_urls")

    @backup_urls.setter
    def backup_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "backup_urls", value)

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the bitrate. This parameter is required when live transcoding is not required.
        The unit is **bps**. Value ranges from `0` to `104,857,600`.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bitrate", value)

    @_builtins.property
    @pulumi.getter(name="bitrateFor3u8")
    def bitrate_for3u8(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to use bitrate to fix the bitrate. Defaults to **false**.
        """
        return pulumi.get(self, "bitrate_for3u8")

    @bitrate_for3u8.setter
    def bitrate_for3u8(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bitrate_for3u8", value)

    @_builtins.property
    @pulumi.getter(name="enableSnapshot")
    def enable_snapshot(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to use this stream to take screenshots.
        """
        return pulumi.get(self, "enable_snapshot")

    @enable_snapshot.setter
    def enable_snapshot(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_snapshot", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the resolution corresponds to the high value. Value ranges from `0` to `2,160`.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the streaming delay when the channel type is **SRT_PULL**.

        <a name="LiveChannel_FailoverConditions"></a>
        The `failover_conditions` block supports:
        """
        return pulumi.get(self, "latency")

    @latency.setter
    def latency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "latency", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the encrypted information when the protocol is **SRT_PUSH**.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the stream ID of the stream pull address when the channel type is **SRT_PULL**.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the DRM address of the key.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the resolution corresponds to the width value. Value ranges from `0` to `4,096`.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "width", value)


if not MYPY:
    class ChannelRecordSettingsArgsDict(TypedDict):
        rollingbuffer_duration: pulumi.Input[_builtins.int]
        """
        Specifies the maximum playback recording time. During this time period,
        the recording will continue. The unit is second.
        When the value is `0`, it means that recording is not supported. The maximum supported recording period is `14` days.

        <a name="LiveChannel_Endpoints"></a>
        The `endpoints` block supports:
        """
elif False:
    ChannelRecordSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelRecordSettingsArgs:
    def __init__(__self__, *,
                 rollingbuffer_duration: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] rollingbuffer_duration: Specifies the maximum playback recording time. During this time period,
               the recording will continue. The unit is second.
               When the value is `0`, it means that recording is not supported. The maximum supported recording period is `14` days.
               
               <a name="LiveChannel_Endpoints"></a>
               The `endpoints` block supports:
        """
        pulumi.set(__self__, "rollingbuffer_duration", rollingbuffer_duration)

    @_builtins.property
    @pulumi.getter(name="rollingbufferDuration")
    def rollingbuffer_duration(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the maximum playback recording time. During this time period,
        the recording will continue. The unit is second.
        When the value is `0`, it means that recording is not supported. The maximum supported recording period is `14` days.

        <a name="LiveChannel_Endpoints"></a>
        The `endpoints` block supports:
        """
        return pulumi.get(self, "rollingbuffer_duration")

    @rollingbuffer_duration.setter
    def rollingbuffer_duration(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rollingbuffer_duration", value)


if not MYPY:
    class HlsConfigurationApplicationArgsDict(TypedDict):
        hls_fragment: pulumi.Input[_builtins.int]
        """
        Specifies the HLS slice duration in seconds.
        """
        hls_min_frags: pulumi.Input[_builtins.int]
        """
        Specifies the minimum number of ts shards in each M3U8 file.
        """
        hls_ts_count: pulumi.Input[_builtins.int]
        """
        Specifies the number of ts slices in each M3U8 file.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the application name.
        Changing this parameter will create a new resource.
        """
elif False:
    HlsConfigurationApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HlsConfigurationApplicationArgs:
    def __init__(__self__, *,
                 hls_fragment: pulumi.Input[_builtins.int],
                 hls_min_frags: pulumi.Input[_builtins.int],
                 hls_ts_count: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] hls_fragment: Specifies the HLS slice duration in seconds.
        :param pulumi.Input[_builtins.int] hls_min_frags: Specifies the minimum number of ts shards in each M3U8 file.
        :param pulumi.Input[_builtins.int] hls_ts_count: Specifies the number of ts slices in each M3U8 file.
        :param pulumi.Input[_builtins.str] name: Specifies the application name.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "hls_fragment", hls_fragment)
        pulumi.set(__self__, "hls_min_frags", hls_min_frags)
        pulumi.set(__self__, "hls_ts_count", hls_ts_count)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="hlsFragment")
    def hls_fragment(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the HLS slice duration in seconds.
        """
        return pulumi.get(self, "hls_fragment")

    @hls_fragment.setter
    def hls_fragment(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hls_fragment", value)

    @_builtins.property
    @pulumi.getter(name="hlsMinFrags")
    def hls_min_frags(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the minimum number of ts shards in each M3U8 file.
        """
        return pulumi.get(self, "hls_min_frags")

    @hls_min_frags.setter
    def hls_min_frags(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hls_min_frags", value)

    @_builtins.property
    @pulumi.getter(name="hlsTsCount")
    def hls_ts_count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of ts slices in each M3U8 file.
        """
        return pulumi.get(self, "hls_ts_count")

    @hls_ts_count.setter
    def hls_ts_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hls_ts_count", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the application name.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class HttpsCertificateGmCertificateArgsDict(TypedDict):
        cert_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the SCM certificate ID.
        """
        cert_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the SCM certificate name.
        """
        enc_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Chinese (SM) encryption certificate body
        """
        enc_certificate_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Chinese (SM) encryption private key
        """
        sign_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Chinese (SM) signature certificate body
        """
        sign_certificate_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the Chinese (SM) signature private key
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the certificate source.
        """
elif False:
    HttpsCertificateGmCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpsCertificateGmCertificateArgs:
    def __init__(__self__, *,
                 cert_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cert_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enc_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 enc_certificate_key: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_certificate_key: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert_id: Specifies the SCM certificate ID.
        :param pulumi.Input[_builtins.str] cert_name: Specifies the SCM certificate name.
        :param pulumi.Input[_builtins.str] enc_certificate: Specifies the Chinese (SM) encryption certificate body
        :param pulumi.Input[_builtins.str] enc_certificate_key: Specifies the Chinese (SM) encryption private key
        :param pulumi.Input[_builtins.str] sign_certificate: Specifies the Chinese (SM) signature certificate body
        :param pulumi.Input[_builtins.str] sign_certificate_key: Specifies the Chinese (SM) signature private key
        :param pulumi.Input[_builtins.str] source: Specifies the certificate source.
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if cert_name is not None:
            pulumi.set(__self__, "cert_name", cert_name)
        if enc_certificate is not None:
            pulumi.set(__self__, "enc_certificate", enc_certificate)
        if enc_certificate_key is not None:
            pulumi.set(__self__, "enc_certificate_key", enc_certificate_key)
        if sign_certificate is not None:
            pulumi.set(__self__, "sign_certificate", sign_certificate)
        if sign_certificate_key is not None:
            pulumi.set(__self__, "sign_certificate_key", sign_certificate_key)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the SCM certificate ID.
        """
        return pulumi.get(self, "cert_id")

    @cert_id.setter
    def cert_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_id", value)

    @_builtins.property
    @pulumi.getter(name="certName")
    def cert_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the SCM certificate name.
        """
        return pulumi.get(self, "cert_name")

    @cert_name.setter
    def cert_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_name", value)

    @_builtins.property
    @pulumi.getter(name="encCertificate")
    def enc_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Chinese (SM) encryption certificate body
        """
        return pulumi.get(self, "enc_certificate")

    @enc_certificate.setter
    def enc_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enc_certificate", value)

    @_builtins.property
    @pulumi.getter(name="encCertificateKey")
    def enc_certificate_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Chinese (SM) encryption private key
        """
        return pulumi.get(self, "enc_certificate_key")

    @enc_certificate_key.setter
    def enc_certificate_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "enc_certificate_key", value)

    @_builtins.property
    @pulumi.getter(name="signCertificate")
    def sign_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Chinese (SM) signature certificate body
        """
        return pulumi.get(self, "sign_certificate")

    @sign_certificate.setter
    def sign_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_certificate", value)

    @_builtins.property
    @pulumi.getter(name="signCertificateKey")
    def sign_certificate_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the Chinese (SM) signature private key
        """
        return pulumi.get(self, "sign_certificate_key")

    @sign_certificate_key.setter
    def sign_certificate_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_certificate_key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class HttpsCertificateTlsCertificateArgsDict(TypedDict):
        cert_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the SCM certificate ID.
        """
        cert_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the SCM certificate name.
        """
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the certificate body.
        """
        certificate_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the private key.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the certificate source.
        """
elif False:
    HttpsCertificateTlsCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpsCertificateTlsCertificateArgs:
    def __init__(__self__, *,
                 cert_id: Optional[pulumi.Input[_builtins.str]] = None,
                 cert_name: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_key: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert_id: Specifies the SCM certificate ID.
        :param pulumi.Input[_builtins.str] cert_name: Specifies the SCM certificate name.
        :param pulumi.Input[_builtins.str] certificate: Specifies the certificate body.
        :param pulumi.Input[_builtins.str] certificate_key: Specifies the private key.
        :param pulumi.Input[_builtins.str] source: Specifies the certificate source.
        """
        if cert_id is not None:
            pulumi.set(__self__, "cert_id", cert_id)
        if cert_name is not None:
            pulumi.set(__self__, "cert_name", cert_name)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_key is not None:
            pulumi.set(__self__, "certificate_key", certificate_key)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="certId")
    def cert_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the SCM certificate ID.
        """
        return pulumi.get(self, "cert_id")

    @cert_id.setter
    def cert_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_id", value)

    @_builtins.property
    @pulumi.getter(name="certName")
    def cert_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the SCM certificate name.
        """
        return pulumi.get(self, "cert_name")

    @cert_name.setter
    def cert_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_name", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate body.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="certificateKey")
    def certificate_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the private key.
        """
        return pulumi.get(self, "certificate_key")

    @certificate_key.setter
    def certificate_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the certificate source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class RecordingFlvArgsDict(TypedDict):
        recording_length: pulumi.Input[_builtins.int]
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        file_naming: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        max_stream_pause_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
elif False:
    RecordingFlvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingFlvArgs:
    def __init__(__self__, *,
                 recording_length: pulumi.Input[_builtins.int],
                 file_naming: Optional[pulumi.Input[_builtins.str]] = None,
                 max_stream_pause_length: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] recording_length: Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
               A stream exceeding the recording length will generate a new recording.
        :param pulumi.Input[_builtins.str] file_naming: Specifies the path and file name prefix of a recording file. The default value is
               `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        :param pulumi.Input[_builtins.int] max_stream_pause_length: Specifies the interval threshold for combining recording chunks. If the
               stream pause length exceeds the value of this parameter, a new recording is generated.
               Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
               If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        pulumi.set(__self__, "recording_length", recording_length)
        if file_naming is not None:
            pulumi.set(__self__, "file_naming", file_naming)
        if max_stream_pause_length is not None:
            pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        return pulumi.get(self, "recording_length")

    @recording_length.setter
    def recording_length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "recording_length", value)

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        return pulumi.get(self, "file_naming")

    @file_naming.setter
    def file_naming(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_naming", value)

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        return pulumi.get(self, "max_stream_pause_length")

    @max_stream_pause_length.setter
    def max_stream_pause_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_stream_pause_length", value)


if not MYPY:
    class RecordingHlsArgsDict(TypedDict):
        recording_length: pulumi.Input[_builtins.int]
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        file_naming: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        max_stream_pause_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        record_slice_duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the TS slice duration for HLS recording.
        Value range: `2` ~ `60`, unit: `second`. Defaults to `10`.
        """
        ts_file_naming: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies TS file name prefix.
        The default value is `{file_start_time_unix}_{file_end_time_unix}_{ts_sequence_number}`.
        """
elif False:
    RecordingHlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingHlsArgs:
    def __init__(__self__, *,
                 recording_length: pulumi.Input[_builtins.int],
                 file_naming: Optional[pulumi.Input[_builtins.str]] = None,
                 max_stream_pause_length: Optional[pulumi.Input[_builtins.int]] = None,
                 record_slice_duration: Optional[pulumi.Input[_builtins.int]] = None,
                 ts_file_naming: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] recording_length: Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
               A stream exceeding the recording length will generate a new recording.
        :param pulumi.Input[_builtins.str] file_naming: Specifies the path and file name prefix of a recording file. The default value is
               `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        :param pulumi.Input[_builtins.int] max_stream_pause_length: Specifies the interval threshold for combining recording chunks. If the
               stream pause length exceeds the value of this parameter, a new recording is generated.
               Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
               If the value is set to `0`, a new file will be generated once the stream is interrupted.
        :param pulumi.Input[_builtins.int] record_slice_duration: Specifies the TS slice duration for HLS recording.
               Value range: `2` ~ `60`, unit: `second`. Defaults to `10`.
        :param pulumi.Input[_builtins.str] ts_file_naming: Specifies TS file name prefix.
               The default value is `{file_start_time_unix}_{file_end_time_unix}_{ts_sequence_number}`.
        """
        pulumi.set(__self__, "recording_length", recording_length)
        if file_naming is not None:
            pulumi.set(__self__, "file_naming", file_naming)
        if max_stream_pause_length is not None:
            pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)
        if record_slice_duration is not None:
            pulumi.set(__self__, "record_slice_duration", record_slice_duration)
        if ts_file_naming is not None:
            pulumi.set(__self__, "ts_file_naming", ts_file_naming)

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        return pulumi.get(self, "recording_length")

    @recording_length.setter
    def recording_length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "recording_length", value)

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        return pulumi.get(self, "file_naming")

    @file_naming.setter
    def file_naming(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_naming", value)

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        return pulumi.get(self, "max_stream_pause_length")

    @max_stream_pause_length.setter
    def max_stream_pause_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_stream_pause_length", value)

    @_builtins.property
    @pulumi.getter(name="recordSliceDuration")
    def record_slice_duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the TS slice duration for HLS recording.
        Value range: `2` ~ `60`, unit: `second`. Defaults to `10`.
        """
        return pulumi.get(self, "record_slice_duration")

    @record_slice_duration.setter
    def record_slice_duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "record_slice_duration", value)

    @_builtins.property
    @pulumi.getter(name="tsFileNaming")
    def ts_file_naming(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies TS file name prefix.
        The default value is `{file_start_time_unix}_{file_end_time_unix}_{ts_sequence_number}`.
        """
        return pulumi.get(self, "ts_file_naming")

    @ts_file_naming.setter
    def ts_file_naming(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ts_file_naming", value)


if not MYPY:
    class RecordingMp4ArgsDict(TypedDict):
        recording_length: pulumi.Input[_builtins.int]
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        file_naming: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        max_stream_pause_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
elif False:
    RecordingMp4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingMp4Args:
    def __init__(__self__, *,
                 recording_length: pulumi.Input[_builtins.int],
                 file_naming: Optional[pulumi.Input[_builtins.str]] = None,
                 max_stream_pause_length: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] recording_length: Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
               A stream exceeding the recording length will generate a new recording.
        :param pulumi.Input[_builtins.str] file_naming: Specifies the path and file name prefix of a recording file. The default value is
               `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        :param pulumi.Input[_builtins.int] max_stream_pause_length: Specifies the interval threshold for combining recording chunks. If the
               stream pause length exceeds the value of this parameter, a new recording is generated.
               Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
               If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        pulumi.set(__self__, "recording_length", recording_length)
        if file_naming is not None:
            pulumi.set(__self__, "file_naming", file_naming)
        if max_stream_pause_length is not None:
            pulumi.set(__self__, "max_stream_pause_length", max_stream_pause_length)

    @_builtins.property
    @pulumi.getter(name="recordingLength")
    def recording_length(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the recording length. Value range: `15` ~ `180`, unit: `minute`.
        A stream exceeding the recording length will generate a new recording.
        """
        return pulumi.get(self, "recording_length")

    @recording_length.setter
    def recording_length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "recording_length", value)

    @_builtins.property
    @pulumi.getter(name="fileNaming")
    def file_naming(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path and file name prefix of a recording file. The default value is
        `Record/{publish_domain}/{app}/{record_type}/{record_format}/{stream}_{file_start_time}/{file_start_time}`.
        """
        return pulumi.get(self, "file_naming")

    @file_naming.setter
    def file_naming(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_naming", value)

    @_builtins.property
    @pulumi.getter(name="maxStreamPauseLength")
    def max_stream_pause_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the interval threshold for combining recording chunks. If the
        stream pause length exceeds the value of this parameter, a new recording is generated.
        Value range: `0` ~ `300`, unit: `second`. Defaults to `0`.
        If the value is set to `0`, a new file will be generated once the stream is interrupted.
        """
        return pulumi.get(self, "max_stream_pause_length")

    @max_stream_pause_length.setter
    def max_stream_pause_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_stream_pause_length", value)


if not MYPY:
    class RecordingObsArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Specifies OBS bucket.
        """
        region: pulumi.Input[_builtins.str]
        """
        Specifies the region of OBS.
        """
        object: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies OBS object path. If omitted, recordings will be saved to the root directory.

        <a name="recording_HLS"></a>
        The `hls` block supports:
        """
elif False:
    RecordingObsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingObsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 object: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Specifies OBS bucket.
        :param pulumi.Input[_builtins.str] region: Specifies the region of OBS.
        :param pulumi.Input[_builtins.str] object: Specifies OBS object path. If omitted, recordings will be saved to the root directory.
               
               <a name="recording_HLS"></a>
               The `hls` block supports:
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "region", region)
        if object is not None:
            pulumi.set(__self__, "object", object)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies OBS bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the region of OBS.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies OBS object path. If omitted, recordings will be saved to the root directory.

        <a name="recording_HLS"></a>
        The `hls` block supports:
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object", value)


if not MYPY:
    class TranscodingTemplateArgsDict(TypedDict):
        bitrate: pulumi.Input[_builtins.int]
        """
        Specifies the bitrate of a transcoded video, in kbit/s. Value range: `40` ~ `30,000`.
        """
        height: pulumi.Input[_builtins.int]
        """
        Specifies video height (unit: pixel).
        + **When the video encoding is H264**, value range: `32` ~ `2,160` and must be a multiple of `2`.
        + **When the video encoding is H265**, value range: `240` ~ `2,160` and must be a multiple of `4`.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the template name. The name can contain a maximum of 64 characters, and only
        contains letters, digits and hyphens (-).
        """
        width: pulumi.Input[_builtins.int]
        """
        Specifies video width (unit: pixel).
        + **When the video encoding is H264**, value range: `32` ~ `3,840` and must be a multiple of `2`.
        + **When the video encoding is H265**, value range: `320` ~ `3,840` and must be a multiple of `4`.
        """
        bitrate_adaptive: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the adaptive bitrate.
        The valid values are as follows:
        + **off**: Disable rate adaptation and output the target rate according to the set rate.
        + **minimum**: Output the target bitrate based on the minimum value of the set bitrate and source file bitrate.
        + **adaptive**: Adaptive output of target bitrate based on source file bitrate.

        Defaults to **off**.
        """
        frame_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the frame rate of the transcoded video, in fps. Value range: `0` ~ `30`.
        Value `0` indicates that the frame rate remains unchanged.
        """
        gop: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the interval time for I-frames, in seconds.
        The value ranges from `0` to `10`, includes `0` and `10`. Defaults to `2`.

        > When `gop` is not `0`, the i-frame interval is set with the `gop` parameter, and the `i_frame_interval` field does
        not take effect.
        """
        i_frame_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the maximum I-frame interval in frames.
        The value ranges from `0` to `500`, includes `0` and `500`. Defaults to `50`.

        > If you want to set the i-frame interval through `i_frame_interval`, please set the `gop` to `0` or do not pass the
        `gop` parameter.
        """
        i_frame_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the encoding output I-frame strategy.
        The valid values are as follows:
        + **auto**: I-frame output according to the set `gop` duration.
        + **strictSync**: The encoded output I-frame is completely consistent with the source, and the `gop` parameter is
        invalid after setting this value.

        Defaults to **auto**.

        > In multi bitrate scenarios, it is recommended to enable I-frame random source to ensure alignment of multi bitrate
        I-frames.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the protocol type supported for transcoding output.
        The valid value is **RTMP**. Defaults to **RTMP**.
        """
elif False:
    TranscodingTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TranscodingTemplateArgs:
    def __init__(__self__, *,
                 bitrate: pulumi.Input[_builtins.int],
                 height: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 width: pulumi.Input[_builtins.int],
                 bitrate_adaptive: Optional[pulumi.Input[_builtins.str]] = None,
                 frame_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 gop: Optional[pulumi.Input[_builtins.str]] = None,
                 i_frame_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 i_frame_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] bitrate: Specifies the bitrate of a transcoded video, in kbit/s. Value range: `40` ~ `30,000`.
        :param pulumi.Input[_builtins.int] height: Specifies video height (unit: pixel).
               + **When the video encoding is H264**, value range: `32` ~ `2,160` and must be a multiple of `2`.
               + **When the video encoding is H265**, value range: `240` ~ `2,160` and must be a multiple of `4`.
        :param pulumi.Input[_builtins.str] name: Specifies the template name. The name can contain a maximum of 64 characters, and only
               contains letters, digits and hyphens (-).
        :param pulumi.Input[_builtins.int] width: Specifies video width (unit: pixel).
               + **When the video encoding is H264**, value range: `32` ~ `3,840` and must be a multiple of `2`.
               + **When the video encoding is H265**, value range: `320` ~ `3,840` and must be a multiple of `4`.
        :param pulumi.Input[_builtins.str] bitrate_adaptive: Specifies the adaptive bitrate.
               The valid values are as follows:
               + **off**: Disable rate adaptation and output the target rate according to the set rate.
               + **minimum**: Output the target bitrate based on the minimum value of the set bitrate and source file bitrate.
               + **adaptive**: Adaptive output of target bitrate based on source file bitrate.
               
               Defaults to **off**.
        :param pulumi.Input[_builtins.int] frame_rate: Specifies the frame rate of the transcoded video, in fps. Value range: `0` ~ `30`.
               Value `0` indicates that the frame rate remains unchanged.
        :param pulumi.Input[_builtins.str] gop: Specifies the interval time for I-frames, in seconds.
               The value ranges from `0` to `10`, includes `0` and `10`. Defaults to `2`.
               
               > When `gop` is not `0`, the i-frame interval is set with the `gop` parameter, and the `i_frame_interval` field does
               not take effect.
        :param pulumi.Input[_builtins.str] i_frame_interval: Specifies the maximum I-frame interval in frames.
               The value ranges from `0` to `500`, includes `0` and `500`. Defaults to `50`.
               
               > If you want to set the i-frame interval through `i_frame_interval`, please set the `gop` to `0` or do not pass the
               `gop` parameter.
        :param pulumi.Input[_builtins.str] i_frame_policy: Specifies the encoding output I-frame strategy.
               The valid values are as follows:
               + **auto**: I-frame output according to the set `gop` duration.
               + **strictSync**: The encoded output I-frame is completely consistent with the source, and the `gop` parameter is
               invalid after setting this value.
               
               Defaults to **auto**.
               
               > In multi bitrate scenarios, it is recommended to enable I-frame random source to ensure alignment of multi bitrate
               I-frames.
        :param pulumi.Input[_builtins.str] protocol: Specifies the protocol type supported for transcoding output.
               The valid value is **RTMP**. Defaults to **RTMP**.
        """
        pulumi.set(__self__, "bitrate", bitrate)
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "width", width)
        if bitrate_adaptive is not None:
            pulumi.set(__self__, "bitrate_adaptive", bitrate_adaptive)
        if frame_rate is not None:
            pulumi.set(__self__, "frame_rate", frame_rate)
        if gop is not None:
            pulumi.set(__self__, "gop", gop)
        if i_frame_interval is not None:
            pulumi.set(__self__, "i_frame_interval", i_frame_interval)
        if i_frame_policy is not None:
            pulumi.set(__self__, "i_frame_policy", i_frame_policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the bitrate of a transcoded video, in kbit/s. Value range: `40` ~ `30,000`.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "bitrate", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies video height (unit: pixel).
        + **When the video encoding is H264**, value range: `32` ~ `2,160` and must be a multiple of `2`.
        + **When the video encoding is H265**, value range: `240` ~ `2,160` and must be a multiple of `4`.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the template name. The name can contain a maximum of 64 characters, and only
        contains letters, digits and hyphens (-).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies video width (unit: pixel).
        + **When the video encoding is H264**, value range: `32` ~ `3,840` and must be a multiple of `2`.
        + **When the video encoding is H265**, value range: `320` ~ `3,840` and must be a multiple of `4`.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "width", value)

    @_builtins.property
    @pulumi.getter(name="bitrateAdaptive")
    def bitrate_adaptive(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the adaptive bitrate.
        The valid values are as follows:
        + **off**: Disable rate adaptation and output the target rate according to the set rate.
        + **minimum**: Output the target bitrate based on the minimum value of the set bitrate and source file bitrate.
        + **adaptive**: Adaptive output of target bitrate based on source file bitrate.

        Defaults to **off**.
        """
        return pulumi.get(self, "bitrate_adaptive")

    @bitrate_adaptive.setter
    def bitrate_adaptive(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bitrate_adaptive", value)

    @_builtins.property
    @pulumi.getter(name="frameRate")
    def frame_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the frame rate of the transcoded video, in fps. Value range: `0` ~ `30`.
        Value `0` indicates that the frame rate remains unchanged.
        """
        return pulumi.get(self, "frame_rate")

    @frame_rate.setter
    def frame_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "frame_rate", value)

    @_builtins.property
    @pulumi.getter
    def gop(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the interval time for I-frames, in seconds.
        The value ranges from `0` to `10`, includes `0` and `10`. Defaults to `2`.

        > When `gop` is not `0`, the i-frame interval is set with the `gop` parameter, and the `i_frame_interval` field does
        not take effect.
        """
        return pulumi.get(self, "gop")

    @gop.setter
    def gop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gop", value)

    @_builtins.property
    @pulumi.getter(name="iFrameInterval")
    def i_frame_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the maximum I-frame interval in frames.
        The value ranges from `0` to `500`, includes `0` and `500`. Defaults to `50`.

        > If you want to set the i-frame interval through `i_frame_interval`, please set the `gop` to `0` or do not pass the
        `gop` parameter.
        """
        return pulumi.get(self, "i_frame_interval")

    @i_frame_interval.setter
    def i_frame_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "i_frame_interval", value)

    @_builtins.property
    @pulumi.getter(name="iFramePolicy")
    def i_frame_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the encoding output I-frame strategy.
        The valid values are as follows:
        + **auto**: I-frame output according to the set `gop` duration.
        + **strictSync**: The encoded output I-frame is completely consistent with the source, and the `gop` parameter is
        invalid after setting this value.

        Defaults to **auto**.

        > In multi bitrate scenarios, it is recommended to enable I-frame random source to ensure alignment of multi bitrate
        I-frames.
        """
        return pulumi.get(self, "i_frame_policy")

    @i_frame_policy.setter
    def i_frame_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "i_frame_policy", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the protocol type supported for transcoding output.
        The valid value is **RTMP**. Defaults to **RTMP**.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


