# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccessPolicyBlacklistArgs',
    'AccessPolicyBlacklistArgsDict',
    'AppGroupAuthorizationAccountArgs',
    'AppGroupAuthorizationAccountArgsDict',
    'AppImageServerAuthorizeAccountArgs',
    'AppImageServerAuthorizeAccountArgsDict',
    'AppImageServerRootVolumeArgs',
    'AppImageServerRootVolumeArgsDict',
    'AppImageServerRoutePolicyArgs',
    'AppImageServerRoutePolicyArgsDict',
    'AppImageServerSchedulerHintsArgs',
    'AppImageServerSchedulerHintsArgsDict',
    'AppNasStorageStorageMetadataArgs',
    'AppNasStorageStorageMetadataArgsDict',
    'AppPersonalFoldersAssignmentArgs',
    'AppPersonalFoldersAssignmentArgsDict',
    'AppPolicyGroupTargetArgs',
    'AppPolicyGroupTargetArgsDict',
    'AppScheduleTaskScheduleTaskPolicyArgs',
    'AppScheduleTaskScheduleTaskPolicyArgsDict',
    'AppScheduleTaskTargetInfoArgs',
    'AppScheduleTaskTargetInfoArgsDict',
    'AppServerGroupFlavorArgs',
    'AppServerGroupFlavorArgsDict',
    'AppServerGroupFlavorLinkArgs',
    'AppServerGroupFlavorLinkArgsDict',
    'AppServerGroupIpVirtualArgs',
    'AppServerGroupIpVirtualArgsDict',
    'AppServerGroupRoutePolicyArgs',
    'AppServerGroupRoutePolicyArgsDict',
    'AppServerGroupScalingPolicyScalingPolicyBySessionArgs',
    'AppServerGroupScalingPolicyScalingPolicyBySessionArgsDict',
    'AppServerRootVolumeArgs',
    'AppServerRootVolumeArgsDict',
    'AppServerSchedulerHintsArgs',
    'AppServerSchedulerHintsArgsDict',
    'ApplicationApplicationFileStoreArgs',
    'ApplicationApplicationFileStoreArgsDict',
    'ApplicationApplicationFileStoreBucketStoreArgs',
    'ApplicationApplicationFileStoreBucketStoreArgsDict',
    'ApplicationRuleDetailArgs',
    'ApplicationRuleDetailArgsDict',
    'ApplicationRuleDetailPathRuleArgs',
    'ApplicationRuleDetailPathRuleArgsDict',
    'ApplicationRuleDetailProductRuleArgs',
    'ApplicationRuleDetailProductRuleArgsDict',
    'DesktopDataVolumeArgs',
    'DesktopDataVolumeArgsDict',
    'DesktopNicArgs',
    'DesktopNicArgsDict',
    'DesktopPoolAuthorizedObjectArgs',
    'DesktopPoolAuthorizedObjectArgsDict',
    'DesktopPoolAutoscalePolicyArgs',
    'DesktopPoolAutoscalePolicyArgsDict',
    'DesktopPoolDataVolumeArgs',
    'DesktopPoolDataVolumeArgsDict',
    'DesktopPoolProductArgs',
    'DesktopPoolProductArgsDict',
    'DesktopPoolRootVolumeArgs',
    'DesktopPoolRootVolumeArgsDict',
    'DesktopPoolSecurityGroupArgs',
    'DesktopPoolSecurityGroupArgsDict',
    'DesktopRootVolumeArgs',
    'DesktopRootVolumeArgsDict',
    'PolicyGroupPolicyArgs',
    'PolicyGroupPolicyArgsDict',
    'PolicyGroupPolicyAccessControlArgs',
    'PolicyGroupPolicyAccessControlArgsDict',
    'PolicyGroupTargetArgs',
    'PolicyGroupTargetArgsDict',
    'ServiceAdDomainArgs',
    'ServiceAdDomainArgsDict',
    'ServiceDesktopSecurityGroupArgs',
    'ServiceDesktopSecurityGroupArgsDict',
    'ServiceInfrastructureSecurityGroupArgs',
    'ServiceInfrastructureSecurityGroupArgsDict',
    'ServiceOtpConfigInfoArgs',
    'ServiceOtpConfigInfoArgsDict',
    'TerminalBindingBindingArgs',
    'TerminalBindingBindingArgsDict',
    'UserGroupUserArgs',
    'UserGroupUserArgsDict',
    'GetDesktopTagsFilterMatchArgs',
    'GetDesktopTagsFilterMatchArgsDict',
    'GetDesktopTagsFilterNotTagArgs',
    'GetDesktopTagsFilterNotTagArgsDict',
    'GetDesktopTagsFilterNotTagsAnyArgs',
    'GetDesktopTagsFilterNotTagsAnyArgsDict',
    'GetDesktopTagsFilterTagArgs',
    'GetDesktopTagsFilterTagArgsDict',
    'GetDesktopTagsFilterTagsAnyArgs',
    'GetDesktopTagsFilterTagsAnyArgsDict',
]

MYPY = False

if not MYPY:
    class AccessPolicyBlacklistArgsDict(TypedDict):
        object_id: pulumi.Input[_builtins.str]
        """
        Specifies the object ID.
        """
        object_type: pulumi.Input[_builtins.str]
        """
        Specifies the object type.
        The valid values are as follows:
        + **USER**
        + **USERGROUP**
        """
        object_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object name.
        """
elif False:
    AccessPolicyBlacklistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessPolicyBlacklistArgs:
    def __init__(__self__, *,
                 object_id: pulumi.Input[_builtins.str],
                 object_type: pulumi.Input[_builtins.str],
                 object_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] object_id: Specifies the object ID.
        :param pulumi.Input[_builtins.str] object_type: Specifies the object type.
               The valid values are as follows:
               + **USER**
               + **USERGROUP**
        :param pulumi.Input[_builtins.str] object_name: The object name.
        """
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "object_type", object_type)
        if object_name is not None:
            pulumi.set(__self__, "object_name", object_name)

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object ID.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_id", value)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object type.
        The valid values are as follows:
        + **USER**
        + **USERGROUP**
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="objectName")
    def object_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object name.
        """
        return pulumi.get(self, "object_name")

    @object_name.setter
    def object_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "object_name", value)


if not MYPY:
    class AppGroupAuthorizationAccountArgsDict(TypedDict):
        account: pulumi.Input[_builtins.str]
        """
        Specifies the name of the user (group).
        Changing this creates a new resource.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the object to be authorized.
        Changing this creates a new resource.
        The valid values are as follows:
        + **USER**
        + **USER_GROUP**
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the user (group).
        Changing this creates a new resource.
        This parameter is required when `type` is set to **USER_GROUP**.
        """
elif False:
    AppGroupAuthorizationAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppGroupAuthorizationAccountArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account: Specifies the name of the user (group).
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the object to be authorized.
               Changing this creates a new resource.
               The valid values are as follows:
               + **USER**
               + **USER_GROUP**
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the user (group).
               Changing this creates a new resource.
               This parameter is required when `type` is set to **USER_GROUP**.
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def account(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the user (group).
        Changing this creates a new resource.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the object to be authorized.
        Changing this creates a new resource.
        The valid values are as follows:
        + **USER**
        + **USER_GROUP**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the user (group).
        Changing this creates a new resource.
        This parameter is required when `type` is set to **USER_GROUP**.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AppImageServerAuthorizeAccountArgsDict(TypedDict):
        account: pulumi.Input[_builtins.str]
        """
        Specifies the name of the account.
        Changing this creates a new resource.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the disk type of the image server.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the domain name of the Workspace service.
        Changing this creates a new resource.

        <a name="app_image_server_root_volume"></a>
        The `root_volume` block supports:
        """
elif False:
    AppImageServerAuthorizeAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageServerAuthorizeAccountArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 domain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account: Specifies the name of the account.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] type: Specifies the disk type of the image server.
               Changing this creates a new resource.
               The valid values are as follows:
               + **ESSD**: Extreme SSD type.
               + **SSD**: Ultra-high I/O type.
               + **GPSSD**: General purpose SSD type.
               + **SAS**: High I/O type.
               + **SATA**: Common I/O type.
        :param pulumi.Input[_builtins.str] domain: Specifies the domain name of the Workspace service.
               Changing this creates a new resource.
               
               <a name="app_image_server_root_volume"></a>
               The `root_volume` block supports:
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "type", type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @_builtins.property
    @pulumi.getter
    def account(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the account.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type of the image server.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the domain name of the Workspace service.
        Changing this creates a new resource.

        <a name="app_image_server_root_volume"></a>
        The `root_volume` block supports:
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)


if not MYPY:
    class AppImageServerRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the disk size of the image server, in GB.
        Changing this creates a new resource.
        The system disk size must be sufficient for the basic image and the application to be installed.

        <a name="app_image_server_route_policy"></a>
        The `route_policy` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the disk type of the image server.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
elif False:
    AppImageServerRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageServerRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the disk size of the image server, in GB.
               Changing this creates a new resource.
               The system disk size must be sufficient for the basic image and the application to be installed.
               
               <a name="app_image_server_route_policy"></a>
               The `route_policy` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the disk type of the image server.
               Changing this creates a new resource.
               The valid values are as follows:
               + **ESSD**: Extreme SSD type.
               + **SSD**: Ultra-high I/O type.
               + **GPSSD**: General purpose SSD type.
               + **SAS**: High I/O type.
               + **SATA**: Common I/O type.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the disk size of the image server, in GB.
        Changing this creates a new resource.
        The system disk size must be sufficient for the basic image and the application to be installed.

        <a name="app_image_server_route_policy"></a>
        The `route_policy` block supports:
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type of the image server.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppImageServerRoutePolicyArgsDict(TypedDict):
        cpu_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the CPU usage of the server. The unit is `%`.  
        Changing this creates a new resource.
        The valid value ranges from `1` to `100`.
        """
        max_session: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of session connections of the server.
        Changing this creates a new resource.
        The maximum number of sessions is equal to the default number of sessions plus the number of additional sessions.
        """
        mem_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the memory usage of the server. The unit is `%`.  
        Changing this creates a new resource.
        The valid value ranges from `1` to `100`.

        <a name="app_image_server_scheduler_hints"></a>
        The `scheduler_hints` block supports:
        """
elif False:
    AppImageServerRoutePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageServerRoutePolicyArgs:
    def __init__(__self__, *,
                 cpu_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 max_session: Optional[pulumi.Input[_builtins.int]] = None,
                 mem_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu_threshold: Specifies the CPU usage of the server. The unit is `%`.  
               Changing this creates a new resource.
               The valid value ranges from `1` to `100`.
        :param pulumi.Input[_builtins.int] max_session: Specifies the number of session connections of the server.
               Changing this creates a new resource.
               The maximum number of sessions is equal to the default number of sessions plus the number of additional sessions.
        :param pulumi.Input[_builtins.int] mem_threshold: Specifies the memory usage of the server. The unit is `%`.  
               Changing this creates a new resource.
               The valid value ranges from `1` to `100`.
               
               <a name="app_image_server_scheduler_hints"></a>
               The `scheduler_hints` block supports:
        """
        if cpu_threshold is not None:
            pulumi.set(__self__, "cpu_threshold", cpu_threshold)
        if max_session is not None:
            pulumi.set(__self__, "max_session", max_session)
        if mem_threshold is not None:
            pulumi.set(__self__, "mem_threshold", mem_threshold)

    @_builtins.property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the CPU usage of the server. The unit is `%`.  
        Changing this creates a new resource.
        The valid value ranges from `1` to `100`.
        """
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_threshold", value)

    @_builtins.property
    @pulumi.getter(name="maxSession")
    def max_session(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of session connections of the server.
        Changing this creates a new resource.
        The maximum number of sessions is equal to the default number of sessions plus the number of additional sessions.
        """
        return pulumi.get(self, "max_session")

    @max_session.setter
    def max_session(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_session", value)

    @_builtins.property
    @pulumi.getter(name="memThreshold")
    def mem_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the memory usage of the server. The unit is `%`.  
        Changing this creates a new resource.
        The valid value ranges from `1` to `100`.

        <a name="app_image_server_scheduler_hints"></a>
        The `scheduler_hints` block supports:
        """
        return pulumi.get(self, "mem_threshold")

    @mem_threshold.setter
    def mem_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_threshold", value)


if not MYPY:
    class AppImageServerSchedulerHintsArgsDict(TypedDict):
        dedicated_host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the dedicate host.
        Changing this creates a new resource.
        """
        tenancy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of the dedicate host.
        Changing this creates a new resource.
        """
elif False:
    AppImageServerSchedulerHintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageServerSchedulerHintsArgs:
    def __init__(__self__, *,
                 dedicated_host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tenancy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dedicated_host_id: Specifies the ID of the dedicate host.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] tenancy: Specifies the type of the dedicate host.
               Changing this creates a new resource.
        """
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the dedicate host.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "dedicated_host_id")

    @dedicated_host_id.setter
    def dedicated_host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_host_id", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the dedicate host.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenancy", value)


if not MYPY:
    class AppNasStorageStorageMetadataArgsDict(TypedDict):
        storage_class: pulumi.Input[_builtins.str]
        """
        Specifies the storage type.  
        The valid values are as follows:
        + **sfs**: SFS file system with v3.0 framework.

        Change this parameter will create a new resource.
        """
        storage_handle: pulumi.Input[_builtins.str]
        """
        Specifies the storage name.  
        Change this parameter will create a new resource.
        """
        export_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The storage access URL.
        """
elif False:
    AppNasStorageStorageMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppNasStorageStorageMetadataArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[_builtins.str],
                 storage_handle: pulumi.Input[_builtins.str],
                 export_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] storage_class: Specifies the storage type.  
               The valid values are as follows:
               + **sfs**: SFS file system with v3.0 framework.
               
               Change this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] storage_handle: Specifies the storage name.  
               Change this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] export_location: The storage access URL.
        """
        pulumi.set(__self__, "storage_class", storage_class)
        pulumi.set(__self__, "storage_handle", storage_handle)
        if export_location is not None:
            pulumi.set(__self__, "export_location", export_location)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the storage type.  
        The valid values are as follows:
        + **sfs**: SFS file system with v3.0 framework.

        Change this parameter will create a new resource.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter(name="storageHandle")
    def storage_handle(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the storage name.  
        Change this parameter will create a new resource.
        """
        return pulumi.get(self, "storage_handle")

    @storage_handle.setter
    def storage_handle(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_handle", value)

    @_builtins.property
    @pulumi.getter(name="exportLocation")
    def export_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The storage access URL.
        """
        return pulumi.get(self, "export_location")

    @export_location.setter
    def export_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "export_location", value)


if not MYPY:
    class AppPersonalFoldersAssignmentArgsDict(TypedDict):
        attach: pulumi.Input[_builtins.str]
        """
        Specifies the object name of personal folder assignment.  
        Change this parameter will create a new resource.
        """
        policy_statement_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the storage permission policy.  
        Change this parameter will create a new resource.
        """
        attach_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of personal folder assignment.  
        The valid value is **USER** (also default value).
        Change this parameter will create a new resource.
        """
elif False:
    AppPersonalFoldersAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppPersonalFoldersAssignmentArgs:
    def __init__(__self__, *,
                 attach: pulumi.Input[_builtins.str],
                 policy_statement_id: pulumi.Input[_builtins.str],
                 attach_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attach: Specifies the object name of personal folder assignment.  
               Change this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] policy_statement_id: Specifies the ID of the storage permission policy.  
               Change this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] attach_type: Specifies the type of personal folder assignment.  
               The valid value is **USER** (also default value).
               Change this parameter will create a new resource.
        """
        pulumi.set(__self__, "attach", attach)
        pulumi.set(__self__, "policy_statement_id", policy_statement_id)
        if attach_type is not None:
            pulumi.set(__self__, "attach_type", attach_type)

    @_builtins.property
    @pulumi.getter
    def attach(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object name of personal folder assignment.  
        Change this parameter will create a new resource.
        """
        return pulumi.get(self, "attach")

    @attach.setter
    def attach(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attach", value)

    @_builtins.property
    @pulumi.getter(name="policyStatementId")
    def policy_statement_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the storage permission policy.  
        Change this parameter will create a new resource.
        """
        return pulumi.get(self, "policy_statement_id")

    @policy_statement_id.setter
    def policy_statement_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_statement_id", value)

    @_builtins.property
    @pulumi.getter(name="attachType")
    def attach_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of personal folder assignment.  
        The valid value is **USER** (also default value).
        Change this parameter will create a new resource.
        """
        return pulumi.get(self, "attach_type")

    @attach_type.setter
    def attach_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attach_type", value)


if not MYPY:
    class AppPolicyGroupTargetArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the object ID.  
        If the `type` is set to **USER**, the ID means the user ID.
        If the `type` is set to **USERGROUP**, the ID means the user group ID.
        If the `type` is set to **APPGROUP**, the ID means the APP group ID.
        If the `type` is set to **OU**, the ID means the OU ID.
        If the `type` is set to **ALL**, the ID fixed with string **default-apply-all-targets**.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the object name.  
        If the `type` is set to **USER**, the name means the user name.
        If the `type` is set to **USERGROUP**, the name means the user group name.
        If the `type` is set to **APPGROUP**, the name means the APP group name.
        If the `type` is set to **OU**, the name means the OU name.
        If the `type` is set to **ALL**, the name fixed with string **All-Targets**.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the object type.  
        The valid values are as follows:
        + **USER**
        + **USERGROUP**
        + **APPGROUP**
        + **OU**
        + **ALL**
        """
elif False:
    AppPolicyGroupTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppPolicyGroupTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the object ID.  
               If the `type` is set to **USER**, the ID means the user ID.
               If the `type` is set to **USERGROUP**, the ID means the user group ID.
               If the `type` is set to **APPGROUP**, the ID means the APP group ID.
               If the `type` is set to **OU**, the ID means the OU ID.
               If the `type` is set to **ALL**, the ID fixed with string **default-apply-all-targets**.
        :param pulumi.Input[_builtins.str] name: Specifies the object name.  
               If the `type` is set to **USER**, the name means the user name.
               If the `type` is set to **USERGROUP**, the name means the user group name.
               If the `type` is set to **APPGROUP**, the name means the APP group name.
               If the `type` is set to **OU**, the name means the OU name.
               If the `type` is set to **ALL**, the name fixed with string **All-Targets**.
        :param pulumi.Input[_builtins.str] type: Specifies the object type.  
               The valid values are as follows:
               + **USER**
               + **USERGROUP**
               + **APPGROUP**
               + **OU**
               + **ALL**
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object ID.  
        If the `type` is set to **USER**, the ID means the user ID.
        If the `type` is set to **USERGROUP**, the ID means the user group ID.
        If the `type` is set to **APPGROUP**, the ID means the APP group ID.
        If the `type` is set to **OU**, the ID means the OU ID.
        If the `type` is set to **ALL**, the ID fixed with string **default-apply-all-targets**.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object name.  
        If the `type` is set to **USER**, the name means the user name.
        If the `type` is set to **USERGROUP**, the name means the user group name.
        If the `type` is set to **APPGROUP**, the name means the APP group name.
        If the `type` is set to **OU**, the name means the OU name.
        If the `type` is set to **ALL**, the name fixed with string **All-Targets**.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the object type.  
        The valid values are as follows:
        + **USER**
        + **USERGROUP**
        + **APPGROUP**
        + **OU**
        + **ALL**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppScheduleTaskScheduleTaskPolicyArgsDict(TypedDict):
        enforcement_enable: pulumi.Input[_builtins.bool]
        """
        Specifies whether to forcefully execute the task when there are
        active sessions.
        Defaults to **false**.
        """
elif False:
    AppScheduleTaskScheduleTaskPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppScheduleTaskScheduleTaskPolicyArgs:
    def __init__(__self__, *,
                 enforcement_enable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enforcement_enable: Specifies whether to forcefully execute the task when there are
               active sessions.
               Defaults to **false**.
        """
        pulumi.set(__self__, "enforcement_enable", enforcement_enable)

    @_builtins.property
    @pulumi.getter(name="enforcementEnable")
    def enforcement_enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to forcefully execute the task when there are
        active sessions.
        Defaults to **false**.
        """
        return pulumi.get(self, "enforcement_enable")

    @enforcement_enable.setter
    def enforcement_enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enforcement_enable", value)


if not MYPY:
    class AppScheduleTaskTargetInfoArgsDict(TypedDict):
        target_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the target object.
        """
        target_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the target object.  
        The valid values are as follows:
        + **SERVER**
        + **SERVER_GROUP**

        <a name="app_schedule_task_policy"></a>
        The `schedule_task_policy` block supports:
        """
elif False:
    AppScheduleTaskTargetInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppScheduleTaskTargetInfoArgs:
    def __init__(__self__, *,
                 target_id: pulumi.Input[_builtins.str],
                 target_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_id: Specifies the ID of the target object.
        :param pulumi.Input[_builtins.str] target_type: Specifies the type of the target object.  
               The valid values are as follows:
               + **SERVER**
               + **SERVER_GROUP**
               
               <a name="app_schedule_task_policy"></a>
               The `schedule_task_policy` block supports:
        """
        pulumi.set(__self__, "target_id", target_id)
        pulumi.set(__self__, "target_type", target_type)

    @_builtins.property
    @pulumi.getter(name="targetId")
    def target_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the target object.
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_id", value)

    @_builtins.property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the target object.  
        The valid values are as follows:
        + **SERVER**
        + **SERVER_GROUP**

        <a name="app_schedule_task_policy"></a>
        The `schedule_task_policy` block supports:
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_type", value)


if not MYPY:
    class AppServerGroupFlavorArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the flavor.
        """
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppServerGroupFlavorLinkArgsDict']]]]
        """
        The quick link information for relevant tags corresponding to server specifications.
        """
elif False:
    AppServerGroupFlavorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServerGroupFlavorArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['AppServerGroupFlavorLinkArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the flavor.
        :param pulumi.Input[Sequence[pulumi.Input['AppServerGroupFlavorLinkArgs']]] links: The quick link information for relevant tags corresponding to server specifications.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the flavor.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppServerGroupFlavorLinkArgs']]]]:
        """
        The quick link information for relevant tags corresponding to server specifications.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppServerGroupFlavorLinkArgs']]]]):
        pulumi.set(self, "links", value)


if not MYPY:
    class AppServerGroupFlavorLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[_builtins.str]]
        """
        The corresponding shortcut link.
        """
        rel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shortcut link tag name.
        """
elif False:
    AppServerGroupFlavorLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServerGroupFlavorLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[_builtins.str]] = None,
                 rel: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] href: The corresponding shortcut link.
        :param pulumi.Input[_builtins.str] rel: The shortcut link tag name.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The corresponding shortcut link.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "href", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shortcut link tag name.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class AppServerGroupIpVirtualArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Whether to enable IP virtualization. Defaults to **false**.  
        Changing this creates a new resource.

        <a name="app_server_group_route_policy"></a>
        The `route_policy` block supports:
        """
elif False:
    AppServerGroupIpVirtualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServerGroupIpVirtualArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enable: Whether to enable IP virtualization. Defaults to **false**.  
               Changing this creates a new resource.
               
               <a name="app_server_group_route_policy"></a>
               The `route_policy` block supports:
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether to enable IP virtualization. Defaults to **false**.  
        Changing this creates a new resource.

        <a name="app_server_group_route_policy"></a>
        The `route_policy` block supports:
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)


if not MYPY:
    class AppServerGroupRoutePolicyArgsDict(TypedDict):
        cpu_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The CPU usage of the server. The unit is `%`.  
        The valid value ranges from `1` to `100`.
        """
        max_session: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of session connections of the server.  
        The maximum number of sessions is equal to the default number of sessions plus the number of additional sessions.
        """
        mem_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The memory usage of the server. The unit is `%`.  
        The valid value ranges from `1` to `100`.
        """
elif False:
    AppServerGroupRoutePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServerGroupRoutePolicyArgs:
    def __init__(__self__, *,
                 cpu_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 max_session: Optional[pulumi.Input[_builtins.int]] = None,
                 mem_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cpu_threshold: The CPU usage of the server. The unit is `%`.  
               The valid value ranges from `1` to `100`.
        :param pulumi.Input[_builtins.int] max_session: The number of session connections of the server.  
               The maximum number of sessions is equal to the default number of sessions plus the number of additional sessions.
        :param pulumi.Input[_builtins.int] mem_threshold: The memory usage of the server. The unit is `%`.  
               The valid value ranges from `1` to `100`.
        """
        if cpu_threshold is not None:
            pulumi.set(__self__, "cpu_threshold", cpu_threshold)
        if max_session is not None:
            pulumi.set(__self__, "max_session", max_session)
        if mem_threshold is not None:
            pulumi.set(__self__, "mem_threshold", mem_threshold)

    @_builtins.property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The CPU usage of the server. The unit is `%`.  
        The valid value ranges from `1` to `100`.
        """
        return pulumi.get(self, "cpu_threshold")

    @cpu_threshold.setter
    def cpu_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cpu_threshold", value)

    @_builtins.property
    @pulumi.getter(name="maxSession")
    def max_session(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of session connections of the server.  
        The maximum number of sessions is equal to the default number of sessions plus the number of additional sessions.
        """
        return pulumi.get(self, "max_session")

    @max_session.setter
    def max_session(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_session", value)

    @_builtins.property
    @pulumi.getter(name="memThreshold")
    def mem_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The memory usage of the server. The unit is `%`.  
        The valid value ranges from `1` to `100`.
        """
        return pulumi.get(self, "mem_threshold")

    @mem_threshold.setter
    def mem_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "mem_threshold", value)


if not MYPY:
    class AppServerGroupScalingPolicyScalingPolicyBySessionArgsDict(TypedDict):
        session_usage_threshold: pulumi.Input[_builtins.int]
        """
        Specifies the total session usage threshold of the server group.
        """
        shrink_after_session_idle_minutes: pulumi.Input[_builtins.int]
        """
        Specifies the number of minutes to wait before releasing instances
        with no session connections.
        """
elif False:
    AppServerGroupScalingPolicyScalingPolicyBySessionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServerGroupScalingPolicyScalingPolicyBySessionArgs:
    def __init__(__self__, *,
                 session_usage_threshold: pulumi.Input[_builtins.int],
                 shrink_after_session_idle_minutes: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] session_usage_threshold: Specifies the total session usage threshold of the server group.
        :param pulumi.Input[_builtins.int] shrink_after_session_idle_minutes: Specifies the number of minutes to wait before releasing instances
               with no session connections.
        """
        pulumi.set(__self__, "session_usage_threshold", session_usage_threshold)
        pulumi.set(__self__, "shrink_after_session_idle_minutes", shrink_after_session_idle_minutes)

    @_builtins.property
    @pulumi.getter(name="sessionUsageThreshold")
    def session_usage_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the total session usage threshold of the server group.
        """
        return pulumi.get(self, "session_usage_threshold")

    @session_usage_threshold.setter
    def session_usage_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "session_usage_threshold", value)

    @_builtins.property
    @pulumi.getter(name="shrinkAfterSessionIdleMinutes")
    def shrink_after_session_idle_minutes(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the number of minutes to wait before releasing instances
        with no session connections.
        """
        return pulumi.get(self, "shrink_after_session_idle_minutes")

    @shrink_after_session_idle_minutes.setter
    def shrink_after_session_idle_minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "shrink_after_session_idle_minutes", value)


if not MYPY:
    class AppServerRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the disk size of the server, in GB.
        Changing this creates a new resource.

        <a name="app_server_scheduler_hints"></a>
        The `scheduler_hints` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the disk type of the server.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
elif False:
    AppServerRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServerRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the disk size of the server, in GB.
               Changing this creates a new resource.
               
               <a name="app_server_scheduler_hints"></a>
               The `scheduler_hints` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the disk type of the server.
               Changing this creates a new resource.
               The valid values are as follows:
               + **ESSD**: Extreme SSD type.
               + **SSD**: Ultra-high I/O type.
               + **GPSSD**: General purpose SSD type.
               + **SAS**: High I/O type.
               + **SATA**: Common I/O type.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the disk size of the server, in GB.
        Changing this creates a new resource.

        <a name="app_server_scheduler_hints"></a>
        The `scheduler_hints` block supports:
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type of the server.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppServerSchedulerHintsArgsDict(TypedDict):
        dedicated_host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the dedicate host.
        Changing this creates a new resource.
        """
        tenancy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of the dedicate host.
        Changing this creates a new resource.
        Currently, only **dedicated** is supported.
        """
elif False:
    AppServerSchedulerHintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppServerSchedulerHintsArgs:
    def __init__(__self__, *,
                 dedicated_host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tenancy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dedicated_host_id: Specifies the ID of the dedicate host.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] tenancy: Specifies the type of the dedicate host.
               Changing this creates a new resource.
               Currently, only **dedicated** is supported.
        """
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the dedicate host.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "dedicated_host_id")

    @dedicated_host_id.setter
    def dedicated_host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_host_id", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the dedicate host.
        Changing this creates a new resource.
        Currently, only **dedicated** is supported.
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenancy", value)


if not MYPY:
    class ApplicationApplicationFileStoreArgsDict(TypedDict):
        store_type: pulumi.Input[_builtins.str]
        """
        Specifies the store type of the application file.  
        The valid values are as follows:
        + **OBS**: Object Storage Service bucket store.
        + **LINK**: External file link.
        """
        bucket_store: NotRequired[pulumi.Input['ApplicationApplicationFileStoreBucketStoreArgsDict']]
        """
        Specifies the OBS bucket store configuration.  
        The bucket_store structure is documented below.
        Required if the value of parameter `store_type` is **OBS**.
        """
        file_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the external file link.  
        Required if the value of parameter `store_type` is **LINK**.

        <a name="workspace_application_bucket_store"></a>
        The `bucket_store` block supports:
        """
elif False:
    ApplicationApplicationFileStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationApplicationFileStoreArgs:
    def __init__(__self__, *,
                 store_type: pulumi.Input[_builtins.str],
                 bucket_store: Optional[pulumi.Input['ApplicationApplicationFileStoreBucketStoreArgs']] = None,
                 file_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] store_type: Specifies the store type of the application file.  
               The valid values are as follows:
               + **OBS**: Object Storage Service bucket store.
               + **LINK**: External file link.
        :param pulumi.Input['ApplicationApplicationFileStoreBucketStoreArgs'] bucket_store: Specifies the OBS bucket store configuration.  
               The bucket_store structure is documented below.
               Required if the value of parameter `store_type` is **OBS**.
        :param pulumi.Input[_builtins.str] file_link: Specifies the external file link.  
               Required if the value of parameter `store_type` is **LINK**.
               
               <a name="workspace_application_bucket_store"></a>
               The `bucket_store` block supports:
        """
        pulumi.set(__self__, "store_type", store_type)
        if bucket_store is not None:
            pulumi.set(__self__, "bucket_store", bucket_store)
        if file_link is not None:
            pulumi.set(__self__, "file_link", file_link)

    @_builtins.property
    @pulumi.getter(name="storeType")
    def store_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the store type of the application file.  
        The valid values are as follows:
        + **OBS**: Object Storage Service bucket store.
        + **LINK**: External file link.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "store_type", value)

    @_builtins.property
    @pulumi.getter(name="bucketStore")
    def bucket_store(self) -> Optional[pulumi.Input['ApplicationApplicationFileStoreBucketStoreArgs']]:
        """
        Specifies the OBS bucket store configuration.  
        The bucket_store structure is documented below.
        Required if the value of parameter `store_type` is **OBS**.
        """
        return pulumi.get(self, "bucket_store")

    @bucket_store.setter
    def bucket_store(self, value: Optional[pulumi.Input['ApplicationApplicationFileStoreBucketStoreArgs']]):
        pulumi.set(self, "bucket_store", value)

    @_builtins.property
    @pulumi.getter(name="fileLink")
    def file_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the external file link.  
        Required if the value of parameter `store_type` is **LINK**.

        <a name="workspace_application_bucket_store"></a>
        The `bucket_store` block supports:
        """
        return pulumi.get(self, "file_link")

    @file_link.setter
    def file_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_link", value)


if not MYPY:
    class ApplicationApplicationFileStoreBucketStoreArgsDict(TypedDict):
        bucket_file_path: pulumi.Input[_builtins.str]
        """
        Specifies the file path in the OBS bucket.
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the OBS bucket.
        """
elif False:
    ApplicationApplicationFileStoreBucketStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationApplicationFileStoreBucketStoreArgs:
    def __init__(__self__, *,
                 bucket_file_path: pulumi.Input[_builtins.str],
                 bucket_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket_file_path: Specifies the file path in the OBS bucket.
        :param pulumi.Input[_builtins.str] bucket_name: Specifies the name of the OBS bucket.
        """
        pulumi.set(__self__, "bucket_file_path", bucket_file_path)
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketFilePath")
    def bucket_file_path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the file path in the OBS bucket.
        """
        return pulumi.get(self, "bucket_file_path")

    @bucket_file_path.setter
    def bucket_file_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_file_path", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the OBS bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class ApplicationRuleDetailArgsDict(TypedDict):
        scope: pulumi.Input[_builtins.str]
        """
        Specifies the scope of the application rule.  
        The valid values are as follows:
        + **PRODUCT**
        + **PATH**
        """
        path_rule: NotRequired[pulumi.Input['ApplicationRuleDetailPathRuleArgsDict']]
        """
        Specifies the detail of the path rule.  
        The path_rule structure is documented below.

        > Required if the value of parameter `scope` is **PATH**.

        <a name="workspace_application_product_rule_config"></a>
        The `product_rule` block supports:
        """
        product_rule: NotRequired[pulumi.Input['ApplicationRuleDetailProductRuleArgsDict']]
        """
        Specifies the detail of the product rule.  
        The product_rule structure is documented below.

        > Required if the value of parameter `scope` is **PRODUCT**.
        """
elif False:
    ApplicationRuleDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationRuleDetailArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[_builtins.str],
                 path_rule: Optional[pulumi.Input['ApplicationRuleDetailPathRuleArgs']] = None,
                 product_rule: Optional[pulumi.Input['ApplicationRuleDetailProductRuleArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] scope: Specifies the scope of the application rule.  
               The valid values are as follows:
               + **PRODUCT**
               + **PATH**
        :param pulumi.Input['ApplicationRuleDetailPathRuleArgs'] path_rule: Specifies the detail of the path rule.  
               The path_rule structure is documented below.
               
               > Required if the value of parameter `scope` is **PATH**.
               
               <a name="workspace_application_product_rule_config"></a>
               The `product_rule` block supports:
        :param pulumi.Input['ApplicationRuleDetailProductRuleArgs'] product_rule: Specifies the detail of the product rule.  
               The product_rule structure is documented below.
               
               > Required if the value of parameter `scope` is **PRODUCT**.
        """
        pulumi.set(__self__, "scope", scope)
        if path_rule is not None:
            pulumi.set(__self__, "path_rule", path_rule)
        if product_rule is not None:
            pulumi.set(__self__, "product_rule", product_rule)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the scope of the application rule.  
        The valid values are as follows:
        + **PRODUCT**
        + **PATH**
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="pathRule")
    def path_rule(self) -> Optional[pulumi.Input['ApplicationRuleDetailPathRuleArgs']]:
        """
        Specifies the detail of the path rule.  
        The path_rule structure is documented below.

        > Required if the value of parameter `scope` is **PATH**.

        <a name="workspace_application_product_rule_config"></a>
        The `product_rule` block supports:
        """
        return pulumi.get(self, "path_rule")

    @path_rule.setter
    def path_rule(self, value: Optional[pulumi.Input['ApplicationRuleDetailPathRuleArgs']]):
        pulumi.set(self, "path_rule", value)

    @_builtins.property
    @pulumi.getter(name="productRule")
    def product_rule(self) -> Optional[pulumi.Input['ApplicationRuleDetailProductRuleArgs']]:
        """
        Specifies the detail of the product rule.  
        The product_rule structure is documented below.

        > Required if the value of parameter `scope` is **PRODUCT**.
        """
        return pulumi.get(self, "product_rule")

    @product_rule.setter
    def product_rule(self, value: Optional[pulumi.Input['ApplicationRuleDetailProductRuleArgs']]):
        pulumi.set(self, "product_rule", value)


if not MYPY:
    class ApplicationRuleDetailPathRuleArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        Specifies the path where the product is installed.
        """
elif False:
    ApplicationRuleDetailPathRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationRuleDetailPathRuleArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path: Specifies the path where the product is installed.
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the path where the product is installed.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ApplicationRuleDetailProductRuleArgsDict(TypedDict):
        identify_condition: pulumi.Input[_builtins.str]
        """
        Specifies the identify condition of the product rule.  
        The valid values are as follows:
        + **publisher**
        + **product**
        + **process**
        """
        process_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the process name of the product.  
        Defaults to empty string, also you can configure this value as asterisk (*).

        > At least one of `publisher`, `product_name` and `process_name` must be provided,
        and both of them cannot be asterisk (*) or empty.
        """
        product_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the product.  
        Defaults to empty string, also you can configure this value as asterisk (*).

        > At least one of `publisher`, `product_name` and `process_name` must be provided,
        and both of them cannot be asterisk (*) or empty.
        """
        product_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the version of the product.

        <a name="workspace_application_path_rule_config"></a>
        The `path_rule` block supports:
        """
        publisher: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the publisher of the product.  
        Defaults to empty string, also you can configure this value as asterisk (*).

        > At least one of `publisher`, `product_name` and `process_name` must be provided,
        and both of them cannot be asterisk (*) or empty.
        """
        support_os: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the list of the supported operating system types.  
        Defaults to **Windows**
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the version of the product rule.
        """
elif False:
    ApplicationRuleDetailProductRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationRuleDetailProductRuleArgs:
    def __init__(__self__, *,
                 identify_condition: pulumi.Input[_builtins.str],
                 process_name: Optional[pulumi.Input[_builtins.str]] = None,
                 product_name: Optional[pulumi.Input[_builtins.str]] = None,
                 product_version: Optional[pulumi.Input[_builtins.str]] = None,
                 publisher: Optional[pulumi.Input[_builtins.str]] = None,
                 support_os: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] identify_condition: Specifies the identify condition of the product rule.  
               The valid values are as follows:
               + **publisher**
               + **product**
               + **process**
        :param pulumi.Input[_builtins.str] process_name: Specifies the process name of the product.  
               Defaults to empty string, also you can configure this value as asterisk (*).
               
               > At least one of `publisher`, `product_name` and `process_name` must be provided,
               and both of them cannot be asterisk (*) or empty.
        :param pulumi.Input[_builtins.str] product_name: Specifies the name of the product.  
               Defaults to empty string, also you can configure this value as asterisk (*).
               
               > At least one of `publisher`, `product_name` and `process_name` must be provided,
               and both of them cannot be asterisk (*) or empty.
        :param pulumi.Input[_builtins.str] product_version: Specifies the version of the product.
               
               <a name="workspace_application_path_rule_config"></a>
               The `path_rule` block supports:
        :param pulumi.Input[_builtins.str] publisher: Specifies the publisher of the product.  
               Defaults to empty string, also you can configure this value as asterisk (*).
               
               > At least one of `publisher`, `product_name` and `process_name` must be provided,
               and both of them cannot be asterisk (*) or empty.
        :param pulumi.Input[_builtins.str] support_os: Specifies the list of the supported operating system types.  
               Defaults to **Windows**
        :param pulumi.Input[_builtins.str] version: Specifies the version of the product rule.
        """
        pulumi.set(__self__, "identify_condition", identify_condition)
        if process_name is not None:
            pulumi.set(__self__, "process_name", process_name)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if product_version is not None:
            pulumi.set(__self__, "product_version", product_version)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if support_os is not None:
            pulumi.set(__self__, "support_os", support_os)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="identifyCondition")
    def identify_condition(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the identify condition of the product rule.  
        The valid values are as follows:
        + **publisher**
        + **product**
        + **process**
        """
        return pulumi.get(self, "identify_condition")

    @identify_condition.setter
    def identify_condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "identify_condition", value)

    @_builtins.property
    @pulumi.getter(name="processName")
    def process_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the process name of the product.  
        Defaults to empty string, also you can configure this value as asterisk (*).

        > At least one of `publisher`, `product_name` and `process_name` must be provided,
        and both of them cannot be asterisk (*) or empty.
        """
        return pulumi.get(self, "process_name")

    @process_name.setter
    def process_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "process_name", value)

    @_builtins.property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the product.  
        Defaults to empty string, also you can configure this value as asterisk (*).

        > At least one of `publisher`, `product_name` and `process_name` must be provided,
        and both of them cannot be asterisk (*) or empty.
        """
        return pulumi.get(self, "product_name")

    @product_name.setter
    def product_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_name", value)

    @_builtins.property
    @pulumi.getter(name="productVersion")
    def product_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the version of the product.

        <a name="workspace_application_path_rule_config"></a>
        The `path_rule` block supports:
        """
        return pulumi.get(self, "product_version")

    @product_version.setter
    def product_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "product_version", value)

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the publisher of the product.  
        Defaults to empty string, also you can configure this value as asterisk (*).

        > At least one of `publisher`, `product_name` and `process_name` must be provided,
        and both of them cannot be asterisk (*) or empty.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "publisher", value)

    @_builtins.property
    @pulumi.getter(name="supportOs")
    def support_os(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the list of the supported operating system types.  
        Defaults to **Windows**
        """
        return pulumi.get(self, "support_os")

    @support_os.setter
    def support_os(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "support_os", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the version of the product rule.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DesktopDataVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the size of system volume, in GB.
        + For root volume, the valid value is range from `80` to `1,020`.
        + For data volume, the valid value is range from `10` to `8,200`.

        <a name="desktop_nic"></a>
        The `nic` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of system volume.
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.

        > Updates are not supported for this parameter. Changing this will not create a new resource, but will throw an
        error.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time that the volume was created.
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device location to which the volume is attached.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The volume ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DesktopDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopDataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the size of system volume, in GB.
               + For root volume, the valid value is range from `80` to `1,020`.
               + For data volume, the valid value is range from `10` to `8,200`.
               
               <a name="desktop_nic"></a>
               The `nic` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the type of system volume.
               The valid values are as follows:
               + **SAS**: High I/O disk type.
               + **SSD**: Ultra-high I/O disk type.
               
               > Updates are not supported for this parameter. Changing this will not create a new resource, but will throw an
               error.
        :param pulumi.Input[_builtins.str] created_at: The time that the volume was created.
        :param pulumi.Input[_builtins.str] device: The device location to which the volume is attached.
        :param pulumi.Input[_builtins.str] id: The volume ID.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the size of system volume, in GB.
        + For root volume, the valid value is range from `80` to `1,020`.
        + For data volume, the valid value is range from `10` to `8,200`.

        <a name="desktop_nic"></a>
        The `nic` block supports:
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of system volume.
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.

        > Updates are not supported for this parameter. Changing this will not create a new resource, but will throw an
        error.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time that the volume was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device location to which the volume is attached.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The volume ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DesktopNicArgsDict(TypedDict):
        network_id: pulumi.Input[_builtins.str]
        """
        Specifies the network ID of subnet resource.
        """
elif False:
    DesktopNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopNicArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] network_id: Specifies the network ID of subnet resource.
        """
        pulumi.set(__self__, "network_id", network_id)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the network ID of subnet resource.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_id", value)


if not MYPY:
    class DesktopPoolAuthorizedObjectArgsDict(TypedDict):
        object_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the object.
        """
        object_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the object.
        """
        object_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the object.  
        The valid values are as follows:
        + **USER**
        + **USER_GROUP**
        """
        user_group: pulumi.Input[_builtins.str]
        """
        Specifies the permission group to which the user belongs.  
        The valid values are as follows:
        + **sudo**: Linux administrator group.
        + **default**: Linux default user group.
        + **administrators**: Windows administrator group.
        + **users**: Windows standard user group.

        <a name="desktop_pool_autoscale_policy"></a>
        The `autoscale_policy` block supports:
        """
elif False:
    DesktopPoolAuthorizedObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopPoolAuthorizedObjectArgs:
    def __init__(__self__, *,
                 object_id: pulumi.Input[_builtins.str],
                 object_name: pulumi.Input[_builtins.str],
                 object_type: pulumi.Input[_builtins.str],
                 user_group: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] object_id: Specifies the ID of the object.
        :param pulumi.Input[_builtins.str] object_name: Specifies the name of the object.
        :param pulumi.Input[_builtins.str] object_type: Specifies the type of the object.  
               The valid values are as follows:
               + **USER**
               + **USER_GROUP**
        :param pulumi.Input[_builtins.str] user_group: Specifies the permission group to which the user belongs.  
               The valid values are as follows:
               + **sudo**: Linux administrator group.
               + **default**: Linux default user group.
               + **administrators**: Windows administrator group.
               + **users**: Windows standard user group.
               
               <a name="desktop_pool_autoscale_policy"></a>
               The `autoscale_policy` block supports:
        """
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "object_name", object_name)
        pulumi.set(__self__, "object_type", object_type)
        pulumi.set(__self__, "user_group", user_group)

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the object.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_id", value)

    @_builtins.property
    @pulumi.getter(name="objectName")
    def object_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the object.
        """
        return pulumi.get(self, "object_name")

    @object_name.setter
    def object_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_name", value)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the object.  
        The valid values are as follows:
        + **USER**
        + **USER_GROUP**
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="userGroup")
    def user_group(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the permission group to which the user belongs.  
        The valid values are as follows:
        + **sudo**: Linux administrator group.
        + **default**: Linux default user group.
        + **administrators**: Windows administrator group.
        + **users**: Windows standard user group.

        <a name="desktop_pool_autoscale_policy"></a>
        The `autoscale_policy` block supports:
        """
        return pulumi.get(self, "user_group")

    @user_group.setter
    def user_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_group", value)


if not MYPY:
    class DesktopPoolAutoscalePolicyArgsDict(TypedDict):
        autoscale_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of automatic scaling policy.  
        The valid values are as follows:
        + **ACCESS_CREATED**: Create desktops during accessing.
        + **AUTO_CREATED**: Pre-creation desktops.
        """
        max_auto_created: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the maximum number of automatically created desktops.  
        The valid value ranges from `1` to `1,000`.
        """
        min_idle: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the desktops will be automatically created when the number of idle desktops is
        less than this value.
        The valid value ranges from `1` to `1,000`.
        """
        once_auto_created: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of desktops automatically created at one time.  
        The valid value ranges from `1` to `100`.

        <a name="desktop_pool_security_groups"></a>
        The `security_groups` block supports:
        """
elif False:
    DesktopPoolAutoscalePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopPoolAutoscalePolicyArgs:
    def __init__(__self__, *,
                 autoscale_type: Optional[pulumi.Input[_builtins.str]] = None,
                 max_auto_created: Optional[pulumi.Input[_builtins.int]] = None,
                 min_idle: Optional[pulumi.Input[_builtins.int]] = None,
                 once_auto_created: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] autoscale_type: Specifies the type of automatic scaling policy.  
               The valid values are as follows:
               + **ACCESS_CREATED**: Create desktops during accessing.
               + **AUTO_CREATED**: Pre-creation desktops.
        :param pulumi.Input[_builtins.int] max_auto_created: Specifies the maximum number of automatically created desktops.  
               The valid value ranges from `1` to `1,000`.
        :param pulumi.Input[_builtins.int] min_idle: Specifies the desktops will be automatically created when the number of idle desktops is
               less than this value.
               The valid value ranges from `1` to `1,000`.
        :param pulumi.Input[_builtins.int] once_auto_created: Specifies the number of desktops automatically created at one time.  
               The valid value ranges from `1` to `100`.
               
               <a name="desktop_pool_security_groups"></a>
               The `security_groups` block supports:
        """
        if autoscale_type is not None:
            pulumi.set(__self__, "autoscale_type", autoscale_type)
        if max_auto_created is not None:
            pulumi.set(__self__, "max_auto_created", max_auto_created)
        if min_idle is not None:
            pulumi.set(__self__, "min_idle", min_idle)
        if once_auto_created is not None:
            pulumi.set(__self__, "once_auto_created", once_auto_created)

    @_builtins.property
    @pulumi.getter(name="autoscaleType")
    def autoscale_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of automatic scaling policy.  
        The valid values are as follows:
        + **ACCESS_CREATED**: Create desktops during accessing.
        + **AUTO_CREATED**: Pre-creation desktops.
        """
        return pulumi.get(self, "autoscale_type")

    @autoscale_type.setter
    def autoscale_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "autoscale_type", value)

    @_builtins.property
    @pulumi.getter(name="maxAutoCreated")
    def max_auto_created(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the maximum number of automatically created desktops.  
        The valid value ranges from `1` to `1,000`.
        """
        return pulumi.get(self, "max_auto_created")

    @max_auto_created.setter
    def max_auto_created(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_auto_created", value)

    @_builtins.property
    @pulumi.getter(name="minIdle")
    def min_idle(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the desktops will be automatically created when the number of idle desktops is
        less than this value.
        The valid value ranges from `1` to `1,000`.
        """
        return pulumi.get(self, "min_idle")

    @min_idle.setter
    def min_idle(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_idle", value)

    @_builtins.property
    @pulumi.getter(name="onceAutoCreated")
    def once_auto_created(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of desktops automatically created at one time.  
        The valid value ranges from `1` to `100`.

        <a name="desktop_pool_security_groups"></a>
        The `security_groups` block supports:
        """
        return pulumi.get(self, "once_auto_created")

    @once_auto_created.setter
    def once_auto_created(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "once_auto_created", value)


if not MYPY:
    class DesktopPoolDataVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the size of the volume, in GB.
        + For root volume, the valid value ranges from `80` to `1,020`.
        + For data volume, the valid value ranges from `10` to `8,200`.

        <a name="desktop_pool_authorized_objects"></a>
        The `authorized_objects` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the volume.  
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the security group.
        """
elif False:
    DesktopPoolDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopPoolDataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the size of the volume, in GB.
               + For root volume, the valid value ranges from `80` to `1,020`.
               + For data volume, the valid value ranges from `10` to `8,200`.
               
               <a name="desktop_pool_authorized_objects"></a>
               The `authorized_objects` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the type of the volume.  
               The valid values are as follows:
               + **SAS**: High I/O disk type.
               + **SSD**: Ultra-high I/O disk type.
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the security group.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the size of the volume, in GB.
        + For root volume, the valid value ranges from `80` to `1,020`.
        + For data volume, the valid value ranges from `10` to `8,200`.

        <a name="desktop_pool_authorized_objects"></a>
        The `authorized_objects` block supports:
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the volume.  
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the security group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DesktopPoolProductArgsDict(TypedDict):
        charging_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product charging mode of the desktop pool.
        + **0**: The yearly/monthly billing mode.
        + **1**: The pay-per-use billing mode.
        """
        cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product CPU of the desktop pool.
        """
        descriptions: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product description of the desktop pool.
        """
        flavor_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product specification ID of the desktop pool.
        """
        memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        The product memory of the desktop pool.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of the volume.  
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.
        """
elif False:
    DesktopPoolProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopPoolProductArgs:
    def __init__(__self__, *,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 descriptions: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor_id: Optional[pulumi.Input[_builtins.str]] = None,
                 memory: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] charging_mode: The product charging mode of the desktop pool.
               + **0**: The yearly/monthly billing mode.
               + **1**: The pay-per-use billing mode.
        :param pulumi.Input[_builtins.str] cpu: The product CPU of the desktop pool.
        :param pulumi.Input[_builtins.str] descriptions: The product description of the desktop pool.
        :param pulumi.Input[_builtins.str] flavor_id: The product specification ID of the desktop pool.
        :param pulumi.Input[_builtins.str] memory: The product memory of the desktop pool.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the volume.  
               The valid values are as follows:
               + **SAS**: High I/O disk type.
               + **SSD**: Ultra-high I/O disk type.
        """
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if descriptions is not None:
            pulumi.set(__self__, "descriptions", descriptions)
        if flavor_id is not None:
            pulumi.set(__self__, "flavor_id", flavor_id)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product charging mode of the desktop pool.
        + **0**: The yearly/monthly billing mode.
        + **1**: The pay-per-use billing mode.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product CPU of the desktop pool.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def descriptions(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product description of the desktop pool.
        """
        return pulumi.get(self, "descriptions")

    @descriptions.setter
    def descriptions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "descriptions", value)

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product specification ID of the desktop pool.
        """
        return pulumi.get(self, "flavor_id")

    @flavor_id.setter
    def flavor_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor_id", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The product memory of the desktop pool.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of the volume.  
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DesktopPoolRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the size of the volume, in GB.
        + For root volume, the valid value ranges from `80` to `1,020`.
        + For data volume, the valid value ranges from `10` to `8,200`.

        <a name="desktop_pool_authorized_objects"></a>
        The `authorized_objects` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the volume.  
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the security group.
        """
elif False:
    DesktopPoolRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopPoolRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the size of the volume, in GB.
               + For root volume, the valid value ranges from `80` to `1,020`.
               + For data volume, the valid value ranges from `10` to `8,200`.
               
               <a name="desktop_pool_authorized_objects"></a>
               The `authorized_objects` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the type of the volume.  
               The valid values are as follows:
               + **SAS**: High I/O disk type.
               + **SSD**: Ultra-high I/O disk type.
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the security group.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the size of the volume, in GB.
        + For root volume, the valid value ranges from `80` to `1,020`.
        + For data volume, the valid value ranges from `10` to `8,200`.

        <a name="desktop_pool_authorized_objects"></a>
        The `authorized_objects` block supports:
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the volume.  
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the security group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DesktopPoolSecurityGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the security group.
        """
elif False:
    DesktopPoolSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopPoolSecurityGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the security group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the security group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DesktopRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.int]
        """
        Specifies the size of system volume, in GB.
        + For root volume, the valid value is range from `80` to `1,020`.
        + For data volume, the valid value is range from `10` to `8,200`.

        <a name="desktop_nic"></a>
        The `nic` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of system volume.
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.

        > Updates are not supported for this parameter. Changing this will not create a new resource, but will throw an
        error.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time that the volume was created.
        """
        device: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device location to which the volume is attached.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The volume ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DesktopRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DesktopRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 device: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the size of system volume, in GB.
               + For root volume, the valid value is range from `80` to `1,020`.
               + For data volume, the valid value is range from `10` to `8,200`.
               
               <a name="desktop_nic"></a>
               The `nic` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the type of system volume.
               The valid values are as follows:
               + **SAS**: High I/O disk type.
               + **SSD**: Ultra-high I/O disk type.
               
               > Updates are not supported for this parameter. Changing this will not create a new resource, but will throw an
               error.
        :param pulumi.Input[_builtins.str] created_at: The time that the volume was created.
        :param pulumi.Input[_builtins.str] device: The device location to which the volume is attached.
        :param pulumi.Input[_builtins.str] id: The volume ID.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the size of system volume, in GB.
        + For root volume, the valid value is range from `80` to `1,020`.
        + For data volume, the valid value is range from `10` to `8,200`.

        <a name="desktop_nic"></a>
        The `nic` block supports:
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of system volume.
        The valid values are as follows:
        + **SAS**: High I/O disk type.
        + **SSD**: Ultra-high I/O disk type.

        > Updates are not supported for this parameter. Changing this will not create a new resource, but will throw an
        error.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time that the volume was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device location to which the volume is attached.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The volume ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PolicyGroupPolicyArgsDict(TypedDict):
        access_control: pulumi.Input['PolicyGroupPolicyAccessControlArgsDict']
        """
        Specifies the configuration of the access policy control.
        The access_control structure is documented below.

        <a name="policy_group_access_control"></a>
        The `access_control` block supports:
        """
elif False:
    PolicyGroupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyGroupPolicyArgs:
    def __init__(__self__, *,
                 access_control: pulumi.Input['PolicyGroupPolicyAccessControlArgs']):
        """
        :param pulumi.Input['PolicyGroupPolicyAccessControlArgs'] access_control: Specifies the configuration of the access policy control.
               The access_control structure is documented below.
               
               <a name="policy_group_access_control"></a>
               The `access_control` block supports:
        """
        pulumi.set(__self__, "access_control", access_control)

    @_builtins.property
    @pulumi.getter(name="accessControl")
    def access_control(self) -> pulumi.Input['PolicyGroupPolicyAccessControlArgs']:
        """
        Specifies the configuration of the access policy control.
        The access_control structure is documented below.

        <a name="policy_group_access_control"></a>
        The `access_control` block supports:
        """
        return pulumi.get(self, "access_control")

    @access_control.setter
    def access_control(self, value: pulumi.Input['PolicyGroupPolicyAccessControlArgs']):
        pulumi.set(self, "access_control", value)


if not MYPY:
    class PolicyGroupPolicyAccessControlArgsDict(TypedDict):
        ip_access_control: pulumi.Input[_builtins.str]
        """
        Specifies the IP access control.  
        It consists of multiple groups of IP addresses and network masks, separated by ';',
        and spliced together by '|' between IP addresses and network masks, e.g. `IP|mask;IP|mask;IP|mask`
        """
elif False:
    PolicyGroupPolicyAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyGroupPolicyAccessControlArgs:
    def __init__(__self__, *,
                 ip_access_control: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip_access_control: Specifies the IP access control.  
               It consists of multiple groups of IP addresses and network masks, separated by ';',
               and spliced together by '|' between IP addresses and network masks, e.g. `IP|mask;IP|mask;IP|mask`
        """
        pulumi.set(__self__, "ip_access_control", ip_access_control)

    @_builtins.property
    @pulumi.getter(name="ipAccessControl")
    def ip_access_control(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP access control.  
        It consists of multiple groups of IP addresses and network masks, separated by ';',
        and spliced together by '|' between IP addresses and network masks, e.g. `IP|mask;IP|mask;IP|mask`
        """
        return pulumi.get(self, "ip_access_control")

    @ip_access_control.setter
    def ip_access_control(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_access_control", value)


if not MYPY:
    class PolicyGroupTargetArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the target ID.  
        If the `targets` type is **INSTANCE**, the ID means the SID of the desktop.
        If the `targets` type is **USER**, the ID means the user ID.
        If the `targets` type is **USERGROUP**, the ID means the user group ID.
        If the `targets` type is **CLIENTIP**, the ID means the terminal IP address.
        If the `targets` type is **OU**, the ID means the OUID.
        If the `targets` type is **ALL**, the ID fixed with string **default-apply-all-targets**.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the target name.  
        If the `targets` type is **INSTANCE**, the ID means the desktop name.
        If the `targets` type is **USER**, the ID means the user name.
        If the `targets` type is **USERGROUP**, the ID means the user group name.
        If the `targets` type is **CLIENTIP**, the ID means the terminal IP address.
        If the `targets` type is **OU**, the ID means the OU name.
        If the `targets` type is **ALL**, the ID fixed with string **All-Targets**.

        <a name="policy_group_policy"></a>
        The `policy` block supports:
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the target type.
        The valid values are as follows:
        + **INSTANCE**: Desktop.
        + **USER**: User.
        + **USERGROUP**: User group.
        + **CLIENTIP**: Terminal IP address.
        + **OU**: Organization unit.
        + **ALL**: All desktops.
        """
elif False:
    PolicyGroupTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyGroupTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the target ID.  
               If the `targets` type is **INSTANCE**, the ID means the SID of the desktop.
               If the `targets` type is **USER**, the ID means the user ID.
               If the `targets` type is **USERGROUP**, the ID means the user group ID.
               If the `targets` type is **CLIENTIP**, the ID means the terminal IP address.
               If the `targets` type is **OU**, the ID means the OUID.
               If the `targets` type is **ALL**, the ID fixed with string **default-apply-all-targets**.
        :param pulumi.Input[_builtins.str] name: Specifies the target name.  
               If the `targets` type is **INSTANCE**, the ID means the desktop name.
               If the `targets` type is **USER**, the ID means the user name.
               If the `targets` type is **USERGROUP**, the ID means the user group name.
               If the `targets` type is **CLIENTIP**, the ID means the terminal IP address.
               If the `targets` type is **OU**, the ID means the OU name.
               If the `targets` type is **ALL**, the ID fixed with string **All-Targets**.
               
               <a name="policy_group_policy"></a>
               The `policy` block supports:
        :param pulumi.Input[_builtins.str] type: Specifies the target type.
               The valid values are as follows:
               + **INSTANCE**: Desktop.
               + **USER**: User.
               + **USERGROUP**: User group.
               + **CLIENTIP**: Terminal IP address.
               + **OU**: Organization unit.
               + **ALL**: All desktops.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the target ID.  
        If the `targets` type is **INSTANCE**, the ID means the SID of the desktop.
        If the `targets` type is **USER**, the ID means the user ID.
        If the `targets` type is **USERGROUP**, the ID means the user group ID.
        If the `targets` type is **CLIENTIP**, the ID means the terminal IP address.
        If the `targets` type is **OU**, the ID means the OUID.
        If the `targets` type is **ALL**, the ID fixed with string **default-apply-all-targets**.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the target name.  
        If the `targets` type is **INSTANCE**, the ID means the desktop name.
        If the `targets` type is **USER**, the ID means the user name.
        If the `targets` type is **USERGROUP**, the ID means the user group name.
        If the `targets` type is **CLIENTIP**, the ID means the terminal IP address.
        If the `targets` type is **OU**, the ID means the OU name.
        If the `targets` type is **ALL**, the ID fixed with string **All-Targets**.

        <a name="policy_group_policy"></a>
        The `policy` block supports:
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the target type.
        The valid values are as follows:
        + **INSTANCE**: Desktop.
        + **USER**: User.
        + **USERGROUP**: User group.
        + **CLIENTIP**: Terminal IP address.
        + **OU**: Organization unit.
        + **ALL**: All desktops.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceAdDomainArgsDict(TypedDict):
        active_domain_ip: pulumi.Input[_builtins.str]
        """
        Specifies the IP address of primary domain controller.
        """
        active_domain_name: pulumi.Input[_builtins.str]
        """
        Specifies the name of primary domain controller.
        """
        admin_account: pulumi.Input[_builtins.str]
        """
        Specifies the domain administrator account.
        It must be an existing domain administrator account on the AD server.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the domain name.
        The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
        password: pulumi.Input[_builtins.str]
        """
        Specifies the account password of domain administrator.
        """
        active_dns_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the primary DNS IP address.
        """
        delete_computer_object: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to delete the corresponding computer object on AD
        while deleting the desktop.

        <a name="config_info"></a>
        The `otp_config_info` block supports:
        """
        standby_dns_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the standby DNS IP address.
        """
        standby_domain_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the IP address of the standby domain controller.
        """
        standby_domain_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the standby domain controller.
        """
elif False:
    ServiceAdDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAdDomainArgs:
    def __init__(__self__, *,
                 active_domain_ip: pulumi.Input[_builtins.str],
                 active_domain_name: pulumi.Input[_builtins.str],
                 admin_account: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 active_dns_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_computer_object: Optional[pulumi.Input[_builtins.bool]] = None,
                 standby_dns_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 standby_domain_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 standby_domain_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] active_domain_ip: Specifies the IP address of primary domain controller.
        :param pulumi.Input[_builtins.str] active_domain_name: Specifies the name of primary domain controller.
        :param pulumi.Input[_builtins.str] admin_account: Specifies the domain administrator account.
               It must be an existing domain administrator account on the AD server.
        :param pulumi.Input[_builtins.str] name: Specifies the domain name.
               The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        :param pulumi.Input[_builtins.str] password: Specifies the account password of domain administrator.
        :param pulumi.Input[_builtins.str] active_dns_ip: Specifies the primary DNS IP address.
        :param pulumi.Input[_builtins.bool] delete_computer_object: Specifies whether to delete the corresponding computer object on AD
               while deleting the desktop.
               
               <a name="config_info"></a>
               The `otp_config_info` block supports:
        :param pulumi.Input[_builtins.str] standby_dns_ip: Specifies the standby DNS IP address.
        :param pulumi.Input[_builtins.str] standby_domain_ip: Specifies the IP address of the standby domain controller.
        :param pulumi.Input[_builtins.str] standby_domain_name: Specifies the name of the standby domain controller.
        """
        pulumi.set(__self__, "active_domain_ip", active_domain_ip)
        pulumi.set(__self__, "active_domain_name", active_domain_name)
        pulumi.set(__self__, "admin_account", admin_account)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        if active_dns_ip is not None:
            pulumi.set(__self__, "active_dns_ip", active_dns_ip)
        if delete_computer_object is not None:
            pulumi.set(__self__, "delete_computer_object", delete_computer_object)
        if standby_dns_ip is not None:
            pulumi.set(__self__, "standby_dns_ip", standby_dns_ip)
        if standby_domain_ip is not None:
            pulumi.set(__self__, "standby_domain_ip", standby_domain_ip)
        if standby_domain_name is not None:
            pulumi.set(__self__, "standby_domain_name", standby_domain_name)

    @_builtins.property
    @pulumi.getter(name="activeDomainIp")
    def active_domain_ip(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP address of primary domain controller.
        """
        return pulumi.get(self, "active_domain_ip")

    @active_domain_ip.setter
    def active_domain_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "active_domain_ip", value)

    @_builtins.property
    @pulumi.getter(name="activeDomainName")
    def active_domain_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of primary domain controller.
        """
        return pulumi.get(self, "active_domain_name")

    @active_domain_name.setter
    def active_domain_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "active_domain_name", value)

    @_builtins.property
    @pulumi.getter(name="adminAccount")
    def admin_account(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the domain administrator account.
        It must be an existing domain administrator account on the AD server.
        """
        return pulumi.get(self, "admin_account")

    @admin_account.setter
    def admin_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "admin_account", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the domain name.
        The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the account password of domain administrator.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="activeDnsIp")
    def active_dns_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the primary DNS IP address.
        """
        return pulumi.get(self, "active_dns_ip")

    @active_dns_ip.setter
    def active_dns_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "active_dns_ip", value)

    @_builtins.property
    @pulumi.getter(name="deleteComputerObject")
    def delete_computer_object(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to delete the corresponding computer object on AD
        while deleting the desktop.

        <a name="config_info"></a>
        The `otp_config_info` block supports:
        """
        return pulumi.get(self, "delete_computer_object")

    @delete_computer_object.setter
    def delete_computer_object(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_computer_object", value)

    @_builtins.property
    @pulumi.getter(name="standbyDnsIp")
    def standby_dns_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the standby DNS IP address.
        """
        return pulumi.get(self, "standby_dns_ip")

    @standby_dns_ip.setter
    def standby_dns_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "standby_dns_ip", value)

    @_builtins.property
    @pulumi.getter(name="standbyDomainIp")
    def standby_domain_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the IP address of the standby domain controller.
        """
        return pulumi.get(self, "standby_domain_ip")

    @standby_domain_ip.setter
    def standby_domain_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "standby_domain_ip", value)

    @_builtins.property
    @pulumi.getter(name="standbyDomainName")
    def standby_domain_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the standby domain controller.
        """
        return pulumi.get(self, "standby_domain_name")

    @standby_domain_name.setter
    def standby_domain_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "standby_domain_name", value)


if not MYPY:
    class ServiceDesktopSecurityGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Security group ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the domain name.
        The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
elif False:
    ServiceDesktopSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDesktopSecurityGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Security group ID.
        :param pulumi.Input[_builtins.str] name: Specifies the domain name.
               The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Security group ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the domain name.
        The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ServiceInfrastructureSecurityGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Security group ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the domain name.
        The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
elif False:
    ServiceInfrastructureSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceInfrastructureSecurityGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Security group ID.
        :param pulumi.Input[_builtins.str] name: Specifies the domain name.
               The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Security group ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the domain name.
        The domain name must be an existing domain name on the AD server, and the length cannot exceed `55`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ServiceOtpConfigInfoArgsDict(TypedDict):
        enable: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable auxiliary authentication.
        """
        receive_mode: pulumi.Input[_builtins.str]
        """
        Specifies the verification code receiving mode.
        + **VMFA**: Indicates virtual MFA device.
        + **HMFA**: Indicates hardware MFA device.
        """
        app_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the auxiliary authentication server access account.
        """
        app_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the authentication service access password.
        """
        auth_server_access_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the authentication service access mode.
        + **INTERNET**: Indicates internet access.
        + **DEDICATED**: Indicates dedicated access.
        + **SYSTEM_DEFAULT**: Indicates system default.
        """
        auth_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the auxiliary authentication server address.
        """
        cert_content: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the PEM format certificate content.
        """
        rule: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies authentication application object.
        + **INTERNET**: Indicates Internet access. Optional only when rule_type is **ACCESS_MODE**.
        + **PRIVATE**: Indicates dedicated line access. Optional only when rule_type is **ACCESS_MODE**.
        """
        rule_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies authentication application object type.
        + **ACCESS_MODE**: Indicates access type.
        """
elif False:
    ServiceOtpConfigInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceOtpConfigInfoArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[_builtins.bool],
                 receive_mode: pulumi.Input[_builtins.str],
                 app_id: Optional[pulumi.Input[_builtins.str]] = None,
                 app_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_server_access_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 auth_url: Optional[pulumi.Input[_builtins.str]] = None,
                 cert_content: Optional[pulumi.Input[_builtins.str]] = None,
                 rule: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable: Specifies whether to enable auxiliary authentication.
        :param pulumi.Input[_builtins.str] receive_mode: Specifies the verification code receiving mode.
               + **VMFA**: Indicates virtual MFA device.
               + **HMFA**: Indicates hardware MFA device.
        :param pulumi.Input[_builtins.str] app_id: Specifies the auxiliary authentication server access account.
        :param pulumi.Input[_builtins.str] app_secret: Specifies the authentication service access password.
        :param pulumi.Input[_builtins.str] auth_server_access_mode: Specifies the authentication service access mode.
               + **INTERNET**: Indicates internet access.
               + **DEDICATED**: Indicates dedicated access.
               + **SYSTEM_DEFAULT**: Indicates system default.
        :param pulumi.Input[_builtins.str] auth_url: Specifies the auxiliary authentication server address.
        :param pulumi.Input[_builtins.str] cert_content: Specifies the PEM format certificate content.
        :param pulumi.Input[_builtins.str] rule: Specifies authentication application object.
               + **INTERNET**: Indicates Internet access. Optional only when rule_type is **ACCESS_MODE**.
               + **PRIVATE**: Indicates dedicated line access. Optional only when rule_type is **ACCESS_MODE**.
        :param pulumi.Input[_builtins.str] rule_type: Specifies authentication application object type.
               + **ACCESS_MODE**: Indicates access type.
        """
        pulumi.set(__self__, "enable", enable)
        pulumi.set(__self__, "receive_mode", receive_mode)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_secret is not None:
            pulumi.set(__self__, "app_secret", app_secret)
        if auth_server_access_mode is not None:
            pulumi.set(__self__, "auth_server_access_mode", auth_server_access_mode)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if cert_content is not None:
            pulumi.set(__self__, "cert_content", cert_content)
        if rule is not None:
            pulumi.set(__self__, "rule", rule)
        if rule_type is not None:
            pulumi.set(__self__, "rule_type", rule_type)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable auxiliary authentication.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable", value)

    @_builtins.property
    @pulumi.getter(name="receiveMode")
    def receive_mode(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the verification code receiving mode.
        + **VMFA**: Indicates virtual MFA device.
        + **HMFA**: Indicates hardware MFA device.
        """
        return pulumi.get(self, "receive_mode")

    @receive_mode.setter
    def receive_mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "receive_mode", value)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the auxiliary authentication server access account.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_id", value)

    @_builtins.property
    @pulumi.getter(name="appSecret")
    def app_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the authentication service access password.
        """
        return pulumi.get(self, "app_secret")

    @app_secret.setter
    def app_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app_secret", value)

    @_builtins.property
    @pulumi.getter(name="authServerAccessMode")
    def auth_server_access_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the authentication service access mode.
        + **INTERNET**: Indicates internet access.
        + **DEDICATED**: Indicates dedicated access.
        + **SYSTEM_DEFAULT**: Indicates system default.
        """
        return pulumi.get(self, "auth_server_access_mode")

    @auth_server_access_mode.setter
    def auth_server_access_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_server_access_mode", value)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the auxiliary authentication server address.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_url", value)

    @_builtins.property
    @pulumi.getter(name="certContent")
    def cert_content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the PEM format certificate content.
        """
        return pulumi.get(self, "cert_content")

    @cert_content.setter
    def cert_content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_content", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies authentication application object.
        + **INTERNET**: Indicates Internet access. Optional only when rule_type is **ACCESS_MODE**.
        + **PRIVATE**: Indicates dedicated line access. Optional only when rule_type is **ACCESS_MODE**.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies authentication application object type.
        + **ACCESS_MODE**: Indicates access type.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_type", value)


if not MYPY:
    class TerminalBindingBindingArgsDict(TypedDict):
        desktop_name: pulumi.Input[_builtins.str]
        """
        Specifies the desktop name.
        """
        mac: pulumi.Input[_builtins.str]
        """
        Specifies the MAC address.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the binding description.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the binding policy.
        """
elif False:
    TerminalBindingBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TerminalBindingBindingArgs:
    def __init__(__self__, *,
                 desktop_name: pulumi.Input[_builtins.str],
                 mac: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] desktop_name: Specifies the desktop name.
        :param pulumi.Input[_builtins.str] mac: Specifies the MAC address.
        :param pulumi.Input[_builtins.str] description: Specifies the binding description.
        :param pulumi.Input[_builtins.str] id: The ID of the binding policy.
        """
        pulumi.set(__self__, "desktop_name", desktop_name)
        pulumi.set(__self__, "mac", mac)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="desktopName")
    def desktop_name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the desktop name.
        """
        return pulumi.get(self, "desktop_name")

    @desktop_name.setter
    def desktop_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "desktop_name", value)

    @_builtins.property
    @pulumi.getter
    def mac(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the MAC address.
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mac", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the binding description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the binding policy.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class UserGroupUserArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the user ID to be added to the user group.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description of user group.
        """
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email of user.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the user group name.  
        > AD domain user group do not support renaming.
        """
        phone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The phone of user.
        """
        total_desktops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of desktops the user has.
        """
elif False:
    UserGroupUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupUserArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 phone: Optional[pulumi.Input[_builtins.str]] = None,
                 total_desktops: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the user ID to be added to the user group.
        :param pulumi.Input[_builtins.str] description: Specifies the description of user group.
        :param pulumi.Input[_builtins.str] email: The email of user.
        :param pulumi.Input[_builtins.str] name: Specifies the user group name.  
               > AD domain user group do not support renaming.
        :param pulumi.Input[_builtins.str] phone: The phone of user.
        :param pulumi.Input[_builtins.int] total_desktops: The number of desktops the user has.
        """
        pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phone is not None:
            pulumi.set(__self__, "phone", phone)
        if total_desktops is not None:
            pulumi.set(__self__, "total_desktops", total_desktops)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the user ID to be added to the user group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description of user group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email of user.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the user group name.  
        > AD domain user group do not support renaming.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def phone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The phone of user.
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phone", value)

    @_builtins.property
    @pulumi.getter(name="totalDesktops")
    def total_desktops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of desktops the user has.
        """
        return pulumi.get(self, "total_desktops")

    @total_desktops.setter
    def total_desktops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_desktops", value)


if not MYPY:
    class GetDesktopTagsFilterMatchArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the name of desktop property.
        """
        value: _builtins.str
        """
        Specifies the value of desktop property.  
        When the key is resource_name, it is a fuzzy search.
        """
elif False:
    GetDesktopTagsFilterMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDesktopTagsFilterMatchArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the name of desktop property.
        :param _builtins.str value: Specifies the value of desktop property.  
               When the key is resource_name, it is a fuzzy search.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the name of desktop property.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of desktop property.  
        When the key is resource_name, it is a fuzzy search.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetDesktopTagsFilterNotTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the name of desktop property.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
elif False:
    GetDesktopTagsFilterNotTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDesktopTagsFilterNotTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the name of desktop property.
        :param Sequence[_builtins.str] values: Specifies the list of tag values that matched corresponding key.
               
               <a name="workspace_desktop_filter_match"></a>
               The `match` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the name of desktop property.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetDesktopTagsFilterNotTagsAnyArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the name of desktop property.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
elif False:
    GetDesktopTagsFilterNotTagsAnyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDesktopTagsFilterNotTagsAnyArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the name of desktop property.
        :param Sequence[_builtins.str] values: Specifies the list of tag values that matched corresponding key.
               
               <a name="workspace_desktop_filter_match"></a>
               The `match` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the name of desktop property.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetDesktopTagsFilterTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the name of desktop property.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
elif False:
    GetDesktopTagsFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDesktopTagsFilterTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the name of desktop property.
        :param Sequence[_builtins.str] values: Specifies the list of tag values that matched corresponding key.
               
               <a name="workspace_desktop_filter_match"></a>
               The `match` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the name of desktop property.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetDesktopTagsFilterTagsAnyArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the name of desktop property.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
elif False:
    GetDesktopTagsFilterTagsAnyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDesktopTagsFilterTagsAnyArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the name of desktop property.
        :param Sequence[_builtins.str] values: Specifies the list of tag values that matched corresponding key.
               
               <a name="workspace_desktop_filter_match"></a>
               The `match` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the name of desktop property.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the list of tag values that matched corresponding key.

        <a name="workspace_desktop_filter_match"></a>
        The `match` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


