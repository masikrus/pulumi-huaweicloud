# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BandwidthPolicyIntervalAlarmAction',
    'BandwidthPolicyMetaData',
    'BandwidthPolicyScalingPolicyAction',
    'BandwidthPolicyScheduledPolicy',
    'ConfigurationInstanceConfig',
    'ConfigurationInstanceConfigDisk',
    'ConfigurationInstanceConfigPersonality',
    'ConfigurationInstanceConfigPublicIp',
    'ConfigurationInstanceConfigPublicIpEip',
    'ConfigurationInstanceConfigPublicIpEipBandwidth',
    'ConfigurationV1InstanceConfig',
    'ConfigurationV1InstanceConfigDisk',
    'ConfigurationV1InstanceConfigPersonality',
    'ConfigurationV1InstanceConfigPublicIp',
    'ConfigurationV1InstanceConfigPublicIpEip',
    'ConfigurationV1InstanceConfigPublicIpEipBandwidth',
    'GroupLbaasListener',
    'GroupNetwork',
    'GroupSecurityGroup',
    'GroupV1LbaasListener',
    'GroupV1Network',
    'GroupV1SecurityGroup',
    'PlannedTaskInstanceNumber',
    'PlannedTaskScheduledPolicy',
    'PolicyScalingPolicyAction',
    'PolicyScheduledPolicy',
    'PolicyV1ScalingPolicyAction',
    'PolicyV1ScheduledPolicy',
    'GetActivityLogsActivityLogResult',
    'GetActivityLogsV2ScalingActivityLogResult',
    'GetActivityLogsV2ScalingActivityLogInstanceAddedListResult',
    'GetActivityLogsV2ScalingActivityLogInstanceDeletedListResult',
    'GetActivityLogsV2ScalingActivityLogInstanceFailedListResult',
    'GetActivityLogsV2ScalingActivityLogInstanceRemovedListResult',
    'GetActivityLogsV2ScalingActivityLogInstanceStandbyListResult',
    'GetActivityLogsV2ScalingActivityLogLbBindFailedListResult',
    'GetActivityLogsV2ScalingActivityLogLbBindFailedListLbaasListenerResult',
    'GetActivityLogsV2ScalingActivityLogLbBindSuccessListResult',
    'GetActivityLogsV2ScalingActivityLogLbBindSuccessListLbaasListenerResult',
    'GetActivityLogsV2ScalingActivityLogLbUnbindFailedListResult',
    'GetActivityLogsV2ScalingActivityLogLbUnbindFailedListLbaasListenerResult',
    'GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListResult',
    'GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListLbaasListenerResult',
    'GetConfigurationsConfigurationResult',
    'GetConfigurationsConfigurationInstanceConfigResult',
    'GetConfigurationsConfigurationInstanceConfigDiskResult',
    'GetConfigurationsConfigurationInstanceConfigPersonalityResult',
    'GetConfigurationsConfigurationInstanceConfigPublicIpResult',
    'GetConfigurationsConfigurationInstanceConfigPublicIpEipResult',
    'GetConfigurationsConfigurationInstanceConfigPublicIpEipBandwidthResult',
    'GetGroupQuotasQuotaResult',
    'GetGroupQuotasQuotaResourceResult',
    'GetGroupTagsTagResult',
    'GetGroupsGroupResult',
    'GetGroupsGroupLbaasListenerResult',
    'GetGroupsGroupNetworkResult',
    'GetGroupsGroupSecurityGroupResult',
    'GetHookInstancesInstanceHangingInfoResult',
    'GetInstancesInstanceResult',
    'GetLifecycleHooksLifecycleHookResult',
    'GetNotificationsTopicResult',
    'GetPlannedTasksScheduledTaskResult',
    'GetPlannedTasksScheduledTaskInstanceNumberResult',
    'GetPlannedTasksScheduledTaskScheduledPolicyResult',
    'GetPoliciesPolicyResult',
    'GetPoliciesPolicyActionResult',
    'GetPoliciesPolicyScheduledPolicyResult',
    'GetPoliciesV2ScalingPolicyResult',
    'GetPoliciesV2ScalingPolicyMetaDataResult',
    'GetPoliciesV2ScalingPolicyScalingPolicyActionResult',
    'GetPoliciesV2ScalingPolicyScheduledPolicyResult',
    'GetPolicyExecuteLogsExecuteLogResult',
    'GetPolicyExecuteLogsExecuteLogJobRecordResult',
    'GetQuotasQuotaResult',
    'GetQuotasQuotaResourceResult',
]

@pulumi.output_type
class BandwidthPolicyIntervalAlarmAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lowerBound":
            suggest = "lower_bound"
        elif key == "upperBound":
            suggest = "upper_bound"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BandwidthPolicyIntervalAlarmAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BandwidthPolicyIntervalAlarmAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BandwidthPolicyIntervalAlarmAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limits: Optional[_builtins.int] = None,
                 lower_bound: Optional[_builtins.str] = None,
                 operation: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 upper_bound: Optional[_builtins.str] = None):
        """
        :param _builtins.int limits: Specifies the operation restrictions, unit is Mbit/s.
               The valid values from `1` to `2,000`.
               If `operation` is not **SET**, this parameter takes effect.
               If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
               If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        :param _builtins.str lower_bound: Specifies the lower limit of the value range.
               The value is null by default. The minimum lower limit allowed is `-1.174271E108`.
        :param _builtins.str operation: Specifies the operation to be performed.
               The valid values are as follows:
               + **ADD** (default): Indicates adding the bandwidth size.
               + **REDUCE**: Indicates reducing the bandwidth size.
               + **SET**: Indicates setting the bandwidth size to a specified value.
        :param _builtins.int size: Specifies the operation size, unit is Mbit/s.
               The valid values from `1` to `300`, the default value is `1`.
        :param _builtins.str upper_bound: Specifies the upper limit of the value range.
               The value is null by default. The maximum upper limit allowed is `1.174271E108`.
               
               > 1. If the `lower_bound` is null, the `upper_bound` must be less than or equal to `0`.
               <br/>2. If the `upper_bound` is null, the `lower_bound` must be greater than or equal to `0`.
               <br/>3. The `lower_bound` and the `upper_bound` cannot be both `0` at the same time.
               <br/>4. The `lower_bound` and `upper_bound` can not be less than `0` when the
               alarm rule `condition.comparison_operator` is set to **>** or **>=**.
               <br/>5. The `lower_bound` and `upper_bound` can be less than `0` when the
               alarm rule `condition.comparison_operator` is set to **<** or **<=**.
               <br/>6. If adding multiple alarm intervals, each interval value range cannot overlap.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if lower_bound is not None:
            pulumi.set(__self__, "lower_bound", lower_bound)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if upper_bound is not None:
            pulumi.set(__self__, "upper_bound", upper_bound)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[_builtins.int]:
        """
        Specifies the operation restrictions, unit is Mbit/s.
        The valid values from `1` to `2,000`.
        If `operation` is not **SET**, this parameter takes effect.
        If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
        If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> Optional[_builtins.str]:
        """
        Specifies the lower limit of the value range.
        The value is null by default. The minimum lower limit allowed is `-1.174271E108`.
        """
        return pulumi.get(self, "lower_bound")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[_builtins.str]:
        """
        Specifies the operation to be performed.
        The valid values are as follows:
        + **ADD** (default): Indicates adding the bandwidth size.
        + **REDUCE**: Indicates reducing the bandwidth size.
        + **SET**: Indicates setting the bandwidth size to a specified value.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Specifies the operation size, unit is Mbit/s.
        The valid values from `1` to `300`, the default value is `1`.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> Optional[_builtins.str]:
        """
        Specifies the upper limit of the value range.
        The value is null by default. The maximum upper limit allowed is `1.174271E108`.

        > 1. If the `lower_bound` is null, the `upper_bound` must be less than or equal to `0`.
        <br/>2. If the `upper_bound` is null, the `lower_bound` must be greater than or equal to `0`.
        <br/>3. The `lower_bound` and the `upper_bound` cannot be both `0` at the same time.
        <br/>4. The `lower_bound` and `upper_bound` can not be less than `0` when the
        alarm rule `condition.comparison_operator` is set to **>** or **>=**.
        <br/>5. The `lower_bound` and `upper_bound` can be less than `0` when the
        alarm rule `condition.comparison_operator` is set to **<** or **<=**.
        <br/>6. If adding multiple alarm intervals, each interval value range cannot overlap.
        """
        return pulumi.get(self, "upper_bound")


@pulumi.output_type
class BandwidthPolicyMetaData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataBandwidthShareType":
            suggest = "metadata_bandwidth_share_type"
        elif key == "metadataEipAddress":
            suggest = "metadata_eip_address"
        elif key == "metadataEipId":
            suggest = "metadata_eip_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BandwidthPolicyMetaData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BandwidthPolicyMetaData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BandwidthPolicyMetaData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_bandwidth_share_type: Optional[_builtins.str] = None,
                 metadata_eip_address: Optional[_builtins.str] = None,
                 metadata_eip_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str metadata_bandwidth_share_type: The bandwidth sharing type in the bandwidth policy.
        :param _builtins.str metadata_eip_address: The EIP IP address for the bandwidth in the bandwidth policy.
        :param _builtins.str metadata_eip_id: The EIP ID for the bandwidth in the bandwidth policy.
        """
        if metadata_bandwidth_share_type is not None:
            pulumi.set(__self__, "metadata_bandwidth_share_type", metadata_bandwidth_share_type)
        if metadata_eip_address is not None:
            pulumi.set(__self__, "metadata_eip_address", metadata_eip_address)
        if metadata_eip_id is not None:
            pulumi.set(__self__, "metadata_eip_id", metadata_eip_id)

    @_builtins.property
    @pulumi.getter(name="metadataBandwidthShareType")
    def metadata_bandwidth_share_type(self) -> Optional[_builtins.str]:
        """
        The bandwidth sharing type in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_bandwidth_share_type")

    @_builtins.property
    @pulumi.getter(name="metadataEipAddress")
    def metadata_eip_address(self) -> Optional[_builtins.str]:
        """
        The EIP IP address for the bandwidth in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_eip_address")

    @_builtins.property
    @pulumi.getter(name="metadataEipId")
    def metadata_eip_id(self) -> Optional[_builtins.str]:
        """
        The EIP ID for the bandwidth in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_eip_id")


@pulumi.output_type
class BandwidthPolicyScalingPolicyAction(dict):
    def __init__(__self__, *,
                 limits: Optional[_builtins.int] = None,
                 operation: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.int limits: Specifies the operation restrictions, unit is Mbit/s.
               The valid values from `1` to `2,000`.
               If `operation` is not **SET**, this parameter takes effect.
               If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
               If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        :param _builtins.str operation: Specifies the operation to be performed.
               The valid values are as follows:
               + **ADD** (default): Indicates adding the bandwidth size.
               + **REDUCE**: Indicates reducing the bandwidth size.
               + **SET**: Indicates setting the bandwidth size to a specified value.
        :param _builtins.int size: Specifies the operation size, unit is Mbit/s.
               The valid values from `1` to `300`, the default value is `1`.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[_builtins.int]:
        """
        Specifies the operation restrictions, unit is Mbit/s.
        The valid values from `1` to `2,000`.
        If `operation` is not **SET**, this parameter takes effect.
        If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
        If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[_builtins.str]:
        """
        Specifies the operation to be performed.
        The valid values are as follows:
        + **ADD** (default): Indicates adding the bandwidth size.
        + **REDUCE**: Indicates reducing the bandwidth size.
        + **SET**: Indicates setting the bandwidth size to a specified value.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Specifies the operation size, unit is Mbit/s.
        The valid values from `1` to `300`, the default value is `1`.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class BandwidthPolicyScheduledPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTime":
            suggest = "launch_time"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "recurrenceValue":
            suggest = "recurrence_value"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BandwidthPolicyScheduledPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BandwidthPolicyScheduledPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BandwidthPolicyScheduledPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_time: _builtins.str,
                 end_time: Optional[_builtins.str] = None,
                 recurrence_type: Optional[_builtins.str] = None,
                 recurrence_value: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str launch_time: Specifies the time when the scaling action is triggered.
               The time format complies with UTC.
               If `scaling_policy_type` is set to **SCHEDULED**, the time format is **YYYY-MM-DDThh:mmZ**.
               If `scaling_policy_type` is set to **RECURRENCE**, the time format is **hh:mm**.
        :param _builtins.str end_time: Specifies the end time of the scaling action triggered periodically.
               The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
               When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
               The time format is **YYYY-MM-DDThh:mmZ**.
               
               <a name="bandwidth_policy_interval_alarm"></a>
               The `interval_alarm_actions` block supports:
        :param _builtins.str recurrence_type: Specifies the periodic triggering type.
               This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
               The valid values are as follows:
               + **Daily**: Indicates that the scaling action is triggered once a day.
               + **Weekly**: Indicates that the scaling action is triggered once a week.
               + **Monthly**: Indicates that the scaling action is triggered once a month.
        :param _builtins.str recurrence_value: Specifies the day when a periodic scaling action is triggered.
               This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
               <br/>If `recurrence_type` is set to **Daily**, the value is null, indicating that the scaling action is triggered
               once a day.
               <br/>If `recurrence_type` is set to **Weekly**, the value ranges from `1` (Sunday) to `7` (Saturday).
               The digits refer to dates in each week and separated by a comma, such as **1,3,5**.
               <br/>If `recurrence_type` is set to **Monthly**, the value ranges from `1` to `31`.
               The digits refer to the dates in each month and separated by a comma, such as **1,10,13,28**.
        :param _builtins.str start_time: Specifies the start time of the scaling action triggered periodically.
               The time format complies with UTC. The default value is the local time.
               The time format is **YYYY-MM-DDThh:mmZ**.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> _builtins.str:
        """
        Specifies the time when the scaling action is triggered.
        The time format complies with UTC.
        If `scaling_policy_type` is set to **SCHEDULED**, the time format is **YYYY-MM-DDThh:mmZ**.
        If `scaling_policy_type` is set to **RECURRENCE**, the time format is **hh:mm**.
        """
        return pulumi.get(self, "launch_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Specifies the end time of the scaling action triggered periodically.
        The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
        When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
        The time format is **YYYY-MM-DDThh:mmZ**.

        <a name="bandwidth_policy_interval_alarm"></a>
        The `interval_alarm_actions` block supports:
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[_builtins.str]:
        """
        Specifies the periodic triggering type.
        This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
        The valid values are as follows:
        + **Daily**: Indicates that the scaling action is triggered once a day.
        + **Weekly**: Indicates that the scaling action is triggered once a week.
        + **Monthly**: Indicates that the scaling action is triggered once a month.
        """
        return pulumi.get(self, "recurrence_type")

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[_builtins.str]:
        """
        Specifies the day when a periodic scaling action is triggered.
        This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
        <br/>If `recurrence_type` is set to **Daily**, the value is null, indicating that the scaling action is triggered
        once a day.
        <br/>If `recurrence_type` is set to **Weekly**, the value ranges from `1` (Sunday) to `7` (Saturday).
        The digits refer to dates in each week and separated by a comma, such as **1,3,5**.
        <br/>If `recurrence_type` is set to **Monthly**, the value ranges from `1` to `31`.
        The digits refer to the dates in each month and separated by a comma, such as **1,10,13,28**.
        """
        return pulumi.get(self, "recurrence_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Specifies the start time of the scaling action triggered periodically.
        The time format complies with UTC. The default value is the local time.
        The time format is **YYYY-MM-DDThh:mmZ**.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ConfigurationInstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPass":
            suggest = "admin_pass"
        elif key == "chargingMode":
            suggest = "charging_mode"
        elif key == "dedicatedHostId":
            suggest = "dedicated_host_id"
        elif key == "ecsGroupId":
            suggest = "ecs_group_id"
        elif key == "flavorPriorityPolicy":
            suggest = "flavor_priority_policy"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "keyFingerprint":
            suggest = "key_fingerprint"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationInstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationInstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationInstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_pass: Optional[_builtins.str] = None,
                 charging_mode: Optional[_builtins.str] = None,
                 dedicated_host_id: Optional[_builtins.str] = None,
                 disks: Optional[Sequence['outputs.ConfigurationInstanceConfigDisk']] = None,
                 ecs_group_id: Optional[_builtins.str] = None,
                 flavor: Optional[_builtins.str] = None,
                 flavor_priority_policy: Optional[_builtins.str] = None,
                 image: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 key_fingerprint: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 personalities: Optional[Sequence['outputs.ConfigurationInstanceConfigPersonality']] = None,
                 public_ip: Optional['outputs.ConfigurationInstanceConfigPublicIp'] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 tenancy: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param _builtins.str admin_pass: Specifies the initial login password of the administrator account for
               logging in to an ECS using password authentication. The Windows administrator is `Administrator`.
               
               > Password complexity requirements:
               <br/>1. Consists of `8` to `26` characters.
               <br/>2. Contains at least three of the following character types: uppercase letters, lowercase letters, digits, and
               special characters `!@$%^-_=+[{}]:,./?`.
               <br/>3. The password cannot contain the username or the username in reversed order.
               <br/>4. The Windows ECS password cannot contain the username, the username in reversed order, or more than two
               consecutive characters in the username.
               
               > Field `admin_pass` is used for Windows system password authentication, and `user_data` is used for Linux system
               password authentication.
        :param _builtins.str charging_mode: Specifies a billing mode for an ECS.
               The value can be `postPaid` and `spot`. The default value is `postPaid`.
               Changing this will create a new resource.
        :param _builtins.str dedicated_host_id: Specifies the ID of the DEH.
               Changing this will create a new resource.
               
               > This parameter is valid only when `tenancy` is set to **dedicated**.
               <br/>If this parameter is specified, ECSs will be created on a specified DeH.
               <br/>If this parameter is not specified, the system automatically selects the DeH with the maximum available memory
               size from the DeHs that meet specifications requirements to create the ECSs, thereby balancing load of the DeHs.
        :param Sequence['ConfigurationInstanceConfigDiskArgs'] disks: Specifies the disk group information. System disks are mandatory and
               data disks are optional. The disk structure is documented below.
               Changing this will create a new resource.
        :param _builtins.str ecs_group_id: Specifies the ECS group ID. Changing this will create a new resource.
               
               > To ensure service reliability, an ECS group allows ECSs within in the group to be automatically allocated to
               different hosts.
        :param _builtins.str flavor: Specifies the ECS flavor name. A maximum of `10` flavors can be selected.
               Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        :param _builtins.str flavor_priority_policy: Specifies the priority policy used when there are multiple flavors
               and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.
               
               + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
               in the flavor list.
               + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.
               
               Changing this will create a new resource.
        :param _builtins.str image: Specifies the ECS image ID. Changing this will create a new resource.
        :param _builtins.str instance_id: Specifies the ECS instance ID when using its specification
               as the template to create AS configurations. In this case, `flavor`, `image`, `disk`, `security_group_ids`, `tenancy`
               and `dedicated_host_id` arguments do not take effect.
               If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
               Changing this will create a new resource.
        :param _builtins.str key_fingerprint: The fingerprint of the SSH key pair used to log in to the instance.
        :param _builtins.str key_name: Specifies the name of the SSH key pair used to log in to the instance.
               Changing this will create a new resource.
        :param Mapping[str, _builtins.str] metadata: Specifies the key/value pairs to make available from within the instance.
               Changing this will create a new resource.
        :param Sequence['ConfigurationInstanceConfigPersonalityArgs'] personalities: Specifies the customize personality of an instance by defining one or
               more files and their contents. The personality structure is documented below.
               Changing this will create a new resource.
               
               <a name="instance_config_disk_object"></a>
               The `disk` block supports:
        :param 'ConfigurationInstanceConfigPublicIpArgs' public_ip: Specifies the EIP of the ECS instance.
               The public_ip structure is documented below.
               Changing this will create a new resource.
        :param Sequence[_builtins.str] security_group_ids: Specifies an array of one or more security group IDs.
               Changing this will create a new resource.
        :param _builtins.str tenancy: Configure this field to **dedicated** to create ECS instances on DeHs.
               Before configuring this field, prepare DeHs. Changing this will create a new resource.
        :param _builtins.str user_data: Specifies the user data to be injected during the ECS creation process.
               Changing this will create a new resource. For more information, see
               [Passing User Data to ECSs](https://support.huaweicloud.com/intl/en-us/usermanual-ecs/en-us_topic_0032380449.html).
               
               > 1. The content to be injected must be encoded with base64. The maximum size of the content to be injected
               (before encoding) is `32` KB.
               <br/>2. If `key_name` is not specified, the data injected by `user_data` is the password of user `root` for logging in
               to the ECS by default.
               <br/>3. If both `key_name` and `user_data` are specified, `user_data` only injects user data.
               <br/>4. This parameter is mandatory when you create a Linux ECS using the password authentication mode. Its value is
               the initial user `root` password.
               <br/>5. When the value of this field is used as a password, the recommended complexity for the password is as follows:
               (1) The value ranges from `8` to `26` characters. (2) The value contains at least three of the following character
               types: uppercase letters, lowercase letters, digits, and special characters `!@$%^-_=+[{}]:,./?`.
        """
        if admin_pass is not None:
            pulumi.set(__self__, "admin_pass", admin_pass)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if ecs_group_id is not None:
            pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_priority_policy is not None:
            pulumi.set(__self__, "flavor_priority_policy", flavor_priority_policy)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if key_fingerprint is not None:
            pulumi.set(__self__, "key_fingerprint", key_fingerprint)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if personalities is not None:
            pulumi.set(__self__, "personalities", personalities)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="adminPass")
    def admin_pass(self) -> Optional[_builtins.str]:
        """
        Specifies the initial login password of the administrator account for
        logging in to an ECS using password authentication. The Windows administrator is `Administrator`.

        > Password complexity requirements:
        <br/>1. Consists of `8` to `26` characters.
        <br/>2. Contains at least three of the following character types: uppercase letters, lowercase letters, digits, and
        special characters `!@$%^-_=+[{}]:,./?`.
        <br/>3. The password cannot contain the username or the username in reversed order.
        <br/>4. The Windows ECS password cannot contain the username, the username in reversed order, or more than two
        consecutive characters in the username.

        > Field `admin_pass` is used for Windows system password authentication, and `user_data` is used for Linux system
        password authentication.
        """
        return pulumi.get(self, "admin_pass")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[_builtins.str]:
        """
        Specifies a billing mode for an ECS.
        The value can be `postPaid` and `spot`. The default value is `postPaid`.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the DEH.
        Changing this will create a new resource.

        > This parameter is valid only when `tenancy` is set to **dedicated**.
        <br/>If this parameter is specified, ECSs will be created on a specified DeH.
        <br/>If this parameter is not specified, the system automatically selects the DeH with the maximum available memory
        size from the DeHs that meet specifications requirements to create the ECSs, thereby balancing load of the DeHs.
        """
        return pulumi.get(self, "dedicated_host_id")

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.ConfigurationInstanceConfigDisk']]:
        """
        Specifies the disk group information. System disks are mandatory and
        data disks are optional. The disk structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ECS group ID. Changing this will create a new resource.

        > To ensure service reliability, an ECS group allows ECSs within in the group to be automatically allocated to
        different hosts.
        """
        return pulumi.get(self, "ecs_group_id")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[_builtins.str]:
        """
        Specifies the ECS flavor name. A maximum of `10` flavors can be selected.
        Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="flavorPriorityPolicy")
    def flavor_priority_policy(self) -> Optional[_builtins.str]:
        """
        Specifies the priority policy used when there are multiple flavors
        and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.

        + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
        in the flavor list.
        + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.

        Changing this will create a new resource.
        """
        return pulumi.get(self, "flavor_priority_policy")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Specifies the ECS image ID. Changing this will create a new resource.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ECS instance ID when using its specification
        as the template to create AS configurations. In this case, `flavor`, `image`, `disk`, `security_group_ids`, `tenancy`
        and `dedicated_host_id` arguments do not take effect.
        If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="keyFingerprint")
    def key_fingerprint(self) -> Optional[_builtins.str]:
        """
        The fingerprint of the SSH key pair used to log in to the instance.
        """
        return pulumi.get(self, "key_fingerprint")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the SSH key pair used to log in to the instance.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the key/value pairs to make available from within the instance.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def personalities(self) -> Optional[Sequence['outputs.ConfigurationInstanceConfigPersonality']]:
        """
        Specifies the customize personality of an instance by defining one or
        more files and their contents. The personality structure is documented below.
        Changing this will create a new resource.

        <a name="instance_config_disk_object"></a>
        The `disk` block supports:
        """
        return pulumi.get(self, "personalities")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional['outputs.ConfigurationInstanceConfigPublicIp']:
        """
        Specifies the EIP of the ECS instance.
        The public_ip structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies an array of one or more security group IDs.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[_builtins.str]:
        """
        Configure this field to **dedicated** to create ECS instances on DeHs.
        Before configuring this field, prepare DeHs. Changing this will create a new resource.
        """
        return pulumi.get(self, "tenancy")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        Specifies the user data to be injected during the ECS creation process.
        Changing this will create a new resource. For more information, see
        [Passing User Data to ECSs](https://support.huaweicloud.com/intl/en-us/usermanual-ecs/en-us_topic_0032380449.html).

        > 1. The content to be injected must be encoded with base64. The maximum size of the content to be injected
        (before encoding) is `32` KB.
        <br/>2. If `key_name` is not specified, the data injected by `user_data` is the password of user `root` for logging in
        to the ECS by default.
        <br/>3. If both `key_name` and `user_data` are specified, `user_data` only injects user data.
        <br/>4. This parameter is mandatory when you create a Linux ECS using the password authentication mode. Its value is
        the initial user `root` password.
        <br/>5. When the value of this field is used as a password, the recommended complexity for the password is as follows:
        (1) The value ranges from `8` to `26` characters. (2) The value contains at least three of the following character
        types: uppercase letters, lowercase letters, digits, and special characters `!@$%^-_=+[{}]:,./?`.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class ConfigurationInstanceConfigDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "volumeType":
            suggest = "volume_type"
        elif key == "dataDiskImageId":
            suggest = "data_disk_image_id"
        elif key == "dedicatedStorageId":
            suggest = "dedicated_storage_id"
        elif key == "kmsId":
            suggest = "kms_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationInstanceConfigDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationInstanceConfigDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationInstanceConfigDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_type: _builtins.str,
                 size: _builtins.int,
                 volume_type: _builtins.str,
                 data_disk_image_id: Optional[_builtins.str] = None,
                 dedicated_storage_id: Optional[_builtins.str] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        """
        :param _builtins.str disk_type: Specifies whether the disk is a system disk or a data disk.
               Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
               Changing this will create a new resource.
        :param _builtins.int size: Specifies the disk size. The unit is GB.
               The system disk size ranges from `1` to `1024`, and not less than the minimum value of the system disk in the
               instance image. The data disk size ranges from `10` to `32,768`.
               Changing this will create a new resource.
        :param _builtins.str volume_type: Specifies the disk type. Changing this will create a new resource.
               Available options are:
               + **SSD**: The ultra-high I/O type.
               + **SAS**: The high I/O EVS type.
               + **SATA**: The common I/O type.
               + **GPSSD**: The general purpose SSD type.
               + **ESSD**: The extreme SSD type.
               + **GPSSD2**: The general purpose SSD V2 type.
               + **ESSD2**: The extreme SSD V2 type.
               
               > Different ECS flavors support different disk types. For details about disk types, see
               [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        :param _builtins.str data_disk_image_id: Specifies the ID of a data disk image used to export data disks of
               an ECS.
        :param _builtins.str dedicated_storage_id: Specifies a DSS device ID for creating an ECS disk.
               
               > Specify DSS devices for all disks in an AS configuration or not. If DSS devices are specified, all the
               data stores must belong to the same AZ, and the disk types supported by a DSS device for a disk must be
               the same as the `volume_type` value.
        :param _builtins.int iops: Specifies the IOPS configured for an EVS disk.
               Changing this will create a new resource.
               
               > This parameter is mandatory only when `volume_type` is set to **GPSSD2** or **ESSD2**.
               <br/>For details about IOPS of GPSSD2 and ESSD2 EVS disks, see
               [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
               <br/>Only pay-per-use billing is supported currently.
        :param _builtins.str kms_id: Specifies the encryption KMS ID of the **DATA** disk.
               Changing this will create a new resource.
        :param _builtins.str snapshot_id: Specifies the disk backup snapshot ID for restoring the system disk and
               data disks using a full-ECS backup when a full-ECS image is used.
               
               > You can obtain the disk backup snapshot ID using the full-ECS backup ID in
               [Querying a Single Backup](https://support.huaweicloud.com/intl/en-us/api-csbs/en-us_topic_0059304234.html).
               <br/>Each disk in an AS configuration must correspond to a disk backup in the full-ECS backup by `snapshot_id`.
               
               <a name="instance_config_public_ip_object"></a>
               The `public_ip` block supports:
        :param _builtins.int throughput: Specifies the throughput of an EVS disk. The unit is MiB/s.
               Changing this will create a new resource.
               
               > This parameter is mandatory only when `volume_type` is set to **GPSSD2** and cannot be configured
               when `volume_type` is set to other values.
               <br/>For details about the throughput range of GPSSD2 EVS disks, see
               [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
               <br/>Only pay-per-use billing is supported currently.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if data_disk_image_id is not None:
            pulumi.set(__self__, "data_disk_image_id", data_disk_image_id)
        if dedicated_storage_id is not None:
            pulumi.set(__self__, "dedicated_storage_id", dedicated_storage_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_id is not None:
            pulumi.set(__self__, "kms_id", kms_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        Specifies whether the disk is a system disk or a data disk.
        Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Specifies the disk size. The unit is GB.
        The system disk size ranges from `1` to `1024`, and not less than the minimum value of the system disk in the
        instance image. The data disk size ranges from `10` to `32,768`.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the disk type. Changing this will create a new resource.
        Available options are:
        + **SSD**: The ultra-high I/O type.
        + **SAS**: The high I/O EVS type.
        + **SATA**: The common I/O type.
        + **GPSSD**: The general purpose SSD type.
        + **ESSD**: The extreme SSD type.
        + **GPSSD2**: The general purpose SSD V2 type.
        + **ESSD2**: The extreme SSD V2 type.

        > Different ECS flavors support different disk types. For details about disk types, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        """
        return pulumi.get(self, "volume_type")

    @_builtins.property
    @pulumi.getter(name="dataDiskImageId")
    def data_disk_image_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of a data disk image used to export data disks of
        an ECS.
        """
        return pulumi.get(self, "data_disk_image_id")

    @_builtins.property
    @pulumi.getter(name="dedicatedStorageId")
    def dedicated_storage_id(self) -> Optional[_builtins.str]:
        """
        Specifies a DSS device ID for creating an ECS disk.

        > Specify DSS devices for all disks in an AS configuration or not. If DSS devices are specified, all the
        data stores must belong to the same AZ, and the disk types supported by a DSS device for a disk must be
        the same as the `volume_type` value.
        """
        return pulumi.get(self, "dedicated_storage_id")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Specifies the IOPS configured for an EVS disk.
        Changing this will create a new resource.

        > This parameter is mandatory only when `volume_type` is set to **GPSSD2** or **ESSD2**.
        <br/>For details about IOPS of GPSSD2 and ESSD2 EVS disks, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        <br/>Only pay-per-use billing is supported currently.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> Optional[_builtins.str]:
        """
        Specifies the encryption KMS ID of the **DATA** disk.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "kms_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        Specifies the disk backup snapshot ID for restoring the system disk and
        data disks using a full-ECS backup when a full-ECS image is used.

        > You can obtain the disk backup snapshot ID using the full-ECS backup ID in
        [Querying a Single Backup](https://support.huaweicloud.com/intl/en-us/api-csbs/en-us_topic_0059304234.html).
        <br/>Each disk in an AS configuration must correspond to a disk backup in the full-ECS backup by `snapshot_id`.

        <a name="instance_config_public_ip_object"></a>
        The `public_ip` block supports:
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Specifies the throughput of an EVS disk. The unit is MiB/s.
        Changing this will create a new resource.

        > This parameter is mandatory only when `volume_type` is set to **GPSSD2** and cannot be configured
        when `volume_type` is set to other values.
        <br/>For details about the throughput range of GPSSD2 EVS disks, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        <br/>Only pay-per-use billing is supported currently.
        """
        return pulumi.get(self, "throughput")


@pulumi.output_type
class ConfigurationInstanceConfigPersonality(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 path: _builtins.str):
        """
        :param _builtins.str content: Specifies the content of the injected file, which must be encoded with base64.
               Changing this creates a new resource.
        :param _builtins.str path: Specifies the path of the injected file. Changing this creates a new resource.
               + For Linux OSs, specify the path, for example, **/etc/foo.txt**, for storing the injected file.
               + For Windows, the injected file is automatically stored in the root directory of drive `C`. You only need to specify
               the file name, for example, **foo**. The file name contains only letters and digits.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        Specifies the content of the injected file, which must be encoded with base64.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Specifies the path of the injected file. Changing this creates a new resource.
        + For Linux OSs, specify the path, for example, **/etc/foo.txt**, for storing the injected file.
        + For Windows, the injected file is automatically stored in the root directory of drive `C`. You only need to specify
        the file name, for example, **foo**. The file name contains only letters and digits.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ConfigurationInstanceConfigPublicIp(dict):
    def __init__(__self__, *,
                 eip: 'outputs.ConfigurationInstanceConfigPublicIpEip'):
        """
        :param 'ConfigurationInstanceConfigPublicIpEipArgs' eip: Specifies the EIP configuration that will be automatically assigned to the instance.
               The object structure is documented below. Changing this will create a new resource.
        """
        pulumi.set(__self__, "eip", eip)

    @_builtins.property
    @pulumi.getter
    def eip(self) -> 'outputs.ConfigurationInstanceConfigPublicIpEip':
        """
        Specifies the EIP configuration that will be automatically assigned to the instance.
        The object structure is documented below. Changing this will create a new resource.
        """
        return pulumi.get(self, "eip")


@pulumi.output_type
class ConfigurationInstanceConfigPublicIpEip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipType":
            suggest = "ip_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationInstanceConfigPublicIpEip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationInstanceConfigPublicIpEip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationInstanceConfigPublicIpEip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: 'outputs.ConfigurationInstanceConfigPublicIpEipBandwidth',
                 ip_type: _builtins.str):
        """
        :param 'ConfigurationInstanceConfigPublicIpEipBandwidthArgs' bandwidth: Specifies the bandwidth information. The object structure is documented below.
               Changing this will create a new resource.
        :param _builtins.str ip_type: Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
               and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "ip_type", ip_type)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> 'outputs.ConfigurationInstanceConfigPublicIpEipBandwidth':
        """
        Specifies the bandwidth information. The object structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> _builtins.str:
        """
        Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
        and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
        return pulumi.get(self, "ip_type")


@pulumi.output_type
class ConfigurationInstanceConfigPublicIpEipBandwidth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareType":
            suggest = "share_type"
        elif key == "chargingMode":
            suggest = "charging_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationInstanceConfigPublicIpEipBandwidth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationInstanceConfigPublicIpEipBandwidth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationInstanceConfigPublicIpEipBandwidth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 share_type: _builtins.str,
                 charging_mode: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None):
        """
        :param _builtins.str share_type: Specifies the bandwidth sharing type.
               The value can be **PER** (exclusive bandwidth) or **WHOLE** (shared bandwidth).
               Changing this will create a new resource.
               
               > If `share_type` is set to **PER**, the parameter `charging_mode` and `size` are mandatory, the parameter `id`
               is invalid.
               If `share_type` is set to **WHOLE**, the parameter `id` is mandatory, the parameter `charging_mode` and `size`
               are invalid.
        :param _builtins.str charging_mode: Specifies the bandwidth billing type.
               Changing this creates a new resource. The valid values are as follows:
               + **bandwidth**: Billing by bandwidth.
               + **traffic**: Billing by traffic.
        :param _builtins.str id: Specifies the ID of the shared bandwidth.
               Changing this will create a new resource.
               
               <a name="instance_config_personality_object"></a>
               The `personality` block supports:
        :param _builtins.int size: Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
               is `1` to `2,000` and that for bandwidth billed by traffic is `1` to `300`.
               Changing this creates a new resource.
        """
        pulumi.set(__self__, "share_type", share_type)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> _builtins.str:
        """
        Specifies the bandwidth sharing type.
        The value can be **PER** (exclusive bandwidth) or **WHOLE** (shared bandwidth).
        Changing this will create a new resource.

        > If `share_type` is set to **PER**, the parameter `charging_mode` and `size` are mandatory, the parameter `id`
        is invalid.
        If `share_type` is set to **WHOLE**, the parameter `id` is mandatory, the parameter `charging_mode` and `size`
        are invalid.
        """
        return pulumi.get(self, "share_type")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[_builtins.str]:
        """
        Specifies the bandwidth billing type.
        Changing this creates a new resource. The valid values are as follows:
        + **bandwidth**: Billing by bandwidth.
        + **traffic**: Billing by traffic.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the shared bandwidth.
        Changing this will create a new resource.

        <a name="instance_config_personality_object"></a>
        The `personality` block supports:
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
        is `1` to `2,000` and that for bandwidth billed by traffic is `1` to `300`.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class ConfigurationV1InstanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPass":
            suggest = "admin_pass"
        elif key == "chargingMode":
            suggest = "charging_mode"
        elif key == "dedicatedHostId":
            suggest = "dedicated_host_id"
        elif key == "ecsGroupId":
            suggest = "ecs_group_id"
        elif key == "flavorPriorityPolicy":
            suggest = "flavor_priority_policy"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "keyFingerprint":
            suggest = "key_fingerprint"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationV1InstanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationV1InstanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationV1InstanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_pass: Optional[_builtins.str] = None,
                 charging_mode: Optional[_builtins.str] = None,
                 dedicated_host_id: Optional[_builtins.str] = None,
                 disks: Optional[Sequence['outputs.ConfigurationV1InstanceConfigDisk']] = None,
                 ecs_group_id: Optional[_builtins.str] = None,
                 flavor: Optional[_builtins.str] = None,
                 flavor_priority_policy: Optional[_builtins.str] = None,
                 image: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 key_fingerprint: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 personalities: Optional[Sequence['outputs.ConfigurationV1InstanceConfigPersonality']] = None,
                 public_ip: Optional['outputs.ConfigurationV1InstanceConfigPublicIp'] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 tenancy: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] security_group_ids: schema: Required
        """
        if admin_pass is not None:
            pulumi.set(__self__, "admin_pass", admin_pass)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if ecs_group_id is not None:
            pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_priority_policy is not None:
            pulumi.set(__self__, "flavor_priority_policy", flavor_priority_policy)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if key_fingerprint is not None:
            pulumi.set(__self__, "key_fingerprint", key_fingerprint)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if personalities is not None:
            pulumi.set(__self__, "personalities", personalities)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="adminPass")
    def admin_pass(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "admin_pass")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dedicated_host_id")

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[Sequence['outputs.ConfigurationV1InstanceConfigDisk']]:
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ecs_group_id")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="flavorPriorityPolicy")
    def flavor_priority_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "flavor_priority_policy")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="keyFingerprint")
    def key_fingerprint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_fingerprint")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def personalities(self) -> Optional[Sequence['outputs.ConfigurationV1InstanceConfigPersonality']]:
        return pulumi.get(self, "personalities")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional['outputs.ConfigurationV1InstanceConfigPublicIp']:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        schema: Required
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenancy")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_data")


@pulumi.output_type
class ConfigurationV1InstanceConfigDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"
        elif key == "volumeType":
            suggest = "volume_type"
        elif key == "dataDiskImageId":
            suggest = "data_disk_image_id"
        elif key == "dedicatedStorageId":
            suggest = "dedicated_storage_id"
        elif key == "kmsId":
            suggest = "kms_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationV1InstanceConfigDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationV1InstanceConfigDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationV1InstanceConfigDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_type: _builtins.str,
                 size: _builtins.int,
                 volume_type: _builtins.str,
                 data_disk_image_id: Optional[_builtins.str] = None,
                 dedicated_storage_id: Optional[_builtins.str] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None):
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if data_disk_image_id is not None:
            pulumi.set(__self__, "data_disk_image_id", data_disk_image_id)
        if dedicated_storage_id is not None:
            pulumi.set(__self__, "dedicated_storage_id", dedicated_storage_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_id is not None:
            pulumi.set(__self__, "kms_id", kms_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        return pulumi.get(self, "volume_type")

    @_builtins.property
    @pulumi.getter(name="dataDiskImageId")
    def data_disk_image_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_disk_image_id")

    @_builtins.property
    @pulumi.getter(name="dedicatedStorageId")
    def dedicated_storage_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dedicated_storage_id")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "throughput")


@pulumi.output_type
class ConfigurationV1InstanceConfigPersonality(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 path: _builtins.str):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")


@pulumi.output_type
class ConfigurationV1InstanceConfigPublicIp(dict):
    def __init__(__self__, *,
                 eip: 'outputs.ConfigurationV1InstanceConfigPublicIpEip'):
        pulumi.set(__self__, "eip", eip)

    @_builtins.property
    @pulumi.getter
    def eip(self) -> 'outputs.ConfigurationV1InstanceConfigPublicIpEip':
        return pulumi.get(self, "eip")


@pulumi.output_type
class ConfigurationV1InstanceConfigPublicIpEip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipType":
            suggest = "ip_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationV1InstanceConfigPublicIpEip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationV1InstanceConfigPublicIpEip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationV1InstanceConfigPublicIpEip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: 'outputs.ConfigurationV1InstanceConfigPublicIpEipBandwidth',
                 ip_type: _builtins.str):
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "ip_type", ip_type)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> 'outputs.ConfigurationV1InstanceConfigPublicIpEipBandwidth':
        return pulumi.get(self, "bandwidth")

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> _builtins.str:
        return pulumi.get(self, "ip_type")


@pulumi.output_type
class ConfigurationV1InstanceConfigPublicIpEipBandwidth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shareType":
            suggest = "share_type"
        elif key == "chargingMode":
            suggest = "charging_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationV1InstanceConfigPublicIpEipBandwidth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationV1InstanceConfigPublicIpEipBandwidth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationV1InstanceConfigPublicIpEipBandwidth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 share_type: _builtins.str,
                 charging_mode: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None):
        pulumi.set(__self__, "share_type", share_type)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> _builtins.str:
        return pulumi.get(self, "share_type")

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "size")


@pulumi.output_type
class GroupLbaasListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"
        elif key == "protocolPort":
            suggest = "protocol_port"
        elif key == "listenerId":
            suggest = "listener_id"
        elif key == "protocolVersion":
            suggest = "protocol_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupLbaasListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupLbaasListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupLbaasListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_id: _builtins.str,
                 protocol_port: _builtins.int,
                 listener_id: Optional[_builtins.str] = None,
                 protocol_version: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param _builtins.str pool_id: Specifies the backend ECS group ID.
        :param _builtins.int protocol_port: Specifies the backend protocol, which is the port on which a backend ECS listens for
               traffic. The number of the port ranges from `1` to `65,535`.
        :param _builtins.str listener_id: The ID of the listener assocaite with the ELB.
        :param _builtins.str protocol_version: Specifies the version of instance IP addresses to be associated with the
               load balancer. The value can be **ipv4** or **ipv6**. Defaults to **ipv4**.
               
               > 1. Instances in an AS group do not support IPv4/IPv6 dual-stack on multiple NICs. IPv4/IPv6 dual-stack is only
               available for the first NIC that supports both IPv4 and IPv6. The NIC may be a primary NIC or an extension NIC.
               <br/>2. Only ECSs with flavors that support IPv6 can use IPv4/IPv6 dual-stack networks. If you want to select IPv6 for
               this parameter, make sure that you have selected such ECS flavors in a supported region.
               <br/>3. If you add two or more load balancers whose pool_id, protocol_port, and protocol_version settings are totally
               same, deduplication will be performed.
        :param _builtins.int weight: Specifies the weight, which determines the portion of requests a backend ECS processes
               compared to other backend ECSs added to the same listener. The value of this parameter ranges from `0` to `100`.
               Defaults to `1`.
        """
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> _builtins.str:
        """
        Specifies the backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> _builtins.int:
        """
        Specifies the backend protocol, which is the port on which a backend ECS listens for
        traffic. The number of the port ranges from `1` to `65,535`.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[_builtins.str]:
        """
        The ID of the listener assocaite with the ELB.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[_builtins.str]:
        """
        Specifies the version of instance IP addresses to be associated with the
        load balancer. The value can be **ipv4** or **ipv6**. Defaults to **ipv4**.

        > 1. Instances in an AS group do not support IPv4/IPv6 dual-stack on multiple NICs. IPv4/IPv6 dual-stack is only
        available for the first NIC that supports both IPv4 and IPv6. The NIC may be a primary NIC or an extension NIC.
        <br/>2. Only ECSs with flavors that support IPv6 can use IPv4/IPv6 dual-stack networks. If you want to select IPv6 for
        this parameter, make sure that you have selected such ECS flavors in a supported region.
        <br/>3. If you add two or more load balancers whose pool_id, protocol_port, and protocol_version settings are totally
        same, deduplication will be performed.
        """
        return pulumi.get(self, "protocol_version")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Specifies the weight, which determines the portion of requests a backend ECS processes
        compared to other backend ECSs added to the same listener. The value of this parameter ranges from `0` to `100`.
        Defaults to `1`.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GroupNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6BandwidthId":
            suggest = "ipv6_bandwidth_id"
        elif key == "ipv6Enable":
            suggest = "ipv6_enable"
        elif key == "sourceDestCheck":
            suggest = "source_dest_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 ipv6_bandwidth_id: Optional[_builtins.str] = None,
                 ipv6_enable: Optional[_builtins.bool] = None,
                 source_dest_check: Optional[_builtins.bool] = None):
        """
        :param _builtins.str id: Specifies the ID of the security group.
               
               <a name="group_lbaas_listener_object"></a>
               The `lbaas_listeners` block supports:
        :param _builtins.str ipv6_bandwidth_id: Specifies the ID of the shared bandwidth of an IPv6 address.
        :param _builtins.bool ipv6_enable: Specifies whether to support IPv6 addresses. Defaults to **false**.
        :param _builtins.bool source_dest_check: Specifies whether process only traffic that is destined specifically
               for it. Defaults to **true**.
               
               <a name="group_security_group_object"></a>
               The `security_groups` block supports:
        """
        pulumi.set(__self__, "id", id)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the shared bandwidth of an IPv6 address.
        """
        return pulumi.get(self, "ipv6_bandwidth_id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to support IPv6 addresses. Defaults to **false**.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[_builtins.bool]:
        """
        Specifies whether process only traffic that is destined specifically
        for it. Defaults to **true**.

        <a name="group_security_group_object"></a>
        The `security_groups` block supports:
        """
        return pulumi.get(self, "source_dest_check")


@pulumi.output_type
class GroupSecurityGroup(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: Specifies the ID of the security group.
               
               <a name="group_lbaas_listener_object"></a>
               The `lbaas_listeners` block supports:
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GroupV1LbaasListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"
        elif key == "protocolPort":
            suggest = "protocol_port"
        elif key == "listenerId":
            suggest = "listener_id"
        elif key == "protocolVersion":
            suggest = "protocol_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupV1LbaasListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupV1LbaasListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupV1LbaasListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_id: _builtins.str,
                 protocol_port: _builtins.int,
                 listener_id: Optional[_builtins.str] = None,
                 protocol_version: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> _builtins.str:
        return pulumi.get(self, "pool_id")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> _builtins.int:
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol_version")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GroupV1Network(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6BandwidthId":
            suggest = "ipv6_bandwidth_id"
        elif key == "ipv6Enable":
            suggest = "ipv6_enable"
        elif key == "sourceDestCheck":
            suggest = "source_dest_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupV1Network. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupV1Network.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupV1Network.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 ipv6_bandwidth_id: Optional[_builtins.str] = None,
                 ipv6_enable: Optional[_builtins.bool] = None,
                 source_dest_check: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "id", id)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ipv6_bandwidth_id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "source_dest_check")


@pulumi.output_type
class GroupV1SecurityGroup(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class PlannedTaskInstanceNumber(dict):
    def __init__(__self__, *,
                 desire: Optional[_builtins.str] = None,
                 max: Optional[_builtins.str] = None,
                 min: Optional[_builtins.str] = None):
        """
        :param _builtins.str desire: Specifies the expected number of instances for the scaling group.
               
               > At least set one of `max`, `min` or `desire` parameters, at the same time, the `min` can not be
               greater than `desire` or `max`, and `desire` can not be greater than `max`. Parameters that are not set or empty,
               it means that the value of this field remains unchanged compared to the scaling group instance number.
        :param _builtins.str max: Specifies the maximum number of instances for the scaling group.
        :param _builtins.str min: Specifies the minimum number of instances for the scaling group.
        """
        if desire is not None:
            pulumi.set(__self__, "desire", desire)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def desire(self) -> Optional[_builtins.str]:
        """
        Specifies the expected number of instances for the scaling group.

        > At least set one of `max`, `min` or `desire` parameters, at the same time, the `min` can not be
        greater than `desire` or `max`, and `desire` can not be greater than `max`. Parameters that are not set or empty,
        it means that the value of this field remains unchanged compared to the scaling group instance number.
        """
        return pulumi.get(self, "desire")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.str]:
        """
        Specifies the maximum number of instances for the scaling group.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.str]:
        """
        Specifies the minimum number of instances for the scaling group.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class PlannedTaskScheduledPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTime":
            suggest = "launch_time"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "recurrenceValue":
            suggest = "recurrence_value"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlannedTaskScheduledPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlannedTaskScheduledPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlannedTaskScheduledPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_time: _builtins.str,
                 end_time: Optional[_builtins.str] = None,
                 recurrence_type: Optional[_builtins.str] = None,
                 recurrence_value: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str launch_time: Specifies the execution time of the AS planned task.
               + If `recurrence_type` not set or is empty, the time format is **yyyy-MM-ddTHH:mmZ**.
               + If `recurrence_type` is specified, the time format is **HH:mm**.
        :param _builtins.str end_time: Specifies the effective end time of the planned task.
               Only effective and required when `recurrence_type` is not empty.
               The time format is **yyyy-MM-ddTHH:mmZ**.
               
               <a name="AS_InstanceNumber"></a>
               The `instance_number` block supports:
        :param _builtins.str recurrence_type: Specifies the triggering type of AS planned task.
               When not set or is empty, the planned task is scheduled execution.
               After setting, the planned task is periodic execution. The valid values are as follows:
               + **DAILY**: by day periodic execution.
               + **WEEKLY**: by week periodic execution.
               + **MONTHLY**: by month periodic execution.
        :param _builtins.str recurrence_value: Specifies the frequency at which planned task are triggered.
               Required only when `recurrence_type` is **WEEKLY** or **MONTHLY**.
               + When `recurrence_type` is **WEEKLY**, The valid value ranges from `1` to `7`.
               + When `recurrence_type` is **MONTHLY**, The valid value ranges from `1` to `31`.
        :param _builtins.str start_time: Specifies the effective start time of the planned task.
               Only effective when `recurrence_type` is not empty.
               The time format is **yyyy-MM-ddTHH:mmZ**.
               If not set, the default is the time when the planned task is successfully created.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> _builtins.str:
        """
        Specifies the execution time of the AS planned task.
        + If `recurrence_type` not set or is empty, the time format is **yyyy-MM-ddTHH:mmZ**.
        + If `recurrence_type` is specified, the time format is **HH:mm**.
        """
        return pulumi.get(self, "launch_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Specifies the effective end time of the planned task.
        Only effective and required when `recurrence_type` is not empty.
        The time format is **yyyy-MM-ddTHH:mmZ**.

        <a name="AS_InstanceNumber"></a>
        The `instance_number` block supports:
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[_builtins.str]:
        """
        Specifies the triggering type of AS planned task.
        When not set or is empty, the planned task is scheduled execution.
        After setting, the planned task is periodic execution. The valid values are as follows:
        + **DAILY**: by day periodic execution.
        + **WEEKLY**: by week periodic execution.
        + **MONTHLY**: by month periodic execution.
        """
        return pulumi.get(self, "recurrence_type")

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency at which planned task are triggered.
        Required only when `recurrence_type` is **WEEKLY** or **MONTHLY**.
        + When `recurrence_type` is **WEEKLY**, The valid value ranges from `1` to `7`.
        + When `recurrence_type` is **MONTHLY**, The valid value ranges from `1` to `31`.
        """
        return pulumi.get(self, "recurrence_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Specifies the effective start time of the planned task.
        Only effective when `recurrence_type` is not empty.
        The time format is **yyyy-MM-ddTHH:mmZ**.
        If not set, the default is the time when the planned task is successfully created.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class PolicyScalingPolicyAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "instancePercentage":
            suggest = "instance_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyScalingPolicyAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyScalingPolicyAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyScalingPolicyAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_number: Optional[_builtins.int] = None,
                 instance_percentage: Optional[_builtins.int] = None,
                 operation: Optional[_builtins.str] = None):
        """
        :param _builtins.int instance_number: Specifies the number of instances to be operated.
        :param _builtins.int instance_percentage: Specifies the percentage of instances to be operated.
               
               > At most one of `instance_number` and `instance_percentage` can be set. When neither `instance_number` nor
               `instance_percentage` is specified, the number of operation instances is **1**.
        :param _builtins.str operation: Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
               and `SET`.
        """
        if instance_number is not None:
            pulumi.set(__self__, "instance_number", instance_number)
        if instance_percentage is not None:
            pulumi.set(__self__, "instance_percentage", instance_percentage)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> Optional[_builtins.int]:
        """
        Specifies the number of instances to be operated.
        """
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter(name="instancePercentage")
    def instance_percentage(self) -> Optional[_builtins.int]:
        """
        Specifies the percentage of instances to be operated.

        > At most one of `instance_number` and `instance_percentage` can be set. When neither `instance_number` nor
        `instance_percentage` is specified, the number of operation instances is **1**.
        """
        return pulumi.get(self, "instance_percentage")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[_builtins.str]:
        """
        Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
        and `SET`.
        """
        return pulumi.get(self, "operation")


@pulumi.output_type
class PolicyScheduledPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTime":
            suggest = "launch_time"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "recurrenceValue":
            suggest = "recurrence_value"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyScheduledPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyScheduledPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyScheduledPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_time: _builtins.str,
                 end_time: Optional[_builtins.str] = None,
                 recurrence_type: Optional[_builtins.str] = None,
                 recurrence_value: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str launch_time: Specifies the time when the scaling action is triggered.
               + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
               + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.
               
               > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        :param _builtins.str end_time: Specifies the end time of the scaling action triggered periodically. The time format complies
               with UTC. This argument is mandatory when `scaling_policy_type`
               is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.
               
               <a name="scaling_policy_action_object"></a>
               The `scaling_policy_action` block supports:
        :param _builtins.str recurrence_type: Specifies the periodic triggering type. This argument is mandatory when
               `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        :param _builtins.str recurrence_value: Specifies the frequency at which scaling actions are triggered.
        :param _builtins.str start_time: Specifies the start time of the scaling action triggered periodically. The time format
               complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> _builtins.str:
        """
        Specifies the time when the scaling action is triggered.
        + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
        + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.

        > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        """
        return pulumi.get(self, "launch_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Specifies the end time of the scaling action triggered periodically. The time format complies
        with UTC. This argument is mandatory when `scaling_policy_type`
        is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.

        <a name="scaling_policy_action_object"></a>
        The `scaling_policy_action` block supports:
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[_builtins.str]:
        """
        Specifies the periodic triggering type. This argument is mandatory when
        `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        """
        return pulumi.get(self, "recurrence_type")

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[_builtins.str]:
        """
        Specifies the frequency at which scaling actions are triggered.
        """
        return pulumi.get(self, "recurrence_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Specifies the start time of the scaling action triggered periodically. The time format
        complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class PolicyV1ScalingPolicyAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNumber":
            suggest = "instance_number"
        elif key == "instancePercentage":
            suggest = "instance_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyV1ScalingPolicyAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyV1ScalingPolicyAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyV1ScalingPolicyAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_number: Optional[_builtins.int] = None,
                 instance_percentage: Optional[_builtins.int] = None,
                 operation: Optional[_builtins.str] = None):
        if instance_number is not None:
            pulumi.set(__self__, "instance_number", instance_number)
        if instance_percentage is not None:
            pulumi.set(__self__, "instance_percentage", instance_percentage)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter(name="instancePercentage")
    def instance_percentage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_percentage")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operation")


@pulumi.output_type
class PolicyV1ScheduledPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTime":
            suggest = "launch_time"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "recurrenceType":
            suggest = "recurrence_type"
        elif key == "recurrenceValue":
            suggest = "recurrence_value"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyV1ScheduledPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyV1ScheduledPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyV1ScheduledPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_time: _builtins.str,
                 end_time: Optional[_builtins.str] = None,
                 recurrence_type: Optional[_builtins.str] = None,
                 recurrence_value: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> _builtins.str:
        return pulumi.get(self, "launch_time")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "recurrence_type")

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "recurrence_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetActivityLogsActivityLogResult(dict):
    def __init__(__self__, *,
                 added_instances: _builtins.str,
                 changes_instance_number: _builtins.int,
                 current_instance_number: _builtins.int,
                 deleted_instances: _builtins.str,
                 description: _builtins.str,
                 desire_instance_number: _builtins.int,
                 end_time: _builtins.str,
                 id: _builtins.str,
                 removed_instances: _builtins.str,
                 start_time: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str added_instances: A list of cloud server names that have completed scaling activity and been added to the elastic
               scaling group, separated by commas.
        :param _builtins.int changes_instance_number: The number of cloud servers increased or decreased during AS scaling activity.
        :param _builtins.int current_instance_number: The current number of instances of the AS scaling group.
        :param _builtins.str deleted_instances: A list of cloud server names that have completed scaling activity and been removed from the
               elastic scaling group and deleted, separated by commas.
        :param _builtins.str description: The description of AS scaling activity.
        :param _builtins.int desire_instance_number: The final expected number of instances for AS scaling activity.
        :param _builtins.str end_time: Specifies the end time of the AS scaling activity for query. The time format is
               **yyyy-MM-ddThh:mm:ssZ**.
               The query result shows all data with an end time less than this value.
        :param _builtins.str id: The scaling activity log ID.
        :param _builtins.str removed_instances: A list of cloud server names that have completed scaling activity and are only removed from
               the elastic scaling group, separated by commas.
        :param _builtins.str start_time: Specifies the start time of the AS scaling activity for query. The time format is
               **yyyy-MM-ddThh:mm:ssZ**.
               The query result is for all data with a start time greater than or equal to this value.
        :param _builtins.str status: Specifies the status of the AS scaling activity for query.  
               The valid values are as follows:
               + **SUCCESS**: Scaling activity execution successfully.
               + **FAIL**: Scaling activity execution failed.
               + **DOING**: Scaling activity is currently being executed.
        """
        pulumi.set(__self__, "added_instances", added_instances)
        pulumi.set(__self__, "changes_instance_number", changes_instance_number)
        pulumi.set(__self__, "current_instance_number", current_instance_number)
        pulumi.set(__self__, "deleted_instances", deleted_instances)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "desire_instance_number", desire_instance_number)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "removed_instances", removed_instances)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="addedInstances")
    def added_instances(self) -> _builtins.str:
        """
        A list of cloud server names that have completed scaling activity and been added to the elastic
        scaling group, separated by commas.
        """
        return pulumi.get(self, "added_instances")

    @_builtins.property
    @pulumi.getter(name="changesInstanceNumber")
    def changes_instance_number(self) -> _builtins.int:
        """
        The number of cloud servers increased or decreased during AS scaling activity.
        """
        return pulumi.get(self, "changes_instance_number")

    @_builtins.property
    @pulumi.getter(name="currentInstanceNumber")
    def current_instance_number(self) -> _builtins.int:
        """
        The current number of instances of the AS scaling group.
        """
        return pulumi.get(self, "current_instance_number")

    @_builtins.property
    @pulumi.getter(name="deletedInstances")
    def deleted_instances(self) -> _builtins.str:
        """
        A list of cloud server names that have completed scaling activity and been removed from the
        elastic scaling group and deleted, separated by commas.
        """
        return pulumi.get(self, "deleted_instances")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of AS scaling activity.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="desireInstanceNumber")
    def desire_instance_number(self) -> _builtins.int:
        """
        The final expected number of instances for AS scaling activity.
        """
        return pulumi.get(self, "desire_instance_number")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Specifies the end time of the AS scaling activity for query. The time format is
        **yyyy-MM-ddThh:mm:ssZ**.
        The query result shows all data with an end time less than this value.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The scaling activity log ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="removedInstances")
    def removed_instances(self) -> _builtins.str:
        """
        A list of cloud server names that have completed scaling activity and are only removed from
        the elastic scaling group, separated by commas.
        """
        return pulumi.get(self, "removed_instances")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Specifies the start time of the AS scaling activity for query. The time format is
        **yyyy-MM-ddThh:mm:ssZ**.
        The query result is for all data with a start time greater than or equal to this value.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the AS scaling activity for query.  
        The valid values are as follows:
        + **SUCCESS**: Scaling activity execution successfully.
        + **FAIL**: Scaling activity execution failed.
        + **DOING**: Scaling activity is currently being executed.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 desire_value: _builtins.int,
                 end_time: _builtins.str,
                 id: _builtins.str,
                 instance_added_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceAddedListResult'],
                 instance_deleted_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceDeletedListResult'],
                 instance_failed_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceFailedListResult'],
                 instance_removed_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceRemovedListResult'],
                 instance_standby_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceStandbyListResult'],
                 instance_value: _builtins.int,
                 lb_bind_failed_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindFailedListResult'],
                 lb_bind_success_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindSuccessListResult'],
                 lb_unbind_failed_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindFailedListResult'],
                 lb_unbind_success_lists: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListResult'],
                 scaling_value: _builtins.int,
                 start_time: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The description of the scaling action.
        :param _builtins.int desire_value: The expected number of instances for the scaling action.
        :param _builtins.str end_time: Specifies the end time that complies with UTC for querying scaling action logs.
               The format of the end time is yyyy-MM-ddThh:mm:ssZ.
        :param _builtins.str id: The scaling action log ID.
        :param Sequence['GetActivityLogsV2ScalingActivityLogInstanceAddedListArgs'] instance_added_lists: The names of the ECSs that are added to the AS group in a scaling action.
        :param Sequence['GetActivityLogsV2ScalingActivityLogInstanceDeletedListArgs'] instance_deleted_lists: The names of the ECSs that are removed from the AS group and deleted in a scaling action.
        :param Sequence['GetActivityLogsV2ScalingActivityLogInstanceFailedListArgs'] instance_failed_lists: The ECSs for which a scaling action fails.
        :param Sequence['GetActivityLogsV2ScalingActivityLogInstanceRemovedListArgs'] instance_removed_lists: The names of the ECSs that are removed from the AS group in a scaling action.
        :param Sequence['GetActivityLogsV2ScalingActivityLogInstanceStandbyListArgs'] instance_standby_lists: The ECSs that are set to standby mode or for which standby mode is canceled in a scaling action.
        :param _builtins.int instance_value: The number of instances in the AS group.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbBindFailedListArgs'] lb_bind_failed_lists: The load balancers that failed to be bound to the AS group.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbBindSuccessListArgs'] lb_bind_success_lists: The load balancers that are bound to the AS group.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbUnbindFailedListArgs'] lb_unbind_failed_lists: The load balancers that failed to be unbound from the AS group.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListArgs'] lb_unbind_success_lists: The load balancers that are unbound from the AS group.
        :param _builtins.int scaling_value: The number of added or deleted instances during the scaling.
        :param _builtins.str start_time: Specifies the start time that complies with UTC for querying scaling action logs.
               The format of the start time is yyyy-MM-ddThh:mm:ssZ.
        :param _builtins.str status: Specifies the status of the scaling action. Valid values are:
               + **SUCCESS**: The scaling action has been performed.
               + **FAIL**: Performing the scaling action failed.
               + **DOING**: The scaling action is being performed.
        :param _builtins.str type: Specifies the types of the scaling actions to be queried. Different types are separated by
               commas (,). Valid values are:
               + **NORMAL**: Indicates a common scaling action.
               + **MANUAL_REMOVE**: Indicates manually removing instances from an AS group.
               + **MANUAL_DELETE**: Indicates manually removing and deleting instances from an AS group.
               + **MANUAL_ADD**: Indicates manually adding instances to an AS group.
               + **ELB_CHECK_DELETE**: Indicates that instances are removed from an AS group and deleted based on the ELB health check
               result.
               + **AUDIT_CHECK_DELETE**: Indicates that instances are removed from an AS group and deleted based on the audit.
               + **DIFF**: Indicates that the number of expected instances is different from the actual number of instances.
               + **MODIFY_ELB**: Indicates the load balancer migration.
               + **ENTER_STANDBY**: Indicates setting instances to standby mode.
               + **EXIT_STANDBY**: Indicates canceling standby mode for instances.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "desire_value", desire_value)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_added_lists", instance_added_lists)
        pulumi.set(__self__, "instance_deleted_lists", instance_deleted_lists)
        pulumi.set(__self__, "instance_failed_lists", instance_failed_lists)
        pulumi.set(__self__, "instance_removed_lists", instance_removed_lists)
        pulumi.set(__self__, "instance_standby_lists", instance_standby_lists)
        pulumi.set(__self__, "instance_value", instance_value)
        pulumi.set(__self__, "lb_bind_failed_lists", lb_bind_failed_lists)
        pulumi.set(__self__, "lb_bind_success_lists", lb_bind_success_lists)
        pulumi.set(__self__, "lb_unbind_failed_lists", lb_unbind_failed_lists)
        pulumi.set(__self__, "lb_unbind_success_lists", lb_unbind_success_lists)
        pulumi.set(__self__, "scaling_value", scaling_value)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the scaling action.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="desireValue")
    def desire_value(self) -> _builtins.int:
        """
        The expected number of instances for the scaling action.
        """
        return pulumi.get(self, "desire_value")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        Specifies the end time that complies with UTC for querying scaling action logs.
        The format of the end time is yyyy-MM-ddThh:mm:ssZ.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The scaling action log ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceAddedLists")
    def instance_added_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceAddedListResult']:
        """
        The names of the ECSs that are added to the AS group in a scaling action.
        """
        return pulumi.get(self, "instance_added_lists")

    @_builtins.property
    @pulumi.getter(name="instanceDeletedLists")
    def instance_deleted_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceDeletedListResult']:
        """
        The names of the ECSs that are removed from the AS group and deleted in a scaling action.
        """
        return pulumi.get(self, "instance_deleted_lists")

    @_builtins.property
    @pulumi.getter(name="instanceFailedLists")
    def instance_failed_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceFailedListResult']:
        """
        The ECSs for which a scaling action fails.
        """
        return pulumi.get(self, "instance_failed_lists")

    @_builtins.property
    @pulumi.getter(name="instanceRemovedLists")
    def instance_removed_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceRemovedListResult']:
        """
        The names of the ECSs that are removed from the AS group in a scaling action.
        """
        return pulumi.get(self, "instance_removed_lists")

    @_builtins.property
    @pulumi.getter(name="instanceStandbyLists")
    def instance_standby_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogInstanceStandbyListResult']:
        """
        The ECSs that are set to standby mode or for which standby mode is canceled in a scaling action.
        """
        return pulumi.get(self, "instance_standby_lists")

    @_builtins.property
    @pulumi.getter(name="instanceValue")
    def instance_value(self) -> _builtins.int:
        """
        The number of instances in the AS group.
        """
        return pulumi.get(self, "instance_value")

    @_builtins.property
    @pulumi.getter(name="lbBindFailedLists")
    def lb_bind_failed_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindFailedListResult']:
        """
        The load balancers that failed to be bound to the AS group.
        """
        return pulumi.get(self, "lb_bind_failed_lists")

    @_builtins.property
    @pulumi.getter(name="lbBindSuccessLists")
    def lb_bind_success_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindSuccessListResult']:
        """
        The load balancers that are bound to the AS group.
        """
        return pulumi.get(self, "lb_bind_success_lists")

    @_builtins.property
    @pulumi.getter(name="lbUnbindFailedLists")
    def lb_unbind_failed_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindFailedListResult']:
        """
        The load balancers that failed to be unbound from the AS group.
        """
        return pulumi.get(self, "lb_unbind_failed_lists")

    @_builtins.property
    @pulumi.getter(name="lbUnbindSuccessLists")
    def lb_unbind_success_lists(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListResult']:
        """
        The load balancers that are unbound from the AS group.
        """
        return pulumi.get(self, "lb_unbind_success_lists")

    @_builtins.property
    @pulumi.getter(name="scalingValue")
    def scaling_value(self) -> _builtins.int:
        """
        The number of added or deleted instances during the scaling.
        """
        return pulumi.get(self, "scaling_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Specifies the start time that complies with UTC for querying scaling action logs.
        The format of the start time is yyyy-MM-ddThh:mm:ssZ.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the scaling action. Valid values are:
        + **SUCCESS**: The scaling action has been performed.
        + **FAIL**: Performing the scaling action failed.
        + **DOING**: The scaling action is being performed.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the types of the scaling actions to be queried. Different types are separated by
        commas (,). Valid values are:
        + **NORMAL**: Indicates a common scaling action.
        + **MANUAL_REMOVE**: Indicates manually removing instances from an AS group.
        + **MANUAL_DELETE**: Indicates manually removing and deleting instances from an AS group.
        + **MANUAL_ADD**: Indicates manually adding instances to an AS group.
        + **ELB_CHECK_DELETE**: Indicates that instances are removed from an AS group and deleted based on the ELB health check
        result.
        + **AUDIT_CHECK_DELETE**: Indicates that instances are removed from an AS group and deleted based on the audit.
        + **DIFF**: Indicates that the number of expected instances is different from the actual number of instances.
        + **MODIFY_ELB**: Indicates the load balancer migration.
        + **ENTER_STANDBY**: Indicates setting instances to standby mode.
        + **EXIT_STANDBY**: Indicates canceling standby mode for instances.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogInstanceAddedListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 instance_config: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param _builtins.str instance_config: The information about instance configurations.
        :param _builtins.str instance_id: The ECS ID.
        :param _builtins.str instance_name: The ECS name.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "instance_config", instance_config)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceConfig")
    def instance_config(self) -> _builtins.str:
        """
        The information about instance configurations.
        """
        return pulumi.get(self, "instance_config")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The ECS ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The ECS name.
        """
        return pulumi.get(self, "instance_name")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogInstanceDeletedListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 instance_config: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param _builtins.str instance_config: The information about instance configurations.
        :param _builtins.str instance_id: The ECS ID.
        :param _builtins.str instance_name: The ECS name.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "instance_config", instance_config)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceConfig")
    def instance_config(self) -> _builtins.str:
        """
        The information about instance configurations.
        """
        return pulumi.get(self, "instance_config")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The ECS ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The ECS name.
        """
        return pulumi.get(self, "instance_name")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogInstanceFailedListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 instance_config: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param _builtins.str instance_config: The information about instance configurations.
        :param _builtins.str instance_id: The ECS ID.
        :param _builtins.str instance_name: The ECS name.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "instance_config", instance_config)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceConfig")
    def instance_config(self) -> _builtins.str:
        """
        The information about instance configurations.
        """
        return pulumi.get(self, "instance_config")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The ECS ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The ECS name.
        """
        return pulumi.get(self, "instance_name")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogInstanceRemovedListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 instance_config: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param _builtins.str instance_config: The information about instance configurations.
        :param _builtins.str instance_id: The ECS ID.
        :param _builtins.str instance_name: The ECS name.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "instance_config", instance_config)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceConfig")
    def instance_config(self) -> _builtins.str:
        """
        The information about instance configurations.
        """
        return pulumi.get(self, "instance_config")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The ECS ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The ECS name.
        """
        return pulumi.get(self, "instance_name")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogInstanceStandbyListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 instance_config: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param _builtins.str instance_config: The information about instance configurations.
        :param _builtins.str instance_id: The ECS ID.
        :param _builtins.str instance_name: The ECS name.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "instance_config", instance_config)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="instanceConfig")
    def instance_config(self) -> _builtins.str:
        """
        The information about instance configurations.
        """
        return pulumi.get(self, "instance_config")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The ECS ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The ECS name.
        """
        return pulumi.get(self, "instance_name")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbBindFailedListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 lbaas_listeners: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindFailedListLbaasListenerResult'],
                 listener: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbBindFailedListLbaasListenerArgs'] lbaas_listeners: The information about an enhanced load balancer.
        :param _builtins.str listener: The information about a classic load balancer.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "lbaas_listeners", lbaas_listeners)
        pulumi.set(__self__, "listener", listener)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="lbaasListeners")
    def lbaas_listeners(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindFailedListLbaasListenerResult']:
        """
        The information about an enhanced load balancer.
        """
        return pulumi.get(self, "lbaas_listeners")

    @_builtins.property
    @pulumi.getter
    def listener(self) -> _builtins.str:
        """
        The information about a classic load balancer.
        """
        return pulumi.get(self, "listener")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbBindFailedListLbaasListenerResult(dict):
    def __init__(__self__, *,
                 listener_id: _builtins.str,
                 pool_id: _builtins.str,
                 protocol_port: _builtins.int,
                 weight: _builtins.int):
        """
        :param _builtins.str listener_id: The listener ID.
        :param _builtins.str pool_id: The backend ECS group ID.
        :param _builtins.int protocol_port: The backend protocol port, which is the port on which a backend ECS listens for traffic.
        :param _builtins.int weight: The weight, which determines the portion of requests a backend ECS processes when being compared to other
               backend ECSs added to the same listener.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        The listener ID.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> _builtins.str:
        """
        The backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> _builtins.int:
        """
        The backend protocol port, which is the port on which a backend ECS listens for traffic.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight, which determines the portion of requests a backend ECS processes when being compared to other
        backend ECSs added to the same listener.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbBindSuccessListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 lbaas_listeners: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindSuccessListLbaasListenerResult'],
                 listener: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbBindSuccessListLbaasListenerArgs'] lbaas_listeners: The information about an enhanced load balancer.
        :param _builtins.str listener: The information about a classic load balancer.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "lbaas_listeners", lbaas_listeners)
        pulumi.set(__self__, "listener", listener)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="lbaasListeners")
    def lbaas_listeners(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbBindSuccessListLbaasListenerResult']:
        """
        The information about an enhanced load balancer.
        """
        return pulumi.get(self, "lbaas_listeners")

    @_builtins.property
    @pulumi.getter
    def listener(self) -> _builtins.str:
        """
        The information about a classic load balancer.
        """
        return pulumi.get(self, "listener")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbBindSuccessListLbaasListenerResult(dict):
    def __init__(__self__, *,
                 listener_id: _builtins.str,
                 pool_id: _builtins.str,
                 protocol_port: _builtins.int,
                 weight: _builtins.int):
        """
        :param _builtins.str listener_id: The listener ID.
        :param _builtins.str pool_id: The backend ECS group ID.
        :param _builtins.int protocol_port: The backend protocol port, which is the port on which a backend ECS listens for traffic.
        :param _builtins.int weight: The weight, which determines the portion of requests a backend ECS processes when being compared to other
               backend ECSs added to the same listener.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        The listener ID.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> _builtins.str:
        """
        The backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> _builtins.int:
        """
        The backend protocol port, which is the port on which a backend ECS listens for traffic.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight, which determines the portion of requests a backend ECS processes when being compared to other
        backend ECSs added to the same listener.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbUnbindFailedListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 lbaas_listeners: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindFailedListLbaasListenerResult'],
                 listener: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbUnbindFailedListLbaasListenerArgs'] lbaas_listeners: The information about an enhanced load balancer.
        :param _builtins.str listener: The information about a classic load balancer.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "lbaas_listeners", lbaas_listeners)
        pulumi.set(__self__, "listener", listener)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="lbaasListeners")
    def lbaas_listeners(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindFailedListLbaasListenerResult']:
        """
        The information about an enhanced load balancer.
        """
        return pulumi.get(self, "lbaas_listeners")

    @_builtins.property
    @pulumi.getter
    def listener(self) -> _builtins.str:
        """
        The information about a classic load balancer.
        """
        return pulumi.get(self, "listener")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbUnbindFailedListLbaasListenerResult(dict):
    def __init__(__self__, *,
                 listener_id: _builtins.str,
                 pool_id: _builtins.str,
                 protocol_port: _builtins.int,
                 weight: _builtins.int):
        """
        :param _builtins.str listener_id: The listener ID.
        :param _builtins.str pool_id: The backend ECS group ID.
        :param _builtins.int protocol_port: The backend protocol port, which is the port on which a backend ECS listens for traffic.
        :param _builtins.int weight: The weight, which determines the portion of requests a backend ECS processes when being compared to other
               backend ECSs added to the same listener.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        The listener ID.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> _builtins.str:
        """
        The backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> _builtins.int:
        """
        The backend protocol port, which is the port on which a backend ECS listens for traffic.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight, which determines the portion of requests a backend ECS processes when being compared to other
        backend ECSs added to the same listener.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListResult(dict):
    def __init__(__self__, *,
                 failed_details: _builtins.str,
                 failed_reason: _builtins.str,
                 lbaas_listeners: Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListLbaasListenerResult'],
                 listener: _builtins.str):
        """
        :param _builtins.str failed_details: The details of a load balancer migration failure.
        :param _builtins.str failed_reason: The cause of a load balancer migration failure.
        :param Sequence['GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListLbaasListenerArgs'] lbaas_listeners: The information about an enhanced load balancer.
        :param _builtins.str listener: The information about a classic load balancer.
        """
        pulumi.set(__self__, "failed_details", failed_details)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "lbaas_listeners", lbaas_listeners)
        pulumi.set(__self__, "listener", listener)

    @_builtins.property
    @pulumi.getter(name="failedDetails")
    def failed_details(self) -> _builtins.str:
        """
        The details of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_details")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The cause of a load balancer migration failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter(name="lbaasListeners")
    def lbaas_listeners(self) -> Sequence['outputs.GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListLbaasListenerResult']:
        """
        The information about an enhanced load balancer.
        """
        return pulumi.get(self, "lbaas_listeners")

    @_builtins.property
    @pulumi.getter
    def listener(self) -> _builtins.str:
        """
        The information about a classic load balancer.
        """
        return pulumi.get(self, "listener")


@pulumi.output_type
class GetActivityLogsV2ScalingActivityLogLbUnbindSuccessListLbaasListenerResult(dict):
    def __init__(__self__, *,
                 listener_id: _builtins.str,
                 pool_id: _builtins.str,
                 protocol_port: _builtins.int,
                 weight: _builtins.int):
        """
        :param _builtins.str listener_id: The listener ID.
        :param _builtins.str pool_id: The backend ECS group ID.
        :param _builtins.int protocol_port: The backend protocol port, which is the port on which a backend ECS listens for traffic.
        :param _builtins.int weight: The weight, which determines the portion of requests a backend ECS processes when being compared to other
               backend ECSs added to the same listener.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        The listener ID.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> _builtins.str:
        """
        The backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> _builtins.int:
        """
        The backend protocol port, which is the port on which a backend ECS listens for traffic.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight, which determines the portion of requests a backend ECS processes when being compared to other
        backend ECSs added to the same listener.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetConfigurationsConfigurationResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 instance_configs: Sequence['outputs.GetConfigurationsConfigurationInstanceConfigResult'],
                 scaling_configuration_id: _builtins.str,
                 scaling_configuration_name: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str create_time: The creation time of the AS configuration, in UTC format.
        :param Sequence['GetConfigurationsConfigurationInstanceConfigArgs'] instance_configs: The list of information about instance configurations.
               The object structure is documented below.
        :param _builtins.str scaling_configuration_id: The ID of the AS configuration.
        :param _builtins.str scaling_configuration_name: The AS configuration name.
        :param _builtins.str status: The AS configuration status, the value can be **Bound** or **Unbound**.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "instance_configs", instance_configs)
        pulumi.set(__self__, "scaling_configuration_id", scaling_configuration_id)
        pulumi.set(__self__, "scaling_configuration_name", scaling_configuration_name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the AS configuration, in UTC format.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="instanceConfigs")
    def instance_configs(self) -> Sequence['outputs.GetConfigurationsConfigurationInstanceConfigResult']:
        """
        The list of information about instance configurations.
        The object structure is documented below.
        """
        return pulumi.get(self, "instance_configs")

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationId")
    def scaling_configuration_id(self) -> _builtins.str:
        """
        The ID of the AS configuration.
        """
        return pulumi.get(self, "scaling_configuration_id")

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationName")
    def scaling_configuration_name(self) -> _builtins.str:
        """
        The AS configuration name.
        """
        return pulumi.get(self, "scaling_configuration_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The AS configuration status, the value can be **Bound** or **Unbound**.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetConfigurationsConfigurationInstanceConfigResult(dict):
    def __init__(__self__, *,
                 charging_mode: _builtins.str,
                 dedicated_host_id: _builtins.str,
                 disks: Sequence['outputs.GetConfigurationsConfigurationInstanceConfigDiskResult'],
                 ecs_group_id: _builtins.str,
                 flavor: _builtins.str,
                 flavor_priority_policy: _builtins.str,
                 image: _builtins.str,
                 instance_id: _builtins.str,
                 key_fingerprint: _builtins.str,
                 key_name: _builtins.str,
                 metadata: Mapping[str, _builtins.str],
                 personalities: Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPersonalityResult'],
                 public_ips: Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPublicIpResult'],
                 security_group_ids: Sequence[_builtins.str],
                 tenancy: _builtins.str,
                 user_data: _builtins.str):
        """
        :param _builtins.str charging_mode: The bandwidth billing mode, the value can be **traffic** or **bandwidth**.
        :param _builtins.str dedicated_host_id: The ID of the DEH.
        :param Sequence['GetConfigurationsConfigurationInstanceConfigDiskArgs'] disks: The list of disk group information. The object structure is documented below.
        :param _builtins.str ecs_group_id: The ECS group ID.
        :param _builtins.str flavor: The ECS flavor name.
        :param _builtins.str flavor_priority_policy: The priority policy used when there are multiple flavors
               and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.
        :param _builtins.str image: The ECS image ID.
        :param _builtins.str instance_id: The ECS instance ID when using its specification as the template to create AS configurations.
        :param _builtins.str key_fingerprint: The fingerprint of the SSH key pair used to log in to the instance.
        :param _builtins.str key_name: The name of the SSH key pair used to log in to the instance.
        :param Mapping[str, _builtins.str] metadata: The key/value pairs to make available from within the instance.
        :param Sequence['GetConfigurationsConfigurationInstanceConfigPersonalityArgs'] personalities: The list of information about the injected file.
               The object structure is documented below.
        :param Sequence['GetConfigurationsConfigurationInstanceConfigPublicIpArgs'] public_ips: The EIP list of the ECS instance.
               The object structure is documented below.
        :param Sequence[_builtins.str] security_group_ids: An array of one or more security group IDs.
        :param _builtins.str tenancy: Indicates creating ECS instance on DEH.
        :param _builtins.str user_data: The user data to provide when launching the instance.
        """
        pulumi.set(__self__, "charging_mode", charging_mode)
        pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        pulumi.set(__self__, "disks", disks)
        pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "flavor_priority_policy", flavor_priority_policy)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "key_fingerprint", key_fingerprint)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "personalities", personalities)
        pulumi.set(__self__, "public_ips", public_ips)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "tenancy", tenancy)
        pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> _builtins.str:
        """
        The bandwidth billing mode, the value can be **traffic** or **bandwidth**.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> _builtins.str:
        """
        The ID of the DEH.
        """
        return pulumi.get(self, "dedicated_host_id")

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Sequence['outputs.GetConfigurationsConfigurationInstanceConfigDiskResult']:
        """
        The list of disk group information. The object structure is documented below.
        """
        return pulumi.get(self, "disks")

    @_builtins.property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> _builtins.str:
        """
        The ECS group ID.
        """
        return pulumi.get(self, "ecs_group_id")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        The ECS flavor name.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="flavorPriorityPolicy")
    def flavor_priority_policy(self) -> _builtins.str:
        """
        The priority policy used when there are multiple flavors
        and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.
        """
        return pulumi.get(self, "flavor_priority_policy")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The ECS image ID.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        The ECS instance ID when using its specification as the template to create AS configurations.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="keyFingerprint")
    def key_fingerprint(self) -> _builtins.str:
        """
        The fingerprint of the SSH key pair used to log in to the instance.
        """
        return pulumi.get(self, "key_fingerprint")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        The name of the SSH key pair used to log in to the instance.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to make available from within the instance.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def personalities(self) -> Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPersonalityResult']:
        """
        The list of information about the injected file.
        The object structure is documented below.
        """
        return pulumi.get(self, "personalities")

    @_builtins.property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPublicIpResult']:
        """
        The EIP list of the ECS instance.
        The object structure is documented below.
        """
        return pulumi.get(self, "public_ips")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        An array of one or more security group IDs.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> _builtins.str:
        """
        Indicates creating ECS instance on DEH.
        """
        return pulumi.get(self, "tenancy")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> _builtins.str:
        """
        The user data to provide when launching the instance.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class GetConfigurationsConfigurationInstanceConfigDiskResult(dict):
    def __init__(__self__, *,
                 data_disk_image_id: _builtins.str,
                 dedicated_storage_id: _builtins.str,
                 disk_type: _builtins.str,
                 iops: _builtins.int,
                 kms_id: _builtins.str,
                 size: _builtins.int,
                 snapshot_id: _builtins.str,
                 throughput: _builtins.int,
                 volume_type: _builtins.str):
        """
        :param _builtins.str data_disk_image_id: The ID of the data disk image for creating a data disk.
        :param _builtins.str dedicated_storage_id: The ID of the DSS device for the disk.
        :param _builtins.str disk_type: The disk type.
        :param _builtins.int iops: The IOPS of an EVS disk.
        :param _builtins.str kms_id: The encryption KMS ID of the **DATA** disk.
        :param _builtins.int size: The bandwidth (Mbit/s).
        :param _builtins.str snapshot_id: The disk backup snapshot ID.
        :param _builtins.int throughput: The throughput of an EVS disk.
        :param _builtins.str volume_type: The volume type.
        """
        pulumi.set(__self__, "data_disk_image_id", data_disk_image_id)
        pulumi.set(__self__, "dedicated_storage_id", dedicated_storage_id)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "kms_id", kms_id)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "throughput", throughput)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="dataDiskImageId")
    def data_disk_image_id(self) -> _builtins.str:
        """
        The ID of the data disk image for creating a data disk.
        """
        return pulumi.get(self, "data_disk_image_id")

    @_builtins.property
    @pulumi.getter(name="dedicatedStorageId")
    def dedicated_storage_id(self) -> _builtins.str:
        """
        The ID of the DSS device for the disk.
        """
        return pulumi.get(self, "dedicated_storage_id")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        The disk type.
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> _builtins.int:
        """
        The IOPS of an EVS disk.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> _builtins.str:
        """
        The encryption KMS ID of the **DATA** disk.
        """
        return pulumi.get(self, "kms_id")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The bandwidth (Mbit/s).
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        The disk backup snapshot ID.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> _builtins.int:
        """
        The throughput of an EVS disk.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        The volume type.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetConfigurationsConfigurationInstanceConfigPersonalityResult(dict):
    def __init__(__self__, *,
                 content: _builtins.str,
                 path: _builtins.str):
        """
        :param _builtins.str content: The content of the injected file.
        :param _builtins.str path: The path of the injected file.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The content of the injected file.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path of the injected file.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetConfigurationsConfigurationInstanceConfigPublicIpResult(dict):
    def __init__(__self__, *,
                 eips: Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPublicIpEipResult']):
        """
        :param Sequence['GetConfigurationsConfigurationInstanceConfigPublicIpEipArgs'] eips: The list of EIP configuration that will be automatically assigned to the instance.
               The object structure is documented below.
        """
        pulumi.set(__self__, "eips", eips)

    @_builtins.property
    @pulumi.getter
    def eips(self) -> Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPublicIpEipResult']:
        """
        The list of EIP configuration that will be automatically assigned to the instance.
        The object structure is documented below.
        """
        return pulumi.get(self, "eips")


@pulumi.output_type
class GetConfigurationsConfigurationInstanceConfigPublicIpEipResult(dict):
    def __init__(__self__, *,
                 bandwidths: Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPublicIpEipBandwidthResult'],
                 ip_type: _builtins.str):
        """
        :param Sequence['GetConfigurationsConfigurationInstanceConfigPublicIpEipBandwidthArgs'] bandwidths: The list of bandwidth information. The object structure is documented below.
        :param _builtins.str ip_type: The EIP type.
        """
        pulumi.set(__self__, "bandwidths", bandwidths)
        pulumi.set(__self__, "ip_type", ip_type)

    @_builtins.property
    @pulumi.getter
    def bandwidths(self) -> Sequence['outputs.GetConfigurationsConfigurationInstanceConfigPublicIpEipBandwidthResult']:
        """
        The list of bandwidth information. The object structure is documented below.
        """
        return pulumi.get(self, "bandwidths")

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> _builtins.str:
        """
        The EIP type.
        """
        return pulumi.get(self, "ip_type")


@pulumi.output_type
class GetConfigurationsConfigurationInstanceConfigPublicIpEipBandwidthResult(dict):
    def __init__(__self__, *,
                 charging_mode: _builtins.str,
                 id: _builtins.str,
                 share_type: _builtins.str,
                 size: _builtins.int):
        """
        :param _builtins.str charging_mode: The bandwidth billing mode, the value can be **traffic** or **bandwidth**.
        :param _builtins.str id: The ID of the bandwidth.
        :param _builtins.str share_type: The bandwidth sharing type.
        :param _builtins.int size: The bandwidth (Mbit/s).
        """
        pulumi.set(__self__, "charging_mode", charging_mode)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "share_type", share_type)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> _builtins.str:
        """
        The bandwidth billing mode, the value can be **traffic** or **bandwidth**.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the bandwidth.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> _builtins.str:
        """
        The bandwidth sharing type.
        """
        return pulumi.get(self, "share_type")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The bandwidth (Mbit/s).
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetGroupQuotasQuotaResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetGroupQuotasQuotaResourceResult']):
        """
        :param Sequence['GetGroupQuotasQuotaResourceArgs'] resources: The quota resource list.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetGroupQuotasQuotaResourceResult']:
        """
        The quota resource list.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetGroupQuotasQuotaResourceResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int,
                 quota: _builtins.int,
                 type: _builtins.str,
                 used: _builtins.int):
        """
        :param _builtins.int max: The quota upper limit.
        :param _builtins.int min: The quota lower limit.
        :param _builtins.int quota: The total quota.
        :param _builtins.str type: The quota type. Valid values are:
               + **scaling_Policy**: Indicates AS policies.
               + **scaling_Instance**: Indicates instances.
        :param _builtins.int used: The used quota.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "quota", quota)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "used", used)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        """
        The quota upper limit.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        The quota lower limit.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def quota(self) -> _builtins.int:
        """
        The total quota.
        """
        return pulumi.get(self, "quota")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The quota type. Valid values are:
        + **scaling_Policy**: Indicates AS policies.
        + **scaling_Instance**: Indicates instances.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def used(self) -> _builtins.int:
        """
        The used quota.
        """
        return pulumi.get(self, "used")


@pulumi.output_type
class GetGroupTagsTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The key of the tag.
        :param Sequence[_builtins.str] values: The list of the tag values.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of the tag values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetGroupsGroupResult(dict):
    def __init__(__self__, *,
                 activity_type: _builtins.str,
                 availability_zones: Sequence[_builtins.str],
                 cool_down_time: _builtins.int,
                 created_at: _builtins.str,
                 current_instance_number: _builtins.int,
                 delete_publicip: _builtins.bool,
                 delete_volume: _builtins.bool,
                 description: _builtins.str,
                 desire_instance_number: _builtins.int,
                 detail: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 health_periodic_audit_grace_period: _builtins.int,
                 health_periodic_audit_method: _builtins.str,
                 health_periodic_audit_time: _builtins.int,
                 iam_agency_name: _builtins.str,
                 instance_terminate_policy: _builtins.str,
                 instances: Sequence[_builtins.str],
                 is_scaling: _builtins.bool,
                 lbaas_listeners: Sequence['outputs.GetGroupsGroupLbaasListenerResult'],
                 max_instance_number: _builtins.int,
                 min_instance_number: _builtins.int,
                 multi_az_scaling_policy: _builtins.str,
                 networks: Sequence['outputs.GetGroupsGroupNetworkResult'],
                 scaling_configuration_id: _builtins.str,
                 scaling_configuration_name: _builtins.str,
                 scaling_group_id: _builtins.str,
                 scaling_group_name: _builtins.str,
                 security_groups: Sequence['outputs.GetGroupsGroupSecurityGroupResult'],
                 status: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 vpc_id: _builtins.str):
        """
        :param _builtins.str activity_type: The type of the AS action.
        :param Sequence[_builtins.str] availability_zones: The AZ information.
        :param _builtins.int cool_down_time: The cooling duration, in seconds..
        :param _builtins.str created_at: The time when an AS group was created. The time format complies with UTC.
        :param _builtins.int current_instance_number: The number of current instances in the AS group.
        :param _builtins.bool delete_publicip: Whether to delete the EIP bound to the ECS when deleting the ECS.
        :param _builtins.bool delete_volume: Whether to delete the data disks attached to the ECS when deleting the ECS.
        :param _builtins.str description: The description of the AS group.
        :param _builtins.int desire_instance_number: The expected number of instances in the AS group.
        :param _builtins.str detail: Details about the AS group. If a scaling action fails, this parameter is used to record errors.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID.
        :param _builtins.int health_periodic_audit_grace_period: The grace period for health check.
        :param _builtins.str health_periodic_audit_method: The health check method.
        :param _builtins.int health_periodic_audit_time: The health check interval.
        :param _builtins.str iam_agency_name: The agency name.
        :param _builtins.str instance_terminate_policy: The instance removal policy.
        :param Sequence[_builtins.str] instances: The scaling group instances ids.
        :param _builtins.bool is_scaling: The scaling flag of the AS group.
        :param Sequence['GetGroupsGroupLbaasListenerArgs'] lbaas_listeners: The enhanced load balancers.
               The object structure is documented below.
        :param _builtins.int max_instance_number: The maximum number of instances in the AS group.
        :param _builtins.int min_instance_number: The minimum number of instances in the AS group.
        :param _builtins.str multi_az_scaling_policy: The priority policy used to select target AZs when adjusting the number of
               instances in an AS group.
        :param Sequence['GetGroupsGroupNetworkArgs'] networks: The network information.
               The object structure is documented below.
        :param _builtins.str scaling_configuration_id: Specifies the AS configuration ID, which can be obtained using
               the API for listing AS configurations.
        :param _builtins.str scaling_configuration_name: The AS configuration name.
        :param _builtins.str scaling_group_id: The AS group ID.
        :param _builtins.str scaling_group_name: The name of the AS group.
        :param Sequence['GetGroupsGroupSecurityGroupArgs'] security_groups: The security group information.
               The object structure is documented below.
        :param _builtins.str status: Specifies the AS group status. The options are as follows:
               - **INSERVICE**: indicates that the AS group is functional.
               - **PAUSED**: indicates that the AS group is paused.
               - **ERROR**: indicates that the AS group malfunctions.
               - **DELETING**: indicates that the AS group is being deleted.
               - **FREEZED**: indicates that the AS group has been frozen.
        :param Mapping[str, _builtins.str] tags: The tag of AS group.
        :param _builtins.str vpc_id: The ID of the VPC to which the AS group belongs.
        """
        pulumi.set(__self__, "activity_type", activity_type)
        pulumi.set(__self__, "availability_zones", availability_zones)
        pulumi.set(__self__, "cool_down_time", cool_down_time)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "current_instance_number", current_instance_number)
        pulumi.set(__self__, "delete_publicip", delete_publicip)
        pulumi.set(__self__, "delete_volume", delete_volume)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "desire_instance_number", desire_instance_number)
        pulumi.set(__self__, "detail", detail)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "health_periodic_audit_grace_period", health_periodic_audit_grace_period)
        pulumi.set(__self__, "health_periodic_audit_method", health_periodic_audit_method)
        pulumi.set(__self__, "health_periodic_audit_time", health_periodic_audit_time)
        pulumi.set(__self__, "iam_agency_name", iam_agency_name)
        pulumi.set(__self__, "instance_terminate_policy", instance_terminate_policy)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "is_scaling", is_scaling)
        pulumi.set(__self__, "lbaas_listeners", lbaas_listeners)
        pulumi.set(__self__, "max_instance_number", max_instance_number)
        pulumi.set(__self__, "min_instance_number", min_instance_number)
        pulumi.set(__self__, "multi_az_scaling_policy", multi_az_scaling_policy)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "scaling_configuration_id", scaling_configuration_id)
        pulumi.set(__self__, "scaling_configuration_name", scaling_configuration_name)
        pulumi.set(__self__, "scaling_group_id", scaling_group_id)
        pulumi.set(__self__, "scaling_group_name", scaling_group_name)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="activityType")
    def activity_type(self) -> _builtins.str:
        """
        The type of the AS action.
        """
        return pulumi.get(self, "activity_type")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Sequence[_builtins.str]:
        """
        The AZ information.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter(name="coolDownTime")
    def cool_down_time(self) -> _builtins.int:
        """
        The cooling duration, in seconds..
        """
        return pulumi.get(self, "cool_down_time")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The time when an AS group was created. The time format complies with UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="currentInstanceNumber")
    def current_instance_number(self) -> _builtins.int:
        """
        The number of current instances in the AS group.
        """
        return pulumi.get(self, "current_instance_number")

    @_builtins.property
    @pulumi.getter(name="deletePublicip")
    def delete_publicip(self) -> _builtins.bool:
        """
        Whether to delete the EIP bound to the ECS when deleting the ECS.
        """
        return pulumi.get(self, "delete_publicip")

    @_builtins.property
    @pulumi.getter(name="deleteVolume")
    def delete_volume(self) -> _builtins.bool:
        """
        Whether to delete the data disks attached to the ECS when deleting the ECS.
        """
        return pulumi.get(self, "delete_volume")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the AS group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="desireInstanceNumber")
    def desire_instance_number(self) -> _builtins.int:
        """
        The expected number of instances in the AS group.
        """
        return pulumi.get(self, "desire_instance_number")

    @_builtins.property
    @pulumi.getter
    def detail(self) -> _builtins.str:
        """
        Details about the AS group. If a scaling action fails, this parameter is used to record errors.
        """
        return pulumi.get(self, "detail")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter(name="healthPeriodicAuditGracePeriod")
    def health_periodic_audit_grace_period(self) -> _builtins.int:
        """
        The grace period for health check.
        """
        return pulumi.get(self, "health_periodic_audit_grace_period")

    @_builtins.property
    @pulumi.getter(name="healthPeriodicAuditMethod")
    def health_periodic_audit_method(self) -> _builtins.str:
        """
        The health check method.
        """
        return pulumi.get(self, "health_periodic_audit_method")

    @_builtins.property
    @pulumi.getter(name="healthPeriodicAuditTime")
    def health_periodic_audit_time(self) -> _builtins.int:
        """
        The health check interval.
        """
        return pulumi.get(self, "health_periodic_audit_time")

    @_builtins.property
    @pulumi.getter(name="iamAgencyName")
    def iam_agency_name(self) -> _builtins.str:
        """
        The agency name.
        """
        return pulumi.get(self, "iam_agency_name")

    @_builtins.property
    @pulumi.getter(name="instanceTerminatePolicy")
    def instance_terminate_policy(self) -> _builtins.str:
        """
        The instance removal policy.
        """
        return pulumi.get(self, "instance_terminate_policy")

    @_builtins.property
    @pulumi.getter
    def instances(self) -> Sequence[_builtins.str]:
        """
        The scaling group instances ids.
        """
        return pulumi.get(self, "instances")

    @_builtins.property
    @pulumi.getter(name="isScaling")
    def is_scaling(self) -> _builtins.bool:
        """
        The scaling flag of the AS group.
        """
        return pulumi.get(self, "is_scaling")

    @_builtins.property
    @pulumi.getter(name="lbaasListeners")
    def lbaas_listeners(self) -> Sequence['outputs.GetGroupsGroupLbaasListenerResult']:
        """
        The enhanced load balancers.
        The object structure is documented below.
        """
        return pulumi.get(self, "lbaas_listeners")

    @_builtins.property
    @pulumi.getter(name="maxInstanceNumber")
    def max_instance_number(self) -> _builtins.int:
        """
        The maximum number of instances in the AS group.
        """
        return pulumi.get(self, "max_instance_number")

    @_builtins.property
    @pulumi.getter(name="minInstanceNumber")
    def min_instance_number(self) -> _builtins.int:
        """
        The minimum number of instances in the AS group.
        """
        return pulumi.get(self, "min_instance_number")

    @_builtins.property
    @pulumi.getter(name="multiAzScalingPolicy")
    def multi_az_scaling_policy(self) -> _builtins.str:
        """
        The priority policy used to select target AZs when adjusting the number of
        instances in an AS group.
        """
        return pulumi.get(self, "multi_az_scaling_policy")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetGroupsGroupNetworkResult']:
        """
        The network information.
        The object structure is documented below.
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationId")
    def scaling_configuration_id(self) -> _builtins.str:
        """
        Specifies the AS configuration ID, which can be obtained using
        the API for listing AS configurations.
        """
        return pulumi.get(self, "scaling_configuration_id")

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationName")
    def scaling_configuration_name(self) -> _builtins.str:
        """
        The AS configuration name.
        """
        return pulumi.get(self, "scaling_configuration_name")

    @_builtins.property
    @pulumi.getter(name="scalingGroupId")
    def scaling_group_id(self) -> _builtins.str:
        """
        The AS group ID.
        """
        return pulumi.get(self, "scaling_group_id")

    @_builtins.property
    @pulumi.getter(name="scalingGroupName")
    def scaling_group_name(self) -> _builtins.str:
        """
        The name of the AS group.
        """
        return pulumi.get(self, "scaling_group_name")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence['outputs.GetGroupsGroupSecurityGroupResult']:
        """
        The security group information.
        The object structure is documented below.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the AS group status. The options are as follows:
        - **INSERVICE**: indicates that the AS group is functional.
        - **PAUSED**: indicates that the AS group is paused.
        - **ERROR**: indicates that the AS group malfunctions.
        - **DELETING**: indicates that the AS group is being deleted.
        - **FREEZED**: indicates that the AS group has been frozen.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The tag of AS group.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the VPC to which the AS group belongs.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetGroupsGroupLbaasListenerResult(dict):
    def __init__(__self__, *,
                 listener_id: _builtins.str,
                 pool_id: _builtins.str,
                 protocol_port: _builtins.int,
                 protocol_version: _builtins.str,
                 weight: _builtins.int):
        """
        :param _builtins.str listener_id: The ID of the listener associate with the ELB.
        :param _builtins.str pool_id: The backend ECS group ID.
        :param _builtins.int protocol_port: The backend protocol ID, which is the port on which a backend ECS listens for traffic.
        :param _builtins.str protocol_version: The version of IP addresses of backend servers to be bound with the ELB.
        :param _builtins.int weight: The weight, which determines the portion of requests a backend ECS processes
               compared to other backend ECSs added to the same listener.
        """
        pulumi.set(__self__, "listener_id", listener_id)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        pulumi.set(__self__, "protocol_version", protocol_version)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> _builtins.str:
        """
        The ID of the listener associate with the ELB.
        """
        return pulumi.get(self, "listener_id")

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> _builtins.str:
        """
        The backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> _builtins.int:
        """
        The backend protocol ID, which is the port on which a backend ECS listens for traffic.
        """
        return pulumi.get(self, "protocol_port")

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> _builtins.str:
        """
        The version of IP addresses of backend servers to be bound with the ELB.
        """
        return pulumi.get(self, "protocol_version")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight, which determines the portion of requests a backend ECS processes
        compared to other backend ECSs added to the same listener.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetGroupsGroupNetworkResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 ipv6_bandwidth_id: _builtins.str,
                 ipv6_enable: _builtins.bool,
                 source_dest_check: _builtins.bool):
        """
        :param _builtins.str id: The ID of the security group.
        :param _builtins.str ipv6_bandwidth_id: The ID of the shared bandwidth of an IPv6 address.
        :param _builtins.bool ipv6_enable: Specifies whether to support IPv6 addresses.
        :param _builtins.bool source_dest_check: Whether processing only traffic that is destined specifically for it.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        pulumi.set(__self__, "source_dest_check", source_dest_check)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> _builtins.str:
        """
        The ID of the shared bandwidth of an IPv6 address.
        """
        return pulumi.get(self, "ipv6_bandwidth_id")

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> _builtins.bool:
        """
        Specifies whether to support IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_enable")

    @_builtins.property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> _builtins.bool:
        """
        Whether processing only traffic that is destined specifically for it.
        """
        return pulumi.get(self, "source_dest_check")


@pulumi.output_type
class GetGroupsGroupSecurityGroupResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the security group.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetHookInstancesInstanceHangingInfoResult(dict):
    def __init__(__self__, *,
                 default_result: _builtins.str,
                 instance_id: _builtins.str,
                 lifecycle_action_key: _builtins.str,
                 lifecycle_hook_name: _builtins.str,
                 lifecycle_hook_status: _builtins.str,
                 scaling_group_id: _builtins.str,
                 timeout: _builtins.str):
        """
        :param _builtins.str default_result: The default lifecycle hook callback operation.
        :param _builtins.str instance_id: Specifies the ID of the AS instance.
        :param _builtins.str lifecycle_action_key: The lifecycle action key, which determines the lifecycle callback object.
        :param _builtins.str lifecycle_hook_name: Specifies the name of the lifecycle hook.
        :param _builtins.str lifecycle_hook_status: Specifies the status of the lifecycle hook.
               The valid values are as follows:
               + **HANGING**: Suspends the instance.
               + **CONTINUE**: Continues the instance.
               + **ABANDON**: Terminates the instance.
        :param _builtins.str scaling_group_id: Specifies the ID of the AS group to which the AS instances belong.
        :param _builtins.str timeout: The timeout duration, in RFC3339 format.
        """
        pulumi.set(__self__, "default_result", default_result)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "lifecycle_action_key", lifecycle_action_key)
        pulumi.set(__self__, "lifecycle_hook_name", lifecycle_hook_name)
        pulumi.set(__self__, "lifecycle_hook_status", lifecycle_hook_status)
        pulumi.set(__self__, "scaling_group_id", scaling_group_id)
        pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="defaultResult")
    def default_result(self) -> _builtins.str:
        """
        The default lifecycle hook callback operation.
        """
        return pulumi.get(self, "default_result")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Specifies the ID of the AS instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="lifecycleActionKey")
    def lifecycle_action_key(self) -> _builtins.str:
        """
        The lifecycle action key, which determines the lifecycle callback object.
        """
        return pulumi.get(self, "lifecycle_action_key")

    @_builtins.property
    @pulumi.getter(name="lifecycleHookName")
    def lifecycle_hook_name(self) -> _builtins.str:
        """
        Specifies the name of the lifecycle hook.
        """
        return pulumi.get(self, "lifecycle_hook_name")

    @_builtins.property
    @pulumi.getter(name="lifecycleHookStatus")
    def lifecycle_hook_status(self) -> _builtins.str:
        """
        Specifies the status of the lifecycle hook.
        The valid values are as follows:
        + **HANGING**: Suspends the instance.
        + **CONTINUE**: Continues the instance.
        + **ABANDON**: Terminates the instance.
        """
        return pulumi.get(self, "lifecycle_hook_status")

    @_builtins.property
    @pulumi.getter(name="scalingGroupId")
    def scaling_group_id(self) -> _builtins.str:
        """
        Specifies the ID of the AS group to which the AS instances belong.
        """
        return pulumi.get(self, "scaling_group_id")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        The timeout duration, in RFC3339 format.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetInstancesInstanceResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 health_status: _builtins.str,
                 instance_id: _builtins.str,
                 instance_name: _builtins.str,
                 life_cycle_state: _builtins.str,
                 protect_from_scaling_down: _builtins.bool,
                 scaling_configuration_id: _builtins.str,
                 scaling_configuration_name: _builtins.str,
                 scaling_group_id: _builtins.str,
                 scaling_group_name: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the time when the instance is added to the AS group. The time format complies with UTC.
        :param _builtins.str health_status: Specifies the instance health status. Valid values are:
               + **INITIALIZING**: The instance is initializing.
               + **NORMAL**: The instance is normal.
               + **ERROR**: The instance is abnormal.
        :param _builtins.str instance_id: Indicates the instance ID.
        :param _builtins.str instance_name: Indicates the instance name.
        :param _builtins.str life_cycle_state: Specifies the instance lifecycle status in the AS group. Valid values are:
               + **INSERVICE**: The instance is enabled.
               + **PENDING**: The instance is being added to the AS group.
               + **PENDING_WAIT**: The instance is waiting to be added to the AS group.
               + **REMOVING**: The instance is being removed from the AS group.
               + **REMOVING_WAIT**: The instance is waiting to be removed from the AS group.
               + **STANDBY**: The instance is in standby state.
               + **ENTERING_STANDBY**: The instance is entering the standby state.
        :param _builtins.bool protect_from_scaling_down: Specifies the instance protection status. Valid values are:
               + **true**: Instance protection is enabled.
               + **false**: Instance protection is disabled.
        :param _builtins.str scaling_configuration_id: Indicates the AS configuration ID.
        :param _builtins.str scaling_configuration_name: Indicates the AS configuration name.
        :param _builtins.str scaling_group_id: Specifies the AS group ID.
        :param _builtins.str scaling_group_name: Indicates the name of the AS group to which the instance belongs.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "health_status", health_status)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "life_cycle_state", life_cycle_state)
        pulumi.set(__self__, "protect_from_scaling_down", protect_from_scaling_down)
        pulumi.set(__self__, "scaling_configuration_id", scaling_configuration_id)
        pulumi.set(__self__, "scaling_configuration_name", scaling_configuration_name)
        pulumi.set(__self__, "scaling_group_id", scaling_group_id)
        pulumi.set(__self__, "scaling_group_name", scaling_group_name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the time when the instance is added to the AS group. The time format complies with UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> _builtins.str:
        """
        Specifies the instance health status. Valid values are:
        + **INITIALIZING**: The instance is initializing.
        + **NORMAL**: The instance is normal.
        + **ERROR**: The instance is abnormal.
        """
        return pulumi.get(self, "health_status")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> _builtins.str:
        """
        Indicates the instance ID.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        Indicates the instance name.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="lifeCycleState")
    def life_cycle_state(self) -> _builtins.str:
        """
        Specifies the instance lifecycle status in the AS group. Valid values are:
        + **INSERVICE**: The instance is enabled.
        + **PENDING**: The instance is being added to the AS group.
        + **PENDING_WAIT**: The instance is waiting to be added to the AS group.
        + **REMOVING**: The instance is being removed from the AS group.
        + **REMOVING_WAIT**: The instance is waiting to be removed from the AS group.
        + **STANDBY**: The instance is in standby state.
        + **ENTERING_STANDBY**: The instance is entering the standby state.
        """
        return pulumi.get(self, "life_cycle_state")

    @_builtins.property
    @pulumi.getter(name="protectFromScalingDown")
    def protect_from_scaling_down(self) -> _builtins.bool:
        """
        Specifies the instance protection status. Valid values are:
        + **true**: Instance protection is enabled.
        + **false**: Instance protection is disabled.
        """
        return pulumi.get(self, "protect_from_scaling_down")

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationId")
    def scaling_configuration_id(self) -> _builtins.str:
        """
        Indicates the AS configuration ID.
        """
        return pulumi.get(self, "scaling_configuration_id")

    @_builtins.property
    @pulumi.getter(name="scalingConfigurationName")
    def scaling_configuration_name(self) -> _builtins.str:
        """
        Indicates the AS configuration name.
        """
        return pulumi.get(self, "scaling_configuration_name")

    @_builtins.property
    @pulumi.getter(name="scalingGroupId")
    def scaling_group_id(self) -> _builtins.str:
        """
        Specifies the AS group ID.
        """
        return pulumi.get(self, "scaling_group_id")

    @_builtins.property
    @pulumi.getter(name="scalingGroupName")
    def scaling_group_name(self) -> _builtins.str:
        """
        Indicates the name of the AS group to which the instance belongs.
        """
        return pulumi.get(self, "scaling_group_name")


@pulumi.output_type
class GetLifecycleHooksLifecycleHookResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 default_result: _builtins.str,
                 name: _builtins.str,
                 notification_message: _builtins.str,
                 notification_topic_name: _builtins.str,
                 notification_topic_urn: _builtins.str,
                 timeout: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str created_at: The creation time of the lifecycle hooks.
        :param _builtins.str default_result: Specifies the default lifecycle hook callback action. This action is
               performed when the timeout duration expires. The valid values are **ABANDON** and **CONTINUE**, defaults to **ABANDON**.
        :param _builtins.str name: Specifies the lifecycle hook name.
        :param _builtins.str notification_message: The customized notification. After a notification object is configured,
               the SMN service sends your customized notification to the object.
        :param _builtins.str notification_topic_name: The topic name of notification topic in SMN.
        :param _builtins.str notification_topic_urn: The unique URN of the notification topic in SMN.
        :param _builtins.int timeout: The lifecycle hook timeout duration in the unit of second.
        :param _builtins.str type: Specifies the lifecycle hook type. The valid values are as follows:
               + **ADD**: The hook suspends the instance when the instance is started.
               + **REMOVE**: The hook suspends the instance when the instance is terminated.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "default_result", default_result)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_message", notification_message)
        pulumi.set(__self__, "notification_topic_name", notification_topic_name)
        pulumi.set(__self__, "notification_topic_urn", notification_topic_urn)
        pulumi.set(__self__, "timeout", timeout)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the lifecycle hooks.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="defaultResult")
    def default_result(self) -> _builtins.str:
        """
        Specifies the default lifecycle hook callback action. This action is
        performed when the timeout duration expires. The valid values are **ABANDON** and **CONTINUE**, defaults to **ABANDON**.
        """
        return pulumi.get(self, "default_result")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the lifecycle hook name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notificationMessage")
    def notification_message(self) -> _builtins.str:
        """
        The customized notification. After a notification object is configured,
        the SMN service sends your customized notification to the object.
        """
        return pulumi.get(self, "notification_message")

    @_builtins.property
    @pulumi.getter(name="notificationTopicName")
    def notification_topic_name(self) -> _builtins.str:
        """
        The topic name of notification topic in SMN.
        """
        return pulumi.get(self, "notification_topic_name")

    @_builtins.property
    @pulumi.getter(name="notificationTopicUrn")
    def notification_topic_urn(self) -> _builtins.str:
        """
        The unique URN of the notification topic in SMN.
        """
        return pulumi.get(self, "notification_topic_urn")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        The lifecycle hook timeout duration in the unit of second.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the lifecycle hook type. The valid values are as follows:
        + **ADD**: The hook suspends the instance when the instance is started.
        + **REMOVE**: The hook suspends the instance when the instance is terminated.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNotificationsTopicResult(dict):
    def __init__(__self__, *,
                 events: Sequence[_builtins.str],
                 topic_name: _builtins.str,
                 topic_urn: _builtins.str):
        """
        :param Sequence[_builtins.str] events: The notification scene list.
        :param _builtins.str topic_name: Specifies the topic name in SMN.
        :param _builtins.str topic_urn: The unique topic URN in SMN.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "topic_name", topic_name)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Sequence[_builtins.str]:
        """
        The notification scene list.
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> _builtins.str:
        """
        Specifies the topic name in SMN.
        """
        return pulumi.get(self, "topic_name")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        The unique topic URN in SMN.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetPlannedTasksScheduledTaskResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 instance_numbers: Sequence['outputs.GetPlannedTasksScheduledTaskInstanceNumberResult'],
                 name: _builtins.str,
                 scaling_group_id: _builtins.str,
                 scheduled_policies: Sequence['outputs.GetPlannedTasksScheduledTaskScheduledPolicyResult']):
        """
        :param _builtins.str created_at: The creation time of the planned task, in RFC3339 format.
        :param _builtins.str id: The ID of the planned task.
        :param Sequence['GetPlannedTasksScheduledTaskInstanceNumberArgs'] instance_numbers: The instance number settings of the AS group.
        :param _builtins.str name: Specifies the name of the planned task.
        :param _builtins.str scaling_group_id: Specifies the ID of the AS group to which the planned tasks belong.
        :param Sequence['GetPlannedTasksScheduledTaskScheduledPolicyArgs'] scheduled_policies: The planned task policy.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_numbers", instance_numbers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scaling_group_id", scaling_group_id)
        pulumi.set(__self__, "scheduled_policies", scheduled_policies)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the planned task, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the planned task.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceNumbers")
    def instance_numbers(self) -> Sequence['outputs.GetPlannedTasksScheduledTaskInstanceNumberResult']:
        """
        The instance number settings of the AS group.
        """
        return pulumi.get(self, "instance_numbers")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the planned task.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="scalingGroupId")
    def scaling_group_id(self) -> _builtins.str:
        """
        Specifies the ID of the AS group to which the planned tasks belong.
        """
        return pulumi.get(self, "scaling_group_id")

    @_builtins.property
    @pulumi.getter(name="scheduledPolicies")
    def scheduled_policies(self) -> Sequence['outputs.GetPlannedTasksScheduledTaskScheduledPolicyResult']:
        """
        The planned task policy.
        """
        return pulumi.get(self, "scheduled_policies")


@pulumi.output_type
class GetPlannedTasksScheduledTaskInstanceNumberResult(dict):
    def __init__(__self__, *,
                 desire: _builtins.int,
                 max: _builtins.int,
                 min: _builtins.int):
        """
        :param _builtins.int desire: The expected number of instances in the AS group.
        :param _builtins.int max: The maximum number of instances in the AS group.
        :param _builtins.int min: The minimum number of instances in the AS group.
        """
        pulumi.set(__self__, "desire", desire)
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def desire(self) -> _builtins.int:
        """
        The expected number of instances in the AS group.
        """
        return pulumi.get(self, "desire")

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        """
        The maximum number of instances in the AS group.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        The minimum number of instances in the AS group.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class GetPlannedTasksScheduledTaskScheduledPolicyResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 launch_time: _builtins.str,
                 recurrence_type: _builtins.str,
                 recurrence_value: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str end_time: The end time of the valid period of the planned task, in RFC3339 format.
        :param _builtins.str launch_time: The execute time of the planned task.
               If **recurrence_type** is left empty or null, the time format is RFC3339.
               If **recurrence_type** is specified, the time format is **HH:mm**.
        :param _builtins.str recurrence_type: The triggering type of planned task.
        :param _builtins.str recurrence_value: The frequency at which planned task are triggered.
        :param _builtins.str start_time: The start time of the valid period of the planned task, in RFC3339 format.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "launch_time", launch_time)
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "recurrence_value", recurrence_value)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time of the valid period of the planned task, in RFC3339 format.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> _builtins.str:
        """
        The execute time of the planned task.
        If **recurrence_type** is left empty or null, the time format is RFC3339.
        If **recurrence_type** is specified, the time format is **HH:mm**.
        """
        return pulumi.get(self, "launch_time")

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> _builtins.str:
        """
        The triggering type of planned task.
        """
        return pulumi.get(self, "recurrence_type")

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> _builtins.str:
        """
        The frequency at which planned task are triggered.
        """
        return pulumi.get(self, "recurrence_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the valid period of the planned task, in RFC3339 format.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetPoliciesPolicyActionResult'],
                 alarm_id: _builtins.str,
                 cool_down_time: _builtins.int,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 scaling_group_id: _builtins.str,
                 scheduled_policies: Sequence['outputs.GetPoliciesPolicyScheduledPolicyResult'],
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param Sequence['GetPoliciesPolicyActionArgs'] actions: The action details of the scaling policy.  
               The action structure is documented below.
        :param _builtins.str alarm_id: The alarm rule ID. This field is not empty while `type` is **ALARM**.
        :param _builtins.int cool_down_time: The cooling duration, in seconds.
        :param _builtins.str created_at: The (UTC) creation time of the event source, in RFC3339 format.
        :param _builtins.str id: The scaling policy ID.
        :param _builtins.str name: The scaling policy name.
        :param _builtins.str scaling_group_id: Specifies the scaling group ID.
        :param Sequence['GetPoliciesPolicyScheduledPolicyArgs'] scheduled_policies: The periodic or scheduled scaling policy. This field is not empty while `type` is
               **SCHEDULED** or **RECURRENCE**.
               The scheduled_policy structure is documented below.
        :param _builtins.str status: The scaling policy status. The value can be **INSERVICE**, **PAUSED** or **EXECUTING**.
        :param _builtins.str type: The scaling policy type.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "alarm_id", alarm_id)
        pulumi.set(__self__, "cool_down_time", cool_down_time)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scaling_group_id", scaling_group_id)
        pulumi.set(__self__, "scheduled_policies", scheduled_policies)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetPoliciesPolicyActionResult']:
        """
        The action details of the scaling policy.  
        The action structure is documented below.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="alarmId")
    def alarm_id(self) -> _builtins.str:
        """
        The alarm rule ID. This field is not empty while `type` is **ALARM**.
        """
        return pulumi.get(self, "alarm_id")

    @_builtins.property
    @pulumi.getter(name="coolDownTime")
    def cool_down_time(self) -> _builtins.int:
        """
        The cooling duration, in seconds.
        """
        return pulumi.get(self, "cool_down_time")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The (UTC) creation time of the event source, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The scaling policy ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The scaling policy name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="scalingGroupId")
    def scaling_group_id(self) -> _builtins.str:
        """
        Specifies the scaling group ID.
        """
        return pulumi.get(self, "scaling_group_id")

    @_builtins.property
    @pulumi.getter(name="scheduledPolicies")
    def scheduled_policies(self) -> Sequence['outputs.GetPoliciesPolicyScheduledPolicyResult']:
        """
        The periodic or scheduled scaling policy. This field is not empty while `type` is
        **SCHEDULED** or **RECURRENCE**.
        The scheduled_policy structure is documented below.
        """
        return pulumi.get(self, "scheduled_policies")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The scaling policy status. The value can be **INSERVICE**, **PAUSED** or **EXECUTING**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The scaling policy type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPoliciesPolicyActionResult(dict):
    def __init__(__self__, *,
                 instance_number: _builtins.int,
                 instance_percentage: _builtins.int,
                 operation: _builtins.str):
        """
        :param _builtins.int instance_number: The number of instances to be operated.
        :param _builtins.int instance_percentage: The percentage of instances to be operated.
        :param _builtins.str operation: The operation to be performed.  
               The valid values are as follows:
               + **ADD**: add instances.
               + **REMOVE**: remove instances.
               + **SET**: set the number of instances to.
        """
        pulumi.set(__self__, "instance_number", instance_number)
        pulumi.set(__self__, "instance_percentage", instance_percentage)
        pulumi.set(__self__, "operation", operation)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> _builtins.int:
        """
        The number of instances to be operated.
        """
        return pulumi.get(self, "instance_number")

    @_builtins.property
    @pulumi.getter(name="instancePercentage")
    def instance_percentage(self) -> _builtins.int:
        """
        The percentage of instances to be operated.
        """
        return pulumi.get(self, "instance_percentage")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operation to be performed.  
        The valid values are as follows:
        + **ADD**: add instances.
        + **REMOVE**: remove instances.
        + **SET**: set the number of instances to.
        """
        return pulumi.get(self, "operation")


@pulumi.output_type
class GetPoliciesPolicyScheduledPolicyResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 launch_time: _builtins.str,
                 recurrence_type: _builtins.str,
                 recurrence_value: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str end_time: The end time of the scaling action triggered periodically. The time format complies with UTC.
               The time format is **YYYY-MM-DDThh:mmZ**.
        :param _builtins.str launch_time: The time when the scaling action is triggered.
               + If `type` is **SCHEDULED**, the time format is **YYYY-MM-DDThh:mmZ**.
               + If `type` is **RECURRENCE**, the time format is **hh:mm**.
        :param _builtins.str recurrence_type: The periodic triggering type. This field is not empty while `type` is **RECURRENCE**.
               The value can be **Daily**, **Weekly** or **Monthly**.
        :param _builtins.str recurrence_value: The frequency at which scaling actions are triggered.
               + When `recurrence_type` is **Daily**, this field is null, indicating daily execution.
               + When `recurrence_type` is **Weekly**, the valid value ranges from `1` to `7`, `1` represents Sunday,
               separate by commas. e.g. **1,3,5**.
               + When `recurrence_type` is **Monthly**, the valid value ranges from `1` to `31`, represent the dates of each month
               separately, separate by commas. e.g. **1,10,13,28**.
        :param _builtins.str start_time: The start time of the scaling action triggered periodically. The time format complies with UTC.
               The time format is **YYYY-MM-DDThh:mmZ**.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "launch_time", launch_time)
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "recurrence_value", recurrence_value)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time of the scaling action triggered periodically. The time format complies with UTC.
        The time format is **YYYY-MM-DDThh:mmZ**.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> _builtins.str:
        """
        The time when the scaling action is triggered.
        + If `type` is **SCHEDULED**, the time format is **YYYY-MM-DDThh:mmZ**.
        + If `type` is **RECURRENCE**, the time format is **hh:mm**.
        """
        return pulumi.get(self, "launch_time")

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> _builtins.str:
        """
        The periodic triggering type. This field is not empty while `type` is **RECURRENCE**.
        The value can be **Daily**, **Weekly** or **Monthly**.
        """
        return pulumi.get(self, "recurrence_type")

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> _builtins.str:
        """
        The frequency at which scaling actions are triggered.
        + When `recurrence_type` is **Daily**, this field is null, indicating daily execution.
        + When `recurrence_type` is **Weekly**, the valid value ranges from `1` to `7`, `1` represents Sunday,
        separate by commas. e.g. **1,3,5**.
        + When `recurrence_type` is **Monthly**, the valid value ranges from `1` to `31`, represent the dates of each month
        separately, separate by commas. e.g. **1,10,13,28**.
        """
        return pulumi.get(self, "recurrence_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the scaling action triggered periodically. The time format complies with UTC.
        The time format is **YYYY-MM-DDThh:mmZ**.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetPoliciesV2ScalingPolicyResult(dict):
    def __init__(__self__, *,
                 alarm_id: _builtins.str,
                 cool_down_time: _builtins.int,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 meta_datas: Sequence['outputs.GetPoliciesV2ScalingPolicyMetaDataResult'],
                 policy_status: _builtins.str,
                 scaling_policy_actions: Sequence['outputs.GetPoliciesV2ScalingPolicyScalingPolicyActionResult'],
                 scaling_policy_id: _builtins.str,
                 scaling_policy_name: _builtins.str,
                 scaling_policy_type: _builtins.str,
                 scaling_resource_id: _builtins.str,
                 scaling_resource_type: _builtins.str,
                 scheduled_policies: Sequence['outputs.GetPoliciesV2ScalingPolicyScheduledPolicyResult']):
        """
        :param _builtins.str alarm_id: Specifies the alarm rule ID associate with the AS policy.
        :param _builtins.int cool_down_time: The cooldown period, in seconds.
        :param _builtins.str create_time: The creation time of the AS policy. in UTC format.
        :param _builtins.str description: The AS policy description.
        :param Sequence['GetPoliciesV2ScalingPolicyMetaDataArgs'] meta_datas: The bandwidth policy additional information.
        :param _builtins.str policy_status: The AS policy status.
        :param Sequence['GetPoliciesV2ScalingPolicyScalingPolicyActionArgs'] scaling_policy_actions: The AS policy execute actions.
        :param _builtins.str scaling_policy_id: Specifies the AS policy ID.
        :param _builtins.str scaling_policy_name: Specifies the AS policy name.
               Fuzzy search is supported.
        :param _builtins.str scaling_policy_type: Specifies the AS policy type.
               The valid values are as follows:
               + **ALARM**: Alarm policy.
               + **SCHEDULED**: Scheduled policy.
               + **RECURRENCE**: Periodic policy.
        :param _builtins.str scaling_resource_id: Specifies the ID of the resource associate with the AS policy.
        :param _builtins.str scaling_resource_type: Specifies the resource type associate with the AS policy.
               The valid values are as follows:
               + **SCALING_GROUP**: AS group.
               + **BANDWIDTH**: Bandwidth.
        :param Sequence['GetPoliciesV2ScalingPolicyScheduledPolicyArgs'] scheduled_policies: The schedule and periodic policy contents.
        """
        pulumi.set(__self__, "alarm_id", alarm_id)
        pulumi.set(__self__, "cool_down_time", cool_down_time)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "meta_datas", meta_datas)
        pulumi.set(__self__, "policy_status", policy_status)
        pulumi.set(__self__, "scaling_policy_actions", scaling_policy_actions)
        pulumi.set(__self__, "scaling_policy_id", scaling_policy_id)
        pulumi.set(__self__, "scaling_policy_name", scaling_policy_name)
        pulumi.set(__self__, "scaling_policy_type", scaling_policy_type)
        pulumi.set(__self__, "scaling_resource_id", scaling_resource_id)
        pulumi.set(__self__, "scaling_resource_type", scaling_resource_type)
        pulumi.set(__self__, "scheduled_policies", scheduled_policies)

    @_builtins.property
    @pulumi.getter(name="alarmId")
    def alarm_id(self) -> _builtins.str:
        """
        Specifies the alarm rule ID associate with the AS policy.
        """
        return pulumi.get(self, "alarm_id")

    @_builtins.property
    @pulumi.getter(name="coolDownTime")
    def cool_down_time(self) -> _builtins.int:
        """
        The cooldown period, in seconds.
        """
        return pulumi.get(self, "cool_down_time")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the AS policy. in UTC format.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The AS policy description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="metaDatas")
    def meta_datas(self) -> Sequence['outputs.GetPoliciesV2ScalingPolicyMetaDataResult']:
        """
        The bandwidth policy additional information.
        """
        return pulumi.get(self, "meta_datas")

    @_builtins.property
    @pulumi.getter(name="policyStatus")
    def policy_status(self) -> _builtins.str:
        """
        The AS policy status.
        """
        return pulumi.get(self, "policy_status")

    @_builtins.property
    @pulumi.getter(name="scalingPolicyActions")
    def scaling_policy_actions(self) -> Sequence['outputs.GetPoliciesV2ScalingPolicyScalingPolicyActionResult']:
        """
        The AS policy execute actions.
        """
        return pulumi.get(self, "scaling_policy_actions")

    @_builtins.property
    @pulumi.getter(name="scalingPolicyId")
    def scaling_policy_id(self) -> _builtins.str:
        """
        Specifies the AS policy ID.
        """
        return pulumi.get(self, "scaling_policy_id")

    @_builtins.property
    @pulumi.getter(name="scalingPolicyName")
    def scaling_policy_name(self) -> _builtins.str:
        """
        Specifies the AS policy name.
        Fuzzy search is supported.
        """
        return pulumi.get(self, "scaling_policy_name")

    @_builtins.property
    @pulumi.getter(name="scalingPolicyType")
    def scaling_policy_type(self) -> _builtins.str:
        """
        Specifies the AS policy type.
        The valid values are as follows:
        + **ALARM**: Alarm policy.
        + **SCHEDULED**: Scheduled policy.
        + **RECURRENCE**: Periodic policy.
        """
        return pulumi.get(self, "scaling_policy_type")

    @_builtins.property
    @pulumi.getter(name="scalingResourceId")
    def scaling_resource_id(self) -> _builtins.str:
        """
        Specifies the ID of the resource associate with the AS policy.
        """
        return pulumi.get(self, "scaling_resource_id")

    @_builtins.property
    @pulumi.getter(name="scalingResourceType")
    def scaling_resource_type(self) -> _builtins.str:
        """
        Specifies the resource type associate with the AS policy.
        The valid values are as follows:
        + **SCALING_GROUP**: AS group.
        + **BANDWIDTH**: Bandwidth.
        """
        return pulumi.get(self, "scaling_resource_type")

    @_builtins.property
    @pulumi.getter(name="scheduledPolicies")
    def scheduled_policies(self) -> Sequence['outputs.GetPoliciesV2ScalingPolicyScheduledPolicyResult']:
        """
        The schedule and periodic policy contents.
        """
        return pulumi.get(self, "scheduled_policies")


@pulumi.output_type
class GetPoliciesV2ScalingPolicyMetaDataResult(dict):
    def __init__(__self__, *,
                 metadata_bandwidth_share_type: _builtins.str,
                 metadata_eip_address: _builtins.str,
                 metadata_eip_id: _builtins.str):
        """
        :param _builtins.str metadata_bandwidth_share_type: The bandwidth sharing type in the bandwidth scaling policy.
        :param _builtins.str metadata_eip_address: The EIP IP address for the bandwidth in the bandwidth scaling policy.
        :param _builtins.str metadata_eip_id: The EIP ID for the bandwidth in the bandwidth scaling policy.
        """
        pulumi.set(__self__, "metadata_bandwidth_share_type", metadata_bandwidth_share_type)
        pulumi.set(__self__, "metadata_eip_address", metadata_eip_address)
        pulumi.set(__self__, "metadata_eip_id", metadata_eip_id)

    @_builtins.property
    @pulumi.getter(name="metadataBandwidthShareType")
    def metadata_bandwidth_share_type(self) -> _builtins.str:
        """
        The bandwidth sharing type in the bandwidth scaling policy.
        """
        return pulumi.get(self, "metadata_bandwidth_share_type")

    @_builtins.property
    @pulumi.getter(name="metadataEipAddress")
    def metadata_eip_address(self) -> _builtins.str:
        """
        The EIP IP address for the bandwidth in the bandwidth scaling policy.
        """
        return pulumi.get(self, "metadata_eip_address")

    @_builtins.property
    @pulumi.getter(name="metadataEipId")
    def metadata_eip_id(self) -> _builtins.str:
        """
        The EIP ID for the bandwidth in the bandwidth scaling policy.
        """
        return pulumi.get(self, "metadata_eip_id")


@pulumi.output_type
class GetPoliciesV2ScalingPolicyScalingPolicyActionResult(dict):
    def __init__(__self__, *,
                 limits: _builtins.int,
                 operation: _builtins.str,
                 percentage: _builtins.int,
                 size: _builtins.int):
        """
        :param _builtins.int limits: The operation restrictions.
        :param _builtins.str operation: The operation to be performed.
        :param _builtins.int percentage: The percentage of instances to be operated.
        :param _builtins.int size: The operation size.
        """
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "percentage", percentage)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> _builtins.int:
        """
        The operation restrictions.
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter
    def operation(self) -> _builtins.str:
        """
        The operation to be performed.
        """
        return pulumi.get(self, "operation")

    @_builtins.property
    @pulumi.getter
    def percentage(self) -> _builtins.int:
        """
        The percentage of instances to be operated.
        """
        return pulumi.get(self, "percentage")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        The operation size.
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class GetPoliciesV2ScalingPolicyScheduledPolicyResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 launch_time: _builtins.str,
                 recurrence_type: _builtins.str,
                 recurrence_value: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str end_time: The end time of the scaling action triggered periodically.
        :param _builtins.str launch_time: The time when the scaling action is triggered.
        :param _builtins.str recurrence_type: The periodic triggering type.
        :param _builtins.str recurrence_value: The day when a periodic scaling action is triggered.
        :param _builtins.str start_time: The start time of the scaling action triggered periodically.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "launch_time", launch_time)
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "recurrence_value", recurrence_value)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        The end time of the scaling action triggered periodically.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> _builtins.str:
        """
        The time when the scaling action is triggered.
        """
        return pulumi.get(self, "launch_time")

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> _builtins.str:
        """
        The periodic triggering type.
        """
        return pulumi.get(self, "recurrence_type")

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> _builtins.str:
        """
        The day when a periodic scaling action is triggered.
        """
        return pulumi.get(self, "recurrence_value")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the scaling action triggered periodically.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetPolicyExecuteLogsExecuteLogResult(dict):
    def __init__(__self__, *,
                 desire_value: _builtins.str,
                 execute_time: _builtins.str,
                 execute_type: _builtins.str,
                 failed_reason: _builtins.str,
                 id: _builtins.str,
                 job_records: Sequence['outputs.GetPolicyExecuteLogsExecuteLogJobRecordResult'],
                 limit_value: _builtins.str,
                 metadata: Mapping[str, _builtins.str],
                 old_value: _builtins.str,
                 scaling_policy_id: _builtins.str,
                 scaling_resource_id: _builtins.str,
                 scaling_resource_type: _builtins.str,
                 status: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str desire_value: The scaling target value.
               + When `scaling_resource_type` is **SCALING_GROUP**, this field represents the number of instances.
               + When `scaling_resource_type` is **BANDWIDTH**, this field represents the bandwidth size, in Mbit/s.
        :param _builtins.str execute_time: The policy execution time, the time format is **yyyy-MM-ddThh:mm:ssZ**.
        :param _builtins.str execute_type: Specifies the policy execution type.  
               The valid values are as follows:
               + **SCHEDULED**: automatically triggered scheduled policy.
               + **RECURRENCE**: automatically triggered recurrence policy.
               + **ALARM**: automatically triggered alarm policy.
               + **MANUAL**: manually triggered policy.
        :param _builtins.str failed_reason: The reason of policy execution failure.
        :param _builtins.str id: The policy execution log ID.
        :param Sequence['GetPolicyExecuteLogsExecuteLogJobRecordArgs'] job_records: The concrete tasks included in executing actions.  
               The job_records structure is documented below.
        :param _builtins.str limit_value: The operational limitations. When `scaling_resource_type` is **BANDWIDTH** and `type` is not **SET**,
               this field takes effect in Mbit/s.
               + When `type` is **ADD**, this field represents the maximum bandwidth limit.
               + When `type` is **REMOVE**, this field represents the minimum bandwidth limit.
        :param Mapping[str, _builtins.str] metadata: The additional information.
        :param _builtins.str old_value: The scaling original value.
               + When `scaling_resource_type` is **SCALING_GROUP**, this field represents the number of instances.
               + When `scaling_resource_type` is **BANDWIDTH**, this field represents the bandwidth size, in Mbit/s.
        :param _builtins.str scaling_policy_id: Specifies the scaling policy ID.
        :param _builtins.str scaling_resource_id: Specifies the scaling resource ID.
        :param _builtins.str scaling_resource_type: Specifies the scaling resource type.
               The value can be **SCALING_GROUP** or **BANDWIDTH**.
        :param _builtins.str status: Specifies the policy execution status. The value can be **SUCCESS**, **FAIL**
               or **EXECUTING**.
        :param _builtins.str type: The policy execution task type. The value can be **REMOVE**, **ADD** or **SET**.
        """
        pulumi.set(__self__, "desire_value", desire_value)
        pulumi.set(__self__, "execute_time", execute_time)
        pulumi.set(__self__, "execute_type", execute_type)
        pulumi.set(__self__, "failed_reason", failed_reason)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_records", job_records)
        pulumi.set(__self__, "limit_value", limit_value)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "old_value", old_value)
        pulumi.set(__self__, "scaling_policy_id", scaling_policy_id)
        pulumi.set(__self__, "scaling_resource_id", scaling_resource_id)
        pulumi.set(__self__, "scaling_resource_type", scaling_resource_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="desireValue")
    def desire_value(self) -> _builtins.str:
        """
        The scaling target value.
        + When `scaling_resource_type` is **SCALING_GROUP**, this field represents the number of instances.
        + When `scaling_resource_type` is **BANDWIDTH**, this field represents the bandwidth size, in Mbit/s.
        """
        return pulumi.get(self, "desire_value")

    @_builtins.property
    @pulumi.getter(name="executeTime")
    def execute_time(self) -> _builtins.str:
        """
        The policy execution time, the time format is **yyyy-MM-ddThh:mm:ssZ**.
        """
        return pulumi.get(self, "execute_time")

    @_builtins.property
    @pulumi.getter(name="executeType")
    def execute_type(self) -> _builtins.str:
        """
        Specifies the policy execution type.  
        The valid values are as follows:
        + **SCHEDULED**: automatically triggered scheduled policy.
        + **RECURRENCE**: automatically triggered recurrence policy.
        + **ALARM**: automatically triggered alarm policy.
        + **MANUAL**: manually triggered policy.
        """
        return pulumi.get(self, "execute_type")

    @_builtins.property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> _builtins.str:
        """
        The reason of policy execution failure.
        """
        return pulumi.get(self, "failed_reason")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The policy execution log ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="jobRecords")
    def job_records(self) -> Sequence['outputs.GetPolicyExecuteLogsExecuteLogJobRecordResult']:
        """
        The concrete tasks included in executing actions.  
        The job_records structure is documented below.
        """
        return pulumi.get(self, "job_records")

    @_builtins.property
    @pulumi.getter(name="limitValue")
    def limit_value(self) -> _builtins.str:
        """
        The operational limitations. When `scaling_resource_type` is **BANDWIDTH** and `type` is not **SET**,
        this field takes effect in Mbit/s.
        + When `type` is **ADD**, this field represents the maximum bandwidth limit.
        + When `type` is **REMOVE**, this field represents the minimum bandwidth limit.
        """
        return pulumi.get(self, "limit_value")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        The additional information.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="oldValue")
    def old_value(self) -> _builtins.str:
        """
        The scaling original value.
        + When `scaling_resource_type` is **SCALING_GROUP**, this field represents the number of instances.
        + When `scaling_resource_type` is **BANDWIDTH**, this field represents the bandwidth size, in Mbit/s.
        """
        return pulumi.get(self, "old_value")

    @_builtins.property
    @pulumi.getter(name="scalingPolicyId")
    def scaling_policy_id(self) -> _builtins.str:
        """
        Specifies the scaling policy ID.
        """
        return pulumi.get(self, "scaling_policy_id")

    @_builtins.property
    @pulumi.getter(name="scalingResourceId")
    def scaling_resource_id(self) -> _builtins.str:
        """
        Specifies the scaling resource ID.
        """
        return pulumi.get(self, "scaling_resource_id")

    @_builtins.property
    @pulumi.getter(name="scalingResourceType")
    def scaling_resource_type(self) -> _builtins.str:
        """
        Specifies the scaling resource type.
        The value can be **SCALING_GROUP** or **BANDWIDTH**.
        """
        return pulumi.get(self, "scaling_resource_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the policy execution status. The value can be **SUCCESS**, **FAIL**
        or **EXECUTING**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The policy execution task type. The value can be **REMOVE**, **ADD** or **SET**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPolicyExecuteLogsExecuteLogJobRecordResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 job_name: _builtins.str,
                 job_status: _builtins.str,
                 message: _builtins.str,
                 record_time: _builtins.str,
                 record_type: _builtins.str,
                 request: _builtins.str,
                 response: _builtins.str):
        """
        :param _builtins.str code: The response code, the field is valid while `record_type` is **API**.
        :param _builtins.str job_name: The job name.
        :param _builtins.str job_status: The job execution status. The value can be **SUCCESS** or **FAIL**.
        :param _builtins.str message: The message content, the field is valid while `record_type` is **MEG**.
        :param _builtins.str record_time: The record time, the time format is **YYYY-MM-DDThh:mmZ**.
        :param _builtins.str record_type: The record type. The value can be **API** or **MEG**.
        :param _builtins.str request: The request information, the field is valid while `record_type` is **API**.
        :param _builtins.str response: The response information, the field is valid while `record_type` is **API**.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "job_name", job_name)
        pulumi.set(__self__, "job_status", job_status)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "record_time", record_time)
        pulumi.set(__self__, "record_type", record_type)
        pulumi.set(__self__, "request", request)
        pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        The response code, the field is valid while `record_type` is **API**.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="jobName")
    def job_name(self) -> _builtins.str:
        """
        The job name.
        """
        return pulumi.get(self, "job_name")

    @_builtins.property
    @pulumi.getter(name="jobStatus")
    def job_status(self) -> _builtins.str:
        """
        The job execution status. The value can be **SUCCESS** or **FAIL**.
        """
        return pulumi.get(self, "job_status")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The message content, the field is valid while `record_type` is **MEG**.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="recordTime")
    def record_time(self) -> _builtins.str:
        """
        The record time, the time format is **YYYY-MM-DDThh:mmZ**.
        """
        return pulumi.get(self, "record_time")

    @_builtins.property
    @pulumi.getter(name="recordType")
    def record_type(self) -> _builtins.str:
        """
        The record type. The value can be **API** or **MEG**.
        """
        return pulumi.get(self, "record_type")

    @_builtins.property
    @pulumi.getter
    def request(self) -> _builtins.str:
        """
        The request information, the field is valid while `record_type` is **API**.
        """
        return pulumi.get(self, "request")

    @_builtins.property
    @pulumi.getter
    def response(self) -> _builtins.str:
        """
        The response information, the field is valid while `record_type` is **API**.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class GetQuotasQuotaResult(dict):
    def __init__(__self__, *,
                 resources: Sequence['outputs.GetQuotasQuotaResourceResult']):
        """
        :param Sequence['GetQuotasQuotaResourceArgs'] resources: The quota resources.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetQuotasQuotaResourceResult']:
        """
        The quota resources.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetQuotasQuotaResourceResult(dict):
    def __init__(__self__, *,
                 max: _builtins.int,
                 min: _builtins.int,
                 quota: _builtins.int,
                 type: _builtins.str,
                 used: _builtins.int):
        """
        :param _builtins.int max: The quota upper limit.
        :param _builtins.int min: The quota lower limit.
        :param _builtins.int quota: The total quota.
        :param _builtins.str type: The quota type. Values are:
               + **scaling_Group**: AS group quota.
               + **scaling_Config**: AS configuration quota.
               + **scaling_Policy**: AS policy quota.
               + **scaling_Instance**: Instance quota.
               + **bandwidth_scaling_policy**: Bandwidth scaling policy quota.
        :param _builtins.int used: The used amount of the quota.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "quota", quota)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "used", used)

    @_builtins.property
    @pulumi.getter
    def max(self) -> _builtins.int:
        """
        The quota upper limit.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> _builtins.int:
        """
        The quota lower limit.
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter
    def quota(self) -> _builtins.int:
        """
        The total quota.
        """
        return pulumi.get(self, "quota")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The quota type. Values are:
        + **scaling_Group**: AS group quota.
        + **scaling_Config**: AS configuration quota.
        + **scaling_Policy**: AS policy quota.
        + **scaling_Instance**: Instance quota.
        + **bandwidth_scaling_policy**: Bandwidth scaling policy quota.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def used(self) -> _builtins.int:
        """
        The used amount of the quota.
        """
        return pulumi.get(self, "used")


