# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BandwidthPolicyIntervalAlarmActionArgs',
    'BandwidthPolicyIntervalAlarmActionArgsDict',
    'BandwidthPolicyMetaDataArgs',
    'BandwidthPolicyMetaDataArgsDict',
    'BandwidthPolicyScalingPolicyActionArgs',
    'BandwidthPolicyScalingPolicyActionArgsDict',
    'BandwidthPolicyScheduledPolicyArgs',
    'BandwidthPolicyScheduledPolicyArgsDict',
    'ConfigurationInstanceConfigArgs',
    'ConfigurationInstanceConfigArgsDict',
    'ConfigurationInstanceConfigDiskArgs',
    'ConfigurationInstanceConfigDiskArgsDict',
    'ConfigurationInstanceConfigPersonalityArgs',
    'ConfigurationInstanceConfigPersonalityArgsDict',
    'ConfigurationInstanceConfigPublicIpArgs',
    'ConfigurationInstanceConfigPublicIpArgsDict',
    'ConfigurationInstanceConfigPublicIpEipArgs',
    'ConfigurationInstanceConfigPublicIpEipArgsDict',
    'ConfigurationInstanceConfigPublicIpEipBandwidthArgs',
    'ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict',
    'ConfigurationV1InstanceConfigArgs',
    'ConfigurationV1InstanceConfigArgsDict',
    'ConfigurationV1InstanceConfigDiskArgs',
    'ConfigurationV1InstanceConfigDiskArgsDict',
    'ConfigurationV1InstanceConfigPersonalityArgs',
    'ConfigurationV1InstanceConfigPersonalityArgsDict',
    'ConfigurationV1InstanceConfigPublicIpArgs',
    'ConfigurationV1InstanceConfigPublicIpArgsDict',
    'ConfigurationV1InstanceConfigPublicIpEipArgs',
    'ConfigurationV1InstanceConfigPublicIpEipArgsDict',
    'ConfigurationV1InstanceConfigPublicIpEipBandwidthArgs',
    'ConfigurationV1InstanceConfigPublicIpEipBandwidthArgsDict',
    'GroupLbaasListenerArgs',
    'GroupLbaasListenerArgsDict',
    'GroupNetworkArgs',
    'GroupNetworkArgsDict',
    'GroupSecurityGroupArgs',
    'GroupSecurityGroupArgsDict',
    'GroupV1LbaasListenerArgs',
    'GroupV1LbaasListenerArgsDict',
    'GroupV1NetworkArgs',
    'GroupV1NetworkArgsDict',
    'GroupV1SecurityGroupArgs',
    'GroupV1SecurityGroupArgsDict',
    'PlannedTaskInstanceNumberArgs',
    'PlannedTaskInstanceNumberArgsDict',
    'PlannedTaskScheduledPolicyArgs',
    'PlannedTaskScheduledPolicyArgsDict',
    'PolicyScalingPolicyActionArgs',
    'PolicyScalingPolicyActionArgsDict',
    'PolicyScheduledPolicyArgs',
    'PolicyScheduledPolicyArgsDict',
    'PolicyV1ScalingPolicyActionArgs',
    'PolicyV1ScalingPolicyActionArgsDict',
    'PolicyV1ScheduledPolicyArgs',
    'PolicyV1ScheduledPolicyArgsDict',
]

MYPY = False

if not MYPY:
    class BandwidthPolicyIntervalAlarmActionArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the operation restrictions, unit is Mbit/s.
        The valid values from `1` to `2,000`.
        If `operation` is not **SET**, this parameter takes effect.
        If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
        If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        """
        lower_bound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the lower limit of the value range.
        The value is null by default. The minimum lower limit allowed is `-1.174271E108`.
        """
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operation to be performed.
        The valid values are as follows:
        + **ADD** (default): Indicates adding the bandwidth size.
        + **REDUCE**: Indicates reducing the bandwidth size.
        + **SET**: Indicates setting the bandwidth size to a specified value.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the operation size, unit is Mbit/s.
        The valid values from `1` to `300`, the default value is `1`.
        """
        upper_bound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the upper limit of the value range.
        The value is null by default. The maximum upper limit allowed is `1.174271E108`.

        > 1. If the `lower_bound` is null, the `upper_bound` must be less than or equal to `0`.
        <br/>2. If the `upper_bound` is null, the `lower_bound` must be greater than or equal to `0`.
        <br/>3. The `lower_bound` and the `upper_bound` cannot be both `0` at the same time.
        <br/>4. The `lower_bound` and `upper_bound` can not be less than `0` when the
        alarm rule `condition.comparison_operator` is set to **>** or **>=**.
        <br/>5. The `lower_bound` and `upper_bound` can be less than `0` when the
        alarm rule `condition.comparison_operator` is set to **<** or **<=**.
        <br/>6. If adding multiple alarm intervals, each interval value range cannot overlap.
        """
elif False:
    BandwidthPolicyIntervalAlarmActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyIntervalAlarmActionArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[_builtins.int]] = None,
                 lower_bound: Optional[pulumi.Input[_builtins.str]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 upper_bound: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] limits: Specifies the operation restrictions, unit is Mbit/s.
               The valid values from `1` to `2,000`.
               If `operation` is not **SET**, this parameter takes effect.
               If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
               If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        :param pulumi.Input[_builtins.str] lower_bound: Specifies the lower limit of the value range.
               The value is null by default. The minimum lower limit allowed is `-1.174271E108`.
        :param pulumi.Input[_builtins.str] operation: Specifies the operation to be performed.
               The valid values are as follows:
               + **ADD** (default): Indicates adding the bandwidth size.
               + **REDUCE**: Indicates reducing the bandwidth size.
               + **SET**: Indicates setting the bandwidth size to a specified value.
        :param pulumi.Input[_builtins.int] size: Specifies the operation size, unit is Mbit/s.
               The valid values from `1` to `300`, the default value is `1`.
        :param pulumi.Input[_builtins.str] upper_bound: Specifies the upper limit of the value range.
               The value is null by default. The maximum upper limit allowed is `1.174271E108`.
               
               > 1. If the `lower_bound` is null, the `upper_bound` must be less than or equal to `0`.
               <br/>2. If the `upper_bound` is null, the `lower_bound` must be greater than or equal to `0`.
               <br/>3. The `lower_bound` and the `upper_bound` cannot be both `0` at the same time.
               <br/>4. The `lower_bound` and `upper_bound` can not be less than `0` when the
               alarm rule `condition.comparison_operator` is set to **>** or **>=**.
               <br/>5. The `lower_bound` and `upper_bound` can be less than `0` when the
               alarm rule `condition.comparison_operator` is set to **<** or **<=**.
               <br/>6. If adding multiple alarm intervals, each interval value range cannot overlap.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if lower_bound is not None:
            pulumi.set(__self__, "lower_bound", lower_bound)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if upper_bound is not None:
            pulumi.set(__self__, "upper_bound", upper_bound)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the operation restrictions, unit is Mbit/s.
        The valid values from `1` to `2,000`.
        If `operation` is not **SET**, this parameter takes effect.
        If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
        If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the lower limit of the value range.
        The value is null by default. The minimum lower limit allowed is `-1.174271E108`.
        """
        return pulumi.get(self, "lower_bound")

    @lower_bound.setter
    def lower_bound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lower_bound", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operation to be performed.
        The valid values are as follows:
        + **ADD** (default): Indicates adding the bandwidth size.
        + **REDUCE**: Indicates reducing the bandwidth size.
        + **SET**: Indicates setting the bandwidth size to a specified value.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the operation size, unit is Mbit/s.
        The valid values from `1` to `300`, the default value is `1`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the upper limit of the value range.
        The value is null by default. The maximum upper limit allowed is `1.174271E108`.

        > 1. If the `lower_bound` is null, the `upper_bound` must be less than or equal to `0`.
        <br/>2. If the `upper_bound` is null, the `lower_bound` must be greater than or equal to `0`.
        <br/>3. The `lower_bound` and the `upper_bound` cannot be both `0` at the same time.
        <br/>4. The `lower_bound` and `upper_bound` can not be less than `0` when the
        alarm rule `condition.comparison_operator` is set to **>** or **>=**.
        <br/>5. The `lower_bound` and `upper_bound` can be less than `0` when the
        alarm rule `condition.comparison_operator` is set to **<** or **<=**.
        <br/>6. If adding multiple alarm intervals, each interval value range cannot overlap.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upper_bound", value)


if not MYPY:
    class BandwidthPolicyMetaDataArgsDict(TypedDict):
        metadata_bandwidth_share_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bandwidth sharing type in the bandwidth policy.
        """
        metadata_eip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP IP address for the bandwidth in the bandwidth policy.
        """
        metadata_eip_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP ID for the bandwidth in the bandwidth policy.
        """
elif False:
    BandwidthPolicyMetaDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyMetaDataArgs:
    def __init__(__self__, *,
                 metadata_bandwidth_share_type: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata_eip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata_eip_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata_bandwidth_share_type: The bandwidth sharing type in the bandwidth policy.
        :param pulumi.Input[_builtins.str] metadata_eip_address: The EIP IP address for the bandwidth in the bandwidth policy.
        :param pulumi.Input[_builtins.str] metadata_eip_id: The EIP ID for the bandwidth in the bandwidth policy.
        """
        if metadata_bandwidth_share_type is not None:
            pulumi.set(__self__, "metadata_bandwidth_share_type", metadata_bandwidth_share_type)
        if metadata_eip_address is not None:
            pulumi.set(__self__, "metadata_eip_address", metadata_eip_address)
        if metadata_eip_id is not None:
            pulumi.set(__self__, "metadata_eip_id", metadata_eip_id)

    @_builtins.property
    @pulumi.getter(name="metadataBandwidthShareType")
    def metadata_bandwidth_share_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bandwidth sharing type in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_bandwidth_share_type")

    @metadata_bandwidth_share_type.setter
    def metadata_bandwidth_share_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_bandwidth_share_type", value)

    @_builtins.property
    @pulumi.getter(name="metadataEipAddress")
    def metadata_eip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP IP address for the bandwidth in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_eip_address")

    @metadata_eip_address.setter
    def metadata_eip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_eip_address", value)

    @_builtins.property
    @pulumi.getter(name="metadataEipId")
    def metadata_eip_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP ID for the bandwidth in the bandwidth policy.
        """
        return pulumi.get(self, "metadata_eip_id")

    @metadata_eip_id.setter
    def metadata_eip_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata_eip_id", value)


if not MYPY:
    class BandwidthPolicyScalingPolicyActionArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the operation restrictions, unit is Mbit/s.
        The valid values from `1` to `2,000`.
        If `operation` is not **SET**, this parameter takes effect.
        If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
        If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        """
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operation to be performed.
        The valid values are as follows:
        + **ADD** (default): Indicates adding the bandwidth size.
        + **REDUCE**: Indicates reducing the bandwidth size.
        + **SET**: Indicates setting the bandwidth size to a specified value.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the operation size, unit is Mbit/s.
        The valid values from `1` to `300`, the default value is `1`.
        """
elif False:
    BandwidthPolicyScalingPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyScalingPolicyActionArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[_builtins.int]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] limits: Specifies the operation restrictions, unit is Mbit/s.
               The valid values from `1` to `2,000`.
               If `operation` is not **SET**, this parameter takes effect.
               If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
               If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        :param pulumi.Input[_builtins.str] operation: Specifies the operation to be performed.
               The valid values are as follows:
               + **ADD** (default): Indicates adding the bandwidth size.
               + **REDUCE**: Indicates reducing the bandwidth size.
               + **SET**: Indicates setting the bandwidth size to a specified value.
        :param pulumi.Input[_builtins.int] size: Specifies the operation size, unit is Mbit/s.
               The valid values from `1` to `300`, the default value is `1`.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the operation restrictions, unit is Mbit/s.
        The valid values from `1` to `2,000`.
        If `operation` is not **SET**, this parameter takes effect.
        If `operation` is set to **ADD**, this parameter indicates the maximum bandwidth allowed.
        If `operation` is set to **REDUCE**, this parameter indicates the minimum bandwidth allowed.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "limits", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operation to be performed.
        The valid values are as follows:
        + **ADD** (default): Indicates adding the bandwidth size.
        + **REDUCE**: Indicates reducing the bandwidth size.
        + **SET**: Indicates setting the bandwidth size to a specified value.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the operation size, unit is Mbit/s.
        The valid values from `1` to `300`, the default value is `1`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class BandwidthPolicyScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[_builtins.str]
        """
        Specifies the time when the scaling action is triggered.
        The time format complies with UTC.
        If `scaling_policy_type` is set to **SCHEDULED**, the time format is **YYYY-MM-DDThh:mmZ**.
        If `scaling_policy_type` is set to **RECURRENCE**, the time format is **hh:mm**.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the end time of the scaling action triggered periodically.
        The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
        When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
        The time format is **YYYY-MM-DDThh:mmZ**.

        <a name="bandwidth_policy_interval_alarm"></a>
        The `interval_alarm_actions` block supports:
        """
        recurrence_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the periodic triggering type.
        This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
        The valid values are as follows:
        + **Daily**: Indicates that the scaling action is triggered once a day.
        + **Weekly**: Indicates that the scaling action is triggered once a week.
        + **Monthly**: Indicates that the scaling action is triggered once a month.
        """
        recurrence_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the day when a periodic scaling action is triggered.
        This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
        <br/>If `recurrence_type` is set to **Daily**, the value is null, indicating that the scaling action is triggered
        once a day.
        <br/>If `recurrence_type` is set to **Weekly**, the value ranges from `1` (Sunday) to `7` (Saturday).
        The digits refer to dates in each week and separated by a comma, such as **1,3,5**.
        <br/>If `recurrence_type` is set to **Monthly**, the value ranges from `1` to `31`.
        The digits refer to the dates in each month and separated by a comma, such as **1,10,13,28**.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the start time of the scaling action triggered periodically.
        The time format complies with UTC. The default value is the local time.
        The time format is **YYYY-MM-DDThh:mmZ**.
        """
elif False:
    BandwidthPolicyScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPolicyScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] launch_time: Specifies the time when the scaling action is triggered.
               The time format complies with UTC.
               If `scaling_policy_type` is set to **SCHEDULED**, the time format is **YYYY-MM-DDThh:mmZ**.
               If `scaling_policy_type` is set to **RECURRENCE**, the time format is **hh:mm**.
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time of the scaling action triggered periodically.
               The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
               When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
               The time format is **YYYY-MM-DDThh:mmZ**.
               
               <a name="bandwidth_policy_interval_alarm"></a>
               The `interval_alarm_actions` block supports:
        :param pulumi.Input[_builtins.str] recurrence_type: Specifies the periodic triggering type.
               This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
               The valid values are as follows:
               + **Daily**: Indicates that the scaling action is triggered once a day.
               + **Weekly**: Indicates that the scaling action is triggered once a week.
               + **Monthly**: Indicates that the scaling action is triggered once a month.
        :param pulumi.Input[_builtins.str] recurrence_value: Specifies the day when a periodic scaling action is triggered.
               This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
               <br/>If `recurrence_type` is set to **Daily**, the value is null, indicating that the scaling action is triggered
               once a day.
               <br/>If `recurrence_type` is set to **Weekly**, the value ranges from `1` (Sunday) to `7` (Saturday).
               The digits refer to dates in each week and separated by a comma, such as **1,3,5**.
               <br/>If `recurrence_type` is set to **Monthly**, the value ranges from `1` to `31`.
               The digits refer to the dates in each month and separated by a comma, such as **1,10,13,28**.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time of the scaling action triggered periodically.
               The time format complies with UTC. The default value is the local time.
               The time format is **YYYY-MM-DDThh:mmZ**.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the time when the scaling action is triggered.
        The time format complies with UTC.
        If `scaling_policy_type` is set to **SCHEDULED**, the time format is **YYYY-MM-DDThh:mmZ**.
        If `scaling_policy_type` is set to **RECURRENCE**, the time format is **hh:mm**.
        """
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "launch_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the end time of the scaling action triggered periodically.
        The time format complies with UTC. This parameter is mandatory when scaling_policy_type is set to RECURRENCE.
        When the scaling action is triggered periodically, the end time cannot be earlier than the current and start time.
        The time format is **YYYY-MM-DDThh:mmZ**.

        <a name="bandwidth_policy_interval_alarm"></a>
        The `interval_alarm_actions` block supports:
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the periodic triggering type.
        This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
        The valid values are as follows:
        + **Daily**: Indicates that the scaling action is triggered once a day.
        + **Weekly**: Indicates that the scaling action is triggered once a week.
        + **Monthly**: Indicates that the scaling action is triggered once a month.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the day when a periodic scaling action is triggered.
        This parameter is mandatory when `scaling_policy_type` is set to **RECURRENCE**.
        <br/>If `recurrence_type` is set to **Daily**, the value is null, indicating that the scaling action is triggered
        once a day.
        <br/>If `recurrence_type` is set to **Weekly**, the value ranges from `1` (Sunday) to `7` (Saturday).
        The digits refer to dates in each week and separated by a comma, such as **1,3,5**.
        <br/>If `recurrence_type` is set to **Monthly**, the value ranges from `1` to `31`.
        The digits refer to the dates in each month and separated by a comma, such as **1,10,13,28**.
        """
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the start time of the scaling action triggered periodically.
        The time format complies with UTC. The default value is the local time.
        The time format is **YYYY-MM-DDThh:mmZ**.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ConfigurationInstanceConfigArgsDict(TypedDict):
        admin_pass: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the initial login password of the administrator account for
        logging in to an ECS using password authentication. The Windows administrator is `Administrator`.

        > Password complexity requirements:
        <br/>1. Consists of `8` to `26` characters.
        <br/>2. Contains at least three of the following character types: uppercase letters, lowercase letters, digits, and
        special characters `!@$%^-_=+[{}]:,./?`.
        <br/>3. The password cannot contain the username or the username in reversed order.
        <br/>4. The Windows ECS password cannot contain the username, the username in reversed order, or more than two
        consecutive characters in the username.

        > Field `admin_pass` is used for Windows system password authentication, and `user_data` is used for Linux system
        password authentication.
        """
        charging_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a billing mode for an ECS.
        The value can be `postPaid` and `spot`. The default value is `postPaid`.
        Changing this will create a new resource.
        """
        dedicated_host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the DEH.
        Changing this will create a new resource.

        > This parameter is valid only when `tenancy` is set to **dedicated**.
        <br/>If this parameter is specified, ECSs will be created on a specified DeH.
        <br/>If this parameter is not specified, the system automatically selects the DeH with the maximum available memory
        size from the DeHs that meet specifications requirements to create the ECSs, thereby balancing load of the DeHs.
        """
        disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgsDict']]]]
        """
        Specifies the disk group information. System disks are mandatory and
        data disks are optional. The disk structure is documented below.
        Changing this will create a new resource.
        """
        ecs_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS group ID. Changing this will create a new resource.

        > To ensure service reliability, an ECS group allows ECSs within in the group to be automatically allocated to
        different hosts.
        """
        flavor: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS flavor name. A maximum of `10` flavors can be selected.
        Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        """
        flavor_priority_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the priority policy used when there are multiple flavors
        and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.

        + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
        in the flavor list.
        + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.

        Changing this will create a new resource.
        """
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS image ID. Changing this will create a new resource.
        """
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ECS instance ID when using its specification
        as the template to create AS configurations. In this case, `flavor`, `image`, `disk`, `security_group_ids`, `tenancy`
        and `dedicated_host_id` arguments do not take effect.
        If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
        Changing this will create a new resource.
        """
        key_fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fingerprint of the SSH key pair used to log in to the instance.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the SSH key pair used to log in to the instance.
        Changing this will create a new resource.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the key/value pairs to make available from within the instance.
        Changing this will create a new resource.
        """
        personalities: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgsDict']]]]
        """
        Specifies the customize personality of an instance by defining one or
        more files and their contents. The personality structure is documented below.
        Changing this will create a new resource.

        <a name="instance_config_disk_object"></a>
        The `disk` block supports:
        """
        public_ip: NotRequired[pulumi.Input['ConfigurationInstanceConfigPublicIpArgsDict']]
        """
        Specifies the EIP of the ECS instance.
        The public_ip structure is documented below.
        Changing this will create a new resource.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies an array of one or more security group IDs.
        Changing this will create a new resource.
        """
        tenancy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure this field to **dedicated** to create ECS instances on DeHs.
        Before configuring this field, prepare DeHs. Changing this will create a new resource.
        """
        user_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the user data to be injected during the ECS creation process.
        Changing this will create a new resource. For more information, see
        [Passing User Data to ECSs](https://support.huaweicloud.com/intl/en-us/usermanual-ecs/en-us_topic_0032380449.html).

        > 1. The content to be injected must be encoded with base64. The maximum size of the content to be injected
        (before encoding) is `32` KB.
        <br/>2. If `key_name` is not specified, the data injected by `user_data` is the password of user `root` for logging in
        to the ECS by default.
        <br/>3. If both `key_name` and `user_data` are specified, `user_data` only injects user data.
        <br/>4. This parameter is mandatory when you create a Linux ECS using the password authentication mode. Its value is
        the initial user `root` password.
        <br/>5. When the value of this field is used as a password, the recommended complexity for the password is as follows:
        (1) The value ranges from `8` to `26` characters. (2) The value contains at least three of the following character
        types: uppercase letters, lowercase letters, digits, and special characters `!@$%^-_=+[{}]:,./?`.
        """
elif False:
    ConfigurationInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigArgs:
    def __init__(__self__, *,
                 admin_pass: Optional[pulumi.Input[_builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 dedicated_host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]]] = None,
                 ecs_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor_priority_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 personalities: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]]] = None,
                 public_ip: Optional[pulumi.Input['ConfigurationInstanceConfigPublicIpArgs']] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tenancy: Optional[pulumi.Input[_builtins.str]] = None,
                 user_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] admin_pass: Specifies the initial login password of the administrator account for
               logging in to an ECS using password authentication. The Windows administrator is `Administrator`.
               
               > Password complexity requirements:
               <br/>1. Consists of `8` to `26` characters.
               <br/>2. Contains at least three of the following character types: uppercase letters, lowercase letters, digits, and
               special characters `!@$%^-_=+[{}]:,./?`.
               <br/>3. The password cannot contain the username or the username in reversed order.
               <br/>4. The Windows ECS password cannot contain the username, the username in reversed order, or more than two
               consecutive characters in the username.
               
               > Field `admin_pass` is used for Windows system password authentication, and `user_data` is used for Linux system
               password authentication.
        :param pulumi.Input[_builtins.str] charging_mode: Specifies a billing mode for an ECS.
               The value can be `postPaid` and `spot`. The default value is `postPaid`.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] dedicated_host_id: Specifies the ID of the DEH.
               Changing this will create a new resource.
               
               > This parameter is valid only when `tenancy` is set to **dedicated**.
               <br/>If this parameter is specified, ECSs will be created on a specified DeH.
               <br/>If this parameter is not specified, the system automatically selects the DeH with the maximum available memory
               size from the DeHs that meet specifications requirements to create the ECSs, thereby balancing load of the DeHs.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]] disks: Specifies the disk group information. System disks are mandatory and
               data disks are optional. The disk structure is documented below.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] ecs_group_id: Specifies the ECS group ID. Changing this will create a new resource.
               
               > To ensure service reliability, an ECS group allows ECSs within in the group to be automatically allocated to
               different hosts.
        :param pulumi.Input[_builtins.str] flavor: Specifies the ECS flavor name. A maximum of `10` flavors can be selected.
               Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] flavor_priority_policy: Specifies the priority policy used when there are multiple flavors
               and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.
               
               + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
               in the flavor list.
               + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.
               
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] image: Specifies the ECS image ID. Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] instance_id: Specifies the ECS instance ID when using its specification
               as the template to create AS configurations. In this case, `flavor`, `image`, `disk`, `security_group_ids`, `tenancy`
               and `dedicated_host_id` arguments do not take effect.
               If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] key_fingerprint: The fingerprint of the SSH key pair used to log in to the instance.
        :param pulumi.Input[_builtins.str] key_name: Specifies the name of the SSH key pair used to log in to the instance.
               Changing this will create a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: Specifies the key/value pairs to make available from within the instance.
               Changing this will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]] personalities: Specifies the customize personality of an instance by defining one or
               more files and their contents. The personality structure is documented below.
               Changing this will create a new resource.
               
               <a name="instance_config_disk_object"></a>
               The `disk` block supports:
        :param pulumi.Input['ConfigurationInstanceConfigPublicIpArgs'] public_ip: Specifies the EIP of the ECS instance.
               The public_ip structure is documented below.
               Changing this will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: Specifies an array of one or more security group IDs.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] tenancy: Configure this field to **dedicated** to create ECS instances on DeHs.
               Before configuring this field, prepare DeHs. Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] user_data: Specifies the user data to be injected during the ECS creation process.
               Changing this will create a new resource. For more information, see
               [Passing User Data to ECSs](https://support.huaweicloud.com/intl/en-us/usermanual-ecs/en-us_topic_0032380449.html).
               
               > 1. The content to be injected must be encoded with base64. The maximum size of the content to be injected
               (before encoding) is `32` KB.
               <br/>2. If `key_name` is not specified, the data injected by `user_data` is the password of user `root` for logging in
               to the ECS by default.
               <br/>3. If both `key_name` and `user_data` are specified, `user_data` only injects user data.
               <br/>4. This parameter is mandatory when you create a Linux ECS using the password authentication mode. Its value is
               the initial user `root` password.
               <br/>5. When the value of this field is used as a password, the recommended complexity for the password is as follows:
               (1) The value ranges from `8` to `26` characters. (2) The value contains at least three of the following character
               types: uppercase letters, lowercase letters, digits, and special characters `!@$%^-_=+[{}]:,./?`.
        """
        if admin_pass is not None:
            pulumi.set(__self__, "admin_pass", admin_pass)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if ecs_group_id is not None:
            pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_priority_policy is not None:
            pulumi.set(__self__, "flavor_priority_policy", flavor_priority_policy)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if key_fingerprint is not None:
            pulumi.set(__self__, "key_fingerprint", key_fingerprint)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if personalities is not None:
            pulumi.set(__self__, "personalities", personalities)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="adminPass")
    def admin_pass(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the initial login password of the administrator account for
        logging in to an ECS using password authentication. The Windows administrator is `Administrator`.

        > Password complexity requirements:
        <br/>1. Consists of `8` to `26` characters.
        <br/>2. Contains at least three of the following character types: uppercase letters, lowercase letters, digits, and
        special characters `!@$%^-_=+[{}]:,./?`.
        <br/>3. The password cannot contain the username or the username in reversed order.
        <br/>4. The Windows ECS password cannot contain the username, the username in reversed order, or more than two
        consecutive characters in the username.

        > Field `admin_pass` is used for Windows system password authentication, and `user_data` is used for Linux system
        password authentication.
        """
        return pulumi.get(self, "admin_pass")

    @admin_pass.setter
    def admin_pass(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "admin_pass", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a billing mode for an ECS.
        The value can be `postPaid` and `spot`. The default value is `postPaid`.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the DEH.
        Changing this will create a new resource.

        > This parameter is valid only when `tenancy` is set to **dedicated**.
        <br/>If this parameter is specified, ECSs will be created on a specified DeH.
        <br/>If this parameter is not specified, the system automatically selects the DeH with the maximum available memory
        size from the DeHs that meet specifications requirements to create the ECSs, thereby balancing load of the DeHs.
        """
        return pulumi.get(self, "dedicated_host_id")

    @dedicated_host_id.setter
    def dedicated_host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_host_id", value)

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]]]:
        """
        Specifies the disk group information. System disks are mandatory and
        data disks are optional. The disk structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "disks")

    @disks.setter
    def disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigDiskArgs']]]]):
        pulumi.set(self, "disks", value)

    @_builtins.property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS group ID. Changing this will create a new resource.

        > To ensure service reliability, an ECS group allows ECSs within in the group to be automatically allocated to
        different hosts.
        """
        return pulumi.get(self, "ecs_group_id")

    @ecs_group_id.setter
    def ecs_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecs_group_id", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS flavor name. A maximum of `10` flavors can be selected.
        Use a comma (,) to separate multiple flavor names. Changing this will create a new resource.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="flavorPriorityPolicy")
    def flavor_priority_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the priority policy used when there are multiple flavors
        and instances to be created using an AS configuration. The value can be `PICK_FIRST` and `COST_FIRST`.

        + **PICK_FIRST** (default): When an ECS is added for capacity expansion, the target flavor is determined in the order
        in the flavor list.
        + **COST_FIRST**: When an ECS is added for capacity expansion, the target flavor is determined for minimal expenses.

        Changing this will create a new resource.
        """
        return pulumi.get(self, "flavor_priority_policy")

    @flavor_priority_policy.setter
    def flavor_priority_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor_priority_policy", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS image ID. Changing this will create a new resource.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ECS instance ID when using its specification
        as the template to create AS configurations. In this case, `flavor`, `image`, `disk`, `security_group_ids`, `tenancy`
        and `dedicated_host_id` arguments do not take effect.
        If this argument is not specified, `flavor`, `image`, and `disk` arguments are mandatory.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="keyFingerprint")
    def key_fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fingerprint of the SSH key pair used to log in to the instance.
        """
        return pulumi.get(self, "key_fingerprint")

    @key_fingerprint.setter
    def key_fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the SSH key pair used to log in to the instance.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the key/value pairs to make available from within the instance.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def personalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]]]:
        """
        Specifies the customize personality of an instance by defining one or
        more files and their contents. The personality structure is documented below.
        Changing this will create a new resource.

        <a name="instance_config_disk_object"></a>
        The `disk` block supports:
        """
        return pulumi.get(self, "personalities")

    @personalities.setter
    def personalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationInstanceConfigPersonalityArgs']]]]):
        pulumi.set(self, "personalities", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input['ConfigurationInstanceConfigPublicIpArgs']]:
        """
        Specifies the EIP of the ECS instance.
        The public_ip structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input['ConfigurationInstanceConfigPublicIpArgs']]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies an array of one or more security group IDs.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure this field to **dedicated** to create ECS instances on DeHs.
        Before configuring this field, prepare DeHs. Changing this will create a new resource.
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenancy", value)

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the user data to be injected during the ECS creation process.
        Changing this will create a new resource. For more information, see
        [Passing User Data to ECSs](https://support.huaweicloud.com/intl/en-us/usermanual-ecs/en-us_topic_0032380449.html).

        > 1. The content to be injected must be encoded with base64. The maximum size of the content to be injected
        (before encoding) is `32` KB.
        <br/>2. If `key_name` is not specified, the data injected by `user_data` is the password of user `root` for logging in
        to the ECS by default.
        <br/>3. If both `key_name` and `user_data` are specified, `user_data` only injects user data.
        <br/>4. This parameter is mandatory when you create a Linux ECS using the password authentication mode. Its value is
        the initial user `root` password.
        <br/>5. When the value of this field is used as a password, the recommended complexity for the password is as follows:
        (1) The value ranges from `8` to `26` characters. (2) The value contains at least three of the following character
        types: uppercase letters, lowercase letters, digits, and special characters `!@$%^-_=+[{}]:,./?`.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class ConfigurationInstanceConfigDiskArgsDict(TypedDict):
        disk_type: pulumi.Input[_builtins.str]
        """
        Specifies whether the disk is a system disk or a data disk.
        Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
        Changing this will create a new resource.
        """
        size: pulumi.Input[_builtins.int]
        """
        Specifies the disk size. The unit is GB.
        The system disk size ranges from `1` to `1024`, and not less than the minimum value of the system disk in the
        instance image. The data disk size ranges from `10` to `32,768`.
        Changing this will create a new resource.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the disk type. Changing this will create a new resource.
        Available options are:
        + **SSD**: The ultra-high I/O type.
        + **SAS**: The high I/O EVS type.
        + **SATA**: The common I/O type.
        + **GPSSD**: The general purpose SSD type.
        + **ESSD**: The extreme SSD type.
        + **GPSSD2**: The general purpose SSD V2 type.
        + **ESSD2**: The extreme SSD V2 type.

        > Different ECS flavors support different disk types. For details about disk types, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        """
        data_disk_image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of a data disk image used to export data disks of
        an ECS.
        """
        dedicated_storage_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a DSS device ID for creating an ECS disk.

        > Specify DSS devices for all disks in an AS configuration or not. If DSS devices are specified, all the
        data stores must belong to the same AZ, and the disk types supported by a DSS device for a disk must be
        the same as the `volume_type` value.
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the IOPS configured for an EVS disk.
        Changing this will create a new resource.

        > This parameter is mandatory only when `volume_type` is set to **GPSSD2** or **ESSD2**.
        <br/>For details about IOPS of GPSSD2 and ESSD2 EVS disks, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        <br/>Only pay-per-use billing is supported currently.
        """
        kms_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the encryption KMS ID of the **DATA** disk.
        Changing this will create a new resource.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the disk backup snapshot ID for restoring the system disk and
        data disks using a full-ECS backup when a full-ECS image is used.

        > You can obtain the disk backup snapshot ID using the full-ECS backup ID in
        [Querying a Single Backup](https://support.huaweicloud.com/intl/en-us/api-csbs/en-us_topic_0059304234.html).
        <br/>Each disk in an AS configuration must correspond to a disk backup in the full-ECS backup by `snapshot_id`.

        <a name="instance_config_public_ip_object"></a>
        The `public_ip` block supports:
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the throughput of an EVS disk. The unit is MiB/s.
        Changing this will create a new resource.

        > This parameter is mandatory only when `volume_type` is set to **GPSSD2** and cannot be configured
        when `volume_type` is set to other values.
        <br/>For details about the throughput range of GPSSD2 EVS disks, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        <br/>Only pay-per-use billing is supported currently.
        """
elif False:
    ConfigurationInstanceConfigDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigDiskArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str],
                 data_disk_image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 dedicated_storage_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] disk_type: Specifies whether the disk is a system disk or a data disk.
               Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.int] size: Specifies the disk size. The unit is GB.
               The system disk size ranges from `1` to `1024`, and not less than the minimum value of the system disk in the
               instance image. The data disk size ranges from `10` to `32,768`.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the disk type. Changing this will create a new resource.
               Available options are:
               + **SSD**: The ultra-high I/O type.
               + **SAS**: The high I/O EVS type.
               + **SATA**: The common I/O type.
               + **GPSSD**: The general purpose SSD type.
               + **ESSD**: The extreme SSD type.
               + **GPSSD2**: The general purpose SSD V2 type.
               + **ESSD2**: The extreme SSD V2 type.
               
               > Different ECS flavors support different disk types. For details about disk types, see
               [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        :param pulumi.Input[_builtins.str] data_disk_image_id: Specifies the ID of a data disk image used to export data disks of
               an ECS.
        :param pulumi.Input[_builtins.str] dedicated_storage_id: Specifies a DSS device ID for creating an ECS disk.
               
               > Specify DSS devices for all disks in an AS configuration or not. If DSS devices are specified, all the
               data stores must belong to the same AZ, and the disk types supported by a DSS device for a disk must be
               the same as the `volume_type` value.
        :param pulumi.Input[_builtins.int] iops: Specifies the IOPS configured for an EVS disk.
               Changing this will create a new resource.
               
               > This parameter is mandatory only when `volume_type` is set to **GPSSD2** or **ESSD2**.
               <br/>For details about IOPS of GPSSD2 and ESSD2 EVS disks, see
               [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
               <br/>Only pay-per-use billing is supported currently.
        :param pulumi.Input[_builtins.str] kms_id: Specifies the encryption KMS ID of the **DATA** disk.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] snapshot_id: Specifies the disk backup snapshot ID for restoring the system disk and
               data disks using a full-ECS backup when a full-ECS image is used.
               
               > You can obtain the disk backup snapshot ID using the full-ECS backup ID in
               [Querying a Single Backup](https://support.huaweicloud.com/intl/en-us/api-csbs/en-us_topic_0059304234.html).
               <br/>Each disk in an AS configuration must correspond to a disk backup in the full-ECS backup by `snapshot_id`.
               
               <a name="instance_config_public_ip_object"></a>
               The `public_ip` block supports:
        :param pulumi.Input[_builtins.int] throughput: Specifies the throughput of an EVS disk. The unit is MiB/s.
               Changing this will create a new resource.
               
               > This parameter is mandatory only when `volume_type` is set to **GPSSD2** and cannot be configured
               when `volume_type` is set to other values.
               <br/>For details about the throughput range of GPSSD2 EVS disks, see
               [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
               <br/>Only pay-per-use billing is supported currently.
        """
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if data_disk_image_id is not None:
            pulumi.set(__self__, "data_disk_image_id", data_disk_image_id)
        if dedicated_storage_id is not None:
            pulumi.set(__self__, "dedicated_storage_id", dedicated_storage_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_id is not None:
            pulumi.set(__self__, "kms_id", kms_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies whether the disk is a system disk or a data disk.
        Option **DATA** indicates a data disk, option **SYS** indicates a system disk.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the disk size. The unit is GB.
        The system disk size ranges from `1` to `1024`, and not less than the minimum value of the system disk in the
        instance image. The data disk size ranges from `10` to `32,768`.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the disk type. Changing this will create a new resource.
        Available options are:
        + **SSD**: The ultra-high I/O type.
        + **SAS**: The high I/O EVS type.
        + **SATA**: The common I/O type.
        + **GPSSD**: The general purpose SSD type.
        + **ESSD**: The extreme SSD type.
        + **GPSSD2**: The general purpose SSD V2 type.
        + **ESSD2**: The extreme SSD V2 type.

        > Different ECS flavors support different disk types. For details about disk types, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)

    @_builtins.property
    @pulumi.getter(name="dataDiskImageId")
    def data_disk_image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of a data disk image used to export data disks of
        an ECS.
        """
        return pulumi.get(self, "data_disk_image_id")

    @data_disk_image_id.setter
    def data_disk_image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_disk_image_id", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedStorageId")
    def dedicated_storage_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a DSS device ID for creating an ECS disk.

        > Specify DSS devices for all disks in an AS configuration or not. If DSS devices are specified, all the
        data stores must belong to the same AZ, and the disk types supported by a DSS device for a disk must be
        the same as the `volume_type` value.
        """
        return pulumi.get(self, "dedicated_storage_id")

    @dedicated_storage_id.setter
    def dedicated_storage_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_storage_id", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the IOPS configured for an EVS disk.
        Changing this will create a new resource.

        > This parameter is mandatory only when `volume_type` is set to **GPSSD2** or **ESSD2**.
        <br/>For details about IOPS of GPSSD2 and ESSD2 EVS disks, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        <br/>Only pay-per-use billing is supported currently.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the encryption KMS ID of the **DATA** disk.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "kms_id")

    @kms_id.setter
    def kms_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the disk backup snapshot ID for restoring the system disk and
        data disks using a full-ECS backup when a full-ECS image is used.

        > You can obtain the disk backup snapshot ID using the full-ECS backup ID in
        [Querying a Single Backup](https://support.huaweicloud.com/intl/en-us/api-csbs/en-us_topic_0059304234.html).
        <br/>Each disk in an AS configuration must correspond to a disk backup in the full-ECS backup by `snapshot_id`.

        <a name="instance_config_public_ip_object"></a>
        The `public_ip` block supports:
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the throughput of an EVS disk. The unit is MiB/s.
        Changing this will create a new resource.

        > This parameter is mandatory only when `volume_type` is set to **GPSSD2** and cannot be configured
        when `volume_type` is set to other values.
        <br/>For details about the throughput range of GPSSD2 EVS disks, see
        [Disk Types and Performance](https://support.huaweicloud.com/intl/en-us/productdesc-evs/en-us_topic_0014580744.html).
        <br/>Only pay-per-use billing is supported currently.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class ConfigurationInstanceConfigPersonalityArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        Specifies the content of the injected file, which must be encoded with base64.
        Changing this creates a new resource.
        """
        path: pulumi.Input[_builtins.str]
        """
        Specifies the path of the injected file. Changing this creates a new resource.
        + For Linux OSs, specify the path, for example, **/etc/foo.txt**, for storing the injected file.
        + For Windows, the injected file is automatically stored in the root directory of drive `C`. You only need to specify
        the file name, for example, **foo**. The file name contains only letters and digits.
        """
elif False:
    ConfigurationInstanceConfigPersonalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPersonalityArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] content: Specifies the content of the injected file, which must be encoded with base64.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] path: Specifies the path of the injected file. Changing this creates a new resource.
               + For Linux OSs, specify the path, for example, **/etc/foo.txt**, for storing the injected file.
               + For Windows, the injected file is automatically stored in the root directory of drive `C`. You only need to specify
               the file name, for example, **foo**. The file name contains only letters and digits.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the content of the injected file, which must be encoded with base64.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the path of the injected file. Changing this creates a new resource.
        + For Linux OSs, specify the path, for example, **/etc/foo.txt**, for storing the injected file.
        + For Windows, the injected file is automatically stored in the root directory of drive `C`. You only need to specify
        the file name, for example, **foo**. The file name contains only letters and digits.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ConfigurationInstanceConfigPublicIpArgsDict(TypedDict):
        eip: pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgsDict']
        """
        Specifies the EIP configuration that will be automatically assigned to the instance.
        The object structure is documented below. Changing this will create a new resource.
        """
elif False:
    ConfigurationInstanceConfigPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPublicIpArgs:
    def __init__(__self__, *,
                 eip: pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs']):
        """
        :param pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs'] eip: Specifies the EIP configuration that will be automatically assigned to the instance.
               The object structure is documented below. Changing this will create a new resource.
        """
        pulumi.set(__self__, "eip", eip)

    @_builtins.property
    @pulumi.getter
    def eip(self) -> pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs']:
        """
        Specifies the EIP configuration that will be automatically assigned to the instance.
        The object structure is documented below. Changing this will create a new resource.
        """
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: pulumi.Input['ConfigurationInstanceConfigPublicIpEipArgs']):
        pulumi.set(self, "eip", value)


if not MYPY:
    class ConfigurationInstanceConfigPublicIpEipArgsDict(TypedDict):
        bandwidth: pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict']
        """
        Specifies the bandwidth information. The object structure is documented below.
        Changing this will create a new resource.
        """
        ip_type: pulumi.Input[_builtins.str]
        """
        Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
        and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
elif False:
    ConfigurationInstanceConfigPublicIpEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPublicIpEipArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs'],
                 ip_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs'] bandwidth: Specifies the bandwidth information. The object structure is documented below.
               Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] ip_type: Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
               and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "ip_type", ip_type)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs']:
        """
        Specifies the bandwidth information. The object structure is documented below.
        Changing this will create a new resource.
        """
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input['ConfigurationInstanceConfigPublicIpEipBandwidthArgs']):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
        and **5_sbgp** (static BGP). Changing this will create a new resource.
        """
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_type", value)


if not MYPY:
    class ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[_builtins.str]
        """
        Specifies the bandwidth sharing type.
        The value can be **PER** (exclusive bandwidth) or **WHOLE** (shared bandwidth).
        Changing this will create a new resource.

        > If `share_type` is set to **PER**, the parameter `charging_mode` and `size` are mandatory, the parameter `id`
        is invalid.
        If `share_type` is set to **WHOLE**, the parameter `id` is mandatory, the parameter `charging_mode` and `size`
        are invalid.
        """
        charging_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the bandwidth billing type.
        Changing this creates a new resource. The valid values are as follows:
        + **bandwidth**: Billing by bandwidth.
        + **traffic**: Billing by traffic.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the shared bandwidth.
        Changing this will create a new resource.

        <a name="instance_config_personality_object"></a>
        The `personality` block supports:
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
        is `1` to `2,000` and that for bandwidth billed by traffic is `1` to `300`.
        Changing this creates a new resource.
        """
elif False:
    ConfigurationInstanceConfigPublicIpEipBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationInstanceConfigPublicIpEipBandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[_builtins.str],
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] share_type: Specifies the bandwidth sharing type.
               The value can be **PER** (exclusive bandwidth) or **WHOLE** (shared bandwidth).
               Changing this will create a new resource.
               
               > If `share_type` is set to **PER**, the parameter `charging_mode` and `size` are mandatory, the parameter `id`
               is invalid.
               If `share_type` is set to **WHOLE**, the parameter `id` is mandatory, the parameter `charging_mode` and `size`
               are invalid.
        :param pulumi.Input[_builtins.str] charging_mode: Specifies the bandwidth billing type.
               Changing this creates a new resource. The valid values are as follows:
               + **bandwidth**: Billing by bandwidth.
               + **traffic**: Billing by traffic.
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the shared bandwidth.
               Changing this will create a new resource.
               
               <a name="instance_config_personality_object"></a>
               The `personality` block supports:
        :param pulumi.Input[_builtins.int] size: Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
               is `1` to `2,000` and that for bandwidth billed by traffic is `1` to `300`.
               Changing this creates a new resource.
        """
        pulumi.set(__self__, "share_type", share_type)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the bandwidth sharing type.
        The value can be **PER** (exclusive bandwidth) or **WHOLE** (shared bandwidth).
        Changing this will create a new resource.

        > If `share_type` is set to **PER**, the parameter `charging_mode` and `size` are mandatory, the parameter `id`
        is invalid.
        If `share_type` is set to **WHOLE**, the parameter `id` is mandatory, the parameter `charging_mode` and `size`
        are invalid.
        """
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "share_type", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the bandwidth billing type.
        Changing this creates a new resource. The valid values are as follows:
        + **bandwidth**: Billing by bandwidth.
        + **traffic**: Billing by traffic.
        """
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the shared bandwidth.
        Changing this will create a new resource.

        <a name="instance_config_personality_object"></a>
        The `personality` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the bandwidth (Mbit/s). The value range for bandwidth billed by bandwidth
        is `1` to `2,000` and that for bandwidth billed by traffic is `1` to `300`.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class ConfigurationV1InstanceConfigArgsDict(TypedDict):
        admin_pass: NotRequired[pulumi.Input[_builtins.str]]
        charging_mode: NotRequired[pulumi.Input[_builtins.str]]
        dedicated_host_id: NotRequired[pulumi.Input[_builtins.str]]
        disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigDiskArgsDict']]]]
        ecs_group_id: NotRequired[pulumi.Input[_builtins.str]]
        flavor: NotRequired[pulumi.Input[_builtins.str]]
        flavor_priority_policy: NotRequired[pulumi.Input[_builtins.str]]
        image: NotRequired[pulumi.Input[_builtins.str]]
        instance_id: NotRequired[pulumi.Input[_builtins.str]]
        key_fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        personalities: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigPersonalityArgsDict']]]]
        public_ip: NotRequired[pulumi.Input['ConfigurationV1InstanceConfigPublicIpArgsDict']]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        schema: Required
        """
        tenancy: NotRequired[pulumi.Input[_builtins.str]]
        user_data: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ConfigurationV1InstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationV1InstanceConfigArgs:
    def __init__(__self__, *,
                 admin_pass: Optional[pulumi.Input[_builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 dedicated_host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigDiskArgs']]]] = None,
                 ecs_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor_priority_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 personalities: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigPersonalityArgs']]]] = None,
                 public_ip: Optional[pulumi.Input['ConfigurationV1InstanceConfigPublicIpArgs']] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tenancy: Optional[pulumi.Input[_builtins.str]] = None,
                 user_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: schema: Required
        """
        if admin_pass is not None:
            pulumi.set(__self__, "admin_pass", admin_pass)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if ecs_group_id is not None:
            pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_priority_policy is not None:
            pulumi.set(__self__, "flavor_priority_policy", flavor_priority_policy)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if key_fingerprint is not None:
            pulumi.set(__self__, "key_fingerprint", key_fingerprint)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if personalities is not None:
            pulumi.set(__self__, "personalities", personalities)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="adminPass")
    def admin_pass(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "admin_pass")

    @admin_pass.setter
    def admin_pass(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "admin_pass", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dedicated_host_id")

    @dedicated_host_id.setter
    def dedicated_host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_host_id", value)

    @_builtins.property
    @pulumi.getter
    def disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigDiskArgs']]]]:
        return pulumi.get(self, "disks")

    @disks.setter
    def disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigDiskArgs']]]]):
        pulumi.set(self, "disks", value)

    @_builtins.property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ecs_group_id")

    @ecs_group_id.setter
    def ecs_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecs_group_id", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="flavorPriorityPolicy")
    def flavor_priority_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "flavor_priority_policy")

    @flavor_priority_policy.setter
    def flavor_priority_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor_priority_policy", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @_builtins.property
    @pulumi.getter(name="keyFingerprint")
    def key_fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_fingerprint")

    @key_fingerprint.setter
    def key_fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_fingerprint", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def personalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigPersonalityArgs']]]]:
        return pulumi.get(self, "personalities")

    @personalities.setter
    def personalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigurationV1InstanceConfigPersonalityArgs']]]]):
        pulumi.set(self, "personalities", value)

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input['ConfigurationV1InstanceConfigPublicIpArgs']]:
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input['ConfigurationV1InstanceConfigPublicIpArgs']]):
        pulumi.set(self, "public_ip", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        schema: Required
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenancy", value)

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class ConfigurationV1InstanceConfigDiskArgsDict(TypedDict):
        disk_type: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.int]
        volume_type: pulumi.Input[_builtins.str]
        data_disk_image_id: NotRequired[pulumi.Input[_builtins.str]]
        dedicated_storage_id: NotRequired[pulumi.Input[_builtins.str]]
        iops: NotRequired[pulumi.Input[_builtins.int]]
        kms_id: NotRequired[pulumi.Input[_builtins.str]]
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        throughput: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ConfigurationV1InstanceConfigDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationV1InstanceConfigDiskArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.int],
                 volume_type: pulumi.Input[_builtins.str],
                 data_disk_image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 dedicated_storage_id: Optional[pulumi.Input[_builtins.str]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if data_disk_image_id is not None:
            pulumi.set(__self__, "data_disk_image_id", data_disk_image_id)
        if dedicated_storage_id is not None:
            pulumi.set(__self__, "dedicated_storage_id", dedicated_storage_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_id is not None:
            pulumi.set(__self__, "kms_id", kms_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "disk_type", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)

    @_builtins.property
    @pulumi.getter(name="dataDiskImageId")
    def data_disk_image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data_disk_image_id")

    @data_disk_image_id.setter
    def data_disk_image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_disk_image_id", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedStorageId")
    def dedicated_storage_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "dedicated_storage_id")

    @dedicated_storage_id.setter
    def dedicated_storage_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_storage_id", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_id")

    @kms_id.setter
    def kms_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class ConfigurationV1InstanceConfigPersonalityArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        path: pulumi.Input[_builtins.str]
elif False:
    ConfigurationV1InstanceConfigPersonalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationV1InstanceConfigPersonalityArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ConfigurationV1InstanceConfigPublicIpArgsDict(TypedDict):
        eip: pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipArgsDict']
elif False:
    ConfigurationV1InstanceConfigPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationV1InstanceConfigPublicIpArgs:
    def __init__(__self__, *,
                 eip: pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipArgs']):
        pulumi.set(__self__, "eip", eip)

    @_builtins.property
    @pulumi.getter
    def eip(self) -> pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipArgs']:
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipArgs']):
        pulumi.set(self, "eip", value)


if not MYPY:
    class ConfigurationV1InstanceConfigPublicIpEipArgsDict(TypedDict):
        bandwidth: pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipBandwidthArgsDict']
        ip_type: pulumi.Input[_builtins.str]
elif False:
    ConfigurationV1InstanceConfigPublicIpEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationV1InstanceConfigPublicIpEipArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipBandwidthArgs'],
                 ip_type: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "ip_type", ip_type)

    @_builtins.property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipBandwidthArgs']:
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input['ConfigurationV1InstanceConfigPublicIpEipBandwidthArgs']):
        pulumi.set(self, "bandwidth", value)

    @_builtins.property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_type", value)


if not MYPY:
    class ConfigurationV1InstanceConfigPublicIpEipBandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[_builtins.str]
        charging_mode: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        size: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    ConfigurationV1InstanceConfigPublicIpEipBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationV1InstanceConfigPublicIpEipBandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[_builtins.str],
                 charging_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "share_type", share_type)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "share_type", value)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class GroupLbaasListenerArgsDict(TypedDict):
        pool_id: pulumi.Input[_builtins.str]
        """
        Specifies the backend ECS group ID.
        """
        protocol_port: pulumi.Input[_builtins.int]
        """
        Specifies the backend protocol, which is the port on which a backend ECS listens for
        traffic. The number of the port ranges from `1` to `65,535`.
        """
        listener_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the listener assocaite with the ELB.
        """
        protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the version of instance IP addresses to be associated with the
        load balancer. The value can be **ipv4** or **ipv6**. Defaults to **ipv4**.

        > 1. Instances in an AS group do not support IPv4/IPv6 dual-stack on multiple NICs. IPv4/IPv6 dual-stack is only
        available for the first NIC that supports both IPv4 and IPv6. The NIC may be a primary NIC or an extension NIC.
        <br/>2. Only ECSs with flavors that support IPv6 can use IPv4/IPv6 dual-stack networks. If you want to select IPv6 for
        this parameter, make sure that you have selected such ECS flavors in a supported region.
        <br/>3. If you add two or more load balancers whose pool_id, protocol_port, and protocol_version settings are totally
        same, deduplication will be performed.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the weight, which determines the portion of requests a backend ECS processes
        compared to other backend ECSs added to the same listener. The value of this parameter ranges from `0` to `100`.
        Defaults to `1`.
        """
elif False:
    GroupLbaasListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupLbaasListenerArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[_builtins.str],
                 protocol_port: pulumi.Input[_builtins.int],
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] pool_id: Specifies the backend ECS group ID.
        :param pulumi.Input[_builtins.int] protocol_port: Specifies the backend protocol, which is the port on which a backend ECS listens for
               traffic. The number of the port ranges from `1` to `65,535`.
        :param pulumi.Input[_builtins.str] listener_id: The ID of the listener assocaite with the ELB.
        :param pulumi.Input[_builtins.str] protocol_version: Specifies the version of instance IP addresses to be associated with the
               load balancer. The value can be **ipv4** or **ipv6**. Defaults to **ipv4**.
               
               > 1. Instances in an AS group do not support IPv4/IPv6 dual-stack on multiple NICs. IPv4/IPv6 dual-stack is only
               available for the first NIC that supports both IPv4 and IPv6. The NIC may be a primary NIC or an extension NIC.
               <br/>2. Only ECSs with flavors that support IPv6 can use IPv4/IPv6 dual-stack networks. If you want to select IPv6 for
               this parameter, make sure that you have selected such ECS flavors in a supported region.
               <br/>3. If you add two or more load balancers whose pool_id, protocol_port, and protocol_version settings are totally
               same, deduplication will be performed.
        :param pulumi.Input[_builtins.int] weight: Specifies the weight, which determines the portion of requests a backend ECS processes
               compared to other backend ECSs added to the same listener. The value of this parameter ranges from `0` to `100`.
               Defaults to `1`.
        """
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the backend ECS group ID.
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pool_id", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the backend protocol, which is the port on which a backend ECS listens for
        traffic. The number of the port ranges from `1` to `65,535`.
        """
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "protocol_port", value)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the listener assocaite with the ELB.
        """
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the version of instance IP addresses to be associated with the
        load balancer. The value can be **ipv4** or **ipv6**. Defaults to **ipv4**.

        > 1. Instances in an AS group do not support IPv4/IPv6 dual-stack on multiple NICs. IPv4/IPv6 dual-stack is only
        available for the first NIC that supports both IPv4 and IPv6. The NIC may be a primary NIC or an extension NIC.
        <br/>2. Only ECSs with flavors that support IPv6 can use IPv4/IPv6 dual-stack networks. If you want to select IPv6 for
        this parameter, make sure that you have selected such ECS flavors in a supported region.
        <br/>3. If you add two or more load balancers whose pool_id, protocol_port, and protocol_version settings are totally
        same, deduplication will be performed.
        """
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol_version", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the weight, which determines the portion of requests a backend ECS processes
        compared to other backend ECSs added to the same listener. The value of this parameter ranges from `0` to `100`.
        Defaults to `1`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GroupNetworkArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        ipv6_bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the shared bandwidth of an IPv6 address.
        """
        ipv6_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to support IPv6 addresses. Defaults to **false**.
        """
        source_dest_check: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether process only traffic that is destined specifically
        for it. Defaults to **true**.

        <a name="group_security_group_object"></a>
        The `security_groups` block supports:
        """
elif False:
    GroupNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 ipv6_bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_dest_check: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the security group.
               
               <a name="group_lbaas_listener_object"></a>
               The `lbaas_listeners` block supports:
        :param pulumi.Input[_builtins.str] ipv6_bandwidth_id: Specifies the ID of the shared bandwidth of an IPv6 address.
        :param pulumi.Input[_builtins.bool] ipv6_enable: Specifies whether to support IPv6 addresses. Defaults to **false**.
        :param pulumi.Input[_builtins.bool] source_dest_check: Specifies whether process only traffic that is destined specifically
               for it. Defaults to **true**.
               
               <a name="group_security_group_object"></a>
               The `security_groups` block supports:
        """
        pulumi.set(__self__, "id", id)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the shared bandwidth of an IPv6 address.
        """
        return pulumi.get(self, "ipv6_bandwidth_id")

    @ipv6_bandwidth_id.setter
    def ipv6_bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to support IPv6 addresses. Defaults to **false**.
        """
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @_builtins.property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether process only traffic that is destined specifically
        for it. Defaults to **true**.

        <a name="group_security_group_object"></a>
        The `security_groups` block supports:
        """
        return pulumi.get(self, "source_dest_check")

    @source_dest_check.setter
    def source_dest_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_dest_check", value)


if not MYPY:
    class GroupSecurityGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
elif False:
    GroupSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupSecurityGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: Specifies the ID of the security group.
               
               <a name="group_lbaas_listener_object"></a>
               The `lbaas_listeners` block supports:
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the security group.

        <a name="group_lbaas_listener_object"></a>
        The `lbaas_listeners` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GroupV1LbaasListenerArgsDict(TypedDict):
        pool_id: pulumi.Input[_builtins.str]
        protocol_port: pulumi.Input[_builtins.int]
        listener_id: NotRequired[pulumi.Input[_builtins.str]]
        protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    GroupV1LbaasListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupV1LbaasListenerArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[_builtins.str],
                 protocol_port: pulumi.Input[_builtins.int],
                 listener_id: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        if listener_id is not None:
            pulumi.set(__self__, "listener_id", listener_id)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pool_id", value)

    @_builtins.property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "protocol_port", value)

    @_builtins.property
    @pulumi.getter(name="listenerId")
    def listener_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "listener_id")

    @listener_id.setter
    def listener_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "listener_id", value)

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol_version", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class GroupV1NetworkArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        ipv6_bandwidth_id: NotRequired[pulumi.Input[_builtins.str]]
        ipv6_enable: NotRequired[pulumi.Input[_builtins.bool]]
        source_dest_check: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    GroupV1NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupV1NetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 ipv6_bandwidth_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_dest_check: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "id", id)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ipv6_bandwidth_id")

    @ipv6_bandwidth_id.setter
    def ipv6_bandwidth_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_bandwidth_id", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @_builtins.property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "source_dest_check")

    @source_dest_check.setter
    def source_dest_check(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_dest_check", value)


if not MYPY:
    class GroupV1SecurityGroupArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
elif False:
    GroupV1SecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupV1SecurityGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PlannedTaskInstanceNumberArgsDict(TypedDict):
        desire: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the expected number of instances for the scaling group.

        > At least set one of `max`, `min` or `desire` parameters, at the same time, the `min` can not be
        greater than `desire` or `max`, and `desire` can not be greater than `max`. Parameters that are not set or empty,
        it means that the value of this field remains unchanged compared to the scaling group instance number.
        """
        max: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the maximum number of instances for the scaling group.
        """
        min: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the minimum number of instances for the scaling group.
        """
elif False:
    PlannedTaskInstanceNumberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlannedTaskInstanceNumberArgs:
    def __init__(__self__, *,
                 desire: Optional[pulumi.Input[_builtins.str]] = None,
                 max: Optional[pulumi.Input[_builtins.str]] = None,
                 min: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] desire: Specifies the expected number of instances for the scaling group.
               
               > At least set one of `max`, `min` or `desire` parameters, at the same time, the `min` can not be
               greater than `desire` or `max`, and `desire` can not be greater than `max`. Parameters that are not set or empty,
               it means that the value of this field remains unchanged compared to the scaling group instance number.
        :param pulumi.Input[_builtins.str] max: Specifies the maximum number of instances for the scaling group.
        :param pulumi.Input[_builtins.str] min: Specifies the minimum number of instances for the scaling group.
        """
        if desire is not None:
            pulumi.set(__self__, "desire", desire)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def desire(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the expected number of instances for the scaling group.

        > At least set one of `max`, `min` or `desire` parameters, at the same time, the `min` can not be
        greater than `desire` or `max`, and `desire` can not be greater than `max`. Parameters that are not set or empty,
        it means that the value of this field remains unchanged compared to the scaling group instance number.
        """
        return pulumi.get(self, "desire")

    @desire.setter
    def desire(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "desire", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the maximum number of instances for the scaling group.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the minimum number of instances for the scaling group.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class PlannedTaskScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[_builtins.str]
        """
        Specifies the execution time of the AS planned task.
        + If `recurrence_type` not set or is empty, the time format is **yyyy-MM-ddTHH:mmZ**.
        + If `recurrence_type` is specified, the time format is **HH:mm**.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the effective end time of the planned task.
        Only effective and required when `recurrence_type` is not empty.
        The time format is **yyyy-MM-ddTHH:mmZ**.

        <a name="AS_InstanceNumber"></a>
        The `instance_number` block supports:
        """
        recurrence_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the triggering type of AS planned task.
        When not set or is empty, the planned task is scheduled execution.
        After setting, the planned task is periodic execution. The valid values are as follows:
        + **DAILY**: by day periodic execution.
        + **WEEKLY**: by week periodic execution.
        + **MONTHLY**: by month periodic execution.
        """
        recurrence_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the frequency at which planned task are triggered.
        Required only when `recurrence_type` is **WEEKLY** or **MONTHLY**.
        + When `recurrence_type` is **WEEKLY**, The valid value ranges from `1` to `7`.
        + When `recurrence_type` is **MONTHLY**, The valid value ranges from `1` to `31`.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the effective start time of the planned task.
        Only effective when `recurrence_type` is not empty.
        The time format is **yyyy-MM-ddTHH:mmZ**.
        If not set, the default is the time when the planned task is successfully created.
        """
elif False:
    PlannedTaskScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlannedTaskScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] launch_time: Specifies the execution time of the AS planned task.
               + If `recurrence_type` not set or is empty, the time format is **yyyy-MM-ddTHH:mmZ**.
               + If `recurrence_type` is specified, the time format is **HH:mm**.
        :param pulumi.Input[_builtins.str] end_time: Specifies the effective end time of the planned task.
               Only effective and required when `recurrence_type` is not empty.
               The time format is **yyyy-MM-ddTHH:mmZ**.
               
               <a name="AS_InstanceNumber"></a>
               The `instance_number` block supports:
        :param pulumi.Input[_builtins.str] recurrence_type: Specifies the triggering type of AS planned task.
               When not set or is empty, the planned task is scheduled execution.
               After setting, the planned task is periodic execution. The valid values are as follows:
               + **DAILY**: by day periodic execution.
               + **WEEKLY**: by week periodic execution.
               + **MONTHLY**: by month periodic execution.
        :param pulumi.Input[_builtins.str] recurrence_value: Specifies the frequency at which planned task are triggered.
               Required only when `recurrence_type` is **WEEKLY** or **MONTHLY**.
               + When `recurrence_type` is **WEEKLY**, The valid value ranges from `1` to `7`.
               + When `recurrence_type` is **MONTHLY**, The valid value ranges from `1` to `31`.
        :param pulumi.Input[_builtins.str] start_time: Specifies the effective start time of the planned task.
               Only effective when `recurrence_type` is not empty.
               The time format is **yyyy-MM-ddTHH:mmZ**.
               If not set, the default is the time when the planned task is successfully created.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the execution time of the AS planned task.
        + If `recurrence_type` not set or is empty, the time format is **yyyy-MM-ddTHH:mmZ**.
        + If `recurrence_type` is specified, the time format is **HH:mm**.
        """
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "launch_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the effective end time of the planned task.
        Only effective and required when `recurrence_type` is not empty.
        The time format is **yyyy-MM-ddTHH:mmZ**.

        <a name="AS_InstanceNumber"></a>
        The `instance_number` block supports:
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the triggering type of AS planned task.
        When not set or is empty, the planned task is scheduled execution.
        After setting, the planned task is periodic execution. The valid values are as follows:
        + **DAILY**: by day periodic execution.
        + **WEEKLY**: by week periodic execution.
        + **MONTHLY**: by month periodic execution.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the frequency at which planned task are triggered.
        Required only when `recurrence_type` is **WEEKLY** or **MONTHLY**.
        + When `recurrence_type` is **WEEKLY**, The valid value ranges from `1` to `7`.
        + When `recurrence_type` is **MONTHLY**, The valid value ranges from `1` to `31`.
        """
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the effective start time of the planned task.
        Only effective when `recurrence_type` is not empty.
        The time format is **yyyy-MM-ddTHH:mmZ**.
        If not set, the default is the time when the planned task is successfully created.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class PolicyScalingPolicyActionArgsDict(TypedDict):
        instance_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of instances to be operated.
        """
        instance_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the percentage of instances to be operated.

        > At most one of `instance_number` and `instance_percentage` can be set. When neither `instance_number` nor
        `instance_percentage` is specified, the number of operation instances is **1**.
        """
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
        and `SET`.
        """
elif False:
    PolicyScalingPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyScalingPolicyActionArgs:
    def __init__(__self__, *,
                 instance_number: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] instance_number: Specifies the number of instances to be operated.
        :param pulumi.Input[_builtins.int] instance_percentage: Specifies the percentage of instances to be operated.
               
               > At most one of `instance_number` and `instance_percentage` can be set. When neither `instance_number` nor
               `instance_percentage` is specified, the number of operation instances is **1**.
        :param pulumi.Input[_builtins.str] operation: Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
               and `SET`.
        """
        if instance_number is not None:
            pulumi.set(__self__, "instance_number", instance_number)
        if instance_percentage is not None:
            pulumi.set(__self__, "instance_percentage", instance_percentage)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of instances to be operated.
        """
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter(name="instancePercentage")
    def instance_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the percentage of instances to be operated.

        > At most one of `instance_number` and `instance_percentage` can be set. When neither `instance_number` nor
        `instance_percentage` is specified, the number of operation instances is **1**.
        """
        return pulumi.get(self, "instance_percentage")

    @instance_percentage.setter
    def instance_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_percentage", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the operation to be performed. The options include `ADD` (default), `REMOVE`,
        and `SET`.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)


if not MYPY:
    class PolicyScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[_builtins.str]
        """
        Specifies the time when the scaling action is triggered.
        + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
        + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.

        > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the end time of the scaling action triggered periodically. The time format complies
        with UTC. This argument is mandatory when `scaling_policy_type`
        is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.

        <a name="scaling_policy_action_object"></a>
        The `scaling_policy_action` block supports:
        """
        recurrence_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the periodic triggering type. This argument is mandatory when
        `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        """
        recurrence_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the frequency at which scaling actions are triggered.
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the start time of the scaling action triggered periodically. The time format
        complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
elif False:
    PolicyScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] launch_time: Specifies the time when the scaling action is triggered.
               + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
               + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.
               
               > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        :param pulumi.Input[_builtins.str] end_time: Specifies the end time of the scaling action triggered periodically. The time format complies
               with UTC. This argument is mandatory when `scaling_policy_type`
               is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.
               
               <a name="scaling_policy_action_object"></a>
               The `scaling_policy_action` block supports:
        :param pulumi.Input[_builtins.str] recurrence_type: Specifies the periodic triggering type. This argument is mandatory when
               `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        :param pulumi.Input[_builtins.str] recurrence_value: Specifies the frequency at which scaling actions are triggered.
        :param pulumi.Input[_builtins.str] start_time: Specifies the start time of the scaling action triggered periodically. The time format
               complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the time when the scaling action is triggered.
        + If `scaling_policy_type` is set to `SCHEDULED`, the time format is **YYYY-MM-DDThh:mmZ**.
        + If `scaling_policy_type` is set to `RECURRENCE`, the time format is **hh:mm**.

        > the `launch_time` of the `SCHEDULED` policy cannot be earlier than the current time.
        """
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "launch_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the end time of the scaling action triggered periodically. The time format complies
        with UTC. This argument is mandatory when `scaling_policy_type`
        is set to `RECURRENCE`. The time format is YYYY-MM-DDThh:mmZ.

        <a name="scaling_policy_action_object"></a>
        The `scaling_policy_action` block supports:
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the periodic triggering type. This argument is mandatory when
        `scaling_policy_type` is set to `RECURRENCE`. The options include `Daily`, `Weekly`, and `Monthly`.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the frequency at which scaling actions are triggered.
        """
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the start time of the scaling action triggered periodically. The time format
        complies with UTC. The current time is used by default. The time format is YYYY-MM-DDThh:mmZ.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class PolicyV1ScalingPolicyActionArgsDict(TypedDict):
        instance_number: NotRequired[pulumi.Input[_builtins.int]]
        instance_percentage: NotRequired[pulumi.Input[_builtins.int]]
        operation: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PolicyV1ScalingPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyV1ScalingPolicyActionArgs:
    def __init__(__self__, *,
                 instance_number: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 operation: Optional[pulumi.Input[_builtins.str]] = None):
        if instance_number is not None:
            pulumi.set(__self__, "instance_number", instance_number)
        if instance_percentage is not None:
            pulumi.set(__self__, "instance_percentage", instance_percentage)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @_builtins.property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_number", value)

    @_builtins.property
    @pulumi.getter(name="instancePercentage")
    def instance_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "instance_percentage")

    @instance_percentage.setter
    def instance_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_percentage", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)


if not MYPY:
    class PolicyV1ScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[_builtins.str]
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        recurrence_type: NotRequired[pulumi.Input[_builtins.str]]
        recurrence_value: NotRequired[pulumi.Input[_builtins.str]]
        start_time: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PolicyV1ScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyV1ScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[_builtins.str],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[_builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "launch_time", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


