# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'DatasetDataSource',
    'DatasetLabel',
    'DatasetLabelFormat',
    'DatasetSchema',
    'DevserverRootVolume',
    'ModelDependency',
    'ModelDependencyPackage',
    'ModelModelDoc',
    'ModelTemplate',
    'ModelTemplateTemplateInput',
    'NetworkPeerConnection',
    'NotebookMountStorage',
    'NotebookVolume',
    'ResourcePoolCluster',
    'ResourcePoolMetadata',
    'ResourcePoolNodeBatchResizeNode',
    'ResourcePoolNodeBatchResizeSource',
    'ResourcePoolNodeBatchResizeSourceCreatingStep',
    'ResourcePoolNodeBatchResizeTarget',
    'ResourcePoolNodeBatchResizeTargetCreatingStep',
    'ResourcePoolResource',
    'ResourcePoolResourceAz',
    'ResourcePoolResourceCreatingStep',
    'ResourcePoolResourceDataVolume',
    'ResourcePoolResourceDriver',
    'ResourcePoolResourceOs',
    'ResourcePoolResourceRootVolume',
    'ResourcePoolResourceTaint',
    'ResourcePoolResourceVolumeGroupConfig',
    'ResourcePoolResourceVolumeGroupConfigLvmConfig',
    'ResourcePoolResourcesOrderOrigin',
    'ResourcePoolUserLogin',
    'ServiceAdditionalProperties',
    'ServiceAdditionalPropertiesLogReportChannels',
    'ServiceAdditionalPropertiesSmnNotification',
    'ServiceConfig',
    'ServiceConfigCustomSpec',
    'ServiceSchedule',
    'ServiceV2GroupConfig',
    'ServiceV2GroupConfigUnitConfig',
    'ServiceV2GroupConfigUnitConfigCode',
    'ServiceV2GroupConfigUnitConfigCustomSpec',
    'ServiceV2GroupConfigUnitConfigImage',
    'ServiceV2GroupConfigUnitConfigLivenessHealth',
    'ServiceV2GroupConfigUnitConfigModel',
    'ServiceV2GroupConfigUnitConfigReadinessHealth',
    'ServiceV2GroupConfigUnitConfigStartupHealth',
    'ServiceV2LogConfig',
    'ServiceV2PredictUrl',
    'WorkspaceGrant',
    'GetDataset_versionsVersionResult',
    'GetDatasetsDatasetResult',
    'GetDatasetsDatasetDataSourceResult',
    'GetDatasetsDatasetLabelResult',
    'GetDatasetsDatasetSchemaResult',
    'GetModelTemplatesTemplateResult',
    'GetModelTemplatesTemplateTemplateDocResult',
    'GetModelTemplatesTemplateTemplateInputResult',
    'GetModelsModelResult',
    'GetModelsModelSpecificationResult',
    'GetNodePoolNodesV2NodeResult',
    'GetNodePoolNodesV2NodeMetadataResult',
    'GetNodePoolNodesV2NodeSpecResult',
    'GetNodePoolNodesV2NodeSpecHostNetworkResult',
    'GetNodePoolNodesV2NodeSpecOResult',
    'GetNodePoolNodesV2NodeStatusResult',
    'GetNodePoolNodesV2NodeStatusDriverResult',
    'GetNodePoolNodesV2NodeStatusOResult',
    'GetNodePoolNodesV2NodeStatusPluginResult',
    'GetNotebookFlavorsFlavorResult',
    'GetNotebookFlavorsFlavorBillingResult',
    'GetNotebookFlavorsFlavorGpusResult',
    'GetNotebookImagesImageResult',
    'GetResourceFlavorsFlavorResult',
    'GetResourceFlavorsFlavorGpusResult',
    'GetResourceFlavorsFlavorNpusResult',
    'GetResourceFlavorsFlavorVolumeResult',
    'GetResourcePoolNodesV2NodeResult',
    'GetResourcePoolNodesV2NodeMetadataResult',
    'GetResourcePoolNodesV2NodeSpecResult',
    'GetResourcePoolNodesV2NodeSpecHostNetworkResult',
    'GetResourcePoolNodesV2NodeSpecOResult',
    'GetResourcePoolNodesV2NodeStatusResult',
    'GetResourcePoolNodesV2NodeStatusDriverResult',
    'GetResourcePoolNodesV2NodeStatusOResult',
    'GetResourcePoolNodesV2NodeStatusPluginResult',
    'GetResourcePoolsV2ResourcePoolResult',
    'GetResourcePoolsV2ResourcePoolClusterResult',
    'GetResourcePoolsV2ResourcePoolMetadataResult',
    'GetResourcePoolsV2ResourcePoolResourceResult',
    'GetResourcePoolsV2ResourcePoolResourceAzResult',
    'GetResourcePoolsV2ResourcePoolResourceCreatingStepResult',
    'GetResourcePoolsV2ResourcePoolResourceDataVolumeResult',
    'GetResourcePoolsV2ResourcePoolResourceRootVolumeResult',
    'GetResourcePoolsV2ResourcePoolResourceTaintResult',
    'GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigResult',
    'GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigLvmConfigResult',
    'GetResourcePoolsV2ResourcePoolSpecResult',
    'GetResourcePoolsV2ResourcePoolSpecClusterResult',
    'GetResourcePoolsV2ResourcePoolSpecNetworkResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceAzResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceCreatingStepResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceDataVolumeResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceNetworkResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceOResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceRootVolumeResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceTaintResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigResult',
    'GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigLvmConfigResult',
    'GetResourcePoolsV2ResourcePoolSpecUserLoginResult',
    'GetResourcePoolsV2ResourcePoolUserLoginResult',
    'GetServiceFlavorsFlavorResult',
    'GetServicesServiceResult',
    'GetServicesServiceAdditionalPropertyResult',
    'GetServicesServiceAdditionalPropertyLogReportChannelResult',
    'GetServicesServiceAdditionalPropertySmnNotificationResult',
    'GetServicesServiceScheduleResult',
    'GetWorkspacesWorkspaceResult',
]

@pulumi.output_type
class DatasetDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "dataType":
            suggest = "data_type"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "queueName":
            suggest = "queue_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "userName":
            suggest = "user_name"
        elif key == "withColumnHeader":
            suggest = "with_column_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.int] = None,
                 database_name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 queue_name: Optional[_builtins.str] = None,
                 table_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None,
                 with_column_header: Optional[_builtins.bool] = None):
        """
        :param _builtins.str cluster_id: Specifies the cluster ID of DWS/MRS when `data_type` is `1` or `4`.
               Changing this parameter will create a new resource.
        :param _builtins.int data_type: Specifies the type of data source. The options are as follows:
               + **0**: OBS.
               + **1**: GaussDB(DWS).
               + **2**: DLI.
               + **4**: MRS.
               
               Default value is 0. Changing this parameter will create a new resource.
        :param _builtins.str database_name: Specifies the database name of DWS/DLI when `data_type` is `1` or `2`.
               Changing this parameter will create a new resource.
        :param _builtins.str password: Specifies the password of database when `data_type` is `1`.
               Changing this parameter will create a new resource.
        :param _builtins.str path: Specifies the OBS path when `data_type` is `0`
               or the hdsf path when `data_type` is `4`. All the file in this directory and subdirectories will be which be imported
               to the dataset. Changing this parameter will create a new resource.
        :param _builtins.str queue_name: Specifies the queue name of DLI when `data_type` is `2`.
               Changing this parameter will create a new resource.
        :param _builtins.str table_name: Specifies the table name of DWS/DLI when `data_type` is `1` or `2`.
               Changing this parameter will create a new resource.
        :param _builtins.str user_name: Specifies the user name of database when `data_type` is `1`.
               Changing this parameter will create a new resource.
        :param _builtins.bool with_column_header: Specifies whether the data contains table header when the type
               of dataset is `400`(Table type). Default value is `true`. Changing this parameter will create a new resource.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if with_column_header is not None:
            pulumi.set(__self__, "with_column_header", with_column_header)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        Specifies the cluster ID of DWS/MRS when `data_type` is `1` or `4`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.int]:
        """
        Specifies the type of data source. The options are as follows:
        + **0**: OBS.
        + **1**: GaussDB(DWS).
        + **2**: DLI.
        + **4**: MRS.

        Default value is 0. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        Specifies the database name of DWS/DLI when `data_type` is `1` or `2`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Specifies the password of database when `data_type` is `1`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Specifies the OBS path when `data_type` is `0`
        or the hdsf path when `data_type` is `4`. All the file in this directory and subdirectories will be which be imported
        to the dataset. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[_builtins.str]:
        """
        Specifies the queue name of DLI when `data_type` is `2`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "queue_name")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[_builtins.str]:
        """
        Specifies the table name of DWS/DLI when `data_type` is `1` or `2`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "table_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        Specifies the user name of database when `data_type` is `1`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter(name="withColumnHeader")
    def with_column_header(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the data contains table header when the type
        of dataset is `400`(Table type). Default value is `true`. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "with_column_header")


@pulumi.output_type
class DatasetLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyColor":
            suggest = "property_color"
        elif key == "propertyShape":
            suggest = "property_shape"
        elif key == "propertyShortcut":
            suggest = "property_shortcut"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 property_color: Optional[_builtins.str] = None,
                 property_shape: Optional[_builtins.str] = None,
                 property_shortcut: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name of label.
        :param _builtins.str property_color: Specifies color of label.
        :param _builtins.str property_shape: Specifies shape of label. Valid values include: `bndbox`, `polygon`,
               `circle`, `line`, `dashed`, `point`, `polyline`.
        :param _builtins.str property_shortcut: Specifies shortcut of label.
        """
        pulumi.set(__self__, "name", name)
        if property_color is not None:
            pulumi.set(__self__, "property_color", property_color)
        if property_shape is not None:
            pulumi.set(__self__, "property_shape", property_shape)
        if property_shortcut is not None:
            pulumi.set(__self__, "property_shortcut", property_shortcut)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of label.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="propertyColor")
    def property_color(self) -> Optional[_builtins.str]:
        """
        Specifies color of label.
        """
        return pulumi.get(self, "property_color")

    @_builtins.property
    @pulumi.getter(name="propertyShape")
    def property_shape(self) -> Optional[_builtins.str]:
        """
        Specifies shape of label. Valid values include: `bndbox`, `polygon`,
        `circle`, `line`, `dashed`, `point`, `polyline`.
        """
        return pulumi.get(self, "property_shape")

    @_builtins.property
    @pulumi.getter(name="propertyShortcut")
    def property_shortcut(self) -> Optional[_builtins.str]:
        """
        Specifies shortcut of label.
        """
        return pulumi.get(self, "property_shortcut")


@pulumi.output_type
class DatasetLabelFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSeparator":
            suggest = "label_separator"
        elif key == "textLabelSeparator":
            suggest = "text_label_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasetLabelFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasetLabelFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasetLabelFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_separator: Optional[_builtins.str] = None,
                 text_label_separator: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str label_separator: Specifies the separator between label and label.
               Changing this parameter will create a new resource.
        :param _builtins.str text_label_separator: Specifies the separator between text and label.
               Changing this parameter will create a new resource.
        :param _builtins.str type: Specifies Label type for text classification.
               The optional values are as follows:
               
               + **0**: Label and text are separated, distinguished by the suffix `_result`.
               For example: the text file is *abc.txt*, and the label file is *abc_result.txt*.
               + **1**: Default, labels and text are in one file, separated by a delimiter. The separator between text and labels,
               the separator between label and label can be specified by `label_separator` and `text_label_separator`.
               
               Default value is `1`.
        """
        if label_separator is not None:
            pulumi.set(__self__, "label_separator", label_separator)
        if text_label_separator is not None:
            pulumi.set(__self__, "text_label_separator", text_label_separator)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="labelSeparator")
    def label_separator(self) -> Optional[_builtins.str]:
        """
        Specifies the separator between label and label.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "label_separator")

    @_builtins.property
    @pulumi.getter(name="textLabelSeparator")
    def text_label_separator(self) -> Optional[_builtins.str]:
        """
        Specifies the separator between text and label.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "text_label_separator")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies Label type for text classification.
        The optional values are as follows:

        + **0**: Label and text are separated, distinguished by the suffix `_result`.
        For example: the text file is *abc.txt*, and the label file is *abc_result.txt*.
        + **1**: Default, labels and text are in one file, separated by a delimiter. The separator between text and labels,
        the separator between label and label can be specified by `label_separator` and `text_label_separator`.

        Default value is `1`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatasetSchema(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str name: Specifies the field name. Changing this parameter will create a new resource.
        :param _builtins.str type: Specifies the field type. Valid values include: `String`, `Short`, `Int`,
               `Long`, `Double`, `Float`, `Byte`, `Date`, `Timestamp`, `Bool`. Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the field name. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the field type. Valid values include: `String`, `Short`, `Int`,
        `Long`, `Double`, `Float`, `Byte`, `Date`, `Timestamp`, `Bool`. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DevserverRootVolume(dict):
    def __init__(__self__, *,
                 size: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.int size: Specifies the size of system disk.
               Changing this creates a new resource.
        :param _builtins.str type: Specifies the type of system disk.
               Changing this creates a new resource.
               The valid values are as follows:
               + **ESSD**: Extreme SSD type.
               + **SSD**: Ultra-high I/O type.
               + **GPSSD**: General purpose SSD type.
               + **SAS**: High I/O type.
               + **SATA**: Common I/O type.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Specifies the size of system disk.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the type of system disk.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ModelDependency(dict):
    def __init__(__self__, *,
                 installer: _builtins.str,
                 packages: Sequence['outputs.ModelDependencyPackage']):
        """
        :param _builtins.str installer: Installation mode. Only **pip** is supported.
               Changing this parameter will create a new resource.
        :param Sequence['ModelDependencyPackageArgs'] packages: Collection of dependency packages.
               The package structure is documented below.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_package"></a>
               The `package` block supports:
        """
        pulumi.set(__self__, "installer", installer)
        pulumi.set(__self__, "packages", packages)

    @_builtins.property
    @pulumi.getter
    def installer(self) -> _builtins.str:
        """
        Installation mode. Only **pip** is supported.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "installer")

    @_builtins.property
    @pulumi.getter
    def packages(self) -> Sequence['outputs.ModelDependencyPackage']:
        """
        Collection of dependency packages.
        The package structure is documented below.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_package"></a>
        The `package` block supports:
        """
        return pulumi.get(self, "packages")


@pulumi.output_type
class ModelDependencyPackage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageName":
            suggest = "package_name"
        elif key == "packageVersion":
            suggest = "package_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelDependencyPackage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelDependencyPackage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelDependencyPackage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 package_name: _builtins.str,
                 package_version: Optional[_builtins.str] = None,
                 restraint: Optional[_builtins.str] = None):
        """
        :param _builtins.str package_name: Name of a dependency package.
               Ensure that the package name is correct and available.
               Chinese characters and special characters (&!'"<>=) are not allowed.
               Changing this parameter will create a new resource.
        :param _builtins.str package_version: Version of a dependency package.
               If this parameter is left blank, the latest version is installed by default.
               Chinese characters and special characters (&!'"<>=) are not allowed.
               Changing this parameter will create a new resource.
        :param _builtins.str restraint: Version restriction, which can be **EXACT**, **ATLEAST**, or **ATMOST**.
               This parameter is mandatory only when package_version is available.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "package_name", package_name)
        if package_version is not None:
            pulumi.set(__self__, "package_version", package_version)
        if restraint is not None:
            pulumi.set(__self__, "restraint", restraint)

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> _builtins.str:
        """
        Name of a dependency package.
        Ensure that the package name is correct and available.
        Chinese characters and special characters (&!'"<>=) are not allowed.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> Optional[_builtins.str]:
        """
        Version of a dependency package.
        If this parameter is left blank, the latest version is installed by default.
        Chinese characters and special characters (&!'"<>=) are not allowed.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "package_version")

    @_builtins.property
    @pulumi.getter
    def restraint(self) -> Optional[_builtins.str]:
        """
        Version restriction, which can be **EXACT**, **ATLEAST**, or **ATMOST**.
        This parameter is mandatory only when package_version is available.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "restraint")


@pulumi.output_type
class ModelModelDoc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "docName":
            suggest = "doc_name"
        elif key == "docUrl":
            suggest = "doc_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelModelDoc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelModelDoc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelModelDoc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 doc_name: Optional[_builtins.str] = None,
                 doc_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str doc_name: Document name, which must start with a letter. Enter 1 to 48 characters.  
               Only letters, digits, hyphens (-), and underscores (_) are allowed.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_Template"></a>
               The `Template` block supports:
        :param _builtins.str doc_url: HTTP(S) link of the document.
               Changing this parameter will create a new resource.
        """
        if doc_name is not None:
            pulumi.set(__self__, "doc_name", doc_name)
        if doc_url is not None:
            pulumi.set(__self__, "doc_url", doc_url)

    @_builtins.property
    @pulumi.getter(name="docName")
    def doc_name(self) -> Optional[_builtins.str]:
        """
        Document name, which must start with a letter. Enter 1 to 48 characters.  
        Only letters, digits, hyphens (-), and underscores (_) are allowed.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_Template"></a>
        The `Template` block supports:
        """
        return pulumi.get(self, "doc_name")

    @_builtins.property
    @pulumi.getter(name="docUrl")
    def doc_url(self) -> Optional[_builtins.str]:
        """
        HTTP(S) link of the document.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "doc_url")


@pulumi.output_type
class ModelTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateId":
            suggest = "template_id"
        elif key == "templateInputs":
            suggest = "template_inputs"
        elif key == "inferFormat":
            suggest = "infer_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_id: _builtins.str,
                 template_inputs: Sequence['outputs.ModelTemplateTemplateInput'],
                 infer_format: Optional[_builtins.str] = None):
        """
        :param _builtins.str template_id: ID of the used template.  
               The template has a built-in input and output mode.
               Changing this parameter will create a new resource.
        :param Sequence['ModelTemplateTemplateInputArgs'] template_inputs: Template input configuration,
               specifying the source path for configuring a model.
               The TemplateInput structure is documented below.
               Changing this parameter will create a new resource.
        :param _builtins.str infer_format: ID of the input and output mode.  
               When this parameter is used, the input and output mode built in the template does not take effect.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_TemplateInput"></a>
               The `TemplateInput` block supports:
        """
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "template_inputs", template_inputs)
        if infer_format is not None:
            pulumi.set(__self__, "infer_format", infer_format)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> _builtins.str:
        """
        ID of the used template.  
        The template has a built-in input and output mode.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter(name="templateInputs")
    def template_inputs(self) -> Sequence['outputs.ModelTemplateTemplateInput']:
        """
        Template input configuration,
        specifying the source path for configuring a model.
        The TemplateInput structure is documented below.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "template_inputs")

    @_builtins.property
    @pulumi.getter(name="inferFormat")
    def infer_format(self) -> Optional[_builtins.str]:
        """
        ID of the input and output mode.  
        When this parameter is used, the input and output mode built in the template does not take effect.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_TemplateInput"></a>
        The `TemplateInput` block supports:
        """
        return pulumi.get(self, "infer_format")


@pulumi.output_type
class ModelTemplateTemplateInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputId":
            suggest = "input_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelTemplateTemplateInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelTemplateTemplateInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelTemplateTemplateInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input: _builtins.str,
                 input_id: _builtins.str):
        """
        :param _builtins.str input: Template input path, which can be a path to an OBS file or directory.  
               When you use a template with multiple input items to create a model,
               if the target paths input_properties specified in the template are the same,
               the OBS directory or OBS file name entered here must be unique to prevent files from being overwritten.
               Changing this parameter will create a new resource.
        :param _builtins.str input_id: Input item ID, which is obtained from template details.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_Dependency"></a>
               The `Dependency` block supports:
        """
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "input_id", input_id)

    @_builtins.property
    @pulumi.getter
    def input(self) -> _builtins.str:
        """
        Template input path, which can be a path to an OBS file or directory.  
        When you use a template with multiple input items to create a model,
        if the target paths input_properties specified in the template are the same,
        the OBS directory or OBS file name entered here must be unique to prevent files from being overwritten.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter(name="inputId")
    def input_id(self) -> _builtins.str:
        """
        Input item ID, which is obtained from template details.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_Dependency"></a>
        The `Dependency` block supports:
        """
        return pulumi.get(self, "input_id")


@pulumi.output_type
class NetworkPeerConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPeerConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPeerConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPeerConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str subnet_id: Interconnect subnet ID.
        :param _builtins.str vpc_id: Interconnect VPC ID.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        Interconnect subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Interconnect VPC ID.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class NotebookMountStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookMountStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookMountStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookMountStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 mount_path: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The mount ID.
        :param _builtins.str mount_path: The local mount path.
        :param _builtins.str path: The path of storage which be mounted.
        :param _builtins.str status: The status of mount.
        :param _builtins.str type: The type of storage which be mounted.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The mount ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[_builtins.str]:
        """
        The local mount path.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path of storage which be mounted.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of mount.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of storage which be mounted.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NotebookVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 mount_path: Optional[_builtins.str] = None,
                 ownership: Optional[_builtins.str] = None,
                 size: Optional[_builtins.int] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the volume type. The options are as follows:
               - *EFS*: use Scalable File Service, default 50GB is **free**.
               - *EVS*: use Elastic Volume Service, default size is 5 GB.
               
               Changing this parameter will create a new resource.
        :param _builtins.str id: Specifies the ID of dedicated storage disk, which is mandatory when the `type`
               is `EFS` and the `ownership` is `DEDICATED`.
               Changing this parameter will create a new resource.
        :param _builtins.str mount_path: The local mount path.
        :param _builtins.str ownership: Specifies the volume ownership. The options are as follows:
               - *MANAGED*: shared storage disk of the ModelArts service.
               - *DEDICATED*: dedicated storage disk, only supported when the category is `EFS`.
               
               Changing this parameter will create a new resource.
        :param _builtins.int size: Specifies the volume size. Its value range is from `5` GB to `4,096` GB.
        :param _builtins.str uri: Specifies the URL of dedicated storage disk, which is mandatory when the `type`
               is `EFS` and the `ownership` is `DEDICATED`. Example: `192.168.0.1:/user-9sfdsdgdfgh5ea4d56871e75d6966aa274/mount/`.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if ownership is not None:
            pulumi.set(__self__, "ownership", ownership)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the volume type. The options are as follows:
        - *EFS*: use Scalable File Service, default 50GB is **free**.
        - *EVS*: use Elastic Volume Service, default size is 5 GB.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of dedicated storage disk, which is mandatory when the `type`
        is `EFS` and the `ownership` is `DEDICATED`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[_builtins.str]:
        """
        The local mount path.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter
    def ownership(self) -> Optional[_builtins.str]:
        """
        Specifies the volume ownership. The options are as follows:
        - *MANAGED*: shared storage disk of the ModelArts service.
        - *DEDICATED*: dedicated storage disk, only supported when the category is `EFS`.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "ownership")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.int]:
        """
        Specifies the volume size. Its value range is from `5` GB to `4,096` GB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        Specifies the URL of dedicated storage disk, which is mandatory when the `type`
        is `EFS` and the `ownership` is `DEDICATED`. Example: `192.168.0.1:/user-9sfdsdgdfgh5ea4d56871e75d6966aa274/mount/`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class ResourcePoolCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerId":
            suggest = "provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_id: _builtins.str,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str provider_id: Specifies the ID of the CCE cluster.
               
               <a name="ModelartsResourcePool_User_login"></a>
               The `user_login` block supports:
        :param _builtins.str name: Specifies the OS name of the image.
        """
        pulumi.set(__self__, "provider_id", provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> _builtins.str:
        """
        Specifies the ID of the CCE cluster.

        <a name="ModelartsResourcePool_User_login"></a>
        The `user_login` block supports:
        """
        return pulumi.get(self, "provider_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the OS name of the image.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ResourcePoolMetadata(dict):
    def __init__(__self__, *,
                 annotations: Optional[_builtins.str] = None):
        """
        :param _builtins.str annotations: Specifies the annotations of the resource pool, in JSON format.  
               For details, please refer to the [document](https://support.huaweicloud.com/intl/en-us/api-modelarts/CreatePool.html#EN-US_TOPIC_0000001868289874__request_PoolAnnotationsCreation).
               
               > 1. This parameter only affects the nodes to be expanded, and will be applied to all nodes that are expanded under
               the `resources` parameter.
               <br>2. The parameter is not allowed to modify the resource pool billing-related parameters.
               <br>3. The `os.modelarts/description` cannot be set at the same time as the external `description` parameter.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[_builtins.str]:
        """
        Specifies the annotations of the resource pool, in JSON format.  
        For details, please refer to the [document](https://support.huaweicloud.com/intl/en-us/api-modelarts/CreatePool.html#EN-US_TOPIC_0000001868289874__request_PoolAnnotationsCreation).

        > 1. This parameter only affects the nodes to be expanded, and will be applied to all nodes that are expanded under
        the `resources` parameter.
        <br>2. The parameter is not allowed to modify the resource pool billing-related parameters.
        <br>3. The `os.modelarts/description` cannot be set at the same time as the external `description` parameter.
        """
        return pulumi.get(self, "annotations")


@pulumi.output_type
class ResourcePoolNodeBatchResizeNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchUid":
            suggest = "batch_uid"
        elif key == "deleteNodeNames":
            suggest = "delete_node_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolNodeBatchResizeNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolNodeBatchResizeNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolNodeBatchResizeNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_uid: _builtins.str,
                 delete_node_names: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str batch_uid: Specifies the batch UID of the node.
        :param Sequence[_builtins.str] delete_node_names: Specifies the list of nodes to be deleted.  
               This parameter is **required** only when downgrading specification of the nodes and cannot be set when upgrading.
               
               <a name="resource_pool_node_batch_resize_node_pool_configuration"></a>
               The `source` and `target` block supports:
        """
        pulumi.set(__self__, "batch_uid", batch_uid)
        if delete_node_names is not None:
            pulumi.set(__self__, "delete_node_names", delete_node_names)

    @_builtins.property
    @pulumi.getter(name="batchUid")
    def batch_uid(self) -> _builtins.str:
        """
        Specifies the batch UID of the node.
        """
        return pulumi.get(self, "batch_uid")

    @_builtins.property
    @pulumi.getter(name="deleteNodeNames")
    def delete_node_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the list of nodes to be deleted.  
        This parameter is **required** only when downgrading specification of the nodes and cannot be set when upgrading.

        <a name="resource_pool_node_batch_resize_node_pool_configuration"></a>
        The `source` and `target` block supports:
        """
        return pulumi.get(self, "delete_node_names")


@pulumi.output_type
class ResourcePoolNodeBatchResizeSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creatingStep":
            suggest = "creating_step"
        elif key == "nodePool":
            suggest = "node_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolNodeBatchResizeSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolNodeBatchResizeSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolNodeBatchResizeSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creating_step: 'outputs.ResourcePoolNodeBatchResizeSourceCreatingStep',
                 flavor: _builtins.str,
                 node_pool: _builtins.str):
        """
        :param 'ResourcePoolNodeBatchResizeSourceCreatingStepArgs' creating_step: Specifies the creating step of the node pool.  
               The creating_step structure is documented below.
               
               <a name="resource_pool_node_batch_resize_source_creating_step"></a>
               The `creating_step` block supports:
        :param _builtins.str flavor: Specifies the flavor of the node pool.
        :param _builtins.str node_pool: Specifies the name of the node pool.
        """
        pulumi.set(__self__, "creating_step", creating_step)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_pool", node_pool)

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> 'outputs.ResourcePoolNodeBatchResizeSourceCreatingStep':
        """
        Specifies the creating step of the node pool.  
        The creating_step structure is documented below.

        <a name="resource_pool_node_batch_resize_source_creating_step"></a>
        The `creating_step` block supports:
        """
        return pulumi.get(self, "creating_step")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor of the node pool.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> _builtins.str:
        """
        Specifies the name of the node pool.
        """
        return pulumi.get(self, "node_pool")


@pulumi.output_type
class ResourcePoolNodeBatchResizeSourceCreatingStep(dict):
    def __init__(__self__, *,
                 step: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int step: Specifies the step number of the nodes.
        :param _builtins.str type: Specifies the type of the nodes.  
               The valid values are as follows:
               + **hyperinstance**
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        Specifies the step number of the nodes.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the nodes.  
        The valid values are as follows:
        + **hyperinstance**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourcePoolNodeBatchResizeTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creatingStep":
            suggest = "creating_step"
        elif key == "nodePool":
            suggest = "node_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolNodeBatchResizeTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolNodeBatchResizeTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolNodeBatchResizeTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creating_step: 'outputs.ResourcePoolNodeBatchResizeTargetCreatingStep',
                 flavor: _builtins.str,
                 node_pool: _builtins.str):
        """
        :param 'ResourcePoolNodeBatchResizeTargetCreatingStepArgs' creating_step: Specifies the creating step of the node pool.  
               The creating_step structure is documented below.
               
               <a name="resource_pool_node_batch_resize_source_creating_step"></a>
               The `creating_step` block supports:
        :param _builtins.str flavor: Specifies the flavor of the node pool.
        :param _builtins.str node_pool: Specifies the name of the node pool.
        """
        pulumi.set(__self__, "creating_step", creating_step)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_pool", node_pool)

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> 'outputs.ResourcePoolNodeBatchResizeTargetCreatingStep':
        """
        Specifies the creating step of the node pool.  
        The creating_step structure is documented below.

        <a name="resource_pool_node_batch_resize_source_creating_step"></a>
        The `creating_step` block supports:
        """
        return pulumi.get(self, "creating_step")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        Specifies the flavor of the node pool.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> _builtins.str:
        """
        Specifies the name of the node pool.
        """
        return pulumi.get(self, "node_pool")


@pulumi.output_type
class ResourcePoolNodeBatchResizeTargetCreatingStep(dict):
    def __init__(__self__, *,
                 step: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int step: Specifies the step number of the nodes.
        :param _builtins.str type: Specifies the type of the nodes.  
               The valid values are as follows:
               + **hyperinstance**
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        Specifies the step number of the nodes.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the nodes.  
        The valid values are as follows:
        + **hyperinstance**
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourcePoolResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flavorId":
            suggest = "flavor_id"
        elif key == "creatingStep":
            suggest = "creating_step"
        elif key == "dataVolumes":
            suggest = "data_volumes"
        elif key == "extendParams":
            suggest = "extend_params"
        elif key == "maxCount":
            suggest = "max_count"
        elif key == "nodePool":
            suggest = "node_pool"
        elif key == "postInstall":
            suggest = "post_install"
        elif key == "rootVolume":
            suggest = "root_volume"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "volumeGroupConfigs":
            suggest = "volume_group_configs"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: _builtins.int,
                 flavor_id: _builtins.str,
                 azs: Optional[Sequence['outputs.ResourcePoolResourceAz']] = None,
                 creating_step: Optional['outputs.ResourcePoolResourceCreatingStep'] = None,
                 data_volumes: Optional[Sequence['outputs.ResourcePoolResourceDataVolume']] = None,
                 driver: Optional['outputs.ResourcePoolResourceDriver'] = None,
                 extend_params: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 max_count: Optional[_builtins.int] = None,
                 node_pool: Optional[_builtins.str] = None,
                 os: Optional['outputs.ResourcePoolResourceOs'] = None,
                 post_install: Optional[_builtins.str] = None,
                 root_volume: Optional['outputs.ResourcePoolResourceRootVolume'] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 taints: Optional[Sequence['outputs.ResourcePoolResourceTaint']] = None,
                 volume_group_configs: Optional[Sequence['outputs.ResourcePoolResourceVolumeGroupConfig']] = None,
                 vpc_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int count: Specifies the count of the current data volume configuration.
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
               The `volume_group_configs` block supports:
        :param _builtins.str flavor_id: Specifies the resource flavor ID.
        :param Sequence['ResourcePoolResourceAzArgs'] azs: Specifies the AZs for resource pool nodes.
               The azs structure is documented below.
        :param 'ResourcePoolResourceCreatingStepArgs' creating_step: Specifies the creation step configuration of the resource pool nodes.  
               The creating_step structure is documented below.
               
               <a name="ModelartsResourcePool_Resources_azs"></a>
               The `azs` block supports:
        :param Sequence['ResourcePoolResourceDataVolumeArgs'] data_volumes: Specifies the data volumes of the resource pool nodes.  
               The data_volumes structure is documented below.
        :param 'ResourcePoolResourceDriverArgs' driver: Specifies the driver information.  
               The driver structure is documented below.
        :param _builtins.str extend_params: Specifies the extend parameters of the data volume.
        :param Mapping[str, _builtins.str] labels: Specifies the labels of resource pool nodes.
        :param _builtins.int max_count: Specifies the max number of resources of the corresponding flavors.
               This parameter must be an integer multiple of `resources.creating_step.step`.
        :param _builtins.str node_pool: Specifies the name of resource pool nodes. It can contain `1` to `50`
               characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
               hyphens (-) are allowed, and cannot end with a hyphen (-).
        :param 'ResourcePoolResourceOsArgs' os: Specifies the image information for the specified OS.  
               The os structure is documented below.
        :param _builtins.str post_install: The script to be executed after security.
        :param 'ResourcePoolResourceRootVolumeArgs' root_volume: Specifies the root volume of the resource pool nodes.  
               The root_volume structure is documented below.
        :param Sequence[_builtins.str] security_group_ids: Specifies the security group IDs. It can not be specified when `network_id` is
               specified.
        :param _builtins.str subnet_id: Specifies the network ID of a subnet. It is mandatory when
               `resources.security_group_ids`is specified, and can not be specified when `network_id` is specified.
        :param Mapping[str, _builtins.str] tags: Specifies the key/value pairs to associate with the resource pool. It can not be specified
               when `network_id` is specified.
        :param Sequence['ResourcePoolResourceTaintArgs'] taints: Specifies the taints added to nodes. It can not be specified when `network_id` is specified.
               The taints structure is documented below.
        :param Sequence['ResourcePoolResourceVolumeGroupConfigArgs'] volume_group_configs: Specifies the extend configurations of the volume groups.  
               The volume_group_configs structure is documented below.
        :param _builtins.str vpc_id: Specifies the VPC ID. It is mandatory when `resources.subnet_id`,
               `resources.security_group_ids` is specified, and can not be specified when `network_id` is specified.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "flavor_id", flavor_id)
        if azs is not None:
            pulumi.set(__self__, "azs", azs)
        if creating_step is not None:
            pulumi.set(__self__, "creating_step", creating_step)
        if data_volumes is not None:
            pulumi.set(__self__, "data_volumes", data_volumes)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if node_pool is not None:
            pulumi.set(__self__, "node_pool", node_pool)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if post_install is not None:
            pulumi.set(__self__, "post_install", post_install)
        if root_volume is not None:
            pulumi.set(__self__, "root_volume", root_volume)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if volume_group_configs is not None:
            pulumi.set(__self__, "volume_group_configs", volume_group_configs)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> _builtins.str:
        """
        Specifies the resource flavor ID.
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter
    def azs(self) -> Optional[Sequence['outputs.ResourcePoolResourceAz']]:
        """
        Specifies the AZs for resource pool nodes.
        The azs structure is documented below.
        """
        return pulumi.get(self, "azs")

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> Optional['outputs.ResourcePoolResourceCreatingStep']:
        """
        Specifies the creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.

        <a name="ModelartsResourcePool_Resources_azs"></a>
        The `azs` block supports:
        """
        return pulumi.get(self, "creating_step")

    @_builtins.property
    @pulumi.getter(name="dataVolumes")
    def data_volumes(self) -> Optional[Sequence['outputs.ResourcePoolResourceDataVolume']]:
        """
        Specifies the data volumes of the resource pool nodes.  
        The data_volumes structure is documented below.
        """
        return pulumi.get(self, "data_volumes")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.ResourcePoolResourceDriver']:
        """
        Specifies the driver information.  
        The driver structure is documented below.
        """
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[_builtins.str]:
        """
        Specifies the extend parameters of the data volume.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the labels of resource pool nodes.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        Specifies the max number of resources of the corresponding flavors.
        This parameter must be an integer multiple of `resources.creating_step.step`.
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> Optional[_builtins.str]:
        """
        Specifies the name of resource pool nodes. It can contain `1` to `50`
        characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
        hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
        return pulumi.get(self, "node_pool")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional['outputs.ResourcePoolResourceOs']:
        """
        Specifies the image information for the specified OS.  
        The os structure is documented below.
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter(name="postInstall")
    def post_install(self) -> Optional[_builtins.str]:
        """
        The script to be executed after security.
        """
        return pulumi.get(self, "post_install")

    @_builtins.property
    @pulumi.getter(name="rootVolume")
    def root_volume(self) -> Optional['outputs.ResourcePoolResourceRootVolume']:
        """
        Specifies the root volume of the resource pool nodes.  
        The root_volume structure is documented below.
        """
        return pulumi.get(self, "root_volume")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the security group IDs. It can not be specified when `network_id` is
        specified.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        Specifies the network ID of a subnet. It is mandatory when
        `resources.security_group_ids`is specified, and can not be specified when `network_id` is specified.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the key/value pairs to associate with the resource pool. It can not be specified
        when `network_id` is specified.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.ResourcePoolResourceTaint']]:
        """
        Specifies the taints added to nodes. It can not be specified when `network_id` is specified.
        The taints structure is documented below.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="volumeGroupConfigs")
    def volume_group_configs(self) -> Optional[Sequence['outputs.ResourcePoolResourceVolumeGroupConfig']]:
        """
        Specifies the extend configurations of the volume groups.  
        The volume_group_configs structure is documented below.
        """
        return pulumi.get(self, "volume_group_configs")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[_builtins.str]:
        """
        Specifies the VPC ID. It is mandatory when `resources.subnet_id`,
        `resources.security_group_ids` is specified, and can not be specified when `network_id` is specified.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class ResourcePoolResourceAz(dict):
    def __init__(__self__, *,
                 az: Optional[_builtins.str] = None,
                 count: Optional[_builtins.int] = None):
        """
        :param _builtins.str az: Specifies the AZ name.
        :param _builtins.int count: Specifies the count of the current data volume configuration.
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
               The `volume_group_configs` block supports:
        """
        if az is not None:
            pulumi.set(__self__, "az", az)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def az(self) -> Optional[_builtins.str]:
        """
        Specifies the AZ name.
        """
        return pulumi.get(self, "az")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class ResourcePoolResourceCreatingStep(dict):
    def __init__(__self__, *,
                 step: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int step: Specifies the creation step of the resource pool nodes.
        :param _builtins.str type: Specifies the type of the resource pool nodes.
               The valid values are as follows:
               + **hyperinstance**
               
               <a name="ModelartsResourcePool_Clusters"></a>
               The `clusters` block supports:
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        Specifies the creation step of the resource pool nodes.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of the resource pool nodes.
        The valid values are as follows:
        + **hyperinstance**

        <a name="ModelartsResourcePool_Clusters"></a>
        The `clusters` block supports:
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourcePoolResourceDataVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"
        elif key == "extendParams":
            suggest = "extend_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolResourceDataVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolResourceDataVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolResourceDataVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.str,
                 volume_type: _builtins.str,
                 count: Optional[_builtins.int] = None,
                 extend_params: Optional[_builtins.str] = None):
        """
        :param _builtins.str size: Specifies the size of the data volume, e.g. **100Gi**.
        :param _builtins.str volume_type: Specifies the type of the data volume.  
               The valid values are as follows:
               + **SSD**
               + **GPSSD**
               + **SAS**
        :param _builtins.int count: Specifies the count of the current data volume configuration.
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
               The `volume_group_configs` block supports:
        :param _builtins.str extend_params: Specifies the extend parameters of the data volume.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Specifies the size of the data volume, e.g. **100Gi**.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the type of the data volume.  
        The valid values are as follows:
        + **SSD**
        + **GPSSD**
        + **SAS**
        """
        return pulumi.get(self, "volume_type")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[_builtins.str]:
        """
        Specifies the extend parameters of the data volume.
        """
        return pulumi.get(self, "extend_params")


@pulumi.output_type
class ResourcePoolResourceDriver(dict):
    def __init__(__self__, *,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: Specifies the driver version.
               
               <a name="ModelartsResourcePool_Resources_creating_step"></a>
               The `creating_step` block supports:
        """
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Specifies the driver version.

        <a name="ModelartsResourcePool_Resources_creating_step"></a>
        The `creating_step` block supports:
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ResourcePoolResourceOs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "imageType":
            suggest = "image_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolResourceOs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolResourceOs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolResourceOs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id: Optional[_builtins.str] = None,
                 image_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str image_id: Specifies the image ID.
        :param _builtins.str image_type: Specifies the image type.
               
               <a name="ModelartsResourcePool_Resources_driver"></a>
               The `driver` block supports:
        :param _builtins.str name: Specifies the OS name of the image.
        """
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        Specifies the image ID.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[_builtins.str]:
        """
        Specifies the image type.

        <a name="ModelartsResourcePool_Resources_driver"></a>
        The `driver` block supports:
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the OS name of the image.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ResourcePoolResourceRootVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeType":
            suggest = "volume_type"
        elif key == "extendParams":
            suggest = "extend_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolResourceRootVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolResourceRootVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolResourceRootVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: _builtins.str,
                 volume_type: _builtins.str,
                 extend_params: Optional[_builtins.str] = None):
        """
        :param _builtins.str size: Specifies the size of the data volume, e.g. **100Gi**.
        :param _builtins.str volume_type: Specifies the type of the data volume.  
               The valid values are as follows:
               + **SSD**
               + **GPSSD**
               + **SAS**
        :param _builtins.str extend_params: Specifies the extend parameters of the data volume.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Specifies the size of the data volume, e.g. **100Gi**.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        Specifies the type of the data volume.  
        The valid values are as follows:
        + **SSD**
        + **GPSSD**
        + **SAS**
        """
        return pulumi.get(self, "volume_type")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[_builtins.str]:
        """
        Specifies the extend parameters of the data volume.
        """
        return pulumi.get(self, "extend_params")


@pulumi.output_type
class ResourcePoolResourceTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Specifies the effect of the taint. Value options: **NoSchedule**, **PreferNoSchedule**,
               **NoExecute**.
               
               <a name="ModelartsResourcePool_Resources_root_volume"></a>
               The `root_volume` block supports:
        :param _builtins.str key: Specifies the key of the taint.
        :param _builtins.str value: Specifies the value of the taint.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Specifies the effect of the taint. Value options: **NoSchedule**, **PreferNoSchedule**,
        **NoExecute**.

        <a name="ModelartsResourcePool_Resources_root_volume"></a>
        The `root_volume` block supports:
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ResourcePoolResourceVolumeGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeGroup":
            suggest = "volume_group"
        elif key == "dockerThinPool":
            suggest = "docker_thin_pool"
        elif key == "lvmConfig":
            suggest = "lvm_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolResourceVolumeGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolResourceVolumeGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolResourceVolumeGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_group: _builtins.str,
                 docker_thin_pool: Optional[_builtins.int] = None,
                 lvm_config: Optional['outputs.ResourcePoolResourceVolumeGroupConfigLvmConfig'] = None,
                 types: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str volume_group: Specifies the name of the volume group.  
               The valid values are as follows:
               + **vgpaas**
               + **default**
               + **vguser{num}**
               + **vg-everest-localvolume-persistent**
               + **vg-everest-localvolume-ephemeral**
        :param _builtins.int docker_thin_pool: Specifies the percentage of container volumes to data volumes on resource pool nodes.
        :param 'ResourcePoolResourceVolumeGroupConfigLvmConfigArgs' lvm_config: Specifies the configuration of the LVM management.  
               The lvm_config structure is documented below.
        :param Sequence[_builtins.str] types: Specifies the storage types of the volume group.  
               The valid values for the list elements are as follows:
               + **volume**
               + **local**
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs_lvm_config"></a>
               The `lvm_config` block supports:
        """
        pulumi.set(__self__, "volume_group", volume_group)
        if docker_thin_pool is not None:
            pulumi.set(__self__, "docker_thin_pool", docker_thin_pool)
        if lvm_config is not None:
            pulumi.set(__self__, "lvm_config", lvm_config)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter(name="volumeGroup")
    def volume_group(self) -> _builtins.str:
        """
        Specifies the name of the volume group.  
        The valid values are as follows:
        + **vgpaas**
        + **default**
        + **vguser{num}**
        + **vg-everest-localvolume-persistent**
        + **vg-everest-localvolume-ephemeral**
        """
        return pulumi.get(self, "volume_group")

    @_builtins.property
    @pulumi.getter(name="dockerThinPool")
    def docker_thin_pool(self) -> Optional[_builtins.int]:
        """
        Specifies the percentage of container volumes to data volumes on resource pool nodes.
        """
        return pulumi.get(self, "docker_thin_pool")

    @_builtins.property
    @pulumi.getter(name="lvmConfig")
    def lvm_config(self) -> Optional['outputs.ResourcePoolResourceVolumeGroupConfigLvmConfig']:
        """
        Specifies the configuration of the LVM management.  
        The lvm_config structure is documented below.
        """
        return pulumi.get(self, "lvm_config")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the storage types of the volume group.  
        The valid values for the list elements are as follows:
        + **volume**
        + **local**

        <a name="ModelartsResourcePool_Resources_volume_group_configs_lvm_config"></a>
        The `lvm_config` block supports:
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class ResourcePoolResourceVolumeGroupConfigLvmConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvType":
            suggest = "lv_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolResourceVolumeGroupConfigLvmConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolResourceVolumeGroupConfigLvmConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolResourceVolumeGroupConfigLvmConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lv_type: _builtins.str,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str lv_type: Specifies the LVM write mode.  
               The valid values are as follows:
               + **linear**
               + **striped**
        :param _builtins.str path: Specifies the volume mount path.
               
               <a name="ModelartsResourcePool_Resources_os_info"></a>
               The `os` block supports:
        """
        pulumi.set(__self__, "lv_type", lv_type)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="lvType")
    def lv_type(self) -> _builtins.str:
        """
        Specifies the LVM write mode.  
        The valid values are as follows:
        + **linear**
        + **striped**
        """
        return pulumi.get(self, "lv_type")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Specifies the volume mount path.

        <a name="ModelartsResourcePool_Resources_os_info"></a>
        The `os` block supports:
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ResourcePoolResourcesOrderOrigin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creatingStep":
            suggest = "creating_step"
        elif key == "flavorId":
            suggest = "flavor_id"
        elif key == "nodePool":
            suggest = "node_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolResourcesOrderOrigin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolResourcesOrderOrigin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolResourcesOrderOrigin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creating_step: Optional[_builtins.str] = None,
                 flavor_id: Optional[_builtins.str] = None,
                 node_pool: Optional[_builtins.str] = None):
        """
        :param _builtins.str creating_step: Specifies the creation step configuration of the resource pool nodes.  
               The creating_step structure is documented below.
               
               <a name="ModelartsResourcePool_Resources_azs"></a>
               The `azs` block supports:
        :param _builtins.str flavor_id: Specifies the resource flavor ID.
        :param _builtins.str node_pool: Specifies the name of resource pool nodes. It can contain `1` to `50`
               characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
               hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
        if creating_step is not None:
            pulumi.set(__self__, "creating_step", creating_step)
        if flavor_id is not None:
            pulumi.set(__self__, "flavor_id", flavor_id)
        if node_pool is not None:
            pulumi.set(__self__, "node_pool", node_pool)

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> Optional[_builtins.str]:
        """
        Specifies the creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.

        <a name="ModelartsResourcePool_Resources_azs"></a>
        The `azs` block supports:
        """
        return pulumi.get(self, "creating_step")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> Optional[_builtins.str]:
        """
        Specifies the resource flavor ID.
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> Optional[_builtins.str]:
        """
        Specifies the name of resource pool nodes. It can contain `1` to `50`
        characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
        hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
        return pulumi.get(self, "node_pool")


@pulumi.output_type
class ResourcePoolUserLogin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyPairName":
            suggest = "key_pair_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourcePoolUserLogin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourcePoolUserLogin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourcePoolUserLogin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_pair_name: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_pair_name: Specifies key pair name of the login user.
               
               Changing this parameter will create a new resource.
               
               > **NOTE:** Exactly one of `password`, `key_pair_name` should be specified.
               
               <a name="ModelartsResourcePool_Metadata"></a>
               The `metadata` block supports:
        :param _builtins.str password: Specifies the password of the login user. The value needs to be salted,
               encrypted and base64 encoded. Default user is **root**.
               
               Changing this parameter will create a new resource.
        """
        if key_pair_name is not None:
            pulumi.set(__self__, "key_pair_name", key_pair_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> Optional[_builtins.str]:
        """
        Specifies key pair name of the login user.

        Changing this parameter will create a new resource.

        > **NOTE:** Exactly one of `password`, `key_pair_name` should be specified.

        <a name="ModelartsResourcePool_Metadata"></a>
        The `metadata` block supports:
        """
        return pulumi.get(self, "key_pair_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Specifies the password of the login user. The value needs to be salted,
        encrypted and base64 encoded. Default user is **root**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class ServiceAdditionalProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logReportChannels":
            suggest = "log_report_channels"
        elif key == "smnNotification":
            suggest = "smn_notification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAdditionalProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAdditionalProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAdditionalProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_report_channels: Optional['outputs.ServiceAdditionalPropertiesLogReportChannels'] = None,
                 smn_notification: Optional['outputs.ServiceAdditionalPropertiesSmnNotification'] = None):
        """
        :param 'ServiceAdditionalPropertiesLogReportChannelsArgs' log_report_channels: Advanced Log configuration.
               The LogReportChannel structure is documented below.
               
               <a name="ModelartsService_SmnNotification"></a>
               The `SmnNotification` block supports:
        :param 'ServiceAdditionalPropertiesSmnNotificationArgs' smn_notification: SMN message notification configuration.
               The SmnNotification structure is documented below.
        """
        if log_report_channels is not None:
            pulumi.set(__self__, "log_report_channels", log_report_channels)
        if smn_notification is not None:
            pulumi.set(__self__, "smn_notification", smn_notification)

    @_builtins.property
    @pulumi.getter(name="logReportChannels")
    def log_report_channels(self) -> Optional['outputs.ServiceAdditionalPropertiesLogReportChannels']:
        """
        Advanced Log configuration.
        The LogReportChannel structure is documented below.

        <a name="ModelartsService_SmnNotification"></a>
        The `SmnNotification` block supports:
        """
        return pulumi.get(self, "log_report_channels")

    @_builtins.property
    @pulumi.getter(name="smnNotification")
    def smn_notification(self) -> Optional['outputs.ServiceAdditionalPropertiesSmnNotification']:
        """
        SMN message notification configuration.
        The SmnNotification structure is documented below.
        """
        return pulumi.get(self, "smn_notification")


@pulumi.output_type
class ServiceAdditionalPropertiesLogReportChannels(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of log report channel. The valid value is **LTS**.  
               If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
               If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
               for a maximum of seven days.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceAdditionalPropertiesSmnNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicUrn":
            suggest = "topic_urn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAdditionalPropertiesSmnNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAdditionalPropertiesSmnNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAdditionalPropertiesSmnNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events: Optional[Sequence[_builtins.int]] = None,
                 topic_urn: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.int] events: Event ID.  
               Value options are as follows:
               + **1**: failed.
               + **2**: stopped.
               + **3**: running.
               + **7**: alarm.
               + **9**: deleted.
               + **11**: pending.
               
               <a name="ModelartsService_LogReportChannel"></a>
               The `LogReportChannel` block supports:
        :param _builtins.str topic_urn: URN of an SMN topic.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if topic_urn is not None:
            pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[Sequence[_builtins.int]]:
        """
        Event ID.  
        Value options are as follows:
        + **1**: failed.
        + **2**: stopped.
        + **3**: running.
        + **7**: alarm.
        + **9**: deleted.
        + **11**: pending.

        <a name="ModelartsService_LogReportChannel"></a>
        The `LogReportChannel` block supports:
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> Optional[_builtins.str]:
        """
        URN of an SMN topic.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class ServiceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customSpec":
            suggest = "custom_spec"
        elif key == "destPath":
            suggest = "dest_path"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "mappingRule":
            suggest = "mapping_rule"
        elif key == "mappingType":
            suggest = "mapping_type"
        elif key == "modelId":
            suggest = "model_id"
        elif key == "poolName":
            suggest = "pool_name"
        elif key == "reqUri":
            suggest = "req_uri"
        elif key == "srcPath":
            suggest = "src_path"
        elif key == "srcType":
            suggest = "src_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_spec: Optional['outputs.ServiceConfigCustomSpec'] = None,
                 dest_path: Optional[_builtins.str] = None,
                 envs: Optional[Mapping[str, _builtins.str]] = None,
                 instance_count: Optional[_builtins.int] = None,
                 mapping_rule: Optional[Mapping[str, _builtins.str]] = None,
                 mapping_type: Optional[_builtins.str] = None,
                 model_id: Optional[_builtins.str] = None,
                 nodes: Optional[Sequence[_builtins.str]] = None,
                 pool_name: Optional[_builtins.str] = None,
                 req_uri: Optional[_builtins.str] = None,
                 specification: Optional[_builtins.str] = None,
                 src_path: Optional[_builtins.str] = None,
                 src_type: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        :param 'ServiceConfigCustomSpecArgs' custom_spec: Custom resource specifications.  
               The CustomSpec structure is documented below.
        :param _builtins.str dest_path: OBS path to the output data of a batch job. Mandatory for batch services.
        :param Mapping[str, _builtins.str] envs: Environment variable key-value pair required for running a model.
        :param _builtins.int instance_count: Number of instances deployed for a model.  
               The maximum number of instances is 5. To use more instances, submit a service ticket.
        :param Mapping[str, _builtins.str] mapping_rule: Mapping between input parameters and CSV data. Optional for batch services.  
               This parameter is mandatory only when mapping_type is set to csv.
               The mapping rule is similar to the definition of the input parameters in the config.json file.
               You only need to configure the index parameters under each parameter of the string, number, integer,
               or boolean type, and specify the value of this parameter to the values of the index parameters
               in the CSV file to send an inference request. Use commas (,) to separate multiple pieces of CSV data.
               The values of the index parameters start from 0. If the value of the index parameter is -1, ignore this parameter.
               For details, see the sample of creating a batch service.
        :param _builtins.str mapping_type: Mapping type of the input data. Mandatory for batch services.  
               The value can be file or csv. file indicates that each inference request corresponds to a file
               in the input data directory.
               If this parameter is set to file, req_uri of the model can have only one input parameter and the type
               of this parameter is file.
               If this parameter is set to csv, each inference request corresponds to a row of data in the CSV file.
               When csv is used, the file in the input data directory can only be suffixed with .csv,
               and the mapping_rule parameter must be configured to map the index of each parameter in
               the inference request body to the CSV file.
        :param _builtins.str model_id: Model ID, which can be obtained by calling the API for obtaining a model list.
        :param Sequence[_builtins.str] nodes: Edge node ID array. Mandatory for edge services.  
               The node ID is the edge node ID on IEF, which can be obtained after the edge node is created on IEF.
        :param _builtins.str pool_name: The ID of the new dedicated resource pool.  
               When using dedicated resource pool to deploy services, ensure that the cluster status is normal.
               If both `pool_name` and `config.pool_name` are configured, `pool_name` in real-time config is preferred.
        :param _builtins.str req_uri: Inference API called in a batch task, which is the RESTful API exposed in the model image.
               Mandatory for batch services.
               You must select an API URL from the config.json file of the model for inference.
               If a built-in inference image of ModelArts is used, the API is displayed as /.
        :param _builtins.str specification: Resource flavors.  
               The valid values are **modelarts.vm.cpu.2u**, **modelarts.vm.gpu.p4** (must be requested for),
               **modelsarts.vm.ai1.a310** (must be requested for),
               and **custom** (available only when the service is deployed in a dedicated resource pool) in the current version.
               To request for a flavor, submit a service ticket and obtain permissions from ModelArts O&M engineers.
               If this parameter is set to custom, the custom_spec parameter must be specified.
               Value options are as follows:
               + **modelarts.vm.cpu.free**: [Time-limited free] CPU: 1 vCPUs | 4 GiB.
               + **modelarts.vm.cpu.2u**: CPU: 2 vCPUs | 8 GiB.
               + **modelarts.vm.gpu.p4**: CPU: 1 vCPUs | 4 GiB GPUP4 (must be requested for).
               + **modelarts.vm.gpu.p4u8.container**: CPU: 8 vCPUs | 32 GiB GPUP4.
               + **modelarts.vm.gpu.t4u8.container**: CPU: 8 vCPUs | 32 GiB GPUT4.
               + **custom**: available only when the service is deployed in a dedicated resource pool,
               and the `custom_spec` parameter must be specified.
        :param _builtins.str src_path: OBS path to the input data of a batch job.  
               Mandatory for batch services.
        :param _builtins.str src_type: Data source type, which can be ManifestFile. Mandatory for batch services.  
               By default, this parameter is left blank, indicating that only files in the src_path directory are read.
               If this parameter is set to ManifestFile, src_path must be set to a specific manifest path.
               Multiple data paths can be specified in the manifest file. For details, see the manifest inference specifications.
        :param _builtins.int weight: Weight of traffic allocated to a model.  
               This parameter is mandatory only when `infer_type` is set to **real-time**.
               The sum of all weights must be equal to 100. If multiple model versions are configured with different
               traffic weights in a real-time service, ModelArts will continuously access the prediction API of the
               service and forward prediction requests to the model instances of the corresponding versions based on the weights.
        """
        if custom_spec is not None:
            pulumi.set(__self__, "custom_spec", custom_spec)
        if dest_path is not None:
            pulumi.set(__self__, "dest_path", dest_path)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if mapping_rule is not None:
            pulumi.set(__self__, "mapping_rule", mapping_rule)
        if mapping_type is not None:
            pulumi.set(__self__, "mapping_type", mapping_type)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if pool_name is not None:
            pulumi.set(__self__, "pool_name", pool_name)
        if req_uri is not None:
            pulumi.set(__self__, "req_uri", req_uri)
        if specification is not None:
            pulumi.set(__self__, "specification", specification)
        if src_path is not None:
            pulumi.set(__self__, "src_path", src_path)
        if src_type is not None:
            pulumi.set(__self__, "src_type", src_type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="customSpec")
    def custom_spec(self) -> Optional['outputs.ServiceConfigCustomSpec']:
        """
        Custom resource specifications.  
        The CustomSpec structure is documented below.
        """
        return pulumi.get(self, "custom_spec")

    @_builtins.property
    @pulumi.getter(name="destPath")
    def dest_path(self) -> Optional[_builtins.str]:
        """
        OBS path to the output data of a batch job. Mandatory for batch services.
        """
        return pulumi.get(self, "dest_path")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Environment variable key-value pair required for running a model.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        Number of instances deployed for a model.  
        The maximum number of instances is 5. To use more instances, submit a service ticket.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="mappingRule")
    def mapping_rule(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Mapping between input parameters and CSV data. Optional for batch services.  
        This parameter is mandatory only when mapping_type is set to csv.
        The mapping rule is similar to the definition of the input parameters in the config.json file.
        You only need to configure the index parameters under each parameter of the string, number, integer,
        or boolean type, and specify the value of this parameter to the values of the index parameters
        in the CSV file to send an inference request. Use commas (,) to separate multiple pieces of CSV data.
        The values of the index parameters start from 0. If the value of the index parameter is -1, ignore this parameter.
        For details, see the sample of creating a batch service.
        """
        return pulumi.get(self, "mapping_rule")

    @_builtins.property
    @pulumi.getter(name="mappingType")
    def mapping_type(self) -> Optional[_builtins.str]:
        """
        Mapping type of the input data. Mandatory for batch services.  
        The value can be file or csv. file indicates that each inference request corresponds to a file
        in the input data directory.
        If this parameter is set to file, req_uri of the model can have only one input parameter and the type
        of this parameter is file.
        If this parameter is set to csv, each inference request corresponds to a row of data in the CSV file.
        When csv is used, the file in the input data directory can only be suffixed with .csv,
        and the mapping_rule parameter must be configured to map the index of each parameter in
        the inference request body to the CSV file.
        """
        return pulumi.get(self, "mapping_type")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[_builtins.str]:
        """
        Model ID, which can be obtained by calling the API for obtaining a model list.
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Edge node ID array. Mandatory for edge services.  
        The node ID is the edge node ID on IEF, which can be obtained after the edge node is created on IEF.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="poolName")
    def pool_name(self) -> Optional[_builtins.str]:
        """
        The ID of the new dedicated resource pool.  
        When using dedicated resource pool to deploy services, ensure that the cluster status is normal.
        If both `pool_name` and `config.pool_name` are configured, `pool_name` in real-time config is preferred.
        """
        return pulumi.get(self, "pool_name")

    @_builtins.property
    @pulumi.getter(name="reqUri")
    def req_uri(self) -> Optional[_builtins.str]:
        """
        Inference API called in a batch task, which is the RESTful API exposed in the model image.
        Mandatory for batch services.
        You must select an API URL from the config.json file of the model for inference.
        If a built-in inference image of ModelArts is used, the API is displayed as /.
        """
        return pulumi.get(self, "req_uri")

    @_builtins.property
    @pulumi.getter
    def specification(self) -> Optional[_builtins.str]:
        """
        Resource flavors.  
        The valid values are **modelarts.vm.cpu.2u**, **modelarts.vm.gpu.p4** (must be requested for),
        **modelsarts.vm.ai1.a310** (must be requested for),
        and **custom** (available only when the service is deployed in a dedicated resource pool) in the current version.
        To request for a flavor, submit a service ticket and obtain permissions from ModelArts O&M engineers.
        If this parameter is set to custom, the custom_spec parameter must be specified.
        Value options are as follows:
        + **modelarts.vm.cpu.free**: [Time-limited free] CPU: 1 vCPUs | 4 GiB.
        + **modelarts.vm.cpu.2u**: CPU: 2 vCPUs | 8 GiB.
        + **modelarts.vm.gpu.p4**: CPU: 1 vCPUs | 4 GiB GPUP4 (must be requested for).
        + **modelarts.vm.gpu.p4u8.container**: CPU: 8 vCPUs | 32 GiB GPUP4.
        + **modelarts.vm.gpu.t4u8.container**: CPU: 8 vCPUs | 32 GiB GPUT4.
        + **custom**: available only when the service is deployed in a dedicated resource pool,
        and the `custom_spec` parameter must be specified.
        """
        return pulumi.get(self, "specification")

    @_builtins.property
    @pulumi.getter(name="srcPath")
    def src_path(self) -> Optional[_builtins.str]:
        """
        OBS path to the input data of a batch job.  
        Mandatory for batch services.
        """
        return pulumi.get(self, "src_path")

    @_builtins.property
    @pulumi.getter(name="srcType")
    def src_type(self) -> Optional[_builtins.str]:
        """
        Data source type, which can be ManifestFile. Mandatory for batch services.  
        By default, this parameter is left blank, indicating that only files in the src_path directory are read.
        If this parameter is set to ManifestFile, src_path must be set to a specific manifest path.
        Multiple data paths can be specified in the manifest file. For details, see the manifest inference specifications.
        """
        return pulumi.get(self, "src_type")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Weight of traffic allocated to a model.  
        This parameter is mandatory only when `infer_type` is set to **real-time**.
        The sum of all weights must be equal to 100. If multiple model versions are configured with different
        traffic weights in a real-time service, ModelArts will continuously access the prediction API of the
        service and forward prediction requests to the model instances of the corresponding versions based on the weights.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class ServiceConfigCustomSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ascendA310":
            suggest = "ascend_a310"
        elif key == "gpuP4":
            suggest = "gpu_p4"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConfigCustomSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConfigCustomSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConfigCustomSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ascend_a310: Optional[_builtins.int] = None,
                 cpu: Optional[_builtins.float] = None,
                 gpu_p4: Optional[_builtins.float] = None,
                 memory: Optional[_builtins.int] = None):
        """
        :param _builtins.int ascend_a310: Number of Ascend chips. Either this parameter or `gpu_p4` is configured.
               
               <a name="ModelartsService_Schedule"></a>
               The `Schedule` block supports:
        :param _builtins.float cpu: Number of CPU cores, which can be a decimal. The value cannot be smaller than 0.01.
        :param _builtins.float gpu_p4: Number of GPU cores, which can be a decimal.  
               The value cannot be smaller than 0, which allows up to two decimal places.
        :param _builtins.int memory: Memory in MB, which must be an integer.
        """
        if ascend_a310 is not None:
            pulumi.set(__self__, "ascend_a310", ascend_a310)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if gpu_p4 is not None:
            pulumi.set(__self__, "gpu_p4", gpu_p4)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="ascendA310")
    def ascend_a310(self) -> Optional[_builtins.int]:
        """
        Number of Ascend chips. Either this parameter or `gpu_p4` is configured.

        <a name="ModelartsService_Schedule"></a>
        The `Schedule` block supports:
        """
        return pulumi.get(self, "ascend_a310")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.float]:
        """
        Number of CPU cores, which can be a decimal. The value cannot be smaller than 0.01.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter(name="gpuP4")
    def gpu_p4(self) -> Optional[_builtins.float]:
        """
        Number of GPU cores, which can be a decimal.  
        The value cannot be smaller than 0, which allows up to two decimal places.
        """
        return pulumi.get(self, "gpu_p4")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.int]:
        """
        Memory in MB, which must be an integer.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ServiceSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeUnit":
            suggest = "time_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: _builtins.int,
                 time_unit: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int duration: Value mapping a time unit.  
               For example, if the task stops after two hours, set time_unit to HOURS and duration to 2.
        :param _builtins.str time_unit: Scheduling time unit. Possible values are DAYS, HOURS, and MINUTES.
        :param _builtins.str type: The type of log report channel. The valid value is **LTS**.  
               If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
               If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
               for a maximum of seven days.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "time_unit", time_unit)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        Value mapping a time unit.  
        For example, if the task stops after two hours, set time_unit to HOURS and duration to 2.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> _builtins.str:
        """
        Scheduling time unit. Possible values are DAYS, HOURS, and MINUTES.
        """
        return pulumi.get(self, "time_unit")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceV2GroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unitConfigs":
            suggest = "unit_configs"
        elif key == "poolId":
            suggest = "pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: _builtins.int,
                 name: _builtins.str,
                 unit_configs: Sequence['outputs.ServiceV2GroupConfigUnitConfig'],
                 weight: _builtins.int,
                 framework: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 pool_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int count: Specifies the instance number of the group unit.
        :param _builtins.str name: Specifies the name of the instance group.  
               The valid length is limited from `1` to `64`, only English letters, Chinese characters, digits, hyphens (-) and
               underscores (_) are allowed.
        :param Sequence['ServiceV2GroupConfigUnitConfigArgs'] unit_configs: Specifies the unit configurations of the instance group.  
               The unit_configs structure is documented below.
               When the unit is used for **SINGLE** deploy type, the length of `unit_configs` is `1`.
               When used for **SINGLE** and **DIST** deploy type, the number of units configuration depending on the framework.
        :param _builtins.int weight: Specifies the weight percentage of the instance group.
               
               > The sum of all group weights must be `100`.
        :param _builtins.str framework: Specifies the algorithm framework.  
               The valid values are as follows:
               + **COMMON**
               + **VLLM**
               + **MINDIE**
               
               > Updates to the `name`, `pool_id` and `framework` parameters in existing group configurations are not supported, but
               new group configurations and remove existing group configurations are not limited.
               
               <a name="v2_service_unit_configs"></a>
               The `unit_configs` block supports:
        :param _builtins.str id: Specifies the image ID of the group unit.  
               Only available if the value of parameter `source` is **IMAGE**.
               
               <a name="v2_service_unit_config_custom_spec"></a>
               The `custom_spec` block supports:
        :param _builtins.str pool_id: Specifies the ID of the dedicated resource pool for the instance group.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit_configs", unit_configs)
        pulumi.set(__self__, "weight", weight)
        if framework is not None:
            pulumi.set(__self__, "framework", framework)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        Specifies the instance number of the group unit.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the instance group.  
        The valid length is limited from `1` to `64`, only English letters, Chinese characters, digits, hyphens (-) and
        underscores (_) are allowed.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="unitConfigs")
    def unit_configs(self) -> Sequence['outputs.ServiceV2GroupConfigUnitConfig']:
        """
        Specifies the unit configurations of the instance group.  
        The unit_configs structure is documented below.
        When the unit is used for **SINGLE** deploy type, the length of `unit_configs` is `1`.
        When used for **SINGLE** and **DIST** deploy type, the number of units configuration depending on the framework.
        """
        return pulumi.get(self, "unit_configs")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        Specifies the weight percentage of the instance group.

        > The sum of all group weights must be `100`.
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter
    def framework(self) -> Optional[_builtins.str]:
        """
        Specifies the algorithm framework.  
        The valid values are as follows:
        + **COMMON**
        + **VLLM**
        + **MINDIE**

        > Updates to the `name`, `pool_id` and `framework` parameters in existing group configurations are not supported, but
        new group configurations and remove existing group configurations are not limited.

        <a name="v2_service_unit_configs"></a>
        The `unit_configs` block supports:
        """
        return pulumi.get(self, "framework")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the dedicated resource pool for the instance group.
        """
        return pulumi.get(self, "pool_id")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customSpec":
            suggest = "custom_spec"
        elif key == "livenessHealth":
            suggest = "liveness_health"
        elif key == "readinessHealth":
            suggest = "readiness_health"
        elif key == "startupHealth":
            suggest = "startup_health"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfigUnitConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfigUnitConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfigUnitConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: 'outputs.ServiceV2GroupConfigUnitConfigImage',
                 cmd: Optional[_builtins.str] = None,
                 codes: Optional[Sequence['outputs.ServiceV2GroupConfigUnitConfigCode']] = None,
                 count: Optional[_builtins.int] = None,
                 custom_spec: Optional['outputs.ServiceV2GroupConfigUnitConfigCustomSpec'] = None,
                 envs: Optional[Mapping[str, _builtins.str]] = None,
                 flavor: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 liveness_health: Optional['outputs.ServiceV2GroupConfigUnitConfigLivenessHealth'] = None,
                 models: Optional[Sequence['outputs.ServiceV2GroupConfigUnitConfigModel']] = None,
                 port: Optional[_builtins.int] = None,
                 readiness_health: Optional['outputs.ServiceV2GroupConfigUnitConfigReadinessHealth'] = None,
                 recovery: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 startup_health: Optional['outputs.ServiceV2GroupConfigUnitConfigStartupHealth'] = None):
        """
        :param 'ServiceV2GroupConfigUnitConfigImageArgs' image: Specifies the image configuration of the group unit.  
               The image structure is documented below.
        :param _builtins.str cmd: Specifies the startup commands of the group unit.
        :param Sequence['ServiceV2GroupConfigUnitConfigCodeArgs'] codes: Specifies the code configuration of the group unit.  
               The codes structure is documented below.
        :param _builtins.int count: Specifies the instance number of the group unit.
        :param 'ServiceV2GroupConfigUnitConfigCustomSpecArgs' custom_spec: Specifies the configuration of the custom resource specification.  
               The custom_spec structure is documented below.
        :param Mapping[str, _builtins.str] envs: Specifies the environment variables of the group unit.
        :param _builtins.str flavor: Specifies the instance flavor of the group unit.
        :param _builtins.str id: Specifies the image ID of the group unit.  
               Only available if the value of parameter `source` is **IMAGE**.
               
               <a name="v2_service_unit_config_custom_spec"></a>
               The `custom_spec` block supports:
        :param 'ServiceV2GroupConfigUnitConfigLivenessHealthArgs' liveness_health: Specifies the configuration of the liveness health check.  
               The liveness_health structure is documented below.
        :param Sequence['ServiceV2GroupConfigUnitConfigModelArgs'] models: Specifies the model configuration of the group unit.  
               The models structure is documented below.
        :param _builtins.int port: Specifies the port of the group unit.
        :param 'ServiceV2GroupConfigUnitConfigReadinessHealthArgs' readiness_health: Specifies the configuration of the readiness health check.  
               The readiness_health structure is documented below.
        :param _builtins.str recovery: Specifies the recovery strategy of the group unit.  
               The valid values are as follows:
               + **INSTANCE_GROUP**
               + **INSTANCE**
               
               > Updates to the `role` parameter in existing unit configurations are not supported, but new unit configurations and
               remove existing unit configurations are not limited.
               
               <a name="v2_service_unit_config_image"></a>
               The `image` block supports:
        :param _builtins.str role: Specifies the role of the group unit.  
               The valid values are as follows:
               + **SCHEDULER**: Scheduling unit, valid in the **MINDIE** framework.
               + **MANAGER**: Management unit, valid in the **MINDIE** framework.
               + **WORKER**: Work unit, valid in the **MINDIE** framework.
               + **PREFILL**: Total unit, valid in the **VLLM** framework.
               + **DECODE**: Incremental unit, valid in the **VLLM** framework.
               + **COMMON**: Others.
        :param 'ServiceV2GroupConfigUnitConfigStartupHealthArgs' startup_health: Specifies the configuration of the startup health check.  
               The startup_health structure is documented below.
        """
        pulumi.set(__self__, "image", image)
        if cmd is not None:
            pulumi.set(__self__, "cmd", cmd)
        if codes is not None:
            pulumi.set(__self__, "codes", codes)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if custom_spec is not None:
            pulumi.set(__self__, "custom_spec", custom_spec)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if liveness_health is not None:
            pulumi.set(__self__, "liveness_health", liveness_health)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if readiness_health is not None:
            pulumi.set(__self__, "readiness_health", readiness_health)
        if recovery is not None:
            pulumi.set(__self__, "recovery", recovery)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if startup_health is not None:
            pulumi.set(__self__, "startup_health", startup_health)

    @_builtins.property
    @pulumi.getter
    def image(self) -> 'outputs.ServiceV2GroupConfigUnitConfigImage':
        """
        Specifies the image configuration of the group unit.  
        The image structure is documented below.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def cmd(self) -> Optional[_builtins.str]:
        """
        Specifies the startup commands of the group unit.
        """
        return pulumi.get(self, "cmd")

    @_builtins.property
    @pulumi.getter
    def codes(self) -> Optional[Sequence['outputs.ServiceV2GroupConfigUnitConfigCode']]:
        """
        Specifies the code configuration of the group unit.  
        The codes structure is documented below.
        """
        return pulumi.get(self, "codes")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        Specifies the instance number of the group unit.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="customSpec")
    def custom_spec(self) -> Optional['outputs.ServiceV2GroupConfigUnitConfigCustomSpec']:
        """
        Specifies the configuration of the custom resource specification.  
        The custom_spec structure is documented below.
        """
        return pulumi.get(self, "custom_spec")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the environment variables of the group unit.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[_builtins.str]:
        """
        Specifies the instance flavor of the group unit.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="livenessHealth")
    def liveness_health(self) -> Optional['outputs.ServiceV2GroupConfigUnitConfigLivenessHealth']:
        """
        Specifies the configuration of the liveness health check.  
        The liveness_health structure is documented below.
        """
        return pulumi.get(self, "liveness_health")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence['outputs.ServiceV2GroupConfigUnitConfigModel']]:
        """
        Specifies the model configuration of the group unit.  
        The models structure is documented below.
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Specifies the port of the group unit.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="readinessHealth")
    def readiness_health(self) -> Optional['outputs.ServiceV2GroupConfigUnitConfigReadinessHealth']:
        """
        Specifies the configuration of the readiness health check.  
        The readiness_health structure is documented below.
        """
        return pulumi.get(self, "readiness_health")

    @_builtins.property
    @pulumi.getter
    def recovery(self) -> Optional[_builtins.str]:
        """
        Specifies the recovery strategy of the group unit.  
        The valid values are as follows:
        + **INSTANCE_GROUP**
        + **INSTANCE**

        > Updates to the `role` parameter in existing unit configurations are not supported, but new unit configurations and
        remove existing unit configurations are not limited.

        <a name="v2_service_unit_config_image"></a>
        The `image` block supports:
        """
        return pulumi.get(self, "recovery")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Specifies the role of the group unit.  
        The valid values are as follows:
        + **SCHEDULER**: Scheduling unit, valid in the **MINDIE** framework.
        + **MANAGER**: Management unit, valid in the **MINDIE** framework.
        + **WORKER**: Work unit, valid in the **MINDIE** framework.
        + **PREFILL**: Total unit, valid in the **VLLM** framework.
        + **DECODE**: Incremental unit, valid in the **VLLM** framework.
        + **COMMON**: Others.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="startupHealth")
    def startup_health(self) -> Optional['outputs.ServiceV2GroupConfigUnitConfigStartupHealth']:
        """
        Specifies the configuration of the startup health check.  
        The startup_health structure is documented below.
        """
        return pulumi.get(self, "startup_health")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfigCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "sourceId":
            suggest = "source_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfigUnitConfigCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfigUnitConfigCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfigUnitConfigCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: _builtins.str,
                 source: _builtins.str,
                 address: Optional[_builtins.str] = None,
                 source_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str mount_path: Specifies the path to mount into the container.  
               The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
               backslash (\\\\) and dots (.).
        :param _builtins.str source: Specifies the source type of the code configuration.  
               The valid values are as follows:
               + **OBS**
               + **OBSFS**
               + **EFS**
               + **GIT**
        :param _builtins.str address: Specifies the source address of the code configuration.  
               This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        :param _builtins.str source_id: Specifies the source ID of the code configuration.  
               This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
               **EFS**.
               
               <a name="v2_service_unit_config_health_check"></a>
               The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "source", source)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        Specifies the path to mount into the container.  
        The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
        backslash (\\\\) and dots (.).
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Specifies the source address of the code configuration.  
        This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[_builtins.str]:
        """
        Specifies the source ID of the code configuration.  
        This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
        **EFS**.

        <a name="v2_service_unit_config_health_check"></a>
        The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfigCustomSpec(dict):
    def __init__(__self__, *,
                 ascend: Optional[_builtins.int] = None,
                 cpu: Optional[_builtins.float] = None,
                 gpu: Optional[_builtins.float] = None,
                 memory: Optional[_builtins.int] = None):
        """
        :param _builtins.int ascend: Specifies the number of Ascend chips.  
               This parameter cannot be configured together with `gpu`.
               
               <a name="v2_service_unit_config_models"></a>
               The `models` block supports:
        :param _builtins.float cpu: Specifies the CPU number of the custom specification.
               The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        :param _builtins.float gpu: Specifies the GPU number of the custom specification.
               The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        :param _builtins.int memory: Specifies the memory size of the custom specification.
        """
        if ascend is not None:
            pulumi.set(__self__, "ascend", ascend)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def ascend(self) -> Optional[_builtins.int]:
        """
        Specifies the number of Ascend chips.  
        This parameter cannot be configured together with `gpu`.

        <a name="v2_service_unit_config_models"></a>
        The `models` block supports:
        """
        return pulumi.get(self, "ascend")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.float]:
        """
        Specifies the CPU number of the custom specification.
        The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> Optional[_builtins.float]:
        """
        Specifies the GPU number of the custom specification.
        The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        """
        return pulumi.get(self, "gpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.int]:
        """
        Specifies the memory size of the custom specification.
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfigImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "swrPath":
            suggest = "swr_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfigUnitConfigImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfigUnitConfigImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfigUnitConfigImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: _builtins.str,
                 swr_path: _builtins.str,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str source: Specifies the source type of the code configuration.  
               The valid values are as follows:
               + **OBS**
               + **OBSFS**
               + **EFS**
               + **GIT**
        :param _builtins.str swr_path: Specifies the SWR storage path of the group unit.
        :param _builtins.str id: Specifies the image ID of the group unit.  
               Only available if the value of parameter `source` is **IMAGE**.
               
               <a name="v2_service_unit_config_custom_spec"></a>
               The `custom_spec` block supports:
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "swr_path", swr_path)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="swrPath")
    def swr_path(self) -> _builtins.str:
        """
        Specifies the SWR storage path of the group unit.
        """
        return pulumi.get(self, "swr_path")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfigLivenessHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkMethod":
            suggest = "check_method"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfigUnitConfigLivenessHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfigUnitConfigLivenessHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfigUnitConfigLivenessHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_method: _builtins.str,
                 failure_threshold: _builtins.int,
                 initial_delay_seconds: _builtins.int,
                 period_seconds: _builtins.int,
                 timeout_seconds: _builtins.int,
                 command: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str check_method: Specifies the method of the health check.  
               The valid values are as follows:
               + **EXEC**
               + **HTTP**
        :param _builtins.int failure_threshold: Specifies the minimum number of consecutive detection failures.  
               The minimum timeout value is `1`.
        :param _builtins.int initial_delay_seconds: Specifies the time to wait when performing the first probe.  
               The minimum timeout value is `1`.
        :param _builtins.int period_seconds: Specifies the period time for performing health check.  
               The minimum timeout value is `1`.
        :param _builtins.int timeout_seconds: Specifies the timeout for executing the probe.  
               The minimum timeout value is `1`.
        :param _builtins.str command: Specifies the commands configuration of the health check.  
               Only available if the `check_method` is **EXEC**.
        :param _builtins.str url: Specifies the request URL of the health check.  
               Only available if the `check_method` is **HTTP**.
               
               <a name="v2_service_log_configs"></a>
               The `log_configs` block supports:
        """
        pulumi.set(__self__, "check_method", check_method)
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="checkMethod")
    def check_method(self) -> _builtins.str:
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        return pulumi.get(self, "check_method")

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> _builtins.int:
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> _builtins.int:
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> _builtins.int:
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> _builtins.int:
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfigModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "sourceId":
            suggest = "source_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfigUnitConfigModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfigUnitConfigModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfigUnitConfigModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: _builtins.str,
                 source: _builtins.str,
                 address: Optional[_builtins.str] = None,
                 source_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str mount_path: Specifies the path to mount into the container.  
               The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
               backslash (\\\\) and dots (.).
        :param _builtins.str source: Specifies the source type of the code configuration.  
               The valid values are as follows:
               + **OBS**
               + **OBSFS**
               + **EFS**
               + **GIT**
        :param _builtins.str address: Specifies the source address of the code configuration.  
               This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        :param _builtins.str source_id: Specifies the source ID of the code configuration.  
               This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
               **EFS**.
               
               <a name="v2_service_unit_config_health_check"></a>
               The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "source", source)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        Specifies the path to mount into the container.  
        The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
        backslash (\\\\) and dots (.).
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Specifies the source address of the code configuration.  
        This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[_builtins.str]:
        """
        Specifies the source ID of the code configuration.  
        This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
        **EFS**.

        <a name="v2_service_unit_config_health_check"></a>
        The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfigReadinessHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkMethod":
            suggest = "check_method"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfigUnitConfigReadinessHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfigUnitConfigReadinessHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfigUnitConfigReadinessHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_method: _builtins.str,
                 failure_threshold: _builtins.int,
                 initial_delay_seconds: _builtins.int,
                 period_seconds: _builtins.int,
                 timeout_seconds: _builtins.int,
                 command: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str check_method: Specifies the method of the health check.  
               The valid values are as follows:
               + **EXEC**
               + **HTTP**
        :param _builtins.int failure_threshold: Specifies the minimum number of consecutive detection failures.  
               The minimum timeout value is `1`.
        :param _builtins.int initial_delay_seconds: Specifies the time to wait when performing the first probe.  
               The minimum timeout value is `1`.
        :param _builtins.int period_seconds: Specifies the period time for performing health check.  
               The minimum timeout value is `1`.
        :param _builtins.int timeout_seconds: Specifies the timeout for executing the probe.  
               The minimum timeout value is `1`.
        :param _builtins.str command: Specifies the commands configuration of the health check.  
               Only available if the `check_method` is **EXEC**.
        :param _builtins.str url: Specifies the request URL of the health check.  
               Only available if the `check_method` is **HTTP**.
               
               <a name="v2_service_log_configs"></a>
               The `log_configs` block supports:
        """
        pulumi.set(__self__, "check_method", check_method)
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="checkMethod")
    def check_method(self) -> _builtins.str:
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        return pulumi.get(self, "check_method")

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> _builtins.int:
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> _builtins.int:
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> _builtins.int:
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> _builtins.int:
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ServiceV2GroupConfigUnitConfigStartupHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkMethod":
            suggest = "check_method"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2GroupConfigUnitConfigStartupHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2GroupConfigUnitConfigStartupHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2GroupConfigUnitConfigStartupHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_method: _builtins.str,
                 failure_threshold: _builtins.int,
                 initial_delay_seconds: _builtins.int,
                 period_seconds: _builtins.int,
                 timeout_seconds: _builtins.int,
                 command: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str check_method: Specifies the method of the health check.  
               The valid values are as follows:
               + **EXEC**
               + **HTTP**
        :param _builtins.int failure_threshold: Specifies the minimum number of consecutive detection failures.  
               The minimum timeout value is `1`.
        :param _builtins.int initial_delay_seconds: Specifies the time to wait when performing the first probe.  
               The minimum timeout value is `1`.
        :param _builtins.int period_seconds: Specifies the period time for performing health check.  
               The minimum timeout value is `1`.
        :param _builtins.int timeout_seconds: Specifies the timeout for executing the probe.  
               The minimum timeout value is `1`.
        :param _builtins.str command: Specifies the commands configuration of the health check.  
               Only available if the `check_method` is **EXEC**.
        :param _builtins.str url: Specifies the request URL of the health check.  
               Only available if the `check_method` is **HTTP**.
               
               <a name="v2_service_log_configs"></a>
               The `log_configs` block supports:
        """
        pulumi.set(__self__, "check_method", check_method)
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="checkMethod")
    def check_method(self) -> _builtins.str:
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        return pulumi.get(self, "check_method")

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> _builtins.int:
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> _builtins.int:
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> _builtins.int:
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> _builtins.int:
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ServiceV2LogConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupId":
            suggest = "log_group_id"
        elif key == "logStreamId":
            suggest = "log_stream_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceV2LogConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceV2LogConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceV2LogConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 log_group_id: Optional[_builtins.str] = None,
                 log_stream_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Specifies the type of LTS configuration.
               Currently, the valid value is **STDOUT**.
        :param _builtins.str log_group_id: Specifies the ID of the LTS group.
        :param _builtins.str log_stream_id: Specifies the ID of the LTS stream.
        """
        pulumi.set(__self__, "type", type)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_stream_id is not None:
            pulumi.set(__self__, "log_stream_id", log_stream_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of LTS configuration.
        Currently, the valid value is **STDOUT**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the LTS group.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> Optional[_builtins.str]:
        """
        Specifies the ID of the LTS stream.
        """
        return pulumi.get(self, "log_stream_id")


@pulumi.output_type
class ServiceV2PredictUrl(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 urls: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str type: Specifies the type of LTS configuration.
               Currently, the valid value is **STDOUT**.
        :param Sequence[_builtins.str] urls: The URLs of service access.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the type of LTS configuration.
        Currently, the valid value is **STDOUT**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        The URLs of service access.
        """
        return pulumi.get(self, "urls")


@pulumi.output_type
class WorkspaceGrant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userId":
            suggest = "user_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceGrant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceGrant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceGrant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str user_id: IAM user ID.  
               User ID and username specify at least one. If both are specified, User ID is preferred.
        :param _builtins.str user_name: IAM username.
        """
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        IAM user ID.  
        User ID and username specify at least one. If both are specified, User ID is preferred.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        IAM username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetDataset_versionsVersionResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 files: _builtins.int,
                 id: _builtins.str,
                 is_current: _builtins.bool,
                 name: _builtins.str,
                 split_ratio: _builtins.str,
                 status: _builtins.int,
                 storage_path: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The creation time, in UTC format.
        :param _builtins.str description: The description of the dataset version.
        :param _builtins.int files: The total number of samples.
        :param _builtins.str id: The ID of the dataset version.
        :param _builtins.bool is_current: Whether this version is current version.
        :param _builtins.str name: Specifies the name of the dataset version.
        :param _builtins.str split_ratio: Specifies the range of splitting ratio which randomly divides a labeled sample
               into a training set and a validation set. Separate the minimum and maximum split ratios with commas,
               for example: "0.0,1.0".
        :param _builtins.int status: Dataset version status. Valid values are as follows:
               + **0**: Creating.
               + **1**: Normal.
               + **2**: Deleting.
               + **3**: Deleted.
               + **4**: Exception.
        :param _builtins.str storage_path: The path to save the manifest file of the version.
        :param _builtins.str updated_at: The last update time, in UTC format.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "files", files)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_current", is_current)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "split_ratio", split_ratio)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_path", storage_path)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time, in UTC format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the dataset version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def files(self) -> _builtins.int:
        """
        The total number of samples.
        """
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dataset version.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isCurrent")
    def is_current(self) -> _builtins.bool:
        """
        Whether this version is current version.
        """
        return pulumi.get(self, "is_current")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the dataset version.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="splitRatio")
    def split_ratio(self) -> _builtins.str:
        """
        Specifies the range of splitting ratio which randomly divides a labeled sample
        into a training set and a validation set. Separate the minimum and maximum split ratios with commas,
        for example: "0.0,1.0".
        """
        return pulumi.get(self, "split_ratio")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Dataset version status. Valid values are as follows:
        + **0**: Creating.
        + **1**: Normal.
        + **2**: Deleting.
        + **3**: Deleted.
        + **4**: Exception.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storagePath")
    def storage_path(self) -> _builtins.str:
        """
        The path to save the manifest file of the version.
        """
        return pulumi.get(self, "storage_path")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The last update time, in UTC format.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetDatasetsDatasetResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 data_format: _builtins.str,
                 data_sources: Sequence['outputs.GetDatasetsDatasetDataSourceResult'],
                 description: _builtins.str,
                 id: _builtins.str,
                 labels: Sequence['outputs.GetDatasetsDatasetLabelResult'],
                 name: _builtins.str,
                 output_path: _builtins.str,
                 schemas: Sequence['outputs.GetDatasetsDatasetSchemaResult'],
                 status: _builtins.int,
                 type: _builtins.int):
        """
        :param _builtins.str created_at: The dataset creation time.
        :param _builtins.str data_format: The dataset format. Valid values include: `Default`, `CarbonData`: Carbon format(Supported only for
               table type dataset.).
        :param Sequence['GetDatasetsDatasetDataSourceArgs'] data_sources: The data sources which is used to imported the source data (such as pictures/files/audio, etc.) in
               this directory and subdirectories to the dataset. Structure is documented below.
        :param _builtins.str description: The description of the dataset.
        :param _builtins.str id: The ID of the dataset.
        :param Sequence['GetDatasetsDatasetLabelArgs'] labels: The labels information. Structure is documented below.
        :param _builtins.str name: Specifies the name of datasets.
        :param _builtins.str output_path: The OBS path for storing output files such as labeled files.
        :param Sequence['GetDatasetsDatasetSchemaArgs'] schemas: The schema information of source data when `type` is `400`(Table Type). Structure is documented below.
        :param _builtins.int status: Dataset status. Valid values are as follows:
               + **0**: Creating.
               + **1**: Completed.
               + **2**: Deleting.
               + **3**: Deleted.
               + **4**: Exception.
               + **5**: Syncing.
               + **6**: Releasing.
               + **7**: Version switching.
               + **8**: Importing.
        :param _builtins.int type: Specifies the type of datasets. The options are:
               + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
               + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
               + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
               + **100**: Text classification, supported formats: `.txt`, `.csv`.
               + **200**: Sound classification, Supported formats: `.wav`.
               + **400**: Table type, supported formats: Carbon type.
               + **600**: Video, supported formats: `.mp4`
               + **900**: Free format.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "data_format", data_format)
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_path", output_path)
        pulumi.set(__self__, "schemas", schemas)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The dataset creation time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> _builtins.str:
        """
        The dataset format. Valid values include: `Default`, `CarbonData`: Carbon format(Supported only for
        table type dataset.).
        """
        return pulumi.get(self, "data_format")

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetDatasetsDatasetDataSourceResult']:
        """
        The data sources which is used to imported the source data (such as pictures/files/audio, etc.) in
        this directory and subdirectories to the dataset. Structure is documented below.
        """
        return pulumi.get(self, "data_sources")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the dataset.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dataset.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetDatasetsDatasetLabelResult']:
        """
        The labels information. Structure is documented below.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of datasets.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputPath")
    def output_path(self) -> _builtins.str:
        """
        The OBS path for storing output files such as labeled files.
        """
        return pulumi.get(self, "output_path")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Sequence['outputs.GetDatasetsDatasetSchemaResult']:
        """
        The schema information of source data when `type` is `400`(Table Type). Structure is documented below.
        """
        return pulumi.get(self, "schemas")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Dataset status. Valid values are as follows:
        + **0**: Creating.
        + **1**: Completed.
        + **2**: Deleting.
        + **3**: Deleted.
        + **4**: Exception.
        + **5**: Syncing.
        + **6**: Releasing.
        + **7**: Version switching.
        + **8**: Importing.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.int:
        """
        Specifies the type of datasets. The options are:
        + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
        + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
        + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
        + **100**: Text classification, supported formats: `.txt`, `.csv`.
        + **200**: Sound classification, Supported formats: `.wav`.
        + **400**: Table type, supported formats: Carbon type.
        + **600**: Video, supported formats: `.mp4`
        + **900**: Free format.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatasetsDatasetDataSourceResult(dict):
    def __init__(__self__, *,
                 data_type: _builtins.int,
                 path: _builtins.str,
                 with_column_header: _builtins.bool):
        """
        :param _builtins.int data_type: The type of data source. Valid values are as follows:
               + *0*: OBS.
               + *1*: GaussDB(DWS).
               + *2*: DLI.
               + *4*: MRS.
        :param _builtins.str path: The OBS path when `data_type` is `0`(OBS) or the HDFS path when `data_type` is `4`(MRS). All the file in this
               directory and subdirectories will be which be imported to the dataset.
        :param _builtins.bool with_column_header: Whether the data contains table header when the type of dataset is `400`(Table type).
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "with_column_header", with_column_header)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.int:
        """
        The type of data source. Valid values are as follows:
        + *0*: OBS.
        + *1*: GaussDB(DWS).
        + *2*: DLI.
        + *4*: MRS.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The OBS path when `data_type` is `0`(OBS) or the HDFS path when `data_type` is `4`(MRS). All the file in this
        directory and subdirectories will be which be imported to the dataset.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="withColumnHeader")
    def with_column_header(self) -> _builtins.bool:
        """
        Whether the data contains table header when the type of dataset is `400`(Table type).
        """
        return pulumi.get(self, "with_column_header")


@pulumi.output_type
class GetDatasetsDatasetLabelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 property_color: _builtins.str,
                 property_shape: _builtins.str,
                 property_shortcut: _builtins.str):
        """
        :param _builtins.str name: Specifies the name of datasets.
        :param _builtins.str property_color: The color of label.
        :param _builtins.str property_shape: The shape of label. Valid values include: `bndbox`, `polygon`, `circle`, `line`, `dashed`,
               `point`, `polyline`.
        :param _builtins.str property_shortcut: The shortcut of label.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "property_color", property_color)
        pulumi.set(__self__, "property_shape", property_shape)
        pulumi.set(__self__, "property_shortcut", property_shortcut)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of datasets.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="propertyColor")
    def property_color(self) -> _builtins.str:
        """
        The color of label.
        """
        return pulumi.get(self, "property_color")

    @_builtins.property
    @pulumi.getter(name="propertyShape")
    def property_shape(self) -> _builtins.str:
        """
        The shape of label. Valid values include: `bndbox`, `polygon`, `circle`, `line`, `dashed`,
        `point`, `polyline`.
        """
        return pulumi.get(self, "property_shape")

    @_builtins.property
    @pulumi.getter(name="propertyShortcut")
    def property_shortcut(self) -> _builtins.str:
        """
        The shortcut of label.
        """
        return pulumi.get(self, "property_shortcut")


@pulumi.output_type
class GetDatasetsDatasetSchemaResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str name: Specifies the name of datasets.
        :param _builtins.str type: Specifies the type of datasets. The options are:
               + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
               + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
               + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
               + **100**: Text classification, supported formats: `.txt`, `.csv`.
               + **200**: Sound classification, Supported formats: `.wav`.
               + **400**: Table type, supported formats: Carbon type.
               + **600**: Video, supported formats: `.mp4`
               + **900**: Free format.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of datasets.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of datasets. The options are:
        + **0**: Image classification, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
        + **1**: Object detection, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
        + **3**: Image segmentation, supported formats: `.jpg`, `.png`, `.jpeg`, `.bmp`.
        + **100**: Text classification, supported formats: `.txt`, `.csv`.
        + **200**: Sound classification, Supported formats: `.wav`.
        + **400**: Table type, supported formats: Carbon type.
        + **600**: Video, supported formats: `.mp4`
        + **900**: Free format.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetModelTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 arch: _builtins.str,
                 description: _builtins.str,
                 engine: _builtins.str,
                 environment: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 template_docs: Sequence['outputs.GetModelTemplatesTemplateTemplateDocResult'],
                 template_inputs: Sequence['outputs.GetModelTemplatesTemplateTemplateInputResult'],
                 type: _builtins.str):
        """
        :param _builtins.str arch: Architecture type. The valid values are **X86_64** and **AARCH64**.
        :param _builtins.str description: The description of the input parameter.
        :param _builtins.str engine: The AI engine.  
               The valid values are **Caffe**, **Caffe1.0 CPU**, **Caffe1.0 GPU**, **MXNet**, **MXNet1.2.1**,
               **MindSpore**, **PyTorch**, **PyTorch1.0**, **TensorFlow**, and **TensorFlow1.8**.
        :param _builtins.str environment: Model runtime environment.  
               The valid values are **ascend-arm-py2.7**, **python2.7**, and **python3.6**.
        :param _builtins.str id: The ID of the input parameter.
        :param _builtins.str name: The name of the input parameter.
        :param Sequence['GetModelTemplatesTemplateTemplateDocArgs'] template_docs: List of template description documents.  
               The template_docs structure is documented below.
        :param Sequence['GetModelTemplatesTemplateTemplateInputArgs'] template_inputs: List of input parameters for the model.
               The template_inputs structure is documented below.
        :param _builtins.str type: The type of model. The valid values are **Classification** and **Common**.
        """
        pulumi.set(__self__, "arch", arch)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "engine", engine)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_docs", template_docs)
        pulumi.set(__self__, "template_inputs", template_inputs)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def arch(self) -> _builtins.str:
        """
        Architecture type. The valid values are **X86_64** and **AARCH64**.
        """
        return pulumi.get(self, "arch")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the input parameter.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> _builtins.str:
        """
        The AI engine.  
        The valid values are **Caffe**, **Caffe1.0 CPU**, **Caffe1.0 GPU**, **MXNet**, **MXNet1.2.1**,
        **MindSpore**, **PyTorch**, **PyTorch1.0**, **TensorFlow**, and **TensorFlow1.8**.
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> _builtins.str:
        """
        Model runtime environment.  
        The valid values are **ascend-arm-py2.7**, **python2.7**, and **python3.6**.
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the input parameter.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the input parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="templateDocs")
    def template_docs(self) -> Sequence['outputs.GetModelTemplatesTemplateTemplateDocResult']:
        """
        List of template description documents.  
        The template_docs structure is documented below.
        """
        return pulumi.get(self, "template_docs")

    @_builtins.property
    @pulumi.getter(name="templateInputs")
    def template_inputs(self) -> Sequence['outputs.GetModelTemplatesTemplateTemplateInputResult']:
        """
        List of input parameters for the model.
        The template_inputs structure is documented below.
        """
        return pulumi.get(self, "template_inputs")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of model. The valid values are **Classification** and **Common**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetModelTemplatesTemplateTemplateDocResult(dict):
    def __init__(__self__, *,
                 doc_name: _builtins.str,
                 doc_url: _builtins.str):
        """
        :param _builtins.str doc_name: Document name.
        :param _builtins.str doc_url: HTTP(S) link of the document.
        """
        pulumi.set(__self__, "doc_name", doc_name)
        pulumi.set(__self__, "doc_url", doc_url)

    @_builtins.property
    @pulumi.getter(name="docName")
    def doc_name(self) -> _builtins.str:
        """
        Document name.
        """
        return pulumi.get(self, "doc_name")

    @_builtins.property
    @pulumi.getter(name="docUrl")
    def doc_url(self) -> _builtins.str:
        """
        HTTP(S) link of the document.
        """
        return pulumi.get(self, "doc_url")


@pulumi.output_type
class GetModelTemplatesTemplateTemplateInputResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The description of the input parameter.
        :param _builtins.str id: The ID of the input parameter.
        :param _builtins.str name: The name of the input parameter.
        :param _builtins.str type: The type of model. The valid values are **Classification** and **Common**.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the input parameter.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the input parameter.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the input parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of model. The valid values are **Classification** and **Common**.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetModelsModelResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 extra: _builtins.str,
                 id: _builtins.str,
                 install_types: Sequence[_builtins.str],
                 market_flag: _builtins.bool,
                 model_source: _builtins.str,
                 model_type: _builtins.str,
                 name: _builtins.str,
                 owner: _builtins.str,
                 publishable_flag: _builtins.bool,
                 size: _builtins.int,
                 source_type: _builtins.str,
                 specifications: Sequence['outputs.GetModelsModelSpecificationResult'],
                 status: _builtins.str,
                 subscription_id: _builtins.str,
                 tunable: _builtins.bool,
                 version: _builtins.str,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str description: The description of the model. Fuzzy match is supported.
        :param _builtins.str extra: Extended parameter.
        :param _builtins.str id: Model ID.
        :param Sequence[_builtins.str] install_types: Deployment types supported by the model.  
               The value can be **real-time**, **edge**, or **batch**.
        :param _builtins.bool market_flag: Whether the model is subscribed from AI Gallery.
        :param _builtins.str model_source: Model source.  
               Value options are as follows:
               + **auto**: ExeML.
               + **algos**: built-in algorithm.
               + **custom**: custom model.
        :param _builtins.str model_type: Model type, which is used for obtaining models of this type.  
               It can be **TensorFlow**, **MXNet**, **Caffe**, **Spark_MLlib**, **Scikit_Learn**,
               **XGBoost**, **Image**, **PyTorch**, or **Template**.
               Either **model_type** or **not_model_type** can be configured.
        :param _builtins.str name: Model name. Fuzzy match is supported. Set **exact_match** to **true** to use exact match.
        :param _builtins.str owner: User ID of the tenant to which the model belongs.
        :param _builtins.bool publishable_flag: Whether the model can be published to AI Gallery.
        :param _builtins.int size: Model size, in bytes.
        :param _builtins.str source_type: Model source type.  
               This parameter is valid and its value is **auto** only if the model is deployed using ExeML.
        :param Sequence['GetModelsModelSpecificationArgs'] specifications: Minimum specifications for model deployment.  
               The specification structure is documented below.
        :param _builtins.str status: Model status.  
               Value options are as follows:
               + **publishing**: The model is being published.
               + **published**: The model has been published.
               + **failed**: Publishing the model failed.
               + **building**: The image is being created.
               + **building_failed**: Creating an image failed.
        :param _builtins.str subscription_id: Model subscription ID.
        :param _builtins.bool tunable: Whether the model can be tuned.
               **true** indicates that the model can be tuned, and **false** indicates not.
        :param _builtins.str version: Model version.
        :param _builtins.str workspace_id: Workspace ID, which defaults to 0.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "extra", extra)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "install_types", install_types)
        pulumi.set(__self__, "market_flag", market_flag)
        pulumi.set(__self__, "model_source", model_source)
        pulumi.set(__self__, "model_type", model_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "publishable_flag", publishable_flag)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "specifications", specifications)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tunable", tunable)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the model. Fuzzy match is supported.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def extra(self) -> _builtins.str:
        """
        Extended parameter.
        """
        return pulumi.get(self, "extra")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Model ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="installTypes")
    def install_types(self) -> Sequence[_builtins.str]:
        """
        Deployment types supported by the model.  
        The value can be **real-time**, **edge**, or **batch**.
        """
        return pulumi.get(self, "install_types")

    @_builtins.property
    @pulumi.getter(name="marketFlag")
    def market_flag(self) -> _builtins.bool:
        """
        Whether the model is subscribed from AI Gallery.
        """
        return pulumi.get(self, "market_flag")

    @_builtins.property
    @pulumi.getter(name="modelSource")
    def model_source(self) -> _builtins.str:
        """
        Model source.  
        Value options are as follows:
        + **auto**: ExeML.
        + **algos**: built-in algorithm.
        + **custom**: custom model.
        """
        return pulumi.get(self, "model_source")

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> _builtins.str:
        """
        Model type, which is used for obtaining models of this type.  
        It can be **TensorFlow**, **MXNet**, **Caffe**, **Spark_MLlib**, **Scikit_Learn**,
        **XGBoost**, **Image**, **PyTorch**, or **Template**.
        Either **model_type** or **not_model_type** can be configured.
        """
        return pulumi.get(self, "model_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Model name. Fuzzy match is supported. Set **exact_match** to **true** to use exact match.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        User ID of the tenant to which the model belongs.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="publishableFlag")
    def publishable_flag(self) -> _builtins.bool:
        """
        Whether the model can be published to AI Gallery.
        """
        return pulumi.get(self, "publishable_flag")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        Model size, in bytes.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> _builtins.str:
        """
        Model source type.  
        This parameter is valid and its value is **auto** only if the model is deployed using ExeML.
        """
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter
    def specifications(self) -> Sequence['outputs.GetModelsModelSpecificationResult']:
        """
        Minimum specifications for model deployment.  
        The specification structure is documented below.
        """
        return pulumi.get(self, "specifications")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Model status.  
        Value options are as follows:
        + **publishing**: The model is being published.
        + **published**: The model has been published.
        + **failed**: Publishing the model failed.
        + **building**: The image is being created.
        + **building_failed**: Creating an image failed.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        Model subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter
    def tunable(self) -> _builtins.bool:
        """
        Whether the model can be tuned.
        **true** indicates that the model can be tuned, and **false** indicates not.
        """
        return pulumi.get(self, "tunable")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Model version.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID, which defaults to 0.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetModelsModelSpecificationResult(dict):
    def __init__(__self__, *,
                 min_ascend: _builtins.str,
                 min_cpu: _builtins.str,
                 min_gpu: _builtins.str,
                 min_memory: _builtins.str):
        """
        :param _builtins.str min_ascend: Minimal Ascend.
        :param _builtins.str min_cpu: Minimal CPU.
        :param _builtins.str min_gpu: Minimal GPU.
        :param _builtins.str min_memory: Minimum memory.
        """
        pulumi.set(__self__, "min_ascend", min_ascend)
        pulumi.set(__self__, "min_cpu", min_cpu)
        pulumi.set(__self__, "min_gpu", min_gpu)
        pulumi.set(__self__, "min_memory", min_memory)

    @_builtins.property
    @pulumi.getter(name="minAscend")
    def min_ascend(self) -> _builtins.str:
        """
        Minimal Ascend.
        """
        return pulumi.get(self, "min_ascend")

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> _builtins.str:
        """
        Minimal CPU.
        """
        return pulumi.get(self, "min_cpu")

    @_builtins.property
    @pulumi.getter(name="minGpu")
    def min_gpu(self) -> _builtins.str:
        """
        Minimal GPU.
        """
        return pulumi.get(self, "min_gpu")

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> _builtins.str:
        """
        Minimum memory.
        """
        return pulumi.get(self, "min_memory")


@pulumi.output_type
class GetNodePoolNodesV2NodeResult(dict):
    def __init__(__self__, *,
                 metadatas: Sequence['outputs.GetNodePoolNodesV2NodeMetadataResult'],
                 specs: Sequence['outputs.GetNodePoolNodesV2NodeSpecResult'],
                 statuses: Sequence['outputs.GetNodePoolNodesV2NodeStatusResult']):
        """
        :param Sequence['GetNodePoolNodesV2NodeMetadataArgs'] metadatas: The metadata information of the node.  
               The metadata structure is documented below.
        :param Sequence['GetNodePoolNodesV2NodeSpecArgs'] specs: The specification of the node.  
               The spec structure is documented below.
        :param Sequence['GetNodePoolNodesV2NodeStatusArgs'] statuses: The status information of the node.  
               The status structure is documented below.
        """
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "specs", specs)
        pulumi.set(__self__, "statuses", statuses)

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetNodePoolNodesV2NodeMetadataResult']:
        """
        The metadata information of the node.  
        The metadata structure is documented below.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GetNodePoolNodesV2NodeSpecResult']:
        """
        The specification of the node.  
        The spec structure is documented below.
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter
    def statuses(self) -> Sequence['outputs.GetNodePoolNodesV2NodeStatusResult']:
        """
        The status information of the node.  
        The status structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class GetNodePoolNodesV2NodeMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: _builtins.str,
                 creation_timestamp: _builtins.str,
                 labels: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str annotations: The annotation configuration of the node, in JSON format.
        :param _builtins.str creation_timestamp: The creation timestamp of the node.
        :param _builtins.str labels: The labels of the node, in JSON format.
        :param _builtins.str name: The name of the plugin.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> _builtins.str:
        """
        The annotation configuration of the node, in JSON format.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        The creation timestamp of the node.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> _builtins.str:
        """
        The labels of the node, in JSON format.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the plugin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNodePoolNodesV2NodeSpecResult(dict):
    def __init__(__self__, *,
                 extend_params: _builtins.str,
                 flavor: _builtins.str,
                 host_networks: Sequence['outputs.GetNodePoolNodesV2NodeSpecHostNetworkResult'],
                 os: Sequence['outputs.GetNodePoolNodesV2NodeSpecOResult']):
        """
        :param _builtins.str extend_params: The extend parameters of the node, in JSON format.
        :param _builtins.str flavor: The flavor of the node.
        :param Sequence['GetNodePoolNodesV2NodeSpecHostNetworkArgs'] host_networks: The network configuration of the node.  
               The host_network structure is documented below.
        :param Sequence['GetNodePoolNodesV2NodeSpecOArgs'] os: The OS information of the kubernetes node.  
               The os structure is documented below.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "host_networks", host_networks)
        pulumi.set(__self__, "os", os)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the node, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        The flavor of the node.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="hostNetworks")
    def host_networks(self) -> Sequence['outputs.GetNodePoolNodesV2NodeSpecHostNetworkResult']:
        """
        The network configuration of the node.  
        The host_network structure is documented below.
        """
        return pulumi.get(self, "host_networks")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Sequence['outputs.GetNodePoolNodesV2NodeSpecOResult']:
        """
        The OS information of the kubernetes node.  
        The os structure is documented below.
        """
        return pulumi.get(self, "os")


@pulumi.output_type
class GetNodePoolNodesV2NodeSpecHostNetworkResult(dict):
    def __init__(__self__, *,
                 security_groups: Sequence[_builtins.str],
                 subnet: _builtins.str,
                 vpc: _builtins.str):
        """
        :param Sequence[_builtins.str] security_groups: The security group IDs that the node used.
        :param _builtins.str subnet: The subnet ID to which the node belongs.
        :param _builtins.str vpc: The VPC ID to which the node belongs.
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        """
        The security group IDs that the node used.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The subnet ID to which the node belongs.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        """
        The VPC ID to which the node belongs.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class GetNodePoolNodesV2NodeSpecOResult(dict):
    def __init__(__self__, *,
                 image_id: _builtins.str,
                 image_type: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str image_id: The image ID of the OS.
        :param _builtins.str image_type: The image type of the OS.
        :param _builtins.str name: The name of the plugin.
        """
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The image ID of the OS.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> _builtins.str:
        """
        The image type of the OS.
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the plugin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNodePoolNodesV2NodeStatusResult(dict):
    def __init__(__self__, *,
                 available_resources: _builtins.str,
                 az: _builtins.str,
                 drivers: Sequence['outputs.GetNodePoolNodesV2NodeStatusDriverResult'],
                 os: Sequence['outputs.GetNodePoolNodesV2NodeStatusOResult'],
                 phase: _builtins.str,
                 plugins: Sequence['outputs.GetNodePoolNodesV2NodeStatusPluginResult'],
                 private_ip: _builtins.str,
                 resources: _builtins.str):
        """
        :param _builtins.str available_resources: The available resource detail of the node, in JSON format.
        :param _builtins.str az: The availability zone where the node is located.
        :param Sequence['GetNodePoolNodesV2NodeStatusDriverArgs'] drivers: The driver configuration of the node.  
               The driver structure is documented below.
        :param Sequence['GetNodePoolNodesV2NodeStatusOArgs'] os: The OS information of the kubernetes node.  
               The os structure is documented below.
        :param _builtins.str phase: The current phase of the plugin.
        :param Sequence['GetNodePoolNodesV2NodeStatusPluginArgs'] plugins: The plugin configuration of the node.  
               The plugins structure is documented above.
        :param _builtins.str private_ip: The private IP address of the node.
        :param _builtins.str resources: The resource detail of the node, in JSON format.
        """
        pulumi.set(__self__, "available_resources", available_resources)
        pulumi.set(__self__, "az", az)
        pulumi.set(__self__, "drivers", drivers)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "plugins", plugins)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter(name="availableResources")
    def available_resources(self) -> _builtins.str:
        """
        The available resource detail of the node, in JSON format.
        """
        return pulumi.get(self, "available_resources")

    @_builtins.property
    @pulumi.getter
    def az(self) -> _builtins.str:
        """
        The availability zone where the node is located.
        """
        return pulumi.get(self, "az")

    @_builtins.property
    @pulumi.getter
    def drivers(self) -> Sequence['outputs.GetNodePoolNodesV2NodeStatusDriverResult']:
        """
        The driver configuration of the node.  
        The driver structure is documented below.
        """
        return pulumi.get(self, "drivers")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Sequence['outputs.GetNodePoolNodesV2NodeStatusOResult']:
        """
        The OS information of the kubernetes node.  
        The os structure is documented below.
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        The current phase of the plugin.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def plugins(self) -> Sequence['outputs.GetNodePoolNodesV2NodeStatusPluginResult']:
        """
        The plugin configuration of the node.  
        The plugins structure is documented above.
        """
        return pulumi.get(self, "plugins")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> _builtins.str:
        """
        The private IP address of the node.
        """
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> _builtins.str:
        """
        The resource detail of the node, in JSON format.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetNodePoolNodesV2NodeStatusDriverResult(dict):
    def __init__(__self__, *,
                 phase: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str phase: The current phase of the plugin.
        :param _builtins.str version: The version of the plugin.
        """
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        The current phase of the plugin.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the plugin.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetNodePoolNodesV2NodeStatusOResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the plugin.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the plugin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNodePoolNodesV2NodeStatusPluginResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 phase: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: The name of the plugin.
        :param _builtins.str phase: The current phase of the plugin.
        :param _builtins.str version: The version of the plugin.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the plugin.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        The current phase of the plugin.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the plugin.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetNotebookFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch: _builtins.str,
                 billings: Sequence['outputs.GetNotebookFlavorsFlavorBillingResult'],
                 category: _builtins.str,
                 description: _builtins.str,
                 feature: _builtins.str,
                 free: _builtins.bool,
                 gpus: Sequence['outputs.GetNotebookFlavorsFlavorGpusResult'],
                 id: _builtins.str,
                 memory: _builtins.int,
                 name: _builtins.str,
                 sold_out: _builtins.bool,
                 vcpus: _builtins.int):
        """
        :param _builtins.str arch: Architecture type. The valid values are **X86_64** and **AARCH64**.
        :param Sequence['GetNotebookFlavorsFlavorBillingArgs'] billings: Billing information.
               The billing structure is documented below.
        :param _builtins.str category: Processor type. The valid values are: **CPU**, **GPU**, **ASCEND**.
        :param _builtins.str description: Specification description.
        :param _builtins.str feature: Flavor type.  
               The options are as follows:
               - **DEFAULT**: CodeLab.
               - **NOTEBOOK**: notebook.
        :param _builtins.bool free: Free flavor or not.
        :param Sequence['GetNotebookFlavorsFlavorGpusArgs'] gpus: Number of GPUs.
        :param _builtins.str id: The ID of the flavor.
        :param _builtins.int memory: Memory size, in KB.
        :param _builtins.str name: The name of the flavor.
        :param _builtins.bool sold_out: Whether resources are sold out.
        :param _builtins.int vcpus: Number of vCPUs.
        """
        pulumi.set(__self__, "arch", arch)
        pulumi.set(__self__, "billings", billings)
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "feature", feature)
        pulumi.set(__self__, "free", free)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sold_out", sold_out)
        pulumi.set(__self__, "vcpus", vcpus)

    @_builtins.property
    @pulumi.getter
    def arch(self) -> _builtins.str:
        """
        Architecture type. The valid values are **X86_64** and **AARCH64**.
        """
        return pulumi.get(self, "arch")

    @_builtins.property
    @pulumi.getter
    def billings(self) -> Sequence['outputs.GetNotebookFlavorsFlavorBillingResult']:
        """
        Billing information.
        The billing structure is documented below.
        """
        return pulumi.get(self, "billings")

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        Processor type. The valid values are: **CPU**, **GPU**, **ASCEND**.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Specification description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def feature(self) -> _builtins.str:
        """
        Flavor type.  
        The options are as follows:
        - **DEFAULT**: CodeLab.
        - **NOTEBOOK**: notebook.
        """
        return pulumi.get(self, "feature")

    @_builtins.property
    @pulumi.getter
    def free(self) -> _builtins.bool:
        """
        Free flavor or not.
        """
        return pulumi.get(self, "free")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> Sequence['outputs.GetNotebookFlavorsFlavorGpusResult']:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "gpus")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the flavor.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        Memory size, in KB.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the flavor.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="soldOut")
    def sold_out(self) -> _builtins.bool:
        """
        Whether resources are sold out.
        """
        return pulumi.get(self, "sold_out")

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> _builtins.int:
        """
        Number of vCPUs.
        """
        return pulumi.get(self, "vcpus")


@pulumi.output_type
class GetNotebookFlavorsFlavorBillingResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 unit_num: _builtins.int):
        """
        :param _builtins.str code: Billing code.
        :param _builtins.int unit_num: Billing unit.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "unit_num", unit_num)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Billing code.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="unitNum")
    def unit_num(self) -> _builtins.int:
        """
        Billing unit.
        """
        return pulumi.get(self, "unit_num")


@pulumi.output_type
class GetNotebookFlavorsFlavorGpusResult(dict):
    def __init__(__self__, *,
                 gpu: _builtins.int,
                 gpu_memory: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int gpu: Number of GPUs.
        :param _builtins.str gpu_memory: GPU memory, in GB.
        :param _builtins.str type: Cluster type.  
               The options are as follows:
               - **MANAGED**: Public cluster.
               - **DEDICATED**: Dedicated cluster.
        """
        pulumi.set(__self__, "gpu", gpu)
        pulumi.set(__self__, "gpu_memory", gpu_memory)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> _builtins.int:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "gpu")

    @_builtins.property
    @pulumi.getter(name="gpuMemory")
    def gpu_memory(self) -> _builtins.str:
        """
        GPU memory, in GB.
        """
        return pulumi.get(self, "gpu_memory")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Cluster type.  
        The options are as follows:
        - **MANAGED**: Public cluster.
        - **DEDICATED**: Dedicated cluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNotebookImagesImageResult(dict):
    def __init__(__self__, *,
                 cpu_arch: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 swr_path: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str cpu_arch: Specifies the CPU architecture of image. The value can be **x86_64** and **aarch64**.
        :param _builtins.str description: The description of the image.
        :param _builtins.str id: The ID of the image.
        :param _builtins.str name: Specifies the name of image.
        :param _builtins.str swr_path: The path the image in HuaweiCloud SWR service (SoftWare Repository for Container).
        :param _builtins.str type: Specifies the type of image. The options are:
               + `BUILD_IN`: The system built-in image.
               + `DEDICATED`: User-saved images.
               
               The default value is `BUILD_IN`.
        """
        pulumi.set(__self__, "cpu_arch", cpu_arch)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "swr_path", swr_path)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cpuArch")
    def cpu_arch(self) -> _builtins.str:
        """
        Specifies the CPU architecture of image. The value can be **x86_64** and **aarch64**.
        """
        return pulumi.get(self, "cpu_arch")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the image.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the image.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of image.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="swrPath")
    def swr_path(self) -> _builtins.str:
        """
        The path the image in HuaweiCloud SWR service (SoftWare Repository for Container).
        """
        return pulumi.get(self, "swr_path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of image. The options are:
        + `BUILD_IN`: The system built-in image.
        + `DEDICATED`: User-saved images.

        The default value is `BUILD_IN`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourceFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 arch: _builtins.str,
                 az_status: Mapping[str, _builtins.str],
                 billing_modes: Sequence[_builtins.int],
                 cpu: _builtins.str,
                 gpus: Sequence['outputs.GetResourceFlavorsFlavorGpusResult'],
                 id: _builtins.str,
                 job_flavors: Sequence[_builtins.str],
                 memory: _builtins.str,
                 npus: Sequence['outputs.GetResourceFlavorsFlavorNpusResult'],
                 tags: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 volumes: Sequence['outputs.GetResourceFlavorsFlavorVolumeResult']):
        """
        :param _builtins.str arch: Computer architecture.  
               The value can be **x86** or **arm64**.
        :param Mapping[str, _builtins.str] az_status: Sales status of a resource specification in each AZ. The value is (AZ, Status).  
               Status options are as follows:
               + **normal**: on-sales.
               + **soldout**: sold out.
        :param Sequence[_builtins.int] billing_modes: Billing mode supported by the flavor.  
               Value options are as follows:
               + **0**: pay-per-use.
               + **1**: yearly/monthly.
        :param _builtins.str cpu: Number of CPU cores.
        :param Sequence['GetResourceFlavorsFlavorGpusArgs'] gpus: GPU information.
               The gpu structure is documented below.
        :param _builtins.str id: Flavor ID.
        :param Sequence[_builtins.str] job_flavors: Training job types supported by the resource flavor.
        :param _builtins.str memory: Memory size in GiB.
        :param Sequence['GetResourceFlavorsFlavorNpusArgs'] npus: NPU information.
               The npu structure is documented below.
        :param Mapping[str, _builtins.str] tags: The key/value pairs to associate with the flavor.
        :param _builtins.str type: The type of resource flavor.  
               Value options are as follows:
               + **Dedicate**: physical resources.
               + **Logical**: logical resources.
        :param Sequence['GetResourceFlavorsFlavorVolumeArgs'] volumes: The list of data disk information.
               The volume structure is documented below.
        """
        pulumi.set(__self__, "arch", arch)
        pulumi.set(__self__, "az_status", az_status)
        pulumi.set(__self__, "billing_modes", billing_modes)
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "gpus", gpus)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_flavors", job_flavors)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "npus", npus)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def arch(self) -> _builtins.str:
        """
        Computer architecture.  
        The value can be **x86** or **arm64**.
        """
        return pulumi.get(self, "arch")

    @_builtins.property
    @pulumi.getter(name="azStatus")
    def az_status(self) -> Mapping[str, _builtins.str]:
        """
        Sales status of a resource specification in each AZ. The value is (AZ, Status).  
        Status options are as follows:
        + **normal**: on-sales.
        + **soldout**: sold out.
        """
        return pulumi.get(self, "az_status")

    @_builtins.property
    @pulumi.getter(name="billingModes")
    def billing_modes(self) -> Sequence[_builtins.int]:
        """
        Billing mode supported by the flavor.  
        Value options are as follows:
        + **0**: pay-per-use.
        + **1**: yearly/monthly.
        """
        return pulumi.get(self, "billing_modes")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        """
        Number of CPU cores.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def gpus(self) -> Sequence['outputs.GetResourceFlavorsFlavorGpusResult']:
        """
        GPU information.
        The gpu structure is documented below.
        """
        return pulumi.get(self, "gpus")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Flavor ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="jobFlavors")
    def job_flavors(self) -> Sequence[_builtins.str]:
        """
        Training job types supported by the resource flavor.
        """
        return pulumi.get(self, "job_flavors")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        """
        Memory size in GiB.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def npus(self) -> Sequence['outputs.GetResourceFlavorsFlavorNpusResult']:
        """
        NPU information.
        The npu structure is documented below.
        """
        return pulumi.get(self, "npus")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to associate with the flavor.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of resource flavor.  
        Value options are as follows:
        + **Dedicate**: physical resources.
        + **Logical**: logical resources.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Sequence['outputs.GetResourceFlavorsFlavorVolumeResult']:
        """
        The list of data disk information.
        The volume structure is documented below.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetResourceFlavorsFlavorGpusResult(dict):
    def __init__(__self__, *,
                 size: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str size: Disk size, in GiB.
        :param _builtins.str type: The type of resource flavor.  
               Value options are as follows:
               + **Dedicate**: physical resources.
               + **Logical**: logical resources.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Disk size, in GiB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of resource flavor.  
        Value options are as follows:
        + **Dedicate**: physical resources.
        + **Logical**: logical resources.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourceFlavorsFlavorNpusResult(dict):
    def __init__(__self__, *,
                 size: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str size: Disk size, in GiB.
        :param _builtins.str type: The type of resource flavor.  
               Value options are as follows:
               + **Dedicate**: physical resources.
               + **Logical**: logical resources.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Disk size, in GiB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of resource flavor.  
        Value options are as follows:
        + **Dedicate**: physical resources.
        + **Logical**: logical resources.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourceFlavorsFlavorVolumeResult(dict):
    def __init__(__self__, *,
                 size: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str size: Disk size, in GiB.
        :param _builtins.str type: The type of resource flavor.  
               Value options are as follows:
               + **Dedicate**: physical resources.
               + **Logical**: logical resources.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Disk size, in GiB.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of resource flavor.  
        Value options are as follows:
        + **Dedicate**: physical resources.
        + **Logical**: logical resources.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourcePoolNodesV2NodeResult(dict):
    def __init__(__self__, *,
                 metadatas: Sequence['outputs.GetResourcePoolNodesV2NodeMetadataResult'],
                 specs: Sequence['outputs.GetResourcePoolNodesV2NodeSpecResult'],
                 statuses: Sequence['outputs.GetResourcePoolNodesV2NodeStatusResult']):
        """
        :param Sequence['GetResourcePoolNodesV2NodeMetadataArgs'] metadatas: The metadata information of the node.  
               The metadata structure is documented below.
        :param Sequence['GetResourcePoolNodesV2NodeSpecArgs'] specs: The specification of the node.  
               The spec structure is documented below.
        :param Sequence['GetResourcePoolNodesV2NodeStatusArgs'] statuses: The status information of the node.  
               The status structure is documented below.
        """
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "specs", specs)
        pulumi.set(__self__, "statuses", statuses)

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeMetadataResult']:
        """
        The metadata information of the node.  
        The metadata structure is documented below.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeSpecResult']:
        """
        The specification of the node.  
        The spec structure is documented below.
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter
    def statuses(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeStatusResult']:
        """
        The status information of the node.  
        The status structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class GetResourcePoolNodesV2NodeMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: _builtins.str,
                 creation_timestamp: _builtins.str,
                 labels: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str annotations: The annotation configuration of the node, in JSON format.
        :param _builtins.str creation_timestamp: The creation timestamp of the node.
        :param _builtins.str labels: The labels of the node, in JSON format.
        :param _builtins.str name: The name of the plugin.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> _builtins.str:
        """
        The annotation configuration of the node, in JSON format.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> _builtins.str:
        """
        The creation timestamp of the node.
        """
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> _builtins.str:
        """
        The labels of the node, in JSON format.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the plugin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoolNodesV2NodeSpecResult(dict):
    def __init__(__self__, *,
                 extend_params: _builtins.str,
                 flavor: _builtins.str,
                 host_networks: Sequence['outputs.GetResourcePoolNodesV2NodeSpecHostNetworkResult'],
                 os: Sequence['outputs.GetResourcePoolNodesV2NodeSpecOResult']):
        """
        :param _builtins.str extend_params: The extend parameters of the node, in JSON format.
        :param _builtins.str flavor: The flavor of the node.
        :param Sequence['GetResourcePoolNodesV2NodeSpecHostNetworkArgs'] host_networks: The network configuration of the node.  
               The host_network structure is documented below.
        :param Sequence['GetResourcePoolNodesV2NodeSpecOArgs'] os: The OS information of the kubernetes node.  
               The os structure is documented below.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "host_networks", host_networks)
        pulumi.set(__self__, "os", os)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the node, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        The flavor of the node.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter(name="hostNetworks")
    def host_networks(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeSpecHostNetworkResult']:
        """
        The network configuration of the node.  
        The host_network structure is documented below.
        """
        return pulumi.get(self, "host_networks")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeSpecOResult']:
        """
        The OS information of the kubernetes node.  
        The os structure is documented below.
        """
        return pulumi.get(self, "os")


@pulumi.output_type
class GetResourcePoolNodesV2NodeSpecHostNetworkResult(dict):
    def __init__(__self__, *,
                 subnet: _builtins.str,
                 vpc: _builtins.str):
        """
        :param _builtins.str subnet: The subnet ID to which the node belongs.
        :param _builtins.str vpc: The VPC ID to which the node belongs.
        """
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The subnet ID to which the node belongs.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        """
        The VPC ID to which the node belongs.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class GetResourcePoolNodesV2NodeSpecOResult(dict):
    def __init__(__self__, *,
                 image_id: _builtins.str):
        """
        :param _builtins.str image_id: The image ID of the OS.
        """
        pulumi.set(__self__, "image_id", image_id)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The image ID of the OS.
        """
        return pulumi.get(self, "image_id")


@pulumi.output_type
class GetResourcePoolNodesV2NodeStatusResult(dict):
    def __init__(__self__, *,
                 available_resources: _builtins.str,
                 az: _builtins.str,
                 drivers: Sequence['outputs.GetResourcePoolNodesV2NodeStatusDriverResult'],
                 os: Sequence['outputs.GetResourcePoolNodesV2NodeStatusOResult'],
                 phase: _builtins.str,
                 plugins: Sequence['outputs.GetResourcePoolNodesV2NodeStatusPluginResult'],
                 private_ip: _builtins.str,
                 resources: _builtins.str):
        """
        :param _builtins.str available_resources: The available resource detail of the node, in JSON format.
        :param _builtins.str az: The availability zone where the node is located.
        :param Sequence['GetResourcePoolNodesV2NodeStatusDriverArgs'] drivers: The driver configuration of the node.  
               The driver structure is documented below.
        :param Sequence['GetResourcePoolNodesV2NodeStatusOArgs'] os: The OS information of the kubernetes node.  
               The os structure is documented below.
        :param _builtins.str phase: The current phase of the plugin.
        :param Sequence['GetResourcePoolNodesV2NodeStatusPluginArgs'] plugins: The plugin configuration of the node.  
               The plugins structure is documented above.
        :param _builtins.str private_ip: The private IP address of the node.
        :param _builtins.str resources: The resource detail of the node, in JSON format.
        """
        pulumi.set(__self__, "available_resources", available_resources)
        pulumi.set(__self__, "az", az)
        pulumi.set(__self__, "drivers", drivers)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "plugins", plugins)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter(name="availableResources")
    def available_resources(self) -> _builtins.str:
        """
        The available resource detail of the node, in JSON format.
        """
        return pulumi.get(self, "available_resources")

    @_builtins.property
    @pulumi.getter
    def az(self) -> _builtins.str:
        """
        The availability zone where the node is located.
        """
        return pulumi.get(self, "az")

    @_builtins.property
    @pulumi.getter
    def drivers(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeStatusDriverResult']:
        """
        The driver configuration of the node.  
        The driver structure is documented below.
        """
        return pulumi.get(self, "drivers")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeStatusOResult']:
        """
        The OS information of the kubernetes node.  
        The os structure is documented below.
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        The current phase of the plugin.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def plugins(self) -> Sequence['outputs.GetResourcePoolNodesV2NodeStatusPluginResult']:
        """
        The plugin configuration of the node.  
        The plugins structure is documented above.
        """
        return pulumi.get(self, "plugins")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> _builtins.str:
        """
        The private IP address of the node.
        """
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> _builtins.str:
        """
        The resource detail of the node, in JSON format.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetResourcePoolNodesV2NodeStatusDriverResult(dict):
    def __init__(__self__, *,
                 phase: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str phase: The current phase of the plugin.
        :param _builtins.str version: The version of the plugin.
        """
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        The current phase of the plugin.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the plugin.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetResourcePoolNodesV2NodeStatusOResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the plugin.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the plugin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoolNodesV2NodeStatusPluginResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 phase: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str name: The name of the plugin.
        :param _builtins.str phase: The current phase of the plugin.
        :param _builtins.str version: The version of the plugin.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the plugin.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> _builtins.str:
        """
        The current phase of the plugin.
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the plugin.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResult(dict):
    def __init__(__self__, *,
                 charging_mode: _builtins.str,
                 clusters: Sequence['outputs.GetResourcePoolsV2ResourcePoolClusterResult'],
                 description: _builtins.str,
                 metadatas: Sequence['outputs.GetResourcePoolsV2ResourcePoolMetadataResult'],
                 name: _builtins.str,
                 network_id: _builtins.str,
                 prefix: _builtins.str,
                 resource_pool_id: _builtins.str,
                 resources: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceResult'],
                 scopes: Sequence[_builtins.str],
                 specs: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResult'],
                 status: _builtins.str,
                 subnet_id: _builtins.str,
                 user_logins: Sequence['outputs.GetResourcePoolsV2ResourcePoolUserLoginResult'],
                 vpc_id: _builtins.str,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str charging_mode: The charging mode of the resource pool.
        :param Sequence['GetResourcePoolsV2ResourcePoolClusterArgs'] clusters: The cluster information of the privileged pool.  
               The clusters structure is documented below.
        :param _builtins.str description: The description of the resource pool.
        :param Sequence['GetResourcePoolsV2ResourcePoolMetadataArgs'] metadatas: The metadata configuration of the resource pool.  
               The metadata structure is documented below.
        :param _builtins.str name: The OS name of the image.
        :param _builtins.str network_id: The ModelArts network ID of the resource pool.
        :param _builtins.str prefix: The prefix of the user-defined node name of the resource pool.
        :param _builtins.str resource_pool_id: The resource ID of the resource pool.
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceArgs'] resources: The list of resource specifications in the resource pool.  
               The resources structure is documented below.
        :param Sequence[_builtins.str] scopes: The list of job types supported by the resource pool.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecArgs'] specs: The specification of the resource pool.  
               The spec structure is documented below.
        :param _builtins.str status: Specifies the status of the resource pool to be queried.  
               The valid values are as follows:
               + **created**
               + **failed**
               + **creating**
        :param _builtins.str subnet_id: The ID of the subnet.
        :param Sequence['GetResourcePoolsV2ResourcePoolUserLoginArgs'] user_logins: The user login information of the privileged pool.  
               The user_login structure is documented below.
        :param _builtins.str vpc_id: The ID of the VPC.
        :param _builtins.str workspace_id: Specifies the workspace ID to which the resource pool belongs.
        """
        pulumi.set(__self__, "charging_mode", charging_mode)
        pulumi.set(__self__, "clusters", clusters)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "resource_pool_id", resource_pool_id)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "specs", specs)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "user_logins", user_logins)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> _builtins.str:
        """
        The charging mode of the resource pool.
        """
        return pulumi.get(self, "charging_mode")

    @_builtins.property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolClusterResult']:
        """
        The cluster information of the privileged pool.  
        The clusters structure is documented below.
        """
        return pulumi.get(self, "clusters")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the resource pool.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolMetadataResult']:
        """
        The metadata configuration of the resource pool.  
        The metadata structure is documented below.
        """
        return pulumi.get(self, "metadatas")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The OS name of the image.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> _builtins.str:
        """
        The ModelArts network ID of the resource pool.
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        The prefix of the user-defined node name of the resource pool.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="resourcePoolId")
    def resource_pool_id(self) -> _builtins.str:
        """
        The resource ID of the resource pool.
        """
        return pulumi.get(self, "resource_pool_id")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceResult']:
        """
        The list of resource specifications in the resource pool.  
        The resources structure is documented below.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        The list of job types supported by the resource pool.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResult']:
        """
        The specification of the resource pool.  
        The spec structure is documented below.
        """
        return pulumi.get(self, "specs")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Specifies the status of the resource pool to be queried.  
        The valid values are as follows:
        + **created**
        + **failed**
        + **creating**
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="userLogins")
    def user_logins(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolUserLoginResult']:
        """
        The user login information of the privileged pool.  
        The user_login structure is documented below.
        """
        return pulumi.get(self, "user_logins")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Specifies the workspace ID to which the resource pool belongs.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolClusterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 provider_id: _builtins.str):
        """
        :param _builtins.str name: The OS name of the image.
        :param _builtins.str provider_id: The provider ID of the cluster.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_id", provider_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The OS name of the image.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> _builtins.str:
        """
        The provider ID of the cluster.
        """
        return pulumi.get(self, "provider_id")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, _builtins.str],
                 created_at: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str):
        """
        :param Mapping[str, _builtins.str] annotations: The annotations of the resource pool.
        :param _builtins.str created_at: The creation time of the resource pool, in RFC3339 format.
        :param Mapping[str, _builtins.str] labels: The key/value pairs labels of resource pool.
        :param _builtins.str name: The OS name of the image.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        The annotations of the resource pool.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time of the resource pool, in RFC3339 format.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs labels of resource pool.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The OS name of the image.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceResult(dict):
    def __init__(__self__, *,
                 azs: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceAzResult'],
                 count: _builtins.int,
                 creating_steps: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceCreatingStepResult'],
                 data_volumes: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceDataVolumeResult'],
                 extend_params: _builtins.str,
                 flavor_id: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 max_count: _builtins.int,
                 node_pool: _builtins.str,
                 root_volumes: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceRootVolumeResult'],
                 security_group_ids: Sequence[_builtins.str],
                 subnet_id: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 taints: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceTaintResult'],
                 volume_group_configs: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigResult'],
                 vpc_id: _builtins.str):
        """
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceAzArgs'] azs: The AZ list of the resource pool nodes.  
               The azs structure is documented below.
        :param _builtins.int count: The number of nodes in the AZ.
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceCreatingStepArgs'] creating_steps: The creation step configuration of the resource pool nodes.  
               The creating_step structure is documented below.
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceDataVolumeArgs'] data_volumes: The data volumes of the resource pool nodes.  
               The data_volumes structure is documented below.
        :param _builtins.str extend_params: The extend parameters of the data volume, in JSON format.
        :param _builtins.str flavor_id: The resource flavor ID.
        :param Mapping[str, _builtins.str] labels: The key/value pairs labels of resource pool.
        :param _builtins.int max_count: The max number of resources of the corresponding flavors.
        :param _builtins.str node_pool: The name of resource pool nodes.
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceRootVolumeArgs'] root_volumes: The root volume of the resource pool nodes.  
               The root_volume structure is documented below.
        :param Sequence[_builtins.str] security_group_ids: The security group IDs to which the the resource pool nodes belong.
        :param _builtins.str subnet_id: The ID of the subnet.
        :param Mapping[str, _builtins.str] tags: The key/value pairs to associate with the resource pool nodes.
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceTaintArgs'] taints: The taint list of the resource pool.  
               The taints structure is documented below.
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigArgs'] volume_group_configs: The extend configurations of the volume groups.  
               The volume_group_configs structure is documented below.
        :param _builtins.str vpc_id: The ID of the VPC.
        """
        pulumi.set(__self__, "azs", azs)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "creating_steps", creating_steps)
        pulumi.set(__self__, "data_volumes", data_volumes)
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "flavor_id", flavor_id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "max_count", max_count)
        pulumi.set(__self__, "node_pool", node_pool)
        pulumi.set(__self__, "root_volumes", root_volumes)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "volume_group_configs", volume_group_configs)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def azs(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceAzResult']:
        """
        The AZ list of the resource pool nodes.  
        The azs structure is documented below.
        """
        return pulumi.get(self, "azs")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of nodes in the AZ.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="creatingSteps")
    def creating_steps(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceCreatingStepResult']:
        """
        The creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.
        """
        return pulumi.get(self, "creating_steps")

    @_builtins.property
    @pulumi.getter(name="dataVolumes")
    def data_volumes(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceDataVolumeResult']:
        """
        The data volumes of the resource pool nodes.  
        The data_volumes structure is documented below.
        """
        return pulumi.get(self, "data_volumes")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the data volume, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> _builtins.str:
        """
        The resource flavor ID.
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs labels of resource pool.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> _builtins.int:
        """
        The max number of resources of the corresponding flavors.
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> _builtins.str:
        """
        The name of resource pool nodes.
        """
        return pulumi.get(self, "node_pool")

    @_builtins.property
    @pulumi.getter(name="rootVolumes")
    def root_volumes(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceRootVolumeResult']:
        """
        The root volume of the resource pool nodes.  
        The root_volume structure is documented below.
        """
        return pulumi.get(self, "root_volumes")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[_builtins.str]:
        """
        The security group IDs to which the the resource pool nodes belong.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to associate with the resource pool nodes.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceTaintResult']:
        """
        The taint list of the resource pool.  
        The taints structure is documented below.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="volumeGroupConfigs")
    def volume_group_configs(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigResult']:
        """
        The extend configurations of the volume groups.  
        The volume_group_configs structure is documented below.
        """
        return pulumi.get(self, "volume_group_configs")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceAzResult(dict):
    def __init__(__self__, *,
                 az: _builtins.str,
                 count: _builtins.int):
        """
        :param _builtins.str az: The AZ name
        :param _builtins.int count: The number of nodes in the AZ.
        """
        pulumi.set(__self__, "az", az)
        pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def az(self) -> _builtins.str:
        """
        The AZ name
        """
        return pulumi.get(self, "az")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of nodes in the AZ.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceCreatingStepResult(dict):
    def __init__(__self__, *,
                 step: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int step: The creation step of the resource pool nodes.
        :param _builtins.str type: The type of the resource pool nodes.
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        The creation step of the resource pool nodes.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource pool nodes.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceDataVolumeResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 extend_params: _builtins.str,
                 size: _builtins.str,
                 volume_type: _builtins.str):
        """
        :param _builtins.int count: The number of nodes in the AZ.
        :param _builtins.str extend_params: The extend parameters of the data volume, in JSON format.
        :param _builtins.str size: The size of the data volume.
        :param _builtins.str volume_type: The type of the data volume.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of nodes in the AZ.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the data volume, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The size of the data volume.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        The type of the data volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceRootVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: _builtins.str,
                 size: _builtins.str,
                 volume_type: _builtins.str):
        """
        :param _builtins.str extend_params: The extend parameters of the data volume, in JSON format.
        :param _builtins.str size: The size of the data volume.
        :param _builtins.str volume_type: The type of the data volume.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the data volume, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The size of the data volume.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        The type of the data volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceTaintResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: The effect of the taint.
        :param _builtins.str key: The key of the taint.
        :param _builtins.str value: The value of the taint.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        The effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigResult(dict):
    def __init__(__self__, *,
                 docker_thin_pool: _builtins.int,
                 lvm_configs: Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigLvmConfigResult'],
                 types: Sequence[_builtins.str],
                 volume_group: _builtins.str):
        """
        :param _builtins.int docker_thin_pool: The percentage of container volumes to data volumes on resource pool nodes.
        :param Sequence['GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigLvmConfigArgs'] lvm_configs: The configuration of the LVM management.  
               The lvm_config structure is documented below.
        :param Sequence[_builtins.str] types: The storage types of the volume group.
        :param _builtins.str volume_group: The name of the volume group.
        """
        pulumi.set(__self__, "docker_thin_pool", docker_thin_pool)
        pulumi.set(__self__, "lvm_configs", lvm_configs)
        pulumi.set(__self__, "types", types)
        pulumi.set(__self__, "volume_group", volume_group)

    @_builtins.property
    @pulumi.getter(name="dockerThinPool")
    def docker_thin_pool(self) -> _builtins.int:
        """
        The percentage of container volumes to data volumes on resource pool nodes.
        """
        return pulumi.get(self, "docker_thin_pool")

    @_builtins.property
    @pulumi.getter(name="lvmConfigs")
    def lvm_configs(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigLvmConfigResult']:
        """
        The configuration of the LVM management.  
        The lvm_config structure is documented below.
        """
        return pulumi.get(self, "lvm_configs")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Sequence[_builtins.str]:
        """
        The storage types of the volume group.
        """
        return pulumi.get(self, "types")

    @_builtins.property
    @pulumi.getter(name="volumeGroup")
    def volume_group(self) -> _builtins.str:
        """
        The name of the volume group.
        """
        return pulumi.get(self, "volume_group")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolResourceVolumeGroupConfigLvmConfigResult(dict):
    def __init__(__self__, *,
                 lv_type: _builtins.str,
                 path: _builtins.str):
        """
        :param _builtins.str lv_type: The LVM write mode.
        :param _builtins.str path: The volume mount path.
        """
        pulumi.set(__self__, "lv_type", lv_type)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="lvType")
    def lv_type(self) -> _builtins.str:
        """
        The LVM write mode.
        """
        return pulumi.get(self, "lv_type")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The volume mount path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResult(dict):
    def __init__(__self__, *,
                 clusters: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecClusterResult'],
                 networks: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecNetworkResult'],
                 resources: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceResult'],
                 scopes: Sequence[_builtins.str],
                 user_logins: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecUserLoginResult']):
        """
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecClusterArgs'] clusters: The cluster information of the privileged pool.  
               The clusters structure is documented below.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecNetworkArgs'] networks: The network of the privileged pool.  
               The network structure is documented below.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceArgs'] resources: The list of resource specifications in the resource pool.  
               The resources structure is documented below.
        :param Sequence[_builtins.str] scopes: The list of job types supported by the resource pool.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecUserLoginArgs'] user_logins: The user login information of the privileged pool.  
               The user_login structure is documented below.
        """
        pulumi.set(__self__, "clusters", clusters)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "user_logins", user_logins)

    @_builtins.property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecClusterResult']:
        """
        The cluster information of the privileged pool.  
        The clusters structure is documented below.
        """
        return pulumi.get(self, "clusters")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecNetworkResult']:
        """
        The network of the privileged pool.  
        The network structure is documented below.
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceResult']:
        """
        The list of resource specifications in the resource pool.  
        The resources structure is documented below.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        """
        The list of job types supported by the resource pool.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="userLogins")
    def user_logins(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecUserLoginResult']:
        """
        The user login information of the privileged pool.  
        The user_login structure is documented below.
        """
        return pulumi.get(self, "user_logins")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecClusterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 provider_id: _builtins.str):
        """
        :param _builtins.str name: The OS name of the image.
        :param _builtins.str provider_id: The provider ID of the cluster.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider_id", provider_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The OS name of the image.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> _builtins.str:
        """
        The provider ID of the cluster.
        """
        return pulumi.get(self, "provider_id")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecNetworkResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str name: The OS name of the image.
        :param _builtins.str subnet_id: The ID of the subnet.
        :param _builtins.str vpc_id: The ID of the VPC.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The OS name of the image.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceResult(dict):
    def __init__(__self__, *,
                 azs: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceAzResult'],
                 count: _builtins.int,
                 creating_steps: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceCreatingStepResult'],
                 data_volumes: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceDataVolumeResult'],
                 extend_params: _builtins.str,
                 flavor: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 max_count: _builtins.int,
                 networks: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceNetworkResult'],
                 node_pool: _builtins.str,
                 os: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceOResult'],
                 root_volumes: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceRootVolumeResult'],
                 tags: Mapping[str, _builtins.str],
                 taints: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceTaintResult'],
                 volume_group_configs: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigResult']):
        """
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceAzArgs'] azs: The AZ list of the resource pool nodes.  
               The azs structure is documented below.
        :param _builtins.int count: The number of nodes in the AZ.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceCreatingStepArgs'] creating_steps: The creation step configuration of the resource pool nodes.  
               The creating_step structure is documented below.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceDataVolumeArgs'] data_volumes: The data volumes of the resource pool nodes.  
               The data_volumes structure is documented below.
        :param _builtins.str extend_params: The extend parameters of the data volume, in JSON format.
        :param _builtins.str flavor: The flavor of the resource pool.
        :param Mapping[str, _builtins.str] labels: The key/value pairs labels of resource pool.
        :param _builtins.int max_count: The max number of resources of the corresponding flavors.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceNetworkArgs'] networks: The network of the privileged pool.  
               The network structure is documented below.
        :param _builtins.str node_pool: The name of resource pool nodes.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceOArgs'] os: The image information for the specified OS.  
               The os structure is documented below.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceRootVolumeArgs'] root_volumes: The root volume of the resource pool nodes.  
               The root_volume structure is documented below.
        :param Mapping[str, _builtins.str] tags: The key/value pairs to associate with the resource pool nodes.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceTaintArgs'] taints: The taint list of the resource pool.  
               The taints structure is documented below.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigArgs'] volume_group_configs: The extend configurations of the volume groups.  
               The volume_group_configs structure is documented below.
        """
        pulumi.set(__self__, "azs", azs)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "creating_steps", creating_steps)
        pulumi.set(__self__, "data_volumes", data_volumes)
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "max_count", max_count)
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "node_pool", node_pool)
        pulumi.set(__self__, "os", os)
        pulumi.set(__self__, "root_volumes", root_volumes)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "volume_group_configs", volume_group_configs)

    @_builtins.property
    @pulumi.getter
    def azs(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceAzResult']:
        """
        The AZ list of the resource pool nodes.  
        The azs structure is documented below.
        """
        return pulumi.get(self, "azs")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of nodes in the AZ.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="creatingSteps")
    def creating_steps(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceCreatingStepResult']:
        """
        The creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.
        """
        return pulumi.get(self, "creating_steps")

    @_builtins.property
    @pulumi.getter(name="dataVolumes")
    def data_volumes(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceDataVolumeResult']:
        """
        The data volumes of the resource pool nodes.  
        The data_volumes structure is documented below.
        """
        return pulumi.get(self, "data_volumes")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the data volume, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> _builtins.str:
        """
        The flavor of the resource pool.
        """
        return pulumi.get(self, "flavor")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs labels of resource pool.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> _builtins.int:
        """
        The max number of resources of the corresponding flavors.
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceNetworkResult']:
        """
        The network of the privileged pool.  
        The network structure is documented below.
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> _builtins.str:
        """
        The name of resource pool nodes.
        """
        return pulumi.get(self, "node_pool")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceOResult']:
        """
        The image information for the specified OS.  
        The os structure is documented below.
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter(name="rootVolumes")
    def root_volumes(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceRootVolumeResult']:
        """
        The root volume of the resource pool nodes.  
        The root_volume structure is documented below.
        """
        return pulumi.get(self, "root_volumes")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The key/value pairs to associate with the resource pool nodes.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceTaintResult']:
        """
        The taint list of the resource pool.  
        The taints structure is documented below.
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="volumeGroupConfigs")
    def volume_group_configs(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigResult']:
        """
        The extend configurations of the volume groups.  
        The volume_group_configs structure is documented below.
        """
        return pulumi.get(self, "volume_group_configs")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceAzResult(dict):
    def __init__(__self__, *,
                 az: _builtins.str,
                 count: _builtins.int):
        """
        :param _builtins.str az: The AZ name
        :param _builtins.int count: The number of nodes in the AZ.
        """
        pulumi.set(__self__, "az", az)
        pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def az(self) -> _builtins.str:
        """
        The AZ name
        """
        return pulumi.get(self, "az")

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of nodes in the AZ.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceCreatingStepResult(dict):
    def __init__(__self__, *,
                 step: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int step: The creation step of the resource pool nodes.
        :param _builtins.str type: The type of the resource pool nodes.
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> _builtins.int:
        """
        The creation step of the resource pool nodes.
        """
        return pulumi.get(self, "step")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource pool nodes.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceDataVolumeResult(dict):
    def __init__(__self__, *,
                 count: _builtins.int,
                 extend_params: _builtins.str,
                 size: _builtins.str,
                 volume_type: _builtins.str):
        """
        :param _builtins.int count: The number of nodes in the AZ.
        :param _builtins.str extend_params: The extend parameters of the data volume, in JSON format.
        :param _builtins.str size: The size of the data volume.
        :param _builtins.str volume_type: The type of the data volume.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        The number of nodes in the AZ.
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the data volume, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The size of the data volume.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        The type of the data volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceNetworkResult(dict):
    def __init__(__self__, *,
                 security_groups: Sequence[_builtins.str],
                 subnet: _builtins.str,
                 vpc: _builtins.str):
        """
        :param Sequence[_builtins.str] security_groups: The ID list of the security group.
        :param _builtins.str subnet: The ID of the subnet.
        :param _builtins.str vpc: The ID of the VPC.
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        """
        The ID list of the security group.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The ID of the subnet.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceOResult(dict):
    def __init__(__self__, *,
                 image_id: _builtins.str,
                 image_type: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str image_id: The image ID.
        :param _builtins.str image_type: The image type.
        :param _builtins.str name: The OS name of the image.
        """
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The image ID.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> _builtins.str:
        """
        The image type.
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The OS name of the image.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceRootVolumeResult(dict):
    def __init__(__self__, *,
                 extend_params: _builtins.str,
                 size: _builtins.str,
                 volume_type: _builtins.str):
        """
        :param _builtins.str extend_params: The extend parameters of the data volume, in JSON format.
        :param _builtins.str size: The size of the data volume.
        :param _builtins.str volume_type: The type of the data volume.
        """
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.str:
        """
        The extend parameters of the data volume, in JSON format.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The size of the data volume.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> _builtins.str:
        """
        The type of the data volume.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceTaintResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: The effect of the taint.
        :param _builtins.str key: The key of the taint.
        :param _builtins.str value: The value of the taint.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        The effect of the taint.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the taint.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the taint.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigResult(dict):
    def __init__(__self__, *,
                 docker_thin_pool: _builtins.int,
                 lvm_configs: Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigLvmConfigResult'],
                 types: Sequence[_builtins.str],
                 volume_group: _builtins.str):
        """
        :param _builtins.int docker_thin_pool: The percentage of container volumes to data volumes on resource pool nodes.
        :param Sequence['GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigLvmConfigArgs'] lvm_configs: The configuration of the LVM management.  
               The lvm_config structure is documented below.
        :param Sequence[_builtins.str] types: The storage types of the volume group.
        :param _builtins.str volume_group: The name of the volume group.
        """
        pulumi.set(__self__, "docker_thin_pool", docker_thin_pool)
        pulumi.set(__self__, "lvm_configs", lvm_configs)
        pulumi.set(__self__, "types", types)
        pulumi.set(__self__, "volume_group", volume_group)

    @_builtins.property
    @pulumi.getter(name="dockerThinPool")
    def docker_thin_pool(self) -> _builtins.int:
        """
        The percentage of container volumes to data volumes on resource pool nodes.
        """
        return pulumi.get(self, "docker_thin_pool")

    @_builtins.property
    @pulumi.getter(name="lvmConfigs")
    def lvm_configs(self) -> Sequence['outputs.GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigLvmConfigResult']:
        """
        The configuration of the LVM management.  
        The lvm_config structure is documented below.
        """
        return pulumi.get(self, "lvm_configs")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Sequence[_builtins.str]:
        """
        The storage types of the volume group.
        """
        return pulumi.get(self, "types")

    @_builtins.property
    @pulumi.getter(name="volumeGroup")
    def volume_group(self) -> _builtins.str:
        """
        The name of the volume group.
        """
        return pulumi.get(self, "volume_group")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecResourceVolumeGroupConfigLvmConfigResult(dict):
    def __init__(__self__, *,
                 lv_type: _builtins.str,
                 path: _builtins.str):
        """
        :param _builtins.str lv_type: The LVM write mode.
        :param _builtins.str path: The volume mount path.
        """
        pulumi.set(__self__, "lv_type", lv_type)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="lvType")
    def lv_type(self) -> _builtins.str:
        """
        The LVM write mode.
        """
        return pulumi.get(self, "lv_type")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The volume mount path.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolSpecUserLoginResult(dict):
    def __init__(__self__, *,
                 key_pair_name: _builtins.str):
        """
        :param _builtins.str key_pair_name: The name of the key pair.
        """
        pulumi.set(__self__, "key_pair_name", key_pair_name)

    @_builtins.property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> _builtins.str:
        """
        The name of the key pair.
        """
        return pulumi.get(self, "key_pair_name")


@pulumi.output_type
class GetResourcePoolsV2ResourcePoolUserLoginResult(dict):
    def __init__(__self__, *,
                 key_pair_name: _builtins.str):
        """
        :param _builtins.str key_pair_name: The name of the key pair.
        """
        pulumi.set(__self__, "key_pair_name", key_pair_name)

    @_builtins.property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> _builtins.str:
        """
        The name of the key pair.
        """
        return pulumi.get(self, "key_pair_name")


@pulumi.output_type
class GetServiceFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 billing_spec: _builtins.str,
                 description: _builtins.str,
                 extend_params: _builtins.int,
                 id: _builtins.str,
                 is_free: _builtins.bool,
                 is_open: _builtins.bool,
                 over_quota: _builtins.bool,
                 source_type: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str billing_spec: ID of the billing specifications.
        :param _builtins.str description: Description of the flavor.
        :param _builtins.int extend_params: Billing item.
        :param _builtins.str id: The ID of the flavor.
        :param _builtins.bool is_free: Whether the flavor is free of charge.  
               The value **true** indicates that the flavor is free of charge.
        :param _builtins.bool is_open: Whether this flavor is open or not.  
               The default value is **true**.
               When the value is **false**, submit a service ticket to apply for the flavor.
        :param _builtins.bool over_quota: Whether the quota exceeds the upper limit.  
               The value **true** indicates that the quota exceeds the upper limit.
        :param _builtins.str source_type: Model type, which can be empty or **auto**.  
               The default value is empty, indicating that the model is generated by the user.
               If the value is **auto**, the model is trained using ExeML.
               The billing mode varies depending on the model type.
        :param _builtins.str status: Flavor status.  
               The options are as follows:
               + **normal**: The flavor is on-sales.
               + **sellout**: The flavor cannot be used to deploy services because it is sold out.
        """
        pulumi.set(__self__, "billing_spec", billing_spec)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "extend_params", extend_params)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_free", is_free)
        pulumi.set(__self__, "is_open", is_open)
        pulumi.set(__self__, "over_quota", over_quota)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="billingSpec")
    def billing_spec(self) -> _builtins.str:
        """
        ID of the billing specifications.
        """
        return pulumi.get(self, "billing_spec")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the flavor.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> _builtins.int:
        """
        Billing item.
        """
        return pulumi.get(self, "extend_params")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the flavor.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isFree")
    def is_free(self) -> _builtins.bool:
        """
        Whether the flavor is free of charge.  
        The value **true** indicates that the flavor is free of charge.
        """
        return pulumi.get(self, "is_free")

    @_builtins.property
    @pulumi.getter(name="isOpen")
    def is_open(self) -> _builtins.bool:
        """
        Whether this flavor is open or not.  
        The default value is **true**.
        When the value is **false**, submit a service ticket to apply for the flavor.
        """
        return pulumi.get(self, "is_open")

    @_builtins.property
    @pulumi.getter(name="overQuota")
    def over_quota(self) -> _builtins.bool:
        """
        Whether the quota exceeds the upper limit.  
        The value **true** indicates that the quota exceeds the upper limit.
        """
        return pulumi.get(self, "over_quota")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> _builtins.str:
        """
        Model type, which can be empty or **auto**.  
        The default value is empty, indicating that the model is generated by the user.
        If the value is **auto**, the model is trained using ExeML.
        The billing mode varies depending on the model type.
        """
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Flavor status.  
        The options are as follows:
        + **normal**: The flavor is on-sales.
        + **sellout**: The flavor cannot be used to deploy services because it is sold out.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetServicesServiceResult(dict):
    def __init__(__self__, *,
                 additional_properties: Sequence['outputs.GetServicesServiceAdditionalPropertyResult'],
                 description: _builtins.str,
                 failed_times: _builtins.int,
                 id: _builtins.str,
                 infer_type: _builtins.str,
                 invocation_times: _builtins.int,
                 is_free: _builtins.bool,
                 is_opened_sample_collection: _builtins.bool,
                 is_shared: _builtins.bool,
                 name: _builtins.str,
                 owner: _builtins.str,
                 schedules: Sequence['outputs.GetServicesServiceScheduleResult'],
                 shared_count: _builtins.int,
                 status: _builtins.str,
                 workspace_id: _builtins.str):
        """
        :param Sequence['GetServicesServiceAdditionalPropertyArgs'] additional_properties: Additional service attribute, which facilitates service management.  
               The additional_properties structure is documented below.
        :param _builtins.str description: The description of the service.
        :param _builtins.int failed_times: Number of failed service calls.
        :param _builtins.str id: Services ID.
        :param _builtins.str infer_type: Inference mode of the service.  
               Value options are as follows:
               + **real-time**: A real-time service. A model is deployed as a web service and provides real-time test UI and monitoring.
               + **batch**: A batch service, which can perform inference on batch data and automatically stops after data is processed.
               + **edge**: An edge service, which uses Intelligent EdgeFabric (IEF) to deploy a model as a web service on an edge
               node created on IEF.
        :param _builtins.int invocation_times: Number of service calls.
        :param _builtins.bool is_free: Whether a free-of-charge flavor is used.
        :param _builtins.bool is_opened_sample_collection: Whether to enable data collection, which defaults to false.
        :param _builtins.bool is_shared: Whether a service is subscribed.
        :param _builtins.str name: Service name.
        :param _builtins.str owner: User to which a service belongs.
        :param Sequence['GetServicesServiceScheduleArgs'] schedules: Service scheduling configuration, which can be configured only for real-time services.  
               By default, this parameter is not used. Services run for a long time.
               The schedule structure is documented below.
        :param _builtins.int shared_count: Number of subscribed services.
        :param _builtins.str status: Service status.  
               Value options are as follows:
               + **running**: The service is running properly.
               + **deploying**: The service is being deployed, including image creation and resource scheduling deployment.
               + **concerning**: An alarm has been generated, indicating that some backend instances malfunction.
               + **failed**: Deploying the service failed. For details about the failure cause, see the event and log tab pages.
               + **stopped**: The service has been stopped.
               + **finished**: Service running is completed. This status is available only for batch services.
        :param _builtins.str workspace_id: The workspace ID to which a service belongs.  
               The default value is 0, indicating the default workspace.
        """
        pulumi.set(__self__, "additional_properties", additional_properties)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "failed_times", failed_times)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "infer_type", infer_type)
        pulumi.set(__self__, "invocation_times", invocation_times)
        pulumi.set(__self__, "is_free", is_free)
        pulumi.set(__self__, "is_opened_sample_collection", is_opened_sample_collection)
        pulumi.set(__self__, "is_shared", is_shared)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "shared_count", shared_count)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Sequence['outputs.GetServicesServiceAdditionalPropertyResult']:
        """
        Additional service attribute, which facilitates service management.  
        The additional_properties structure is documented below.
        """
        return pulumi.get(self, "additional_properties")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the service.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="failedTimes")
    def failed_times(self) -> _builtins.int:
        """
        Number of failed service calls.
        """
        return pulumi.get(self, "failed_times")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Services ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inferType")
    def infer_type(self) -> _builtins.str:
        """
        Inference mode of the service.  
        Value options are as follows:
        + **real-time**: A real-time service. A model is deployed as a web service and provides real-time test UI and monitoring.
        + **batch**: A batch service, which can perform inference on batch data and automatically stops after data is processed.
        + **edge**: An edge service, which uses Intelligent EdgeFabric (IEF) to deploy a model as a web service on an edge
        node created on IEF.
        """
        return pulumi.get(self, "infer_type")

    @_builtins.property
    @pulumi.getter(name="invocationTimes")
    def invocation_times(self) -> _builtins.int:
        """
        Number of service calls.
        """
        return pulumi.get(self, "invocation_times")

    @_builtins.property
    @pulumi.getter(name="isFree")
    def is_free(self) -> _builtins.bool:
        """
        Whether a free-of-charge flavor is used.
        """
        return pulumi.get(self, "is_free")

    @_builtins.property
    @pulumi.getter(name="isOpenedSampleCollection")
    def is_opened_sample_collection(self) -> _builtins.bool:
        """
        Whether to enable data collection, which defaults to false.
        """
        return pulumi.get(self, "is_opened_sample_collection")

    @_builtins.property
    @pulumi.getter(name="isShared")
    def is_shared(self) -> _builtins.bool:
        """
        Whether a service is subscribed.
        """
        return pulumi.get(self, "is_shared")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Service name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        User to which a service belongs.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetServicesServiceScheduleResult']:
        """
        Service scheduling configuration, which can be configured only for real-time services.  
        By default, this parameter is not used. Services run for a long time.
        The schedule structure is documented below.
        """
        return pulumi.get(self, "schedules")

    @_builtins.property
    @pulumi.getter(name="sharedCount")
    def shared_count(self) -> _builtins.int:
        """
        Number of subscribed services.
        """
        return pulumi.get(self, "shared_count")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Service status.  
        Value options are as follows:
        + **running**: The service is running properly.
        + **deploying**: The service is being deployed, including image creation and resource scheduling deployment.
        + **concerning**: An alarm has been generated, indicating that some backend instances malfunction.
        + **failed**: Deploying the service failed. For details about the failure cause, see the event and log tab pages.
        + **stopped**: The service has been stopped.
        + **finished**: Service running is completed. This status is available only for batch services.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        The workspace ID to which a service belongs.  
        The default value is 0, indicating the default workspace.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetServicesServiceAdditionalPropertyResult(dict):
    def __init__(__self__, *,
                 log_report_channels: Sequence['outputs.GetServicesServiceAdditionalPropertyLogReportChannelResult'],
                 smn_notifications: Sequence['outputs.GetServicesServiceAdditionalPropertySmnNotificationResult']):
        """
        :param Sequence['GetServicesServiceAdditionalPropertyLogReportChannelArgs'] log_report_channels: Advanced Log configuration.
               The log_report_channels structure is documented below.
        :param Sequence['GetServicesServiceAdditionalPropertySmnNotificationArgs'] smn_notifications: SMN message notification configuration.
               The smn_notification structure is documented below.
        """
        pulumi.set(__self__, "log_report_channels", log_report_channels)
        pulumi.set(__self__, "smn_notifications", smn_notifications)

    @_builtins.property
    @pulumi.getter(name="logReportChannels")
    def log_report_channels(self) -> Sequence['outputs.GetServicesServiceAdditionalPropertyLogReportChannelResult']:
        """
        Advanced Log configuration.
        The log_report_channels structure is documented below.
        """
        return pulumi.get(self, "log_report_channels")

    @_builtins.property
    @pulumi.getter(name="smnNotifications")
    def smn_notifications(self) -> Sequence['outputs.GetServicesServiceAdditionalPropertySmnNotificationResult']:
        """
        SMN message notification configuration.
        The smn_notification structure is documented below.
        """
        return pulumi.get(self, "smn_notifications")


@pulumi.output_type
class GetServicesServiceAdditionalPropertyLogReportChannelResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The type of log report channel. The valid value is **LTS**.  
               If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
               If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
               for a maximum of seven days.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServicesServiceAdditionalPropertySmnNotificationResult(dict):
    def __init__(__self__, *,
                 events: Sequence[_builtins.int],
                 topic_urn: _builtins.str):
        """
        :param Sequence[_builtins.int] events: Event ID.  
               Value options are as follows::
               + **1**: failed.
               + **2**: stopped.
               + **3**: running.
               + **7**: alarm.
               + **9**: deleted.
               + **11**: pending.
        :param _builtins.str topic_urn: URN of an SMN topic.
        """
        pulumi.set(__self__, "events", events)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Sequence[_builtins.int]:
        """
        Event ID.  
        Value options are as follows::
        + **1**: failed.
        + **2**: stopped.
        + **3**: running.
        + **7**: alarm.
        + **9**: deleted.
        + **11**: pending.
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        URN of an SMN topic.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetServicesServiceScheduleResult(dict):
    def __init__(__self__, *,
                 duration: _builtins.int,
                 time_unit: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.int duration: Value mapping a time unit.  
               For example, if the task stops after two hours, set `time_unit` to HOURS and `duration` to 2.
        :param _builtins.str time_unit: Scheduling time unit. Possible values are **DAYS**, **HOURS**, and **MINUTES**.
        :param _builtins.str type: The type of log report channel. The valid value is **LTS**.  
               If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
               If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
               for a maximum of seven days.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "time_unit", time_unit)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.int:
        """
        Value mapping a time unit.  
        For example, if the task stops after two hours, set `time_unit` to HOURS and `duration` to 2.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> _builtins.str:
        """
        Scheduling time unit. Possible values are **DAYS**, **HOURS**, and **MINUTES**.
        """
        return pulumi.get(self, "time_unit")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWorkspacesWorkspaceResult(dict):
    def __init__(__self__, *,
                 auth_type: _builtins.str,
                 description: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 owner: _builtins.str,
                 status: _builtins.str,
                 status_info: _builtins.str):
        """
        :param _builtins.str auth_type: Authorization type.  
               Value options are as follows:
               + **public**: public access within the tenant.
               + **private**: Only the creator and master account can access.
               + **internal**: Accessible to the creator, main account, and specified IAM sub-accounts.
        :param _builtins.str description: The description of the workspace.
        :param _builtins.str enterprise_project_id: The enterprise project ID to which the workspace belongs.
        :param _builtins.str id: Workspace ID.
        :param _builtins.str name: Workspace name. Fuzzy match is supported.
        :param _builtins.str owner: Account name of the owner.
        :param _builtins.str status: Workspace status.  
               Valid values are **CREATE_FAILED**, **NORMALL**, **DELETING** and **DELETE_FAILED**.
        :param _builtins.str status_info: Status details.  
               If the deletion fails, you can check the reason through this field.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_info", status_info)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> _builtins.str:
        """
        Authorization type.  
        Value options are as follows:
        + **public**: public access within the tenant.
        + **private**: Only the creator and master account can access.
        + **internal**: Accessible to the creator, main account, and specified IAM sub-accounts.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the workspace.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        The enterprise project ID to which the workspace belongs.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Workspace ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Workspace name. Fuzzy match is supported.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        Account name of the owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Workspace status.  
        Valid values are **CREATE_FAILED**, **NORMALL**, **DELETING** and **DELETE_FAILED**.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusInfo")
    def status_info(self) -> _builtins.str:
        """
        Status details.  
        If the deletion fails, you can check the reason through this field.
        """
        return pulumi.get(self, "status_info")


