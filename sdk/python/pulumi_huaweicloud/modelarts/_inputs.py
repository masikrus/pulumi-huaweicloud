# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DatasetDataSourceArgs',
    'DatasetDataSourceArgsDict',
    'DatasetLabelArgs',
    'DatasetLabelArgsDict',
    'DatasetLabelFormatArgs',
    'DatasetLabelFormatArgsDict',
    'DatasetSchemaArgs',
    'DatasetSchemaArgsDict',
    'DevserverRootVolumeArgs',
    'DevserverRootVolumeArgsDict',
    'ModelDependencyArgs',
    'ModelDependencyArgsDict',
    'ModelDependencyPackageArgs',
    'ModelDependencyPackageArgsDict',
    'ModelModelDocArgs',
    'ModelModelDocArgsDict',
    'ModelTemplateArgs',
    'ModelTemplateArgsDict',
    'ModelTemplateTemplateInputArgs',
    'ModelTemplateTemplateInputArgsDict',
    'NetworkPeerConnectionArgs',
    'NetworkPeerConnectionArgsDict',
    'NotebookMountStorageArgs',
    'NotebookMountStorageArgsDict',
    'NotebookVolumeArgs',
    'NotebookVolumeArgsDict',
    'ResourcePoolClusterArgs',
    'ResourcePoolClusterArgsDict',
    'ResourcePoolMetadataArgs',
    'ResourcePoolMetadataArgsDict',
    'ResourcePoolNodeBatchResizeNodeArgs',
    'ResourcePoolNodeBatchResizeNodeArgsDict',
    'ResourcePoolNodeBatchResizeSourceArgs',
    'ResourcePoolNodeBatchResizeSourceArgsDict',
    'ResourcePoolNodeBatchResizeSourceCreatingStepArgs',
    'ResourcePoolNodeBatchResizeSourceCreatingStepArgsDict',
    'ResourcePoolNodeBatchResizeTargetArgs',
    'ResourcePoolNodeBatchResizeTargetArgsDict',
    'ResourcePoolNodeBatchResizeTargetCreatingStepArgs',
    'ResourcePoolNodeBatchResizeTargetCreatingStepArgsDict',
    'ResourcePoolResourceArgs',
    'ResourcePoolResourceArgsDict',
    'ResourcePoolResourceAzArgs',
    'ResourcePoolResourceAzArgsDict',
    'ResourcePoolResourceCreatingStepArgs',
    'ResourcePoolResourceCreatingStepArgsDict',
    'ResourcePoolResourceDataVolumeArgs',
    'ResourcePoolResourceDataVolumeArgsDict',
    'ResourcePoolResourceDriverArgs',
    'ResourcePoolResourceDriverArgsDict',
    'ResourcePoolResourceOsArgs',
    'ResourcePoolResourceOsArgsDict',
    'ResourcePoolResourceRootVolumeArgs',
    'ResourcePoolResourceRootVolumeArgsDict',
    'ResourcePoolResourceTaintArgs',
    'ResourcePoolResourceTaintArgsDict',
    'ResourcePoolResourceVolumeGroupConfigArgs',
    'ResourcePoolResourceVolumeGroupConfigArgsDict',
    'ResourcePoolResourceVolumeGroupConfigLvmConfigArgs',
    'ResourcePoolResourceVolumeGroupConfigLvmConfigArgsDict',
    'ResourcePoolResourcesOrderOriginArgs',
    'ResourcePoolResourcesOrderOriginArgsDict',
    'ResourcePoolUserLoginArgs',
    'ResourcePoolUserLoginArgsDict',
    'ServiceAdditionalPropertiesArgs',
    'ServiceAdditionalPropertiesArgsDict',
    'ServiceAdditionalPropertiesLogReportChannelsArgs',
    'ServiceAdditionalPropertiesLogReportChannelsArgsDict',
    'ServiceAdditionalPropertiesSmnNotificationArgs',
    'ServiceAdditionalPropertiesSmnNotificationArgsDict',
    'ServiceConfigArgs',
    'ServiceConfigArgsDict',
    'ServiceConfigCustomSpecArgs',
    'ServiceConfigCustomSpecArgsDict',
    'ServiceScheduleArgs',
    'ServiceScheduleArgsDict',
    'ServiceV2GroupConfigArgs',
    'ServiceV2GroupConfigArgsDict',
    'ServiceV2GroupConfigUnitConfigArgs',
    'ServiceV2GroupConfigUnitConfigArgsDict',
    'ServiceV2GroupConfigUnitConfigCodeArgs',
    'ServiceV2GroupConfigUnitConfigCodeArgsDict',
    'ServiceV2GroupConfigUnitConfigCustomSpecArgs',
    'ServiceV2GroupConfigUnitConfigCustomSpecArgsDict',
    'ServiceV2GroupConfigUnitConfigImageArgs',
    'ServiceV2GroupConfigUnitConfigImageArgsDict',
    'ServiceV2GroupConfigUnitConfigLivenessHealthArgs',
    'ServiceV2GroupConfigUnitConfigLivenessHealthArgsDict',
    'ServiceV2GroupConfigUnitConfigModelArgs',
    'ServiceV2GroupConfigUnitConfigModelArgsDict',
    'ServiceV2GroupConfigUnitConfigReadinessHealthArgs',
    'ServiceV2GroupConfigUnitConfigReadinessHealthArgsDict',
    'ServiceV2GroupConfigUnitConfigStartupHealthArgs',
    'ServiceV2GroupConfigUnitConfigStartupHealthArgsDict',
    'ServiceV2LogConfigArgs',
    'ServiceV2LogConfigArgsDict',
    'ServiceV2PredictUrlArgs',
    'ServiceV2PredictUrlArgsDict',
    'WorkspaceGrantArgs',
    'WorkspaceGrantArgsDict',
]

MYPY = False

if not MYPY:
    class DatasetDataSourceArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the cluster ID of DWS/MRS when `data_type` is `1` or `4`.
        Changing this parameter will create a new resource.
        """
        data_type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the type of data source. The options are as follows:
        + **0**: OBS.
        + **1**: GaussDB(DWS).
        + **2**: DLI.
        + **4**: MRS.

        Default value is 0. Changing this parameter will create a new resource.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the database name of DWS/DLI when `data_type` is `1` or `2`.
        Changing this parameter will create a new resource.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the password of database when `data_type` is `1`.
        Changing this parameter will create a new resource.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OBS path when `data_type` is `0`
        or the hdsf path when `data_type` is `4`. All the file in this directory and subdirectories will be which be imported
        to the dataset. Changing this parameter will create a new resource.
        """
        queue_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the queue name of DLI when `data_type` is `2`.
        Changing this parameter will create a new resource.
        """
        table_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the table name of DWS/DLI when `data_type` is `1` or `2`.
        Changing this parameter will create a new resource.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the user name of database when `data_type` is `1`.
        Changing this parameter will create a new resource.
        """
        with_column_header: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the data contains table header when the type
        of dataset is `400`(Table type). Default value is `true`. Changing this parameter will create a new resource.
        """
elif False:
    DatasetDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetDataSourceArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[_builtins.str]] = None,
                 data_type: Optional[pulumi.Input[_builtins.int]] = None,
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 queue_name: Optional[pulumi.Input[_builtins.str]] = None,
                 table_name: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None,
                 with_column_header: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_id: Specifies the cluster ID of DWS/MRS when `data_type` is `1` or `4`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] data_type: Specifies the type of data source. The options are as follows:
               + **0**: OBS.
               + **1**: GaussDB(DWS).
               + **2**: DLI.
               + **4**: MRS.
               
               Default value is 0. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] database_name: Specifies the database name of DWS/DLI when `data_type` is `1` or `2`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] password: Specifies the password of database when `data_type` is `1`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] path: Specifies the OBS path when `data_type` is `0`
               or the hdsf path when `data_type` is `4`. All the file in this directory and subdirectories will be which be imported
               to the dataset. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] queue_name: Specifies the queue name of DLI when `data_type` is `2`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] table_name: Specifies the table name of DWS/DLI when `data_type` is `1` or `2`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] user_name: Specifies the user name of database when `data_type` is `1`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.bool] with_column_header: Specifies whether the data contains table header when the type
               of dataset is `400`(Table type). Default value is `true`. Changing this parameter will create a new resource.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)
        if table_name is not None:
            pulumi.set(__self__, "table_name", table_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if with_column_header is not None:
            pulumi.set(__self__, "with_column_header", with_column_header)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the cluster ID of DWS/MRS when `data_type` is `1` or `4`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the type of data source. The options are as follows:
        + **0**: OBS.
        + **1**: GaussDB(DWS).
        + **2**: DLI.
        + **4**: MRS.

        Default value is 0. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data_type", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the database name of DWS/DLI when `data_type` is `1` or `2`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the password of database when `data_type` is `1`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OBS path when `data_type` is `0`
        or the hdsf path when `data_type` is `4`. All the file in this directory and subdirectories will be which be imported
        to the dataset. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the queue name of DLI when `data_type` is `2`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "queue_name", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the table name of DWS/DLI when `data_type` is `1` or `2`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "table_name", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the user name of database when `data_type` is `1`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)

    @_builtins.property
    @pulumi.getter(name="withColumnHeader")
    def with_column_header(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the data contains table header when the type
        of dataset is `400`(Table type). Default value is `true`. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "with_column_header")

    @with_column_header.setter
    def with_column_header(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "with_column_header", value)


if not MYPY:
    class DatasetLabelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of label.
        """
        property_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies color of label.
        """
        property_shape: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies shape of label. Valid values include: `bndbox`, `polygon`,
        `circle`, `line`, `dashed`, `point`, `polyline`.
        """
        property_shortcut: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies shortcut of label.
        """
elif False:
    DatasetLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 property_color: Optional[pulumi.Input[_builtins.str]] = None,
                 property_shape: Optional[pulumi.Input[_builtins.str]] = None,
                 property_shortcut: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of label.
        :param pulumi.Input[_builtins.str] property_color: Specifies color of label.
        :param pulumi.Input[_builtins.str] property_shape: Specifies shape of label. Valid values include: `bndbox`, `polygon`,
               `circle`, `line`, `dashed`, `point`, `polyline`.
        :param pulumi.Input[_builtins.str] property_shortcut: Specifies shortcut of label.
        """
        pulumi.set(__self__, "name", name)
        if property_color is not None:
            pulumi.set(__self__, "property_color", property_color)
        if property_shape is not None:
            pulumi.set(__self__, "property_shape", property_shape)
        if property_shortcut is not None:
            pulumi.set(__self__, "property_shortcut", property_shortcut)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of label.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="propertyColor")
    def property_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies color of label.
        """
        return pulumi.get(self, "property_color")

    @property_color.setter
    def property_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property_color", value)

    @_builtins.property
    @pulumi.getter(name="propertyShape")
    def property_shape(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies shape of label. Valid values include: `bndbox`, `polygon`,
        `circle`, `line`, `dashed`, `point`, `polyline`.
        """
        return pulumi.get(self, "property_shape")

    @property_shape.setter
    def property_shape(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property_shape", value)

    @_builtins.property
    @pulumi.getter(name="propertyShortcut")
    def property_shortcut(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies shortcut of label.
        """
        return pulumi.get(self, "property_shortcut")

    @property_shortcut.setter
    def property_shortcut(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property_shortcut", value)


if not MYPY:
    class DatasetLabelFormatArgsDict(TypedDict):
        label_separator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the separator between label and label.
        Changing this parameter will create a new resource.
        """
        text_label_separator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the separator between text and label.
        Changing this parameter will create a new resource.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies Label type for text classification.
        The optional values are as follows:

        + **0**: Label and text are separated, distinguished by the suffix `_result`.
        For example: the text file is *abc.txt*, and the label file is *abc_result.txt*.
        + **1**: Default, labels and text are in one file, separated by a delimiter. The separator between text and labels,
        the separator between label and label can be specified by `label_separator` and `text_label_separator`.

        Default value is `1`.
        """
elif False:
    DatasetLabelFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetLabelFormatArgs:
    def __init__(__self__, *,
                 label_separator: Optional[pulumi.Input[_builtins.str]] = None,
                 text_label_separator: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] label_separator: Specifies the separator between label and label.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] text_label_separator: Specifies the separator between text and label.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] type: Specifies Label type for text classification.
               The optional values are as follows:
               
               + **0**: Label and text are separated, distinguished by the suffix `_result`.
               For example: the text file is *abc.txt*, and the label file is *abc_result.txt*.
               + **1**: Default, labels and text are in one file, separated by a delimiter. The separator between text and labels,
               the separator between label and label can be specified by `label_separator` and `text_label_separator`.
               
               Default value is `1`.
        """
        if label_separator is not None:
            pulumi.set(__self__, "label_separator", label_separator)
        if text_label_separator is not None:
            pulumi.set(__self__, "text_label_separator", text_label_separator)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="labelSeparator")
    def label_separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the separator between label and label.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "label_separator")

    @label_separator.setter
    def label_separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label_separator", value)

    @_builtins.property
    @pulumi.getter(name="textLabelSeparator")
    def text_label_separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the separator between text and label.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "text_label_separator")

    @text_label_separator.setter
    def text_label_separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_label_separator", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies Label type for text classification.
        The optional values are as follows:

        + **0**: Label and text are separated, distinguished by the suffix `_result`.
        For example: the text file is *abc.txt*, and the label file is *abc_result.txt*.
        + **1**: Default, labels and text are in one file, separated by a delimiter. The separator between text and labels,
        the separator between label and label can be specified by `label_separator` and `text_label_separator`.

        Default value is `1`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DatasetSchemaArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the field name. Changing this parameter will create a new resource.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the field type. Valid values include: `String`, `Short`, `Int`,
        `Long`, `Double`, `Float`, `Byte`, `Date`, `Timestamp`, `Bool`. Changing this parameter will create a new resource.
        """
elif False:
    DatasetSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetSchemaArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the field name. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] type: Specifies the field type. Valid values include: `String`, `Short`, `Int`,
               `Long`, `Double`, `Float`, `Byte`, `Date`, `Timestamp`, `Bool`. Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field name. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the field type. Valid values include: `String`, `Short`, `Int`,
        `Long`, `Double`, `Float`, `Byte`, `Date`, `Timestamp`, `Bool`. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DevserverRootVolumeArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the size of system disk.
        Changing this creates a new resource.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of system disk.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
elif False:
    DevserverRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DevserverRootVolumeArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] size: Specifies the size of system disk.
               Changing this creates a new resource.
        :param pulumi.Input[_builtins.str] type: Specifies the type of system disk.
               Changing this creates a new resource.
               The valid values are as follows:
               + **ESSD**: Extreme SSD type.
               + **SSD**: Ultra-high I/O type.
               + **GPSSD**: General purpose SSD type.
               + **SAS**: High I/O type.
               + **SATA**: Common I/O type.
        """
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the size of system disk.
        Changing this creates a new resource.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of system disk.
        Changing this creates a new resource.
        The valid values are as follows:
        + **ESSD**: Extreme SSD type.
        + **SSD**: Ultra-high I/O type.
        + **GPSSD**: General purpose SSD type.
        + **SAS**: High I/O type.
        + **SATA**: Common I/O type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ModelDependencyArgsDict(TypedDict):
        installer: pulumi.Input[_builtins.str]
        """
        Installation mode. Only **pip** is supported.
        Changing this parameter will create a new resource.
        """
        packages: pulumi.Input[Sequence[pulumi.Input['ModelDependencyPackageArgsDict']]]
        """
        Collection of dependency packages.
        The package structure is documented below.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_package"></a>
        The `package` block supports:
        """
elif False:
    ModelDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDependencyArgs:
    def __init__(__self__, *,
                 installer: pulumi.Input[_builtins.str],
                 packages: pulumi.Input[Sequence[pulumi.Input['ModelDependencyPackageArgs']]]):
        """
        :param pulumi.Input[_builtins.str] installer: Installation mode. Only **pip** is supported.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['ModelDependencyPackageArgs']]] packages: Collection of dependency packages.
               The package structure is documented below.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_package"></a>
               The `package` block supports:
        """
        pulumi.set(__self__, "installer", installer)
        pulumi.set(__self__, "packages", packages)

    @_builtins.property
    @pulumi.getter
    def installer(self) -> pulumi.Input[_builtins.str]:
        """
        Installation mode. Only **pip** is supported.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "installer")

    @installer.setter
    def installer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "installer", value)

    @_builtins.property
    @pulumi.getter
    def packages(self) -> pulumi.Input[Sequence[pulumi.Input['ModelDependencyPackageArgs']]]:
        """
        Collection of dependency packages.
        The package structure is documented below.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_package"></a>
        The `package` block supports:
        """
        return pulumi.get(self, "packages")

    @packages.setter
    def packages(self, value: pulumi.Input[Sequence[pulumi.Input['ModelDependencyPackageArgs']]]):
        pulumi.set(self, "packages", value)


if not MYPY:
    class ModelDependencyPackageArgsDict(TypedDict):
        package_name: pulumi.Input[_builtins.str]
        """
        Name of a dependency package.
        Ensure that the package name is correct and available.
        Chinese characters and special characters (&!'"<>=) are not allowed.
        Changing this parameter will create a new resource.
        """
        package_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of a dependency package.
        If this parameter is left blank, the latest version is installed by default.
        Chinese characters and special characters (&!'"<>=) are not allowed.
        Changing this parameter will create a new resource.
        """
        restraint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version restriction, which can be **EXACT**, **ATLEAST**, or **ATMOST**.
        This parameter is mandatory only when package_version is available.
        Changing this parameter will create a new resource.
        """
elif False:
    ModelDependencyPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelDependencyPackageArgs:
    def __init__(__self__, *,
                 package_name: pulumi.Input[_builtins.str],
                 package_version: Optional[pulumi.Input[_builtins.str]] = None,
                 restraint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] package_name: Name of a dependency package.
               Ensure that the package name is correct and available.
               Chinese characters and special characters (&!'"<>=) are not allowed.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] package_version: Version of a dependency package.
               If this parameter is left blank, the latest version is installed by default.
               Chinese characters and special characters (&!'"<>=) are not allowed.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] restraint: Version restriction, which can be **EXACT**, **ATLEAST**, or **ATMOST**.
               This parameter is mandatory only when package_version is available.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "package_name", package_name)
        if package_version is not None:
            pulumi.set(__self__, "package_version", package_version)
        if restraint is not None:
            pulumi.set(__self__, "restraint", restraint)

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a dependency package.
        Ensure that the package name is correct and available.
        Chinese characters and special characters (&!'"<>=) are not allowed.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "package_name", value)

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of a dependency package.
        If this parameter is left blank, the latest version is installed by default.
        Chinese characters and special characters (&!'"<>=) are not allowed.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "package_version")

    @package_version.setter
    def package_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "package_version", value)

    @_builtins.property
    @pulumi.getter
    def restraint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version restriction, which can be **EXACT**, **ATLEAST**, or **ATMOST**.
        This parameter is mandatory only when package_version is available.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "restraint")

    @restraint.setter
    def restraint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restraint", value)


if not MYPY:
    class ModelModelDocArgsDict(TypedDict):
        doc_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Document name, which must start with a letter. Enter 1 to 48 characters.  
        Only letters, digits, hyphens (-), and underscores (_) are allowed.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_Template"></a>
        The `Template` block supports:
        """
        doc_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP(S) link of the document.
        Changing this parameter will create a new resource.
        """
elif False:
    ModelModelDocArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelModelDocArgs:
    def __init__(__self__, *,
                 doc_name: Optional[pulumi.Input[_builtins.str]] = None,
                 doc_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] doc_name: Document name, which must start with a letter. Enter 1 to 48 characters.  
               Only letters, digits, hyphens (-), and underscores (_) are allowed.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_Template"></a>
               The `Template` block supports:
        :param pulumi.Input[_builtins.str] doc_url: HTTP(S) link of the document.
               Changing this parameter will create a new resource.
        """
        if doc_name is not None:
            pulumi.set(__self__, "doc_name", doc_name)
        if doc_url is not None:
            pulumi.set(__self__, "doc_url", doc_url)

    @_builtins.property
    @pulumi.getter(name="docName")
    def doc_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Document name, which must start with a letter. Enter 1 to 48 characters.  
        Only letters, digits, hyphens (-), and underscores (_) are allowed.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_Template"></a>
        The `Template` block supports:
        """
        return pulumi.get(self, "doc_name")

    @doc_name.setter
    def doc_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "doc_name", value)

    @_builtins.property
    @pulumi.getter(name="docUrl")
    def doc_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP(S) link of the document.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "doc_url")

    @doc_url.setter
    def doc_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "doc_url", value)


if not MYPY:
    class ModelTemplateArgsDict(TypedDict):
        template_id: pulumi.Input[_builtins.str]
        """
        ID of the used template.  
        The template has a built-in input and output mode.
        Changing this parameter will create a new resource.
        """
        template_inputs: pulumi.Input[Sequence[pulumi.Input['ModelTemplateTemplateInputArgsDict']]]
        """
        Template input configuration,
        specifying the source path for configuring a model.
        The TemplateInput structure is documented below.
        Changing this parameter will create a new resource.
        """
        infer_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the input and output mode.  
        When this parameter is used, the input and output mode built in the template does not take effect.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_TemplateInput"></a>
        The `TemplateInput` block supports:
        """
elif False:
    ModelTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelTemplateArgs:
    def __init__(__self__, *,
                 template_id: pulumi.Input[_builtins.str],
                 template_inputs: pulumi.Input[Sequence[pulumi.Input['ModelTemplateTemplateInputArgs']]],
                 infer_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] template_id: ID of the used template.  
               The template has a built-in input and output mode.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Sequence[pulumi.Input['ModelTemplateTemplateInputArgs']]] template_inputs: Template input configuration,
               specifying the source path for configuring a model.
               The TemplateInput structure is documented below.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] infer_format: ID of the input and output mode.  
               When this parameter is used, the input and output mode built in the template does not take effect.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_TemplateInput"></a>
               The `TemplateInput` block supports:
        """
        pulumi.set(__self__, "template_id", template_id)
        pulumi.set(__self__, "template_inputs", template_inputs)
        if infer_format is not None:
            pulumi.set(__self__, "infer_format", infer_format)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the used template.  
        The template has a built-in input and output mode.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_id", value)

    @_builtins.property
    @pulumi.getter(name="templateInputs")
    def template_inputs(self) -> pulumi.Input[Sequence[pulumi.Input['ModelTemplateTemplateInputArgs']]]:
        """
        Template input configuration,
        specifying the source path for configuring a model.
        The TemplateInput structure is documented below.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "template_inputs")

    @template_inputs.setter
    def template_inputs(self, value: pulumi.Input[Sequence[pulumi.Input['ModelTemplateTemplateInputArgs']]]):
        pulumi.set(self, "template_inputs", value)

    @_builtins.property
    @pulumi.getter(name="inferFormat")
    def infer_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the input and output mode.  
        When this parameter is used, the input and output mode built in the template does not take effect.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_TemplateInput"></a>
        The `TemplateInput` block supports:
        """
        return pulumi.get(self, "infer_format")

    @infer_format.setter
    def infer_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "infer_format", value)


if not MYPY:
    class ModelTemplateTemplateInputArgsDict(TypedDict):
        input: pulumi.Input[_builtins.str]
        """
        Template input path, which can be a path to an OBS file or directory.  
        When you use a template with multiple input items to create a model,
        if the target paths input_properties specified in the template are the same,
        the OBS directory or OBS file name entered here must be unique to prevent files from being overwritten.
        Changing this parameter will create a new resource.
        """
        input_id: pulumi.Input[_builtins.str]
        """
        Input item ID, which is obtained from template details.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_Dependency"></a>
        The `Dependency` block supports:
        """
elif False:
    ModelTemplateTemplateInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelTemplateTemplateInputArgs:
    def __init__(__self__, *,
                 input: pulumi.Input[_builtins.str],
                 input_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] input: Template input path, which can be a path to an OBS file or directory.  
               When you use a template with multiple input items to create a model,
               if the target paths input_properties specified in the template are the same,
               the OBS directory or OBS file name entered here must be unique to prevent files from being overwritten.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] input_id: Input item ID, which is obtained from template details.
               Changing this parameter will create a new resource.
               
               <a name="ModelartsModel_Dependency"></a>
               The `Dependency` block supports:
        """
        pulumi.set(__self__, "input", input)
        pulumi.set(__self__, "input_id", input_id)

    @_builtins.property
    @pulumi.getter
    def input(self) -> pulumi.Input[_builtins.str]:
        """
        Template input path, which can be a path to an OBS file or directory.  
        When you use a template with multiple input items to create a model,
        if the target paths input_properties specified in the template are the same,
        the OBS directory or OBS file name entered here must be unique to prevent files from being overwritten.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter(name="inputId")
    def input_id(self) -> pulumi.Input[_builtins.str]:
        """
        Input item ID, which is obtained from template details.
        Changing this parameter will create a new resource.

        <a name="ModelartsModel_Dependency"></a>
        The `Dependency` block supports:
        """
        return pulumi.get(self, "input_id")

    @input_id.setter
    def input_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_id", value)


if not MYPY:
    class NetworkPeerConnectionArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        Interconnect subnet ID.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        Interconnect VPC ID.
        """
elif False:
    NetworkPeerConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPeerConnectionArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Interconnect subnet ID.
        :param pulumi.Input[_builtins.str] vpc_id: Interconnect VPC ID.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Interconnect subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        Interconnect VPC ID.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class NotebookMountStorageArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mount ID.
        """
        mount_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The local mount path.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path of storage which be mounted.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of mount.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of storage which be mounted.
        """
elif False:
    NotebookMountStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookMountStorageArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_path: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The mount ID.
        :param pulumi.Input[_builtins.str] mount_path: The local mount path.
        :param pulumi.Input[_builtins.str] path: The path of storage which be mounted.
        :param pulumi.Input[_builtins.str] status: The status of mount.
        :param pulumi.Input[_builtins.str] type: The type of storage which be mounted.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mount ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The local mount path.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path of storage which be mounted.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of mount.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of storage which be mounted.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NotebookVolumeArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the volume type. The options are as follows:
        - *EFS*: use Scalable File Service, default 50GB is **free**.
        - *EVS*: use Elastic Volume Service, default size is 5 GB.

        Changing this parameter will create a new resource.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of dedicated storage disk, which is mandatory when the `type`
        is `EFS` and the `ownership` is `DEDICATED`.
        Changing this parameter will create a new resource.
        """
        mount_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The local mount path.
        """
        ownership: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the volume ownership. The options are as follows:
        - *MANAGED*: shared storage disk of the ModelArts service.
        - *DEDICATED*: dedicated storage disk, only supported when the category is `EFS`.

        Changing this parameter will create a new resource.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the volume size. Its value range is from `5` GB to `4,096` GB.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URL of dedicated storage disk, which is mandatory when the `type`
        is `EFS` and the `ownership` is `DEDICATED`. Example: `192.168.0.1:/user-9sfdsdgdfgh5ea4d56871e75d6966aa274/mount/`.
        Changing this parameter will create a new resource.
        """
elif False:
    NotebookVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotebookVolumeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 mount_path: Optional[pulumi.Input[_builtins.str]] = None,
                 ownership: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the volume type. The options are as follows:
               - *EFS*: use Scalable File Service, default 50GB is **free**.
               - *EVS*: use Elastic Volume Service, default size is 5 GB.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] id: Specifies the ID of dedicated storage disk, which is mandatory when the `type`
               is `EFS` and the `ownership` is `DEDICATED`.
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] mount_path: The local mount path.
        :param pulumi.Input[_builtins.str] ownership: Specifies the volume ownership. The options are as follows:
               - *MANAGED*: shared storage disk of the ModelArts service.
               - *DEDICATED*: dedicated storage disk, only supported when the category is `EFS`.
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.int] size: Specifies the volume size. Its value range is from `5` GB to `4,096` GB.
        :param pulumi.Input[_builtins.str] uri: Specifies the URL of dedicated storage disk, which is mandatory when the `type`
               is `EFS` and the `ownership` is `DEDICATED`. Example: `192.168.0.1:/user-9sfdsdgdfgh5ea4d56871e75d6966aa274/mount/`.
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if ownership is not None:
            pulumi.set(__self__, "ownership", ownership)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the volume type. The options are as follows:
        - *EFS*: use Scalable File Service, default 50GB is **free**.
        - *EVS*: use Elastic Volume Service, default size is 5 GB.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of dedicated storage disk, which is mandatory when the `type`
        is `EFS` and the `ownership` is `DEDICATED`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The local mount path.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def ownership(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the volume ownership. The options are as follows:
        - *MANAGED*: shared storage disk of the ModelArts service.
        - *DEDICATED*: dedicated storage disk, only supported when the category is `EFS`.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "ownership")

    @ownership.setter
    def ownership(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ownership", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the volume size. Its value range is from `5` GB to `4,096` GB.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URL of dedicated storage disk, which is mandatory when the `type`
        is `EFS` and the `ownership` is `DEDICATED`. Example: `192.168.0.1:/user-9sfdsdgdfgh5ea4d56871e75d6966aa274/mount/`.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class ResourcePoolClusterArgsDict(TypedDict):
        provider_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the CCE cluster.

        <a name="ModelartsResourcePool_User_login"></a>
        The `user_login` block supports:
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OS name of the image.
        """
elif False:
    ResourcePoolClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolClusterArgs:
    def __init__(__self__, *,
                 provider_id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] provider_id: Specifies the ID of the CCE cluster.
               
               <a name="ModelartsResourcePool_User_login"></a>
               The `user_login` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the OS name of the image.
        """
        pulumi.set(__self__, "provider_id", provider_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the CCE cluster.

        <a name="ModelartsResourcePool_User_login"></a>
        The `user_login` block supports:
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OS name of the image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourcePoolMetadataArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the annotations of the resource pool, in JSON format.  
        For details, please refer to the [document](https://support.huaweicloud.com/intl/en-us/api-modelarts/CreatePool.html#EN-US_TOPIC_0000001868289874__request_PoolAnnotationsCreation).

        > 1. This parameter only affects the nodes to be expanded, and will be applied to all nodes that are expanded under
        the `resources` parameter.
        <br>2. The parameter is not allowed to modify the resource pool billing-related parameters.
        <br>3. The `os.modelarts/description` cannot be set at the same time as the external `description` parameter.
        """
elif False:
    ResourcePoolMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] annotations: Specifies the annotations of the resource pool, in JSON format.  
               For details, please refer to the [document](https://support.huaweicloud.com/intl/en-us/api-modelarts/CreatePool.html#EN-US_TOPIC_0000001868289874__request_PoolAnnotationsCreation).
               
               > 1. This parameter only affects the nodes to be expanded, and will be applied to all nodes that are expanded under
               the `resources` parameter.
               <br>2. The parameter is not allowed to modify the resource pool billing-related parameters.
               <br>3. The `os.modelarts/description` cannot be set at the same time as the external `description` parameter.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the annotations of the resource pool, in JSON format.  
        For details, please refer to the [document](https://support.huaweicloud.com/intl/en-us/api-modelarts/CreatePool.html#EN-US_TOPIC_0000001868289874__request_PoolAnnotationsCreation).

        > 1. This parameter only affects the nodes to be expanded, and will be applied to all nodes that are expanded under
        the `resources` parameter.
        <br>2. The parameter is not allowed to modify the resource pool billing-related parameters.
        <br>3. The `os.modelarts/description` cannot be set at the same time as the external `description` parameter.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "annotations", value)


if not MYPY:
    class ResourcePoolNodeBatchResizeNodeArgsDict(TypedDict):
        batch_uid: pulumi.Input[_builtins.str]
        """
        Specifies the batch UID of the node.
        """
        delete_node_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the list of nodes to be deleted.  
        This parameter is **required** only when downgrading specification of the nodes and cannot be set when upgrading.

        <a name="resource_pool_node_batch_resize_node_pool_configuration"></a>
        The `source` and `target` block supports:
        """
elif False:
    ResourcePoolNodeBatchResizeNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolNodeBatchResizeNodeArgs:
    def __init__(__self__, *,
                 batch_uid: pulumi.Input[_builtins.str],
                 delete_node_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] batch_uid: Specifies the batch UID of the node.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] delete_node_names: Specifies the list of nodes to be deleted.  
               This parameter is **required** only when downgrading specification of the nodes and cannot be set when upgrading.
               
               <a name="resource_pool_node_batch_resize_node_pool_configuration"></a>
               The `source` and `target` block supports:
        """
        pulumi.set(__self__, "batch_uid", batch_uid)
        if delete_node_names is not None:
            pulumi.set(__self__, "delete_node_names", delete_node_names)

    @_builtins.property
    @pulumi.getter(name="batchUid")
    def batch_uid(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the batch UID of the node.
        """
        return pulumi.get(self, "batch_uid")

    @batch_uid.setter
    def batch_uid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "batch_uid", value)

    @_builtins.property
    @pulumi.getter(name="deleteNodeNames")
    def delete_node_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the list of nodes to be deleted.  
        This parameter is **required** only when downgrading specification of the nodes and cannot be set when upgrading.

        <a name="resource_pool_node_batch_resize_node_pool_configuration"></a>
        The `source` and `target` block supports:
        """
        return pulumi.get(self, "delete_node_names")

    @delete_node_names.setter
    def delete_node_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "delete_node_names", value)


if not MYPY:
    class ResourcePoolNodeBatchResizeSourceArgsDict(TypedDict):
        creating_step: pulumi.Input['ResourcePoolNodeBatchResizeSourceCreatingStepArgsDict']
        """
        Specifies the creating step of the node pool.  
        The creating_step structure is documented below.

        <a name="resource_pool_node_batch_resize_source_creating_step"></a>
        The `creating_step` block supports:
        """
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor of the node pool.
        """
        node_pool: pulumi.Input[_builtins.str]
        """
        Specifies the name of the node pool.
        """
elif False:
    ResourcePoolNodeBatchResizeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolNodeBatchResizeSourceArgs:
    def __init__(__self__, *,
                 creating_step: pulumi.Input['ResourcePoolNodeBatchResizeSourceCreatingStepArgs'],
                 flavor: pulumi.Input[_builtins.str],
                 node_pool: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['ResourcePoolNodeBatchResizeSourceCreatingStepArgs'] creating_step: Specifies the creating step of the node pool.  
               The creating_step structure is documented below.
               
               <a name="resource_pool_node_batch_resize_source_creating_step"></a>
               The `creating_step` block supports:
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor of the node pool.
        :param pulumi.Input[_builtins.str] node_pool: Specifies the name of the node pool.
        """
        pulumi.set(__self__, "creating_step", creating_step)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_pool", node_pool)

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> pulumi.Input['ResourcePoolNodeBatchResizeSourceCreatingStepArgs']:
        """
        Specifies the creating step of the node pool.  
        The creating_step structure is documented below.

        <a name="resource_pool_node_batch_resize_source_creating_step"></a>
        The `creating_step` block supports:
        """
        return pulumi.get(self, "creating_step")

    @creating_step.setter
    def creating_step(self, value: pulumi.Input['ResourcePoolNodeBatchResizeSourceCreatingStepArgs']):
        pulumi.set(self, "creating_step", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor of the node pool.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the node pool.
        """
        return pulumi.get(self, "node_pool")

    @node_pool.setter
    def node_pool(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_pool", value)


if not MYPY:
    class ResourcePoolNodeBatchResizeSourceCreatingStepArgsDict(TypedDict):
        step: pulumi.Input[_builtins.int]
        """
        Specifies the step number of the nodes.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the nodes.  
        The valid values are as follows:
        + **hyperinstance**
        """
elif False:
    ResourcePoolNodeBatchResizeSourceCreatingStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolNodeBatchResizeSourceCreatingStepArgs:
    def __init__(__self__, *,
                 step: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] step: Specifies the step number of the nodes.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the nodes.  
               The valid values are as follows:
               + **hyperinstance**
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the step number of the nodes.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "step", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the nodes.  
        The valid values are as follows:
        + **hyperinstance**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourcePoolNodeBatchResizeTargetArgsDict(TypedDict):
        creating_step: pulumi.Input['ResourcePoolNodeBatchResizeTargetCreatingStepArgsDict']
        """
        Specifies the creating step of the node pool.  
        The creating_step structure is documented below.

        <a name="resource_pool_node_batch_resize_source_creating_step"></a>
        The `creating_step` block supports:
        """
        flavor: pulumi.Input[_builtins.str]
        """
        Specifies the flavor of the node pool.
        """
        node_pool: pulumi.Input[_builtins.str]
        """
        Specifies the name of the node pool.
        """
elif False:
    ResourcePoolNodeBatchResizeTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolNodeBatchResizeTargetArgs:
    def __init__(__self__, *,
                 creating_step: pulumi.Input['ResourcePoolNodeBatchResizeTargetCreatingStepArgs'],
                 flavor: pulumi.Input[_builtins.str],
                 node_pool: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['ResourcePoolNodeBatchResizeTargetCreatingStepArgs'] creating_step: Specifies the creating step of the node pool.  
               The creating_step structure is documented below.
               
               <a name="resource_pool_node_batch_resize_source_creating_step"></a>
               The `creating_step` block supports:
        :param pulumi.Input[_builtins.str] flavor: Specifies the flavor of the node pool.
        :param pulumi.Input[_builtins.str] node_pool: Specifies the name of the node pool.
        """
        pulumi.set(__self__, "creating_step", creating_step)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_pool", node_pool)

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> pulumi.Input['ResourcePoolNodeBatchResizeTargetCreatingStepArgs']:
        """
        Specifies the creating step of the node pool.  
        The creating_step structure is documented below.

        <a name="resource_pool_node_batch_resize_source_creating_step"></a>
        The `creating_step` block supports:
        """
        return pulumi.get(self, "creating_step")

    @creating_step.setter
    def creating_step(self, value: pulumi.Input['ResourcePoolNodeBatchResizeTargetCreatingStepArgs']):
        pulumi.set(self, "creating_step", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the flavor of the node pool.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the node pool.
        """
        return pulumi.get(self, "node_pool")

    @node_pool.setter
    def node_pool(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "node_pool", value)


if not MYPY:
    class ResourcePoolNodeBatchResizeTargetCreatingStepArgsDict(TypedDict):
        step: pulumi.Input[_builtins.int]
        """
        Specifies the step number of the nodes.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the nodes.  
        The valid values are as follows:
        + **hyperinstance**
        """
elif False:
    ResourcePoolNodeBatchResizeTargetCreatingStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolNodeBatchResizeTargetCreatingStepArgs:
    def __init__(__self__, *,
                 step: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] step: Specifies the step number of the nodes.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the nodes.  
               The valid values are as follows:
               + **hyperinstance**
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the step number of the nodes.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "step", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the nodes.  
        The valid values are as follows:
        + **hyperinstance**
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourcePoolResourceArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        flavor_id: pulumi.Input[_builtins.str]
        """
        Specifies the resource flavor ID.
        """
        azs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceAzArgsDict']]]]
        """
        Specifies the AZs for resource pool nodes.
        The azs structure is documented below.
        """
        creating_step: NotRequired[pulumi.Input['ResourcePoolResourceCreatingStepArgsDict']]
        """
        Specifies the creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.

        <a name="ModelartsResourcePool_Resources_azs"></a>
        The `azs` block supports:
        """
        data_volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceDataVolumeArgsDict']]]]
        """
        Specifies the data volumes of the resource pool nodes.  
        The data_volumes structure is documented below.
        """
        driver: NotRequired[pulumi.Input['ResourcePoolResourceDriverArgsDict']]
        """
        Specifies the driver information.  
        The driver structure is documented below.
        """
        extend_params: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the extend parameters of the data volume.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the labels of resource pool nodes.
        """
        max_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the max number of resources of the corresponding flavors.
        This parameter must be an integer multiple of `resources.creating_step.step`.
        """
        node_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of resource pool nodes. It can contain `1` to `50`
        characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
        hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
        os: NotRequired[pulumi.Input['ResourcePoolResourceOsArgsDict']]
        """
        Specifies the image information for the specified OS.  
        The os structure is documented below.
        """
        post_install: NotRequired[pulumi.Input[_builtins.str]]
        """
        The script to be executed after security.
        """
        root_volume: NotRequired[pulumi.Input['ResourcePoolResourceRootVolumeArgsDict']]
        """
        Specifies the root volume of the resource pool nodes.  
        The root_volume structure is documented below.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the security group IDs. It can not be specified when `network_id` is
        specified.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the network ID of a subnet. It is mandatory when
        `resources.security_group_ids`is specified, and can not be specified when `network_id` is specified.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the key/value pairs to associate with the resource pool. It can not be specified
        when `network_id` is specified.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceTaintArgsDict']]]]
        """
        Specifies the taints added to nodes. It can not be specified when `network_id` is specified.
        The taints structure is documented below.
        """
        volume_group_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceVolumeGroupConfigArgsDict']]]]
        """
        Specifies the extend configurations of the volume groups.  
        The volume_group_configs structure is documented below.
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the VPC ID. It is mandatory when `resources.subnet_id`,
        `resources.security_group_ids` is specified, and can not be specified when `network_id` is specified.
        """
elif False:
    ResourcePoolResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 flavor_id: pulumi.Input[_builtins.str],
                 azs: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceAzArgs']]]] = None,
                 creating_step: Optional[pulumi.Input['ResourcePoolResourceCreatingStepArgs']] = None,
                 data_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceDataVolumeArgs']]]] = None,
                 driver: Optional[pulumi.Input['ResourcePoolResourceDriverArgs']] = None,
                 extend_params: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_count: Optional[pulumi.Input[_builtins.int]] = None,
                 node_pool: Optional[pulumi.Input[_builtins.str]] = None,
                 os: Optional[pulumi.Input['ResourcePoolResourceOsArgs']] = None,
                 post_install: Optional[pulumi.Input[_builtins.str]] = None,
                 root_volume: Optional[pulumi.Input['ResourcePoolResourceRootVolumeArgs']] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceTaintArgs']]]] = None,
                 volume_group_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceVolumeGroupConfigArgs']]]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Specifies the count of the current data volume configuration.
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
               The `volume_group_configs` block supports:
        :param pulumi.Input[_builtins.str] flavor_id: Specifies the resource flavor ID.
        :param pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceAzArgs']]] azs: Specifies the AZs for resource pool nodes.
               The azs structure is documented below.
        :param pulumi.Input['ResourcePoolResourceCreatingStepArgs'] creating_step: Specifies the creation step configuration of the resource pool nodes.  
               The creating_step structure is documented below.
               
               <a name="ModelartsResourcePool_Resources_azs"></a>
               The `azs` block supports:
        :param pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceDataVolumeArgs']]] data_volumes: Specifies the data volumes of the resource pool nodes.  
               The data_volumes structure is documented below.
        :param pulumi.Input['ResourcePoolResourceDriverArgs'] driver: Specifies the driver information.  
               The driver structure is documented below.
        :param pulumi.Input[_builtins.str] extend_params: Specifies the extend parameters of the data volume.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Specifies the labels of resource pool nodes.
        :param pulumi.Input[_builtins.int] max_count: Specifies the max number of resources of the corresponding flavors.
               This parameter must be an integer multiple of `resources.creating_step.step`.
        :param pulumi.Input[_builtins.str] node_pool: Specifies the name of resource pool nodes. It can contain `1` to `50`
               characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
               hyphens (-) are allowed, and cannot end with a hyphen (-).
        :param pulumi.Input['ResourcePoolResourceOsArgs'] os: Specifies the image information for the specified OS.  
               The os structure is documented below.
        :param pulumi.Input[_builtins.str] post_install: The script to be executed after security.
        :param pulumi.Input['ResourcePoolResourceRootVolumeArgs'] root_volume: Specifies the root volume of the resource pool nodes.  
               The root_volume structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: Specifies the security group IDs. It can not be specified when `network_id` is
               specified.
        :param pulumi.Input[_builtins.str] subnet_id: Specifies the network ID of a subnet. It is mandatory when
               `resources.security_group_ids`is specified, and can not be specified when `network_id` is specified.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Specifies the key/value pairs to associate with the resource pool. It can not be specified
               when `network_id` is specified.
        :param pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceTaintArgs']]] taints: Specifies the taints added to nodes. It can not be specified when `network_id` is specified.
               The taints structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceVolumeGroupConfigArgs']]] volume_group_configs: Specifies the extend configurations of the volume groups.  
               The volume_group_configs structure is documented below.
        :param pulumi.Input[_builtins.str] vpc_id: Specifies the VPC ID. It is mandatory when `resources.subnet_id`,
               `resources.security_group_ids` is specified, and can not be specified when `network_id` is specified.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "flavor_id", flavor_id)
        if azs is not None:
            pulumi.set(__self__, "azs", azs)
        if creating_step is not None:
            pulumi.set(__self__, "creating_step", creating_step)
        if data_volumes is not None:
            pulumi.set(__self__, "data_volumes", data_volumes)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if node_pool is not None:
            pulumi.set(__self__, "node_pool", node_pool)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if post_install is not None:
            pulumi.set(__self__, "post_install", post_install)
        if root_volume is not None:
            pulumi.set(__self__, "root_volume", root_volume)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if volume_group_configs is not None:
            pulumi.set(__self__, "volume_group_configs", volume_group_configs)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the resource flavor ID.
        """
        return pulumi.get(self, "flavor_id")

    @flavor_id.setter
    def flavor_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor_id", value)

    @_builtins.property
    @pulumi.getter
    def azs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceAzArgs']]]]:
        """
        Specifies the AZs for resource pool nodes.
        The azs structure is documented below.
        """
        return pulumi.get(self, "azs")

    @azs.setter
    def azs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceAzArgs']]]]):
        pulumi.set(self, "azs", value)

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> Optional[pulumi.Input['ResourcePoolResourceCreatingStepArgs']]:
        """
        Specifies the creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.

        <a name="ModelartsResourcePool_Resources_azs"></a>
        The `azs` block supports:
        """
        return pulumi.get(self, "creating_step")

    @creating_step.setter
    def creating_step(self, value: Optional[pulumi.Input['ResourcePoolResourceCreatingStepArgs']]):
        pulumi.set(self, "creating_step", value)

    @_builtins.property
    @pulumi.getter(name="dataVolumes")
    def data_volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceDataVolumeArgs']]]]:
        """
        Specifies the data volumes of the resource pool nodes.  
        The data_volumes structure is documented below.
        """
        return pulumi.get(self, "data_volumes")

    @data_volumes.setter
    def data_volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceDataVolumeArgs']]]]):
        pulumi.set(self, "data_volumes", value)

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional[pulumi.Input['ResourcePoolResourceDriverArgs']]:
        """
        Specifies the driver information.  
        The driver structure is documented below.
        """
        return pulumi.get(self, "driver")

    @driver.setter
    def driver(self, value: Optional[pulumi.Input['ResourcePoolResourceDriverArgs']]):
        pulumi.set(self, "driver", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the extend parameters of the data volume.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_params", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the labels of resource pool nodes.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the max number of resources of the corresponding flavors.
        This parameter must be an integer multiple of `resources.creating_step.step`.
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_count", value)

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of resource pool nodes. It can contain `1` to `50`
        characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
        hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
        return pulumi.get(self, "node_pool")

    @node_pool.setter
    def node_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_pool", value)

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input['ResourcePoolResourceOsArgs']]:
        """
        Specifies the image information for the specified OS.  
        The os structure is documented below.
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input['ResourcePoolResourceOsArgs']]):
        pulumi.set(self, "os", value)

    @_builtins.property
    @pulumi.getter(name="postInstall")
    def post_install(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The script to be executed after security.
        """
        return pulumi.get(self, "post_install")

    @post_install.setter
    def post_install(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "post_install", value)

    @_builtins.property
    @pulumi.getter(name="rootVolume")
    def root_volume(self) -> Optional[pulumi.Input['ResourcePoolResourceRootVolumeArgs']]:
        """
        Specifies the root volume of the resource pool nodes.  
        The root_volume structure is documented below.
        """
        return pulumi.get(self, "root_volume")

    @root_volume.setter
    def root_volume(self, value: Optional[pulumi.Input['ResourcePoolResourceRootVolumeArgs']]):
        pulumi.set(self, "root_volume", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the security group IDs. It can not be specified when `network_id` is
        specified.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the network ID of a subnet. It is mandatory when
        `resources.security_group_ids`is specified, and can not be specified when `network_id` is specified.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the key/value pairs to associate with the resource pool. It can not be specified
        when `network_id` is specified.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceTaintArgs']]]]:
        """
        Specifies the taints added to nodes. It can not be specified when `network_id` is specified.
        The taints structure is documented below.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceTaintArgs']]]]):
        pulumi.set(self, "taints", value)

    @_builtins.property
    @pulumi.getter(name="volumeGroupConfigs")
    def volume_group_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceVolumeGroupConfigArgs']]]]:
        """
        Specifies the extend configurations of the volume groups.  
        The volume_group_configs structure is documented below.
        """
        return pulumi.get(self, "volume_group_configs")

    @volume_group_configs.setter
    def volume_group_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourcePoolResourceVolumeGroupConfigArgs']]]]):
        pulumi.set(self, "volume_group_configs", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the VPC ID. It is mandatory when `resources.subnet_id`,
        `resources.security_group_ids` is specified, and can not be specified when `network_id` is specified.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class ResourcePoolResourceAzArgsDict(TypedDict):
        az: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the AZ name.
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
elif False:
    ResourcePoolResourceAzArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceAzArgs:
    def __init__(__self__, *,
                 az: Optional[pulumi.Input[_builtins.str]] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] az: Specifies the AZ name.
        :param pulumi.Input[_builtins.int] count: Specifies the count of the current data volume configuration.
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
               The `volume_group_configs` block supports:
        """
        if az is not None:
            pulumi.set(__self__, "az", az)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def az(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the AZ name.
        """
        return pulumi.get(self, "az")

    @az.setter
    def az(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "az", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class ResourcePoolResourceCreatingStepArgsDict(TypedDict):
        step: pulumi.Input[_builtins.int]
        """
        Specifies the creation step of the resource pool nodes.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the resource pool nodes.
        The valid values are as follows:
        + **hyperinstance**

        <a name="ModelartsResourcePool_Clusters"></a>
        The `clusters` block supports:
        """
elif False:
    ResourcePoolResourceCreatingStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceCreatingStepArgs:
    def __init__(__self__, *,
                 step: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] step: Specifies the creation step of the resource pool nodes.
        :param pulumi.Input[_builtins.str] type: Specifies the type of the resource pool nodes.
               The valid values are as follows:
               + **hyperinstance**
               
               <a name="ModelartsResourcePool_Clusters"></a>
               The `clusters` block supports:
        """
        pulumi.set(__self__, "step", step)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def step(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the creation step of the resource pool nodes.
        """
        return pulumi.get(self, "step")

    @step.setter
    def step(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "step", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the resource pool nodes.
        The valid values are as follows:
        + **hyperinstance**

        <a name="ModelartsResourcePool_Clusters"></a>
        The `clusters` block supports:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourcePoolResourceDataVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.str]
        """
        Specifies the size of the data volume, e.g. **100Gi**.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the data volume.  
        The valid values are as follows:
        + **SSD**
        + **GPSSD**
        + **SAS**
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        extend_params: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the extend parameters of the data volume.
        """
elif False:
    ResourcePoolResourceDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceDataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.str],
                 volume_type: pulumi.Input[_builtins.str],
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 extend_params: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] size: Specifies the size of the data volume, e.g. **100Gi**.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the type of the data volume.  
               The valid values are as follows:
               + **SSD**
               + **GPSSD**
               + **SAS**
        :param pulumi.Input[_builtins.int] count: Specifies the count of the current data volume configuration.
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
               The `volume_group_configs` block supports:
        :param pulumi.Input[_builtins.str] extend_params: Specifies the extend parameters of the data volume.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the size of the data volume, e.g. **100Gi**.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the data volume.  
        The valid values are as follows:
        + **SSD**
        + **GPSSD**
        + **SAS**
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the count of the current data volume configuration.

        <a name="ModelartsResourcePool_Resources_volume_group_configs"></a>
        The `volume_group_configs` block supports:
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the extend parameters of the data volume.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_params", value)


if not MYPY:
    class ResourcePoolResourceDriverArgsDict(TypedDict):
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the driver version.

        <a name="ModelartsResourcePool_Resources_creating_step"></a>
        The `creating_step` block supports:
        """
elif False:
    ResourcePoolResourceDriverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceDriverArgs:
    def __init__(__self__, *,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] version: Specifies the driver version.
               
               <a name="ModelartsResourcePool_Resources_creating_step"></a>
               The `creating_step` block supports:
        """
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the driver version.

        <a name="ModelartsResourcePool_Resources_creating_step"></a>
        The `creating_step` block supports:
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ResourcePoolResourceOsArgsDict(TypedDict):
        image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image ID.
        """
        image_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image type.

        <a name="ModelartsResourcePool_Resources_driver"></a>
        The `driver` block supports:
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the OS name of the image.
        """
elif False:
    ResourcePoolResourceOsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceOsArgs:
    def __init__(__self__, *,
                 image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 image_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image_id: Specifies the image ID.
        :param pulumi.Input[_builtins.str] image_type: Specifies the image type.
               
               <a name="ModelartsResourcePool_Resources_driver"></a>
               The `driver` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the OS name of the image.
        """
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image ID.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image type.

        <a name="ModelartsResourcePool_Resources_driver"></a>
        The `driver` block supports:
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the OS name of the image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ResourcePoolResourceRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[_builtins.str]
        """
        Specifies the size of the data volume, e.g. **100Gi**.
        """
        volume_type: pulumi.Input[_builtins.str]
        """
        Specifies the type of the data volume.  
        The valid values are as follows:
        + **SSD**
        + **GPSSD**
        + **SAS**
        """
        extend_params: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the extend parameters of the data volume.
        """
elif False:
    ResourcePoolResourceRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[_builtins.str],
                 volume_type: pulumi.Input[_builtins.str],
                 extend_params: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] size: Specifies the size of the data volume, e.g. **100Gi**.
        :param pulumi.Input[_builtins.str] volume_type: Specifies the type of the data volume.  
               The valid values are as follows:
               + **SSD**
               + **GPSSD**
               + **SAS**
        :param pulumi.Input[_builtins.str] extend_params: Specifies the extend parameters of the data volume.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the size of the data volume, e.g. **100Gi**.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of the data volume.  
        The valid values are as follows:
        + **SSD**
        + **GPSSD**
        + **SAS**
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_type", value)

    @_builtins.property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the extend parameters of the data volume.
        """
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "extend_params", value)


if not MYPY:
    class ResourcePoolResourceTaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Specifies the effect of the taint. Value options: **NoSchedule**, **PreferNoSchedule**,
        **NoExecute**.

        <a name="ModelartsResourcePool_Resources_root_volume"></a>
        The `root_volume` block supports:
        """
        key: pulumi.Input[_builtins.str]
        """
        Specifies the key of the taint.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the value of the taint.
        """
elif False:
    ResourcePoolResourceTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Specifies the effect of the taint. Value options: **NoSchedule**, **PreferNoSchedule**,
               **NoExecute**.
               
               <a name="ModelartsResourcePool_Resources_root_volume"></a>
               The `root_volume` block supports:
        :param pulumi.Input[_builtins.str] key: Specifies the key of the taint.
        :param pulumi.Input[_builtins.str] value: Specifies the value of the taint.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the effect of the taint. Value options: **NoSchedule**, **PreferNoSchedule**,
        **NoExecute**.

        <a name="ModelartsResourcePool_Resources_root_volume"></a>
        The `root_volume` block supports:
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the key of the taint.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the value of the taint.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ResourcePoolResourceVolumeGroupConfigArgsDict(TypedDict):
        volume_group: pulumi.Input[_builtins.str]
        """
        Specifies the name of the volume group.  
        The valid values are as follows:
        + **vgpaas**
        + **default**
        + **vguser{num}**
        + **vg-everest-localvolume-persistent**
        + **vg-everest-localvolume-ephemeral**
        """
        docker_thin_pool: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the percentage of container volumes to data volumes on resource pool nodes.
        """
        lvm_config: NotRequired[pulumi.Input['ResourcePoolResourceVolumeGroupConfigLvmConfigArgsDict']]
        """
        Specifies the configuration of the LVM management.  
        The lvm_config structure is documented below.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the storage types of the volume group.  
        The valid values for the list elements are as follows:
        + **volume**
        + **local**

        <a name="ModelartsResourcePool_Resources_volume_group_configs_lvm_config"></a>
        The `lvm_config` block supports:
        """
elif False:
    ResourcePoolResourceVolumeGroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceVolumeGroupConfigArgs:
    def __init__(__self__, *,
                 volume_group: pulumi.Input[_builtins.str],
                 docker_thin_pool: Optional[pulumi.Input[_builtins.int]] = None,
                 lvm_config: Optional[pulumi.Input['ResourcePoolResourceVolumeGroupConfigLvmConfigArgs']] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] volume_group: Specifies the name of the volume group.  
               The valid values are as follows:
               + **vgpaas**
               + **default**
               + **vguser{num}**
               + **vg-everest-localvolume-persistent**
               + **vg-everest-localvolume-ephemeral**
        :param pulumi.Input[_builtins.int] docker_thin_pool: Specifies the percentage of container volumes to data volumes on resource pool nodes.
        :param pulumi.Input['ResourcePoolResourceVolumeGroupConfigLvmConfigArgs'] lvm_config: Specifies the configuration of the LVM management.  
               The lvm_config structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] types: Specifies the storage types of the volume group.  
               The valid values for the list elements are as follows:
               + **volume**
               + **local**
               
               <a name="ModelartsResourcePool_Resources_volume_group_configs_lvm_config"></a>
               The `lvm_config` block supports:
        """
        pulumi.set(__self__, "volume_group", volume_group)
        if docker_thin_pool is not None:
            pulumi.set(__self__, "docker_thin_pool", docker_thin_pool)
        if lvm_config is not None:
            pulumi.set(__self__, "lvm_config", lvm_config)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter(name="volumeGroup")
    def volume_group(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the volume group.  
        The valid values are as follows:
        + **vgpaas**
        + **default**
        + **vguser{num}**
        + **vg-everest-localvolume-persistent**
        + **vg-everest-localvolume-ephemeral**
        """
        return pulumi.get(self, "volume_group")

    @volume_group.setter
    def volume_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_group", value)

    @_builtins.property
    @pulumi.getter(name="dockerThinPool")
    def docker_thin_pool(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the percentage of container volumes to data volumes on resource pool nodes.
        """
        return pulumi.get(self, "docker_thin_pool")

    @docker_thin_pool.setter
    def docker_thin_pool(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "docker_thin_pool", value)

    @_builtins.property
    @pulumi.getter(name="lvmConfig")
    def lvm_config(self) -> Optional[pulumi.Input['ResourcePoolResourceVolumeGroupConfigLvmConfigArgs']]:
        """
        Specifies the configuration of the LVM management.  
        The lvm_config structure is documented below.
        """
        return pulumi.get(self, "lvm_config")

    @lvm_config.setter
    def lvm_config(self, value: Optional[pulumi.Input['ResourcePoolResourceVolumeGroupConfigLvmConfigArgs']]):
        pulumi.set(self, "lvm_config", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the storage types of the volume group.  
        The valid values for the list elements are as follows:
        + **volume**
        + **local**

        <a name="ModelartsResourcePool_Resources_volume_group_configs_lvm_config"></a>
        The `lvm_config` block supports:
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class ResourcePoolResourceVolumeGroupConfigLvmConfigArgsDict(TypedDict):
        lv_type: pulumi.Input[_builtins.str]
        """
        Specifies the LVM write mode.  
        The valid values are as follows:
        + **linear**
        + **striped**
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the volume mount path.

        <a name="ModelartsResourcePool_Resources_os_info"></a>
        The `os` block supports:
        """
elif False:
    ResourcePoolResourceVolumeGroupConfigLvmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourceVolumeGroupConfigLvmConfigArgs:
    def __init__(__self__, *,
                 lv_type: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] lv_type: Specifies the LVM write mode.  
               The valid values are as follows:
               + **linear**
               + **striped**
        :param pulumi.Input[_builtins.str] path: Specifies the volume mount path.
               
               <a name="ModelartsResourcePool_Resources_os_info"></a>
               The `os` block supports:
        """
        pulumi.set(__self__, "lv_type", lv_type)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="lvType")
    def lv_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the LVM write mode.  
        The valid values are as follows:
        + **linear**
        + **striped**
        """
        return pulumi.get(self, "lv_type")

    @lv_type.setter
    def lv_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lv_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the volume mount path.

        <a name="ModelartsResourcePool_Resources_os_info"></a>
        The `os` block supports:
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ResourcePoolResourcesOrderOriginArgsDict(TypedDict):
        creating_step: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.

        <a name="ModelartsResourcePool_Resources_azs"></a>
        The `azs` block supports:
        """
        flavor_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the resource flavor ID.
        """
        node_pool: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of resource pool nodes. It can contain `1` to `50`
        characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
        hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
elif False:
    ResourcePoolResourcesOrderOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolResourcesOrderOriginArgs:
    def __init__(__self__, *,
                 creating_step: Optional[pulumi.Input[_builtins.str]] = None,
                 flavor_id: Optional[pulumi.Input[_builtins.str]] = None,
                 node_pool: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] creating_step: Specifies the creation step configuration of the resource pool nodes.  
               The creating_step structure is documented below.
               
               <a name="ModelartsResourcePool_Resources_azs"></a>
               The `azs` block supports:
        :param pulumi.Input[_builtins.str] flavor_id: Specifies the resource flavor ID.
        :param pulumi.Input[_builtins.str] node_pool: Specifies the name of resource pool nodes. It can contain `1` to `50`
               characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
               hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
        if creating_step is not None:
            pulumi.set(__self__, "creating_step", creating_step)
        if flavor_id is not None:
            pulumi.set(__self__, "flavor_id", flavor_id)
        if node_pool is not None:
            pulumi.set(__self__, "node_pool", node_pool)

    @_builtins.property
    @pulumi.getter(name="creatingStep")
    def creating_step(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the creation step configuration of the resource pool nodes.  
        The creating_step structure is documented below.

        <a name="ModelartsResourcePool_Resources_azs"></a>
        The `azs` block supports:
        """
        return pulumi.get(self, "creating_step")

    @creating_step.setter
    def creating_step(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "creating_step", value)

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the resource flavor ID.
        """
        return pulumi.get(self, "flavor_id")

    @flavor_id.setter
    def flavor_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor_id", value)

    @_builtins.property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of resource pool nodes. It can contain `1` to `50`
        characters, and should start with a letter and ending with a letter or digit, only lowercase letters, digits,
        hyphens (-) are allowed, and cannot end with a hyphen (-).
        """
        return pulumi.get(self, "node_pool")

    @node_pool.setter
    def node_pool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_pool", value)


if not MYPY:
    class ResourcePoolUserLoginArgsDict(TypedDict):
        key_pair_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies key pair name of the login user.

        Changing this parameter will create a new resource.

        > **NOTE:** Exactly one of `password`, `key_pair_name` should be specified.

        <a name="ModelartsResourcePool_Metadata"></a>
        The `metadata` block supports:
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the password of the login user. The value needs to be salted,
        encrypted and base64 encoded. Default user is **root**.

        Changing this parameter will create a new resource.
        """
elif False:
    ResourcePoolUserLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePoolUserLoginArgs:
    def __init__(__self__, *,
                 key_pair_name: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key_pair_name: Specifies key pair name of the login user.
               
               Changing this parameter will create a new resource.
               
               > **NOTE:** Exactly one of `password`, `key_pair_name` should be specified.
               
               <a name="ModelartsResourcePool_Metadata"></a>
               The `metadata` block supports:
        :param pulumi.Input[_builtins.str] password: Specifies the password of the login user. The value needs to be salted,
               encrypted and base64 encoded. Default user is **root**.
               
               Changing this parameter will create a new resource.
        """
        if key_pair_name is not None:
            pulumi.set(__self__, "key_pair_name", key_pair_name)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies key pair name of the login user.

        Changing this parameter will create a new resource.

        > **NOTE:** Exactly one of `password`, `key_pair_name` should be specified.

        <a name="ModelartsResourcePool_Metadata"></a>
        The `metadata` block supports:
        """
        return pulumi.get(self, "key_pair_name")

    @key_pair_name.setter
    def key_pair_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_pair_name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the password of the login user. The value needs to be salted,
        encrypted and base64 encoded. Default user is **root**.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class ServiceAdditionalPropertiesArgsDict(TypedDict):
        log_report_channels: NotRequired[pulumi.Input['ServiceAdditionalPropertiesLogReportChannelsArgsDict']]
        """
        Advanced Log configuration.
        The LogReportChannel structure is documented below.

        <a name="ModelartsService_SmnNotification"></a>
        The `SmnNotification` block supports:
        """
        smn_notification: NotRequired[pulumi.Input['ServiceAdditionalPropertiesSmnNotificationArgsDict']]
        """
        SMN message notification configuration.
        The SmnNotification structure is documented below.
        """
elif False:
    ServiceAdditionalPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAdditionalPropertiesArgs:
    def __init__(__self__, *,
                 log_report_channels: Optional[pulumi.Input['ServiceAdditionalPropertiesLogReportChannelsArgs']] = None,
                 smn_notification: Optional[pulumi.Input['ServiceAdditionalPropertiesSmnNotificationArgs']] = None):
        """
        :param pulumi.Input['ServiceAdditionalPropertiesLogReportChannelsArgs'] log_report_channels: Advanced Log configuration.
               The LogReportChannel structure is documented below.
               
               <a name="ModelartsService_SmnNotification"></a>
               The `SmnNotification` block supports:
        :param pulumi.Input['ServiceAdditionalPropertiesSmnNotificationArgs'] smn_notification: SMN message notification configuration.
               The SmnNotification structure is documented below.
        """
        if log_report_channels is not None:
            pulumi.set(__self__, "log_report_channels", log_report_channels)
        if smn_notification is not None:
            pulumi.set(__self__, "smn_notification", smn_notification)

    @_builtins.property
    @pulumi.getter(name="logReportChannels")
    def log_report_channels(self) -> Optional[pulumi.Input['ServiceAdditionalPropertiesLogReportChannelsArgs']]:
        """
        Advanced Log configuration.
        The LogReportChannel structure is documented below.

        <a name="ModelartsService_SmnNotification"></a>
        The `SmnNotification` block supports:
        """
        return pulumi.get(self, "log_report_channels")

    @log_report_channels.setter
    def log_report_channels(self, value: Optional[pulumi.Input['ServiceAdditionalPropertiesLogReportChannelsArgs']]):
        pulumi.set(self, "log_report_channels", value)

    @_builtins.property
    @pulumi.getter(name="smnNotification")
    def smn_notification(self) -> Optional[pulumi.Input['ServiceAdditionalPropertiesSmnNotificationArgs']]:
        """
        SMN message notification configuration.
        The SmnNotification structure is documented below.
        """
        return pulumi.get(self, "smn_notification")

    @smn_notification.setter
    def smn_notification(self, value: Optional[pulumi.Input['ServiceAdditionalPropertiesSmnNotificationArgs']]):
        pulumi.set(self, "smn_notification", value)


if not MYPY:
    class ServiceAdditionalPropertiesLogReportChannelsArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
elif False:
    ServiceAdditionalPropertiesLogReportChannelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAdditionalPropertiesLogReportChannelsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of log report channel. The valid value is **LTS**.  
               If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
               If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
               for a maximum of seven days.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceAdditionalPropertiesSmnNotificationArgsDict(TypedDict):
        events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        Event ID.  
        Value options are as follows:
        + **1**: failed.
        + **2**: stopped.
        + **3**: running.
        + **7**: alarm.
        + **9**: deleted.
        + **11**: pending.

        <a name="ModelartsService_LogReportChannel"></a>
        The `LogReportChannel` block supports:
        """
        topic_urn: NotRequired[pulumi.Input[_builtins.str]]
        """
        URN of an SMN topic.
        """
elif False:
    ServiceAdditionalPropertiesSmnNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAdditionalPropertiesSmnNotificationArgs:
    def __init__(__self__, *,
                 events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 topic_urn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] events: Event ID.  
               Value options are as follows:
               + **1**: failed.
               + **2**: stopped.
               + **3**: running.
               + **7**: alarm.
               + **9**: deleted.
               + **11**: pending.
               
               <a name="ModelartsService_LogReportChannel"></a>
               The `LogReportChannel` block supports:
        :param pulumi.Input[_builtins.str] topic_urn: URN of an SMN topic.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if topic_urn is not None:
            pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        Event ID.  
        Value options are as follows:
        + **1**: failed.
        + **2**: stopped.
        + **3**: running.
        + **7**: alarm.
        + **9**: deleted.
        + **11**: pending.

        <a name="ModelartsService_LogReportChannel"></a>
        The `LogReportChannel` block supports:
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URN of an SMN topic.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic_urn", value)


if not MYPY:
    class ServiceConfigArgsDict(TypedDict):
        custom_spec: NotRequired[pulumi.Input['ServiceConfigCustomSpecArgsDict']]
        """
        Custom resource specifications.  
        The CustomSpec structure is documented below.
        """
        dest_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        OBS path to the output data of a batch job. Mandatory for batch services.
        """
        envs: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variable key-value pair required for running a model.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of instances deployed for a model.  
        The maximum number of instances is 5. To use more instances, submit a service ticket.
        """
        mapping_rule: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Mapping between input parameters and CSV data. Optional for batch services.  
        This parameter is mandatory only when mapping_type is set to csv.
        The mapping rule is similar to the definition of the input parameters in the config.json file.
        You only need to configure the index parameters under each parameter of the string, number, integer,
        or boolean type, and specify the value of this parameter to the values of the index parameters
        in the CSV file to send an inference request. Use commas (,) to separate multiple pieces of CSV data.
        The values of the index parameters start from 0. If the value of the index parameter is -1, ignore this parameter.
        For details, see the sample of creating a batch service.
        """
        mapping_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mapping type of the input data. Mandatory for batch services.  
        The value can be file or csv. file indicates that each inference request corresponds to a file
        in the input data directory.
        If this parameter is set to file, req_uri of the model can have only one input parameter and the type
        of this parameter is file.
        If this parameter is set to csv, each inference request corresponds to a row of data in the CSV file.
        When csv is used, the file in the input data directory can only be suffixed with .csv,
        and the mapping_rule parameter must be configured to map the index of each parameter in
        the inference request body to the CSV file.
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Model ID, which can be obtained by calling the API for obtaining a model list.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Edge node ID array. Mandatory for edge services.  
        The node ID is the edge node ID on IEF, which can be obtained after the edge node is created on IEF.
        """
        pool_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the new dedicated resource pool.  
        When using dedicated resource pool to deploy services, ensure that the cluster status is normal.
        If both `pool_name` and `config.pool_name` are configured, `pool_name` in real-time config is preferred.
        """
        req_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inference API called in a batch task, which is the RESTful API exposed in the model image.
        Mandatory for batch services.
        You must select an API URL from the config.json file of the model for inference.
        If a built-in inference image of ModelArts is used, the API is displayed as /.
        """
        specification: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource flavors.  
        The valid values are **modelarts.vm.cpu.2u**, **modelarts.vm.gpu.p4** (must be requested for),
        **modelsarts.vm.ai1.a310** (must be requested for),
        and **custom** (available only when the service is deployed in a dedicated resource pool) in the current version.
        To request for a flavor, submit a service ticket and obtain permissions from ModelArts O&M engineers.
        If this parameter is set to custom, the custom_spec parameter must be specified.
        Value options are as follows:
        + **modelarts.vm.cpu.free**: [Time-limited free] CPU: 1 vCPUs | 4 GiB.
        + **modelarts.vm.cpu.2u**: CPU: 2 vCPUs | 8 GiB.
        + **modelarts.vm.gpu.p4**: CPU: 1 vCPUs | 4 GiB GPUP4 (must be requested for).
        + **modelarts.vm.gpu.p4u8.container**: CPU: 8 vCPUs | 32 GiB GPUP4.
        + **modelarts.vm.gpu.t4u8.container**: CPU: 8 vCPUs | 32 GiB GPUT4.
        + **custom**: available only when the service is deployed in a dedicated resource pool,
        and the `custom_spec` parameter must be specified.
        """
        src_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        OBS path to the input data of a batch job.  
        Mandatory for batch services.
        """
        src_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Data source type, which can be ManifestFile. Mandatory for batch services.  
        By default, this parameter is left blank, indicating that only files in the src_path directory are read.
        If this parameter is set to ManifestFile, src_path must be set to a specific manifest path.
        Multiple data paths can be specified in the manifest file. For details, see the manifest inference specifications.
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        Weight of traffic allocated to a model.  
        This parameter is mandatory only when `infer_type` is set to **real-time**.
        The sum of all weights must be equal to 100. If multiple model versions are configured with different
        traffic weights in a real-time service, ModelArts will continuously access the prediction API of the
        service and forward prediction requests to the model instances of the corresponding versions based on the weights.
        """
elif False:
    ServiceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConfigArgs:
    def __init__(__self__, *,
                 custom_spec: Optional[pulumi.Input['ServiceConfigCustomSpecArgs']] = None,
                 dest_path: Optional[pulumi.Input[_builtins.str]] = None,
                 envs: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 mapping_rule: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 mapping_type: Optional[pulumi.Input[_builtins.str]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pool_name: Optional[pulumi.Input[_builtins.str]] = None,
                 req_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 specification: Optional[pulumi.Input[_builtins.str]] = None,
                 src_path: Optional[pulumi.Input[_builtins.str]] = None,
                 src_type: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['ServiceConfigCustomSpecArgs'] custom_spec: Custom resource specifications.  
               The CustomSpec structure is documented below.
        :param pulumi.Input[_builtins.str] dest_path: OBS path to the output data of a batch job. Mandatory for batch services.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] envs: Environment variable key-value pair required for running a model.
        :param pulumi.Input[_builtins.int] instance_count: Number of instances deployed for a model.  
               The maximum number of instances is 5. To use more instances, submit a service ticket.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] mapping_rule: Mapping between input parameters and CSV data. Optional for batch services.  
               This parameter is mandatory only when mapping_type is set to csv.
               The mapping rule is similar to the definition of the input parameters in the config.json file.
               You only need to configure the index parameters under each parameter of the string, number, integer,
               or boolean type, and specify the value of this parameter to the values of the index parameters
               in the CSV file to send an inference request. Use commas (,) to separate multiple pieces of CSV data.
               The values of the index parameters start from 0. If the value of the index parameter is -1, ignore this parameter.
               For details, see the sample of creating a batch service.
        :param pulumi.Input[_builtins.str] mapping_type: Mapping type of the input data. Mandatory for batch services.  
               The value can be file or csv. file indicates that each inference request corresponds to a file
               in the input data directory.
               If this parameter is set to file, req_uri of the model can have only one input parameter and the type
               of this parameter is file.
               If this parameter is set to csv, each inference request corresponds to a row of data in the CSV file.
               When csv is used, the file in the input data directory can only be suffixed with .csv,
               and the mapping_rule parameter must be configured to map the index of each parameter in
               the inference request body to the CSV file.
        :param pulumi.Input[_builtins.str] model_id: Model ID, which can be obtained by calling the API for obtaining a model list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nodes: Edge node ID array. Mandatory for edge services.  
               The node ID is the edge node ID on IEF, which can be obtained after the edge node is created on IEF.
        :param pulumi.Input[_builtins.str] pool_name: The ID of the new dedicated resource pool.  
               When using dedicated resource pool to deploy services, ensure that the cluster status is normal.
               If both `pool_name` and `config.pool_name` are configured, `pool_name` in real-time config is preferred.
        :param pulumi.Input[_builtins.str] req_uri: Inference API called in a batch task, which is the RESTful API exposed in the model image.
               Mandatory for batch services.
               You must select an API URL from the config.json file of the model for inference.
               If a built-in inference image of ModelArts is used, the API is displayed as /.
        :param pulumi.Input[_builtins.str] specification: Resource flavors.  
               The valid values are **modelarts.vm.cpu.2u**, **modelarts.vm.gpu.p4** (must be requested for),
               **modelsarts.vm.ai1.a310** (must be requested for),
               and **custom** (available only when the service is deployed in a dedicated resource pool) in the current version.
               To request for a flavor, submit a service ticket and obtain permissions from ModelArts O&M engineers.
               If this parameter is set to custom, the custom_spec parameter must be specified.
               Value options are as follows:
               + **modelarts.vm.cpu.free**: [Time-limited free] CPU: 1 vCPUs | 4 GiB.
               + **modelarts.vm.cpu.2u**: CPU: 2 vCPUs | 8 GiB.
               + **modelarts.vm.gpu.p4**: CPU: 1 vCPUs | 4 GiB GPUP4 (must be requested for).
               + **modelarts.vm.gpu.p4u8.container**: CPU: 8 vCPUs | 32 GiB GPUP4.
               + **modelarts.vm.gpu.t4u8.container**: CPU: 8 vCPUs | 32 GiB GPUT4.
               + **custom**: available only when the service is deployed in a dedicated resource pool,
               and the `custom_spec` parameter must be specified.
        :param pulumi.Input[_builtins.str] src_path: OBS path to the input data of a batch job.  
               Mandatory for batch services.
        :param pulumi.Input[_builtins.str] src_type: Data source type, which can be ManifestFile. Mandatory for batch services.  
               By default, this parameter is left blank, indicating that only files in the src_path directory are read.
               If this parameter is set to ManifestFile, src_path must be set to a specific manifest path.
               Multiple data paths can be specified in the manifest file. For details, see the manifest inference specifications.
        :param pulumi.Input[_builtins.int] weight: Weight of traffic allocated to a model.  
               This parameter is mandatory only when `infer_type` is set to **real-time**.
               The sum of all weights must be equal to 100. If multiple model versions are configured with different
               traffic weights in a real-time service, ModelArts will continuously access the prediction API of the
               service and forward prediction requests to the model instances of the corresponding versions based on the weights.
        """
        if custom_spec is not None:
            pulumi.set(__self__, "custom_spec", custom_spec)
        if dest_path is not None:
            pulumi.set(__self__, "dest_path", dest_path)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if mapping_rule is not None:
            pulumi.set(__self__, "mapping_rule", mapping_rule)
        if mapping_type is not None:
            pulumi.set(__self__, "mapping_type", mapping_type)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if pool_name is not None:
            pulumi.set(__self__, "pool_name", pool_name)
        if req_uri is not None:
            pulumi.set(__self__, "req_uri", req_uri)
        if specification is not None:
            pulumi.set(__self__, "specification", specification)
        if src_path is not None:
            pulumi.set(__self__, "src_path", src_path)
        if src_type is not None:
            pulumi.set(__self__, "src_type", src_type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="customSpec")
    def custom_spec(self) -> Optional[pulumi.Input['ServiceConfigCustomSpecArgs']]:
        """
        Custom resource specifications.  
        The CustomSpec structure is documented below.
        """
        return pulumi.get(self, "custom_spec")

    @custom_spec.setter
    def custom_spec(self, value: Optional[pulumi.Input['ServiceConfigCustomSpecArgs']]):
        pulumi.set(self, "custom_spec", value)

    @_builtins.property
    @pulumi.getter(name="destPath")
    def dest_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OBS path to the output data of a batch job. Mandatory for batch services.
        """
        return pulumi.get(self, "dest_path")

    @dest_path.setter
    def dest_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_path", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variable key-value pair required for running a model.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of instances deployed for a model.  
        The maximum number of instances is 5. To use more instances, submit a service ticket.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="mappingRule")
    def mapping_rule(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Mapping between input parameters and CSV data. Optional for batch services.  
        This parameter is mandatory only when mapping_type is set to csv.
        The mapping rule is similar to the definition of the input parameters in the config.json file.
        You only need to configure the index parameters under each parameter of the string, number, integer,
        or boolean type, and specify the value of this parameter to the values of the index parameters
        in the CSV file to send an inference request. Use commas (,) to separate multiple pieces of CSV data.
        The values of the index parameters start from 0. If the value of the index parameter is -1, ignore this parameter.
        For details, see the sample of creating a batch service.
        """
        return pulumi.get(self, "mapping_rule")

    @mapping_rule.setter
    def mapping_rule(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mapping_rule", value)

    @_builtins.property
    @pulumi.getter(name="mappingType")
    def mapping_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mapping type of the input data. Mandatory for batch services.  
        The value can be file or csv. file indicates that each inference request corresponds to a file
        in the input data directory.
        If this parameter is set to file, req_uri of the model can have only one input parameter and the type
        of this parameter is file.
        If this parameter is set to csv, each inference request corresponds to a row of data in the CSV file.
        When csv is used, the file in the input data directory can only be suffixed with .csv,
        and the mapping_rule parameter must be configured to map the index of each parameter in
        the inference request body to the CSV file.
        """
        return pulumi.get(self, "mapping_type")

    @mapping_type.setter
    def mapping_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mapping_type", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Model ID, which can be obtained by calling the API for obtaining a model list.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Edge node ID array. Mandatory for edge services.  
        The node ID is the edge node ID on IEF, which can be obtained after the edge node is created on IEF.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter(name="poolName")
    def pool_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the new dedicated resource pool.  
        When using dedicated resource pool to deploy services, ensure that the cluster status is normal.
        If both `pool_name` and `config.pool_name` are configured, `pool_name` in real-time config is preferred.
        """
        return pulumi.get(self, "pool_name")

    @pool_name.setter
    def pool_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pool_name", value)

    @_builtins.property
    @pulumi.getter(name="reqUri")
    def req_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inference API called in a batch task, which is the RESTful API exposed in the model image.
        Mandatory for batch services.
        You must select an API URL from the config.json file of the model for inference.
        If a built-in inference image of ModelArts is used, the API is displayed as /.
        """
        return pulumi.get(self, "req_uri")

    @req_uri.setter
    def req_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "req_uri", value)

    @_builtins.property
    @pulumi.getter
    def specification(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource flavors.  
        The valid values are **modelarts.vm.cpu.2u**, **modelarts.vm.gpu.p4** (must be requested for),
        **modelsarts.vm.ai1.a310** (must be requested for),
        and **custom** (available only when the service is deployed in a dedicated resource pool) in the current version.
        To request for a flavor, submit a service ticket and obtain permissions from ModelArts O&M engineers.
        If this parameter is set to custom, the custom_spec parameter must be specified.
        Value options are as follows:
        + **modelarts.vm.cpu.free**: [Time-limited free] CPU: 1 vCPUs | 4 GiB.
        + **modelarts.vm.cpu.2u**: CPU: 2 vCPUs | 8 GiB.
        + **modelarts.vm.gpu.p4**: CPU: 1 vCPUs | 4 GiB GPUP4 (must be requested for).
        + **modelarts.vm.gpu.p4u8.container**: CPU: 8 vCPUs | 32 GiB GPUP4.
        + **modelarts.vm.gpu.t4u8.container**: CPU: 8 vCPUs | 32 GiB GPUT4.
        + **custom**: available only when the service is deployed in a dedicated resource pool,
        and the `custom_spec` parameter must be specified.
        """
        return pulumi.get(self, "specification")

    @specification.setter
    def specification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "specification", value)

    @_builtins.property
    @pulumi.getter(name="srcPath")
    def src_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OBS path to the input data of a batch job.  
        Mandatory for batch services.
        """
        return pulumi.get(self, "src_path")

    @src_path.setter
    def src_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_path", value)

    @_builtins.property
    @pulumi.getter(name="srcType")
    def src_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Data source type, which can be ManifestFile. Mandatory for batch services.  
        By default, this parameter is left blank, indicating that only files in the src_path directory are read.
        If this parameter is set to ManifestFile, src_path must be set to a specific manifest path.
        Multiple data paths can be specified in the manifest file. For details, see the manifest inference specifications.
        """
        return pulumi.get(self, "src_type")

    @src_type.setter
    def src_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_type", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Weight of traffic allocated to a model.  
        This parameter is mandatory only when `infer_type` is set to **real-time**.
        The sum of all weights must be equal to 100. If multiple model versions are configured with different
        traffic weights in a real-time service, ModelArts will continuously access the prediction API of the
        service and forward prediction requests to the model instances of the corresponding versions based on the weights.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ServiceConfigCustomSpecArgsDict(TypedDict):
        ascend_a310: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of Ascend chips. Either this parameter or `gpu_p4` is configured.

        <a name="ModelartsService_Schedule"></a>
        The `Schedule` block supports:
        """
        cpu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of CPU cores, which can be a decimal. The value cannot be smaller than 0.01.
        """
        gpu_p4: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of GPU cores, which can be a decimal.  
        The value cannot be smaller than 0, which allows up to two decimal places.
        """
        memory: NotRequired[pulumi.Input[_builtins.int]]
        """
        Memory in MB, which must be an integer.
        """
elif False:
    ServiceConfigCustomSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConfigCustomSpecArgs:
    def __init__(__self__, *,
                 ascend_a310: Optional[pulumi.Input[_builtins.int]] = None,
                 cpu: Optional[pulumi.Input[_builtins.float]] = None,
                 gpu_p4: Optional[pulumi.Input[_builtins.float]] = None,
                 memory: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] ascend_a310: Number of Ascend chips. Either this parameter or `gpu_p4` is configured.
               
               <a name="ModelartsService_Schedule"></a>
               The `Schedule` block supports:
        :param pulumi.Input[_builtins.float] cpu: Number of CPU cores, which can be a decimal. The value cannot be smaller than 0.01.
        :param pulumi.Input[_builtins.float] gpu_p4: Number of GPU cores, which can be a decimal.  
               The value cannot be smaller than 0, which allows up to two decimal places.
        :param pulumi.Input[_builtins.int] memory: Memory in MB, which must be an integer.
        """
        if ascend_a310 is not None:
            pulumi.set(__self__, "ascend_a310", ascend_a310)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if gpu_p4 is not None:
            pulumi.set(__self__, "gpu_p4", gpu_p4)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="ascendA310")
    def ascend_a310(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of Ascend chips. Either this parameter or `gpu_p4` is configured.

        <a name="ModelartsService_Schedule"></a>
        The `Schedule` block supports:
        """
        return pulumi.get(self, "ascend_a310")

    @ascend_a310.setter
    def ascend_a310(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ascend_a310", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of CPU cores, which can be a decimal. The value cannot be smaller than 0.01.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter(name="gpuP4")
    def gpu_p4(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of GPU cores, which can be a decimal.  
        The value cannot be smaller than 0, which allows up to two decimal places.
        """
        return pulumi.get(self, "gpu_p4")

    @gpu_p4.setter
    def gpu_p4(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "gpu_p4", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Memory in MB, which must be an integer.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class ServiceScheduleArgsDict(TypedDict):
        duration: pulumi.Input[_builtins.int]
        """
        Value mapping a time unit.  
        For example, if the task stops after two hours, set time_unit to HOURS and duration to 2.
        """
        time_unit: pulumi.Input[_builtins.str]
        """
        Scheduling time unit. Possible values are DAYS, HOURS, and MINUTES.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
elif False:
    ServiceScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceScheduleArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[_builtins.int],
                 time_unit: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] duration: Value mapping a time unit.  
               For example, if the task stops after two hours, set time_unit to HOURS and duration to 2.
        :param pulumi.Input[_builtins.str] time_unit: Scheduling time unit. Possible values are DAYS, HOURS, and MINUTES.
        :param pulumi.Input[_builtins.str] type: The type of log report channel. The valid value is **LTS**.  
               If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
               If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
               for a maximum of seven days.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "time_unit", time_unit)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input[_builtins.int]:
        """
        Value mapping a time unit.  
        For example, if the task stops after two hours, set time_unit to HOURS and duration to 2.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> pulumi.Input[_builtins.str]:
        """
        Scheduling time unit. Possible values are DAYS, HOURS, and MINUTES.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_unit", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of log report channel. The valid value is **LTS**.  
        If this parameter is configured, the advanced log management service, Log Tank Service (LTS) will be used.
        If not, the ModelArts log system will be used, which provides simple log query and caches runtime logs
        for a maximum of seven days.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceV2GroupConfigArgsDict(TypedDict):
        count: pulumi.Input[_builtins.int]
        """
        Specifies the instance number of the group unit.
        """
        name: pulumi.Input[_builtins.str]
        """
        Specifies the name of the instance group.  
        The valid length is limited from `1` to `64`, only English letters, Chinese characters, digits, hyphens (-) and
        underscores (_) are allowed.
        """
        unit_configs: pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigArgsDict']]]
        """
        Specifies the unit configurations of the instance group.  
        The unit_configs structure is documented below.
        When the unit is used for **SINGLE** deploy type, the length of `unit_configs` is `1`.
        When used for **SINGLE** and **DIST** deploy type, the number of units configuration depending on the framework.
        """
        weight: pulumi.Input[_builtins.int]
        """
        Specifies the weight percentage of the instance group.

        > The sum of all group weights must be `100`.
        """
        framework: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the algorithm framework.  
        The valid values are as follows:
        + **COMMON**
        + **VLLM**
        + **MINDIE**

        > Updates to the `name`, `pool_id` and `framework` parameters in existing group configurations are not supported, but
        new group configurations and remove existing group configurations are not limited.

        <a name="v2_service_unit_configs"></a>
        The `unit_configs` block supports:
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        pool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the dedicated resource pool for the instance group.
        """
elif False:
    ServiceV2GroupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 unit_configs: pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigArgs']]],
                 weight: pulumi.Input[_builtins.int],
                 framework: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 pool_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] count: Specifies the instance number of the group unit.
        :param pulumi.Input[_builtins.str] name: Specifies the name of the instance group.  
               The valid length is limited from `1` to `64`, only English letters, Chinese characters, digits, hyphens (-) and
               underscores (_) are allowed.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigArgs']]] unit_configs: Specifies the unit configurations of the instance group.  
               The unit_configs structure is documented below.
               When the unit is used for **SINGLE** deploy type, the length of `unit_configs` is `1`.
               When used for **SINGLE** and **DIST** deploy type, the number of units configuration depending on the framework.
        :param pulumi.Input[_builtins.int] weight: Specifies the weight percentage of the instance group.
               
               > The sum of all group weights must be `100`.
        :param pulumi.Input[_builtins.str] framework: Specifies the algorithm framework.  
               The valid values are as follows:
               + **COMMON**
               + **VLLM**
               + **MINDIE**
               
               > Updates to the `name`, `pool_id` and `framework` parameters in existing group configurations are not supported, but
               new group configurations and remove existing group configurations are not limited.
               
               <a name="v2_service_unit_configs"></a>
               The `unit_configs` block supports:
        :param pulumi.Input[_builtins.str] id: Specifies the image ID of the group unit.  
               Only available if the value of parameter `source` is **IMAGE**.
               
               <a name="v2_service_unit_config_custom_spec"></a>
               The `custom_spec` block supports:
        :param pulumi.Input[_builtins.str] pool_id: Specifies the ID of the dedicated resource pool for the instance group.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit_configs", unit_configs)
        pulumi.set(__self__, "weight", weight)
        if framework is not None:
            pulumi.set(__self__, "framework", framework)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the instance number of the group unit.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the name of the instance group.  
        The valid length is limited from `1` to `64`, only English letters, Chinese characters, digits, hyphens (-) and
        underscores (_) are allowed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="unitConfigs")
    def unit_configs(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigArgs']]]:
        """
        Specifies the unit configurations of the instance group.  
        The unit_configs structure is documented below.
        When the unit is used for **SINGLE** deploy type, the length of `unit_configs` is `1`.
        When used for **SINGLE** and **DIST** deploy type, the number of units configuration depending on the framework.
        """
        return pulumi.get(self, "unit_configs")

    @unit_configs.setter
    def unit_configs(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigArgs']]]):
        pulumi.set(self, "unit_configs", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the weight percentage of the instance group.

        > The sum of all group weights must be `100`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "weight", value)

    @_builtins.property
    @pulumi.getter
    def framework(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the algorithm framework.  
        The valid values are as follows:
        + **COMMON**
        + **VLLM**
        + **MINDIE**

        > Updates to the `name`, `pool_id` and `framework` parameters in existing group configurations are not supported, but
        new group configurations and remove existing group configurations are not limited.

        <a name="v2_service_unit_configs"></a>
        The `unit_configs` block supports:
        """
        return pulumi.get(self, "framework")

    @framework.setter
    def framework(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "framework", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the dedicated resource pool for the instance group.
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pool_id", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigArgsDict(TypedDict):
        image: pulumi.Input['ServiceV2GroupConfigUnitConfigImageArgsDict']
        """
        Specifies the image configuration of the group unit.  
        The image structure is documented below.
        """
        cmd: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the startup commands of the group unit.
        """
        codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigCodeArgsDict']]]]
        """
        Specifies the code configuration of the group unit.  
        The codes structure is documented below.
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the instance number of the group unit.
        """
        custom_spec: NotRequired[pulumi.Input['ServiceV2GroupConfigUnitConfigCustomSpecArgsDict']]
        """
        Specifies the configuration of the custom resource specification.  
        The custom_spec structure is documented below.
        """
        envs: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the environment variables of the group unit.
        """
        flavor: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the instance flavor of the group unit.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        liveness_health: NotRequired[pulumi.Input['ServiceV2GroupConfigUnitConfigLivenessHealthArgsDict']]
        """
        Specifies the configuration of the liveness health check.  
        The liveness_health structure is documented below.
        """
        models: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigModelArgsDict']]]]
        """
        Specifies the model configuration of the group unit.  
        The models structure is documented below.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the port of the group unit.
        """
        readiness_health: NotRequired[pulumi.Input['ServiceV2GroupConfigUnitConfigReadinessHealthArgsDict']]
        """
        Specifies the configuration of the readiness health check.  
        The readiness_health structure is documented below.
        """
        recovery: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the recovery strategy of the group unit.  
        The valid values are as follows:
        + **INSTANCE_GROUP**
        + **INSTANCE**

        > Updates to the `role` parameter in existing unit configurations are not supported, but new unit configurations and
        remove existing unit configurations are not limited.

        <a name="v2_service_unit_config_image"></a>
        The `image` block supports:
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the role of the group unit.  
        The valid values are as follows:
        + **SCHEDULER**: Scheduling unit, valid in the **MINDIE** framework.
        + **MANAGER**: Management unit, valid in the **MINDIE** framework.
        + **WORKER**: Work unit, valid in the **MINDIE** framework.
        + **PREFILL**: Total unit, valid in the **VLLM** framework.
        + **DECODE**: Incremental unit, valid in the **VLLM** framework.
        + **COMMON**: Others.
        """
        startup_health: NotRequired[pulumi.Input['ServiceV2GroupConfigUnitConfigStartupHealthArgsDict']]
        """
        Specifies the configuration of the startup health check.  
        The startup_health structure is documented below.
        """
elif False:
    ServiceV2GroupConfigUnitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigArgs:
    def __init__(__self__, *,
                 image: pulumi.Input['ServiceV2GroupConfigUnitConfigImageArgs'],
                 cmd: Optional[pulumi.Input[_builtins.str]] = None,
                 codes: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigCodeArgs']]]] = None,
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 custom_spec: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigCustomSpecArgs']] = None,
                 envs: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 flavor: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 liveness_health: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigLivenessHealthArgs']] = None,
                 models: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigModelArgs']]]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 readiness_health: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigReadinessHealthArgs']] = None,
                 recovery: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 startup_health: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigStartupHealthArgs']] = None):
        """
        :param pulumi.Input['ServiceV2GroupConfigUnitConfigImageArgs'] image: Specifies the image configuration of the group unit.  
               The image structure is documented below.
        :param pulumi.Input[_builtins.str] cmd: Specifies the startup commands of the group unit.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigCodeArgs']]] codes: Specifies the code configuration of the group unit.  
               The codes structure is documented below.
        :param pulumi.Input[_builtins.int] count: Specifies the instance number of the group unit.
        :param pulumi.Input['ServiceV2GroupConfigUnitConfigCustomSpecArgs'] custom_spec: Specifies the configuration of the custom resource specification.  
               The custom_spec structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] envs: Specifies the environment variables of the group unit.
        :param pulumi.Input[_builtins.str] flavor: Specifies the instance flavor of the group unit.
        :param pulumi.Input[_builtins.str] id: Specifies the image ID of the group unit.  
               Only available if the value of parameter `source` is **IMAGE**.
               
               <a name="v2_service_unit_config_custom_spec"></a>
               The `custom_spec` block supports:
        :param pulumi.Input['ServiceV2GroupConfigUnitConfigLivenessHealthArgs'] liveness_health: Specifies the configuration of the liveness health check.  
               The liveness_health structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigModelArgs']]] models: Specifies the model configuration of the group unit.  
               The models structure is documented below.
        :param pulumi.Input[_builtins.int] port: Specifies the port of the group unit.
        :param pulumi.Input['ServiceV2GroupConfigUnitConfigReadinessHealthArgs'] readiness_health: Specifies the configuration of the readiness health check.  
               The readiness_health structure is documented below.
        :param pulumi.Input[_builtins.str] recovery: Specifies the recovery strategy of the group unit.  
               The valid values are as follows:
               + **INSTANCE_GROUP**
               + **INSTANCE**
               
               > Updates to the `role` parameter in existing unit configurations are not supported, but new unit configurations and
               remove existing unit configurations are not limited.
               
               <a name="v2_service_unit_config_image"></a>
               The `image` block supports:
        :param pulumi.Input[_builtins.str] role: Specifies the role of the group unit.  
               The valid values are as follows:
               + **SCHEDULER**: Scheduling unit, valid in the **MINDIE** framework.
               + **MANAGER**: Management unit, valid in the **MINDIE** framework.
               + **WORKER**: Work unit, valid in the **MINDIE** framework.
               + **PREFILL**: Total unit, valid in the **VLLM** framework.
               + **DECODE**: Incremental unit, valid in the **VLLM** framework.
               + **COMMON**: Others.
        :param pulumi.Input['ServiceV2GroupConfigUnitConfigStartupHealthArgs'] startup_health: Specifies the configuration of the startup health check.  
               The startup_health structure is documented below.
        """
        pulumi.set(__self__, "image", image)
        if cmd is not None:
            pulumi.set(__self__, "cmd", cmd)
        if codes is not None:
            pulumi.set(__self__, "codes", codes)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if custom_spec is not None:
            pulumi.set(__self__, "custom_spec", custom_spec)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if liveness_health is not None:
            pulumi.set(__self__, "liveness_health", liveness_health)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if readiness_health is not None:
            pulumi.set(__self__, "readiness_health", readiness_health)
        if recovery is not None:
            pulumi.set(__self__, "recovery", recovery)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if startup_health is not None:
            pulumi.set(__self__, "startup_health", startup_health)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input['ServiceV2GroupConfigUnitConfigImageArgs']:
        """
        Specifies the image configuration of the group unit.  
        The image structure is documented below.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input['ServiceV2GroupConfigUnitConfigImageArgs']):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def cmd(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the startup commands of the group unit.
        """
        return pulumi.get(self, "cmd")

    @cmd.setter
    def cmd(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cmd", value)

    @_builtins.property
    @pulumi.getter
    def codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigCodeArgs']]]]:
        """
        Specifies the code configuration of the group unit.  
        The codes structure is documented below.
        """
        return pulumi.get(self, "codes")

    @codes.setter
    def codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigCodeArgs']]]]):
        pulumi.set(self, "codes", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the instance number of the group unit.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter(name="customSpec")
    def custom_spec(self) -> Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigCustomSpecArgs']]:
        """
        Specifies the configuration of the custom resource specification.  
        The custom_spec structure is documented below.
        """
        return pulumi.get(self, "custom_spec")

    @custom_spec.setter
    def custom_spec(self, value: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigCustomSpecArgs']]):
        pulumi.set(self, "custom_spec", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the environment variables of the group unit.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the instance flavor of the group unit.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="livenessHealth")
    def liveness_health(self) -> Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigLivenessHealthArgs']]:
        """
        Specifies the configuration of the liveness health check.  
        The liveness_health structure is documented below.
        """
        return pulumi.get(self, "liveness_health")

    @liveness_health.setter
    def liveness_health(self, value: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigLivenessHealthArgs']]):
        pulumi.set(self, "liveness_health", value)

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigModelArgs']]]]:
        """
        Specifies the model configuration of the group unit.  
        The models structure is documented below.
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceV2GroupConfigUnitConfigModelArgs']]]]):
        pulumi.set(self, "models", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the port of the group unit.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="readinessHealth")
    def readiness_health(self) -> Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigReadinessHealthArgs']]:
        """
        Specifies the configuration of the readiness health check.  
        The readiness_health structure is documented below.
        """
        return pulumi.get(self, "readiness_health")

    @readiness_health.setter
    def readiness_health(self, value: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigReadinessHealthArgs']]):
        pulumi.set(self, "readiness_health", value)

    @_builtins.property
    @pulumi.getter
    def recovery(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the recovery strategy of the group unit.  
        The valid values are as follows:
        + **INSTANCE_GROUP**
        + **INSTANCE**

        > Updates to the `role` parameter in existing unit configurations are not supported, but new unit configurations and
        remove existing unit configurations are not limited.

        <a name="v2_service_unit_config_image"></a>
        The `image` block supports:
        """
        return pulumi.get(self, "recovery")

    @recovery.setter
    def recovery(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recovery", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the role of the group unit.  
        The valid values are as follows:
        + **SCHEDULER**: Scheduling unit, valid in the **MINDIE** framework.
        + **MANAGER**: Management unit, valid in the **MINDIE** framework.
        + **WORKER**: Work unit, valid in the **MINDIE** framework.
        + **PREFILL**: Total unit, valid in the **VLLM** framework.
        + **DECODE**: Incremental unit, valid in the **VLLM** framework.
        + **COMMON**: Others.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="startupHealth")
    def startup_health(self) -> Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigStartupHealthArgs']]:
        """
        Specifies the configuration of the startup health check.  
        The startup_health structure is documented below.
        """
        return pulumi.get(self, "startup_health")

    @startup_health.setter
    def startup_health(self, value: Optional[pulumi.Input['ServiceV2GroupConfigUnitConfigStartupHealthArgs']]):
        pulumi.set(self, "startup_health", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigCodeArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        """
        Specifies the path to mount into the container.  
        The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
        backslash (\\\\) and dots (.).
        """
        source: pulumi.Input[_builtins.str]
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source address of the code configuration.  
        This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        """
        source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source ID of the code configuration.  
        This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
        **EFS**.

        <a name="v2_service_unit_config_health_check"></a>
        The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
elif False:
    ServiceV2GroupConfigUnitConfigCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigCodeArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mount_path: Specifies the path to mount into the container.  
               The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
               backslash (\\\\) and dots (.).
        :param pulumi.Input[_builtins.str] source: Specifies the source type of the code configuration.  
               The valid values are as follows:
               + **OBS**
               + **OBSFS**
               + **EFS**
               + **GIT**
        :param pulumi.Input[_builtins.str] address: Specifies the source address of the code configuration.  
               This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        :param pulumi.Input[_builtins.str] source_id: Specifies the source ID of the code configuration.  
               This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
               **EFS**.
               
               <a name="v2_service_unit_config_health_check"></a>
               The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "source", source)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the path to mount into the container.  
        The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
        backslash (\\\\) and dots (.).
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source address of the code configuration.  
        This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source ID of the code configuration.  
        This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
        **EFS**.

        <a name="v2_service_unit_config_health_check"></a>
        The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_id", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigCustomSpecArgsDict(TypedDict):
        ascend: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of Ascend chips.  
        This parameter cannot be configured together with `gpu`.

        <a name="v2_service_unit_config_models"></a>
        The `models` block supports:
        """
        cpu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the CPU number of the custom specification.
        The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        """
        gpu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies the GPU number of the custom specification.
        The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        """
        memory: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the memory size of the custom specification.
        """
elif False:
    ServiceV2GroupConfigUnitConfigCustomSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigCustomSpecArgs:
    def __init__(__self__, *,
                 ascend: Optional[pulumi.Input[_builtins.int]] = None,
                 cpu: Optional[pulumi.Input[_builtins.float]] = None,
                 gpu: Optional[pulumi.Input[_builtins.float]] = None,
                 memory: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] ascend: Specifies the number of Ascend chips.  
               This parameter cannot be configured together with `gpu`.
               
               <a name="v2_service_unit_config_models"></a>
               The `models` block supports:
        :param pulumi.Input[_builtins.float] cpu: Specifies the CPU number of the custom specification.
               The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        :param pulumi.Input[_builtins.float] gpu: Specifies the GPU number of the custom specification.
               The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        :param pulumi.Input[_builtins.int] memory: Specifies the memory size of the custom specification.
        """
        if ascend is not None:
            pulumi.set(__self__, "ascend", ascend)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def ascend(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of Ascend chips.  
        This parameter cannot be configured together with `gpu`.

        <a name="v2_service_unit_config_models"></a>
        The `models` block supports:
        """
        return pulumi.get(self, "ascend")

    @ascend.setter
    def ascend(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ascend", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the CPU number of the custom specification.
        The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies the GPU number of the custom specification.
        The input value must be greater than `0` and support two decimal places (the third decimal place will be rounded off).
        """
        return pulumi.get(self, "gpu")

    @gpu.setter
    def gpu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "gpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the memory size of the custom specification.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigImageArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        swr_path: pulumi.Input[_builtins.str]
        """
        Specifies the SWR storage path of the group unit.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
elif False:
    ServiceV2GroupConfigUnitConfigImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigImageArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 swr_path: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Specifies the source type of the code configuration.  
               The valid values are as follows:
               + **OBS**
               + **OBSFS**
               + **EFS**
               + **GIT**
        :param pulumi.Input[_builtins.str] swr_path: Specifies the SWR storage path of the group unit.
        :param pulumi.Input[_builtins.str] id: Specifies the image ID of the group unit.  
               Only available if the value of parameter `source` is **IMAGE**.
               
               <a name="v2_service_unit_config_custom_spec"></a>
               The `custom_spec` block supports:
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "swr_path", swr_path)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="swrPath")
    def swr_path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the SWR storage path of the group unit.
        """
        return pulumi.get(self, "swr_path")

    @swr_path.setter
    def swr_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "swr_path", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the image ID of the group unit.  
        Only available if the value of parameter `source` is **IMAGE**.

        <a name="v2_service_unit_config_custom_spec"></a>
        The `custom_spec` block supports:
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigLivenessHealthArgsDict(TypedDict):
        check_method: pulumi.Input[_builtins.str]
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        failure_threshold: pulumi.Input[_builtins.int]
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        initial_delay_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        period_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        timeout_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
elif False:
    ServiceV2GroupConfigUnitConfigLivenessHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigLivenessHealthArgs:
    def __init__(__self__, *,
                 check_method: pulumi.Input[_builtins.str],
                 failure_threshold: pulumi.Input[_builtins.int],
                 initial_delay_seconds: pulumi.Input[_builtins.int],
                 period_seconds: pulumi.Input[_builtins.int],
                 timeout_seconds: pulumi.Input[_builtins.int],
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] check_method: Specifies the method of the health check.  
               The valid values are as follows:
               + **EXEC**
               + **HTTP**
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum number of consecutive detection failures.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: Specifies the time to wait when performing the first probe.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies the period time for performing health check.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] timeout_seconds: Specifies the timeout for executing the probe.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.str] command: Specifies the commands configuration of the health check.  
               Only available if the `check_method` is **EXEC**.
        :param pulumi.Input[_builtins.str] url: Specifies the request URL of the health check.  
               Only available if the `check_method` is **HTTP**.
               
               <a name="v2_service_log_configs"></a>
               The `log_configs` block supports:
        """
        pulumi.set(__self__, "check_method", check_method)
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="checkMethod")
    def check_method(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        return pulumi.get(self, "check_method")

    @check_method.setter
    def check_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "check_method", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigModelArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        """
        Specifies the path to mount into the container.  
        The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
        backslash (\\\\) and dots (.).
        """
        source: pulumi.Input[_builtins.str]
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source address of the code configuration.  
        This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        """
        source_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source ID of the code configuration.  
        This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
        **EFS**.

        <a name="v2_service_unit_config_health_check"></a>
        The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
elif False:
    ServiceV2GroupConfigUnitConfigModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigModelArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 source_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mount_path: Specifies the path to mount into the container.  
               The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
               backslash (\\\\) and dots (.).
        :param pulumi.Input[_builtins.str] source: Specifies the source type of the code configuration.  
               The valid values are as follows:
               + **OBS**
               + **OBSFS**
               + **EFS**
               + **GIT**
        :param pulumi.Input[_builtins.str] address: Specifies the source address of the code configuration.  
               This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        :param pulumi.Input[_builtins.str] source_id: Specifies the source ID of the code configuration.  
               This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
               **EFS**.
               
               <a name="v2_service_unit_config_health_check"></a>
               The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "source", source)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the path to mount into the container.  
        The value must start with a slash (/) and the path content allows letters, digits, hyphens (-), underscores (_),
        backslash (\\\\) and dots (.).
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the source type of the code configuration.  
        The valid values are as follows:
        + **OBS**
        + **OBSFS**
        + **EFS**
        + **GIT**
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source address of the code configuration.  
        This parameter is mutually exclusive with `source_id` and only required if the value of `source` is not **EFS**.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source ID of the code configuration.  
        This parameter is mutually exclusive with `mount_path` and the SFS Turbo ID is required if the value of `source` is
        **EFS**.

        <a name="v2_service_unit_config_health_check"></a>
        The `readiness_health`, `startup_health` and `liveness_health` blocks support:
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_id", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigReadinessHealthArgsDict(TypedDict):
        check_method: pulumi.Input[_builtins.str]
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        failure_threshold: pulumi.Input[_builtins.int]
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        initial_delay_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        period_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        timeout_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
elif False:
    ServiceV2GroupConfigUnitConfigReadinessHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigReadinessHealthArgs:
    def __init__(__self__, *,
                 check_method: pulumi.Input[_builtins.str],
                 failure_threshold: pulumi.Input[_builtins.int],
                 initial_delay_seconds: pulumi.Input[_builtins.int],
                 period_seconds: pulumi.Input[_builtins.int],
                 timeout_seconds: pulumi.Input[_builtins.int],
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] check_method: Specifies the method of the health check.  
               The valid values are as follows:
               + **EXEC**
               + **HTTP**
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum number of consecutive detection failures.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: Specifies the time to wait when performing the first probe.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies the period time for performing health check.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] timeout_seconds: Specifies the timeout for executing the probe.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.str] command: Specifies the commands configuration of the health check.  
               Only available if the `check_method` is **EXEC**.
        :param pulumi.Input[_builtins.str] url: Specifies the request URL of the health check.  
               Only available if the `check_method` is **HTTP**.
               
               <a name="v2_service_log_configs"></a>
               The `log_configs` block supports:
        """
        pulumi.set(__self__, "check_method", check_method)
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="checkMethod")
    def check_method(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        return pulumi.get(self, "check_method")

    @check_method.setter
    def check_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "check_method", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ServiceV2GroupConfigUnitConfigStartupHealthArgsDict(TypedDict):
        check_method: pulumi.Input[_builtins.str]
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        failure_threshold: pulumi.Input[_builtins.int]
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        initial_delay_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        period_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        timeout_seconds: pulumi.Input[_builtins.int]
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
elif False:
    ServiceV2GroupConfigUnitConfigStartupHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2GroupConfigUnitConfigStartupHealthArgs:
    def __init__(__self__, *,
                 check_method: pulumi.Input[_builtins.str],
                 failure_threshold: pulumi.Input[_builtins.int],
                 initial_delay_seconds: pulumi.Input[_builtins.int],
                 period_seconds: pulumi.Input[_builtins.int],
                 timeout_seconds: pulumi.Input[_builtins.int],
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] check_method: Specifies the method of the health check.  
               The valid values are as follows:
               + **EXEC**
               + **HTTP**
        :param pulumi.Input[_builtins.int] failure_threshold: Specifies the minimum number of consecutive detection failures.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: Specifies the time to wait when performing the first probe.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] period_seconds: Specifies the period time for performing health check.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.int] timeout_seconds: Specifies the timeout for executing the probe.  
               The minimum timeout value is `1`.
        :param pulumi.Input[_builtins.str] command: Specifies the commands configuration of the health check.  
               Only available if the `check_method` is **EXEC**.
        :param pulumi.Input[_builtins.str] url: Specifies the request URL of the health check.  
               Only available if the `check_method` is **HTTP**.
               
               <a name="v2_service_log_configs"></a>
               The `log_configs` block supports:
        """
        pulumi.set(__self__, "check_method", check_method)
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="checkMethod")
    def check_method(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the method of the health check.  
        The valid values are as follows:
        + **EXEC**
        + **HTTP**
        """
        return pulumi.get(self, "check_method")

    @check_method.setter
    def check_method(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "check_method", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the minimum number of consecutive detection failures.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the time to wait when performing the first probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the period time for performing health check.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the timeout for executing the probe.  
        The minimum timeout value is `1`.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the commands configuration of the health check.  
        Only available if the `check_method` is **EXEC**.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the request URL of the health check.  
        Only available if the `check_method` is **HTTP**.

        <a name="v2_service_log_configs"></a>
        The `log_configs` block supports:
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ServiceV2LogConfigArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Specifies the type of LTS configuration.
        Currently, the valid value is **STDOUT**.
        """
        log_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the LTS group.
        """
        log_stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the ID of the LTS stream.
        """
elif False:
    ServiceV2LogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2LogConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 log_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 log_stream_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of LTS configuration.
               Currently, the valid value is **STDOUT**.
        :param pulumi.Input[_builtins.str] log_group_id: Specifies the ID of the LTS group.
        :param pulumi.Input[_builtins.str] log_stream_id: Specifies the ID of the LTS stream.
        """
        pulumi.set(__self__, "type", type)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_stream_id is not None:
            pulumi.set(__self__, "log_stream_id", log_stream_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the type of LTS configuration.
        Currently, the valid value is **STDOUT**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the LTS group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_id", value)

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the ID of the LTS stream.
        """
        return pulumi.get(self, "log_stream_id")

    @log_stream_id.setter
    def log_stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_stream_id", value)


if not MYPY:
    class ServiceV2PredictUrlArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the type of LTS configuration.
        Currently, the valid value is **STDOUT**.
        """
        urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The URLs of service access.
        """
elif False:
    ServiceV2PredictUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceV2PredictUrlArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Specifies the type of LTS configuration.
               Currently, the valid value is **STDOUT**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] urls: The URLs of service access.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the type of LTS configuration.
        Currently, the valid value is **STDOUT**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The URLs of service access.
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "urls", value)


if not MYPY:
    class WorkspaceGrantArgsDict(TypedDict):
        user_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        IAM user ID.  
        User ID and username specify at least one. If both are specified, User ID is preferred.
        """
        user_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        IAM username.
        """
elif False:
    WorkspaceGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceGrantArgs:
    def __init__(__self__, *,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 user_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] user_id: IAM user ID.  
               User ID and username specify at least one. If both are specified, User ID is preferred.
        :param pulumi.Input[_builtins.str] user_name: IAM username.
        """
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IAM user ID.  
        User ID and username specify at least one. If both are specified, User ID is preferred.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IAM username.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_name", value)


