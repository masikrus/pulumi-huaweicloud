# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'MessagePublishMessageAttribute',
    'SubscriptionExtension',
    'SubscriptionFilterPolicy',
    'SubscriptionFilterPolicyFilterPolicy',
    'SubscriptionV2Extension',
    'SubscriptionV2FilterPolicy',
    'GetLogtanksLogtankResult',
    'GetMessageTemplatesTemplateResult',
    'GetSubscriptionsSubscriptionResult',
    'GetSubscriptionsSubscriptionFilterPoliceResult',
    'GetTopicSubscriptionsSubscriptionResult',
    'GetTopicSubscriptionsSubscriptionFilterPoliceResult',
    'GetTopicsTopicResult',
]

@pulumi.output_type
class MessagePublishMessageAttribute(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Specifies the property name.
        :param _builtins.str type: Specifies the property type.
               The value can be **STRING**, **STRING_ARRAY** or **PROTOCOL**.
        :param _builtins.str value: Specifies the property value.
               This parameter is valid only when the `type` set to **STRING**. The attribute value can only contain Chinese
               and English, numbers, and underscores, and the length is **1** to **32** characters.
        :param Sequence[_builtins.str] values: Specifies the property values.
               This parameter is valid when the `type` set to **STRING_ARRAY** or **PROTOCOL**.
               + When the `type` is **STRING_ARRAY**, the `values` is a string array, the array length is
               **1** to **10**, the element content in the array cannot be repeated, each string in the array can only contain
               Chinese and English, numbers, and underscores, and length is **1** to **32** characters.
               + When the `type` is **PROTOCOL**, the `values` is a string array of supported protocol types.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the property type.
        The value can be **STRING**, **STRING_ARRAY** or **PROTOCOL**.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the property value.
        This parameter is valid only when the `type` set to **STRING**. The attribute value can only contain Chinese
        and English, numbers, and underscores, and the length is **1** to **32** characters.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the property values.
        This parameter is valid when the `type` set to **STRING_ARRAY** or **PROTOCOL**.
        + When the `type` is **STRING_ARRAY**, the `values` is a string array, the array length is
        **1** to **10**, the element content in the array cannot be repeated, each string in the array can only contain
        Chinese and English, numbers, and underscores, and length is **1** to **32** characters.
        + When the `type` is **PROTOCOL**, the `values` is a string array of supported protocol types.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class SubscriptionExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "signSecret":
            suggest = "sign_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 header: Optional[Mapping[str, _builtins.str]] = None,
                 keyword: Optional[_builtins.str] = None,
                 sign_secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Specifies the client ID. This field is the tenant ID field in
               the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
               is set to **welink**. Changing this parameter will create a new resource.
        :param _builtins.str client_secret: Specifies the client secret. This field is the client secret
               field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
               Changing this parameter will create a new resource.
        :param Mapping[str, _builtins.str] header: Specifies the HTTP/HTTPS headers to be added to the requests when the
               message is delivered via HTTP/HTTPS. This field is used when `protocol` is set to **http** or **https**.
               The following requirements apply to the header keys and values:
               + Header keys must:
               - Contain only letters, numbers, and hyphens (`[A-Za-z0-9-]`)
               - Not end with a hyphen
               - Not contain consecutive hyphens
               - Start with "x-" (e.g., "x-abc-cba", "x-abc")
               - Not start with "x-smn"
               - Be case-insensitive (e.g., "X-Custom" and "x-custom" are considered the same)
               - Not be duplicated
               + Maximum of 10 key-value pairs allowed
               + Total length of all keys and values combined must not exceed 1024 characters
               + Values must only contain ASCII characters (no Chinese or other Unicode characters, spaces are allowed)
               
               Changing this parameter will create a new resource.
        :param _builtins.str keyword: Specifies the keyword. When `protocol` is set to **feishu**,
               either `keyword` or `sign_secret` must be specified. When you use `keywords` to configure a security policy
               for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
               or DingTalk client. Changing this parameter will create a new resource.
        :param _builtins.str sign_secret: Specifies the key including signature. When `protocol` is set
               to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
               the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
               enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
               Changing this parameter will create a new resource.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if sign_secret is not None:
            pulumi.set(__self__, "sign_secret", sign_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Specifies the client ID. This field is the tenant ID field in
        the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
        is set to **welink**. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        Specifies the client secret. This field is the client secret
        field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Specifies the HTTP/HTTPS headers to be added to the requests when the
        message is delivered via HTTP/HTTPS. This field is used when `protocol` is set to **http** or **https**.
        The following requirements apply to the header keys and values:
        + Header keys must:
        - Contain only letters, numbers, and hyphens (`[A-Za-z0-9-]`)
        - Not end with a hyphen
        - Not contain consecutive hyphens
        - Start with "x-" (e.g., "x-abc-cba", "x-abc")
        - Not start with "x-smn"
        - Be case-insensitive (e.g., "X-Custom" and "x-custom" are considered the same)
        - Not be duplicated
        + Maximum of 10 key-value pairs allowed
        + Total length of all keys and values combined must not exceed 1024 characters
        + Values must only contain ASCII characters (no Chinese or other Unicode characters, spaces are allowed)

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> Optional[_builtins.str]:
        """
        Specifies the keyword. When `protocol` is set to **feishu**,
        either `keyword` or `sign_secret` must be specified. When you use `keywords` to configure a security policy
        for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
        or DingTalk client. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "keyword")

    @_builtins.property
    @pulumi.getter(name="signSecret")
    def sign_secret(self) -> Optional[_builtins.str]:
        """
        Specifies the key including signature. When `protocol` is set
        to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
        the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
        enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sign_secret")


@pulumi.output_type
class SubscriptionFilterPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stringEquals":
            suggest = "string_equals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionFilterPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionFilterPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionFilterPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 string_equals: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The filter policy name.
        :param Sequence[_builtins.str] string_equals: The string array for exact match.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if string_equals is not None:
            pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The filter policy name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Optional[Sequence[_builtins.str]]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")


@pulumi.output_type
class SubscriptionFilterPolicyFilterPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stringEquals":
            suggest = "string_equals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionFilterPolicyFilterPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionFilterPolicyFilterPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionFilterPolicyFilterPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 string_equals: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Specifies the filter policy name. The policy name must be unique.
               + It can contain `1` to `32` characters, including lowercase letters, digits, and underscores (_).
               + It cannot start or end with an underscore, nor contain consecutive underscores. It cannot start with **smn**.
        :param Sequence[_builtins.str] string_equals: Specifies the string array for exact match. The array can contain `1`
               to `10` strings. The array content must be unique. The string cannot be **null** or an empty string "".
               A string can contain `1` to `32` characters, including letters, digits, and underscores (_).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the filter policy name. The policy name must be unique.
        + It can contain `1` to `32` characters, including lowercase letters, digits, and underscores (_).
        + It cannot start or end with an underscore, nor contain consecutive underscores. It cannot start with **smn**.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Sequence[_builtins.str]:
        """
        Specifies the string array for exact match. The array can contain `1`
        to `10` strings. The array content must be unique. The string cannot be **null** or an empty string "".
        A string can contain `1` to `32` characters, including letters, digits, and underscores (_).
        """
        return pulumi.get(self, "string_equals")


@pulumi.output_type
class SubscriptionV2Extension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "signSecret":
            suggest = "sign_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionV2Extension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionV2Extension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionV2Extension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 header: Optional[Mapping[str, _builtins.str]] = None,
                 keyword: Optional[_builtins.str] = None,
                 sign_secret: Optional[_builtins.str] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if sign_secret is not None:
            pulumi.set(__self__, "sign_secret", sign_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "keyword")

    @_builtins.property
    @pulumi.getter(name="signSecret")
    def sign_secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sign_secret")


@pulumi.output_type
class SubscriptionV2FilterPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stringEquals":
            suggest = "string_equals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionV2FilterPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionV2FilterPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionV2FilterPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 string_equals: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The filter policy name. The policy name must be unique.
        :param Sequence[_builtins.str] string_equals: The string array for exact match.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if string_equals is not None:
            pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The filter policy name. The policy name must be unique.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Optional[Sequence[_builtins.str]]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")


@pulumi.output_type
class GetLogtanksLogtankResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 log_group_id: _builtins.str,
                 log_stream_id: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The creation time.
        :param _builtins.str id: The ID of the cloud log.
        :param _builtins.str log_group_id: The LTS log group ID.
        :param _builtins.str log_stream_id: The LTS log stream ID.
        :param _builtins.str updated_at: The update time.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_stream_id", log_stream_id)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the cloud log.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> _builtins.str:
        """
        The LTS log group ID.
        """
        return pulumi.get(self, "log_group_id")

    @_builtins.property
    @pulumi.getter(name="logStreamId")
    def log_stream_id(self) -> _builtins.str:
        """
        The LTS log stream ID.
        """
        return pulumi.get(self, "log_stream_id")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetMessageTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 protocol: _builtins.str,
                 tag_names: Sequence[_builtins.str],
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: Indicates the create time.
        :param _builtins.str id: Indicates the message template ID.
        :param _builtins.str name: Specifies the name of the message template.
        :param _builtins.str protocol: Specifies the protocol of the message template.
        :param Sequence[_builtins.str] tag_names: Indicates the variable list. The variable name will be quoted in braces ({}) in the template.
               When you use a template to send messages, you can replace the variable with any content.
        :param _builtins.str updated_at: Indicates the update time.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "tag_names", tag_names)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Indicates the create time.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Indicates the message template ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the message template.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Specifies the protocol of the message template.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="tagNames")
    def tag_names(self) -> Sequence[_builtins.str]:
        """
        Indicates the variable list. The variable name will be quoted in braces ({}) in the template.
        When you use a template to send messages, you can replace the variable with any content.
        """
        return pulumi.get(self, "tag_names")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Indicates the update time.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetSubscriptionsSubscriptionResult(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 filter_polices: Sequence['outputs.GetSubscriptionsSubscriptionFilterPoliceResult'],
                 owner: _builtins.str,
                 protocol: _builtins.str,
                 remark: _builtins.str,
                 status: _builtins.int,
                 subscription_urn: _builtins.str,
                 topic_urn: _builtins.str):
        """
        :param _builtins.str endpoint: Specifies the subscription endpoint.
        :param Sequence['GetSubscriptionsSubscriptionFilterPoliceArgs'] filter_polices: The subscription filter polices.
        :param _builtins.str owner: The subscription owner.
        :param _builtins.str protocol: Specifies the protocol name.
               The enumerated values are **http**, **https**, **sms**, **email**, **functionstage**, **dms**, and **application**.
        :param _builtins.str remark: The subscriptions remark.
        :param _builtins.int status: Specifies the subscription status.
               + **0**: The subscription has not been confirmed.
               + **1**: The subscription has been confirmed.
               + **2**: Confirmation is not required.
               + **3**: The subscription was canceled.
               + **4**: The subscription was deleted.
        :param _builtins.str subscription_urn: The subscription URN.
        :param _builtins.str topic_urn: The topic URN.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "filter_polices", filter_polices)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "remark", remark)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subscription_urn", subscription_urn)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Specifies the subscription endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="filterPolices")
    def filter_polices(self) -> Sequence['outputs.GetSubscriptionsSubscriptionFilterPoliceResult']:
        """
        The subscription filter polices.
        """
        return pulumi.get(self, "filter_polices")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        The subscription owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Specifies the protocol name.
        The enumerated values are **http**, **https**, **sms**, **email**, **functionstage**, **dms**, and **application**.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def remark(self) -> _builtins.str:
        """
        The subscriptions remark.
        """
        return pulumi.get(self, "remark")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        Specifies the subscription status.
        + **0**: The subscription has not been confirmed.
        + **1**: The subscription has been confirmed.
        + **2**: Confirmation is not required.
        + **3**: The subscription was canceled.
        + **4**: The subscription was deleted.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subscriptionUrn")
    def subscription_urn(self) -> _builtins.str:
        """
        The subscription URN.
        """
        return pulumi.get(self, "subscription_urn")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        The topic URN.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetSubscriptionsSubscriptionFilterPoliceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 string_equals: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The filter policy name.
        :param Sequence[_builtins.str] string_equals: The string array for exact match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The filter policy name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Sequence[_builtins.str]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")


@pulumi.output_type
class GetTopicSubscriptionsSubscriptionResult(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 filter_polices: Sequence['outputs.GetTopicSubscriptionsSubscriptionFilterPoliceResult'],
                 owner: _builtins.str,
                 protocol: _builtins.str,
                 remark: _builtins.str,
                 status: _builtins.int,
                 subscription_urn: _builtins.str,
                 topic_urn: _builtins.str):
        """
        :param _builtins.str endpoint: The subscriptions endpoint.
        :param Sequence['GetTopicSubscriptionsSubscriptionFilterPoliceArgs'] filter_polices: The subscription filter polices.
        :param _builtins.str owner: The subscription owner.
        :param _builtins.str protocol: The subscription protocol.
        :param _builtins.str remark: The subscription remark.
        :param _builtins.int status: The subscription status.
        :param _builtins.str subscription_urn: The subscription URN.
        :param _builtins.str topic_urn: Specifies the topic URN.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "filter_polices", filter_polices)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "remark", remark)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "subscription_urn", subscription_urn)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The subscriptions endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="filterPolices")
    def filter_polices(self) -> Sequence['outputs.GetTopicSubscriptionsSubscriptionFilterPoliceResult']:
        """
        The subscription filter polices.
        """
        return pulumi.get(self, "filter_polices")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        The subscription owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The subscription protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def remark(self) -> _builtins.str:
        """
        The subscription remark.
        """
        return pulumi.get(self, "remark")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.int:
        """
        The subscription status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="subscriptionUrn")
    def subscription_urn(self) -> _builtins.str:
        """
        The subscription URN.
        """
        return pulumi.get(self, "subscription_urn")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")


@pulumi.output_type
class GetTopicSubscriptionsSubscriptionFilterPoliceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 string_equals: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The filter policy name.
        :param Sequence[_builtins.str] string_equals: The string array for exact match.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The filter policy name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Sequence[_builtins.str]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")


@pulumi.output_type
class GetTopicsTopicResult(dict):
    def __init__(__self__, *,
                 display_name: _builtins.str,
                 enterprise_project_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 push_policy: _builtins.int,
                 tags: Mapping[str, _builtins.str],
                 topic_urn: _builtins.str):
        """
        :param _builtins.str display_name: Specifies the topic display name.
        :param _builtins.str enterprise_project_id: Specifies the enterprise project ID of the SMN topic.
        :param _builtins.str id: The topic ID. The value is the topic URN.
        :param _builtins.str name: Specifies the name of the topic.
        :param _builtins.int push_policy: Message pushing policy.
               + **0**: indicates that the message sending fails and the message is cached in the queue.
               + **1**: indicates that the failed message is discarded.
        :param Mapping[str, _builtins.str] tags: The tags of the SMN topic, key/value pair format.
        :param _builtins.str topic_urn: Specifies the topic URN.
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "enterprise_project_id", enterprise_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "push_policy", push_policy)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Specifies the topic display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="enterpriseProjectId")
    def enterprise_project_id(self) -> _builtins.str:
        """
        Specifies the enterprise project ID of the SMN topic.
        """
        return pulumi.get(self, "enterprise_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The topic ID. The value is the topic URN.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the topic.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pushPolicy")
    def push_policy(self) -> _builtins.int:
        """
        Message pushing policy.
        + **0**: indicates that the message sending fails and the message is cached in the queue.
        + **1**: indicates that the failed message is discarded.
        """
        return pulumi.get(self, "push_policy")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The tags of the SMN topic, key/value pair format.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> _builtins.str:
        """
        Specifies the topic URN.
        """
        return pulumi.get(self, "topic_urn")


