# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'MessagePublishMessageAttributeArgs',
    'MessagePublishMessageAttributeArgsDict',
    'SubscriptionExtensionArgs',
    'SubscriptionExtensionArgsDict',
    'SubscriptionFilterPolicyArgs',
    'SubscriptionFilterPolicyArgsDict',
    'SubscriptionFilterPolicyFilterPolicyArgs',
    'SubscriptionFilterPolicyFilterPolicyArgsDict',
    'SubscriptionV2ExtensionArgs',
    'SubscriptionV2ExtensionArgsDict',
    'SubscriptionV2FilterPolicyArgs',
    'SubscriptionV2FilterPolicyArgsDict',
]

MYPY = False

if not MYPY:
    class MessagePublishMessageAttributeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the property name.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the property type.
        The value can be **STRING**, **STRING_ARRAY** or **PROTOCOL**.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the property value.
        This parameter is valid only when the `type` set to **STRING**. The attribute value can only contain Chinese
        and English, numbers, and underscores, and the length is **1** to **32** characters.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the property values.
        This parameter is valid when the `type` set to **STRING_ARRAY** or **PROTOCOL**.
        + When the `type` is **STRING_ARRAY**, the `values` is a string array, the array length is
        **1** to **10**, the element content in the array cannot be repeated, each string in the array can only contain
        Chinese and English, numbers, and underscores, and length is **1** to **32** characters.
        + When the `type` is **PROTOCOL**, the `values` is a string array of supported protocol types.
        """
elif False:
    MessagePublishMessageAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MessagePublishMessageAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the property name.
        :param pulumi.Input[_builtins.str] type: Specifies the property type.
               The value can be **STRING**, **STRING_ARRAY** or **PROTOCOL**.
        :param pulumi.Input[_builtins.str] value: Specifies the property value.
               This parameter is valid only when the `type` set to **STRING**. The attribute value can only contain Chinese
               and English, numbers, and underscores, and the length is **1** to **32** characters.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: Specifies the property values.
               This parameter is valid when the `type` set to **STRING_ARRAY** or **PROTOCOL**.
               + When the `type` is **STRING_ARRAY**, the `values` is a string array, the array length is
               **1** to **10**, the element content in the array cannot be repeated, each string in the array can only contain
               Chinese and English, numbers, and underscores, and length is **1** to **32** characters.
               + When the `type` is **PROTOCOL**, the `values` is a string array of supported protocol types.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the property type.
        The value can be **STRING**, **STRING_ARRAY** or **PROTOCOL**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the property value.
        This parameter is valid only when the `type` set to **STRING**. The attribute value can only contain Chinese
        and English, numbers, and underscores, and the length is **1** to **32** characters.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the property values.
        This parameter is valid when the `type` set to **STRING_ARRAY** or **PROTOCOL**.
        + When the `type` is **STRING_ARRAY**, the `values` is a string array, the array length is
        **1** to **10**, the element content in the array cannot be repeated, each string in the array can only contain
        Chinese and English, numbers, and underscores, and length is **1** to **32** characters.
        + When the `type` is **PROTOCOL**, the `values` is a string array of supported protocol types.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SubscriptionExtensionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the client ID. This field is the tenant ID field in
        the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
        is set to **welink**. Changing this parameter will create a new resource.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the client secret. This field is the client secret
        field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
        Changing this parameter will create a new resource.
        """
        header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Specifies the HTTP/HTTPS headers to be added to the requests when the
        message is delivered via HTTP/HTTPS. This field is used when `protocol` is set to **http** or **https**.
        The following requirements apply to the header keys and values:
        + Header keys must:
        - Contain only letters, numbers, and hyphens (`[A-Za-z0-9-]`)
        - Not end with a hyphen
        - Not contain consecutive hyphens
        - Start with "x-" (e.g., "x-abc-cba", "x-abc")
        - Not start with "x-smn"
        - Be case-insensitive (e.g., "X-Custom" and "x-custom" are considered the same)
        - Not be duplicated
        + Maximum of 10 key-value pairs allowed
        + Total length of all keys and values combined must not exceed 1024 characters
        + Values must only contain ASCII characters (no Chinese or other Unicode characters, spaces are allowed)

        Changing this parameter will create a new resource.
        """
        keyword: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the keyword. When `protocol` is set to **feishu**,
        either `keyword` or `sign_secret` must be specified. When you use `keywords` to configure a security policy
        for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
        or DingTalk client. Changing this parameter will create a new resource.
        """
        sign_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the key including signature. When `protocol` is set
        to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
        the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
        enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
        Changing this parameter will create a new resource.
        """
elif False:
    SubscriptionExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionExtensionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 header: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 keyword: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: Specifies the client ID. This field is the tenant ID field in
               the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
               is set to **welink**. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] client_secret: Specifies the client secret. This field is the client secret
               field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
               Changing this parameter will create a new resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] header: Specifies the HTTP/HTTPS headers to be added to the requests when the
               message is delivered via HTTP/HTTPS. This field is used when `protocol` is set to **http** or **https**.
               The following requirements apply to the header keys and values:
               + Header keys must:
               - Contain only letters, numbers, and hyphens (`[A-Za-z0-9-]`)
               - Not end with a hyphen
               - Not contain consecutive hyphens
               - Start with "x-" (e.g., "x-abc-cba", "x-abc")
               - Not start with "x-smn"
               - Be case-insensitive (e.g., "X-Custom" and "x-custom" are considered the same)
               - Not be duplicated
               + Maximum of 10 key-value pairs allowed
               + Total length of all keys and values combined must not exceed 1024 characters
               + Values must only contain ASCII characters (no Chinese or other Unicode characters, spaces are allowed)
               
               Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] keyword: Specifies the keyword. When `protocol` is set to **feishu**,
               either `keyword` or `sign_secret` must be specified. When you use `keywords` to configure a security policy
               for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
               or DingTalk client. Changing this parameter will create a new resource.
        :param pulumi.Input[_builtins.str] sign_secret: Specifies the key including signature. When `protocol` is set
               to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
               the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
               enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
               Changing this parameter will create a new resource.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if sign_secret is not None:
            pulumi.set(__self__, "sign_secret", sign_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the client ID. This field is the tenant ID field in
        the WeLink subscription and is obtained by the tenant from WeLink. This field is mandatory when `protocol`
        is set to **welink**. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the client secret. This field is the client secret
        field obtained by the tenant from WeLink. This field is mandatory when `protocol` is set to **welink**.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Specifies the HTTP/HTTPS headers to be added to the requests when the
        message is delivered via HTTP/HTTPS. This field is used when `protocol` is set to **http** or **https**.
        The following requirements apply to the header keys and values:
        + Header keys must:
        - Contain only letters, numbers, and hyphens (`[A-Za-z0-9-]`)
        - Not end with a hyphen
        - Not contain consecutive hyphens
        - Start with "x-" (e.g., "x-abc-cba", "x-abc")
        - Not start with "x-smn"
        - Be case-insensitive (e.g., "X-Custom" and "x-custom" are considered the same)
        - Not be duplicated
        + Maximum of 10 key-value pairs allowed
        + Total length of all keys and values combined must not exceed 1024 characters
        + Values must only contain ASCII characters (no Chinese or other Unicode characters, spaces are allowed)

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the keyword. When `protocol` is set to **feishu**,
        either `keyword` or `sign_secret` must be specified. When you use `keywords` to configure a security policy
        for the Lark or DingTalk chatbot on SMN, the keywords must have one of the keywords configured on the Lark
        or DingTalk client. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyword", value)

    @_builtins.property
    @pulumi.getter(name="signSecret")
    def sign_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the key including signature. When `protocol` is set
        to **feishu** or **dingding**, this field or `keyword` must be specified. The key configurations must be
        the same as those on the Lark or DingTalk client. For example, if only key is configured on the Lark client,
        enter the key field obtained from the Lark client. If only keyword is configured on the Lark client, skip this field.
        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "sign_secret")

    @sign_secret.setter
    def sign_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_secret", value)


if not MYPY:
    class SubscriptionFilterPolicyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filter policy name.
        """
        string_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The string array for exact match.
        """
elif False:
    SubscriptionFilterPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionFilterPolicyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 string_equals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The filter policy name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] string_equals: The string array for exact match.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if string_equals is not None:
            pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filter policy name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")

    @string_equals.setter
    def string_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "string_equals", value)


if not MYPY:
    class SubscriptionFilterPolicyFilterPolicyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies the filter policy name. The policy name must be unique.
        + It can contain `1` to `32` characters, including lowercase letters, digits, and underscores (_).
        + It cannot start or end with an underscore, nor contain consecutive underscores. It cannot start with **smn**.
        """
        string_equals: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specifies the string array for exact match. The array can contain `1`
        to `10` strings. The array content must be unique. The string cannot be **null** or an empty string "".
        A string can contain `1` to `32` characters, including letters, digits, and underscores (_).
        """
elif False:
    SubscriptionFilterPolicyFilterPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionFilterPolicyFilterPolicyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 string_equals: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the filter policy name. The policy name must be unique.
               + It can contain `1` to `32` characters, including lowercase letters, digits, and underscores (_).
               + It cannot start or end with an underscore, nor contain consecutive underscores. It cannot start with **smn**.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] string_equals: Specifies the string array for exact match. The array can contain `1`
               to `10` strings. The array content must be unique. The string cannot be **null** or an empty string "".
               A string can contain `1` to `32` characters, including letters, digits, and underscores (_).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the filter policy name. The policy name must be unique.
        + It can contain `1` to `32` characters, including lowercase letters, digits, and underscores (_).
        + It cannot start or end with an underscore, nor contain consecutive underscores. It cannot start with **smn**.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specifies the string array for exact match. The array can contain `1`
        to `10` strings. The array content must be unique. The string cannot be **null** or an empty string "".
        A string can contain `1` to `32` characters, including letters, digits, and underscores (_).
        """
        return pulumi.get(self, "string_equals")

    @string_equals.setter
    def string_equals(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "string_equals", value)


if not MYPY:
    class SubscriptionV2ExtensionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        keyword: NotRequired[pulumi.Input[_builtins.str]]
        sign_secret: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SubscriptionV2ExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionV2ExtensionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 header: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 keyword: Optional[pulumi.Input[_builtins.str]] = None,
                 sign_secret: Optional[pulumi.Input[_builtins.str]] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if sign_secret is not None:
            pulumi.set(__self__, "sign_secret", sign_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def keyword(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyword", value)

    @_builtins.property
    @pulumi.getter(name="signSecret")
    def sign_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sign_secret")

    @sign_secret.setter
    def sign_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sign_secret", value)


if not MYPY:
    class SubscriptionV2FilterPolicyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filter policy name. The policy name must be unique.
        """
        string_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The string array for exact match.
        """
elif False:
    SubscriptionV2FilterPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionV2FilterPolicyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 string_equals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The filter policy name. The policy name must be unique.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] string_equals: The string array for exact match.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if string_equals is not None:
            pulumi.set(__self__, "string_equals", string_equals)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filter policy name. The policy name must be unique.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")

    @string_equals.setter
    def string_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "string_equals", value)


