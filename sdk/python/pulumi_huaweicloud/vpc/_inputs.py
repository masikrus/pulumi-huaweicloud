# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AddressGroupIpExtraSetArgs',
    'AddressGroupIpExtraSetArgsDict',
    'BandwidthPublicipArgs',
    'BandwidthPublicipArgsDict',
    'BandwidthV2PublicipArgs',
    'BandwidthV2PublicipArgsDict',
    'EipBandwidthArgs',
    'EipBandwidthArgsDict',
    'EipPublicipArgs',
    'EipPublicipArgsDict',
    'EipV1BandwidthArgs',
    'EipV1BandwidthArgsDict',
    'EipV1PublicipArgs',
    'EipV1PublicipArgsDict',
    'NetworkAclAssociatedSubnetArgs',
    'NetworkAclAssociatedSubnetArgsDict',
    'NetworkAclEgressRuleArgs',
    'NetworkAclEgressRuleArgsDict',
    'NetworkAclIngressRuleArgs',
    'NetworkAclIngressRuleArgsDict',
    'NetworkV2SegmentArgs',
    'NetworkV2SegmentArgsDict',
    'PortAllowedAddressPairArgs',
    'PortAllowedAddressPairArgsDict',
    'PortExtraDhcpOptionArgs',
    'PortExtraDhcpOptionArgsDict',
    'PortFixedIpArgs',
    'PortFixedIpArgsDict',
    'PortV2AllowedAddressPairArgs',
    'PortV2AllowedAddressPairArgsDict',
    'PortV2ExtraDhcpOptionArgs',
    'PortV2ExtraDhcpOptionArgsDict',
    'PortV2FixedIpArgs',
    'PortV2FixedIpArgsDict',
    'RouteTableRouteArgs',
    'RouteTableRouteArgsDict',
    'RouterV2ExternalFixedIpArgs',
    'RouterV2ExternalFixedIpArgsDict',
    'SecgroupRuleArgs',
    'SecgroupRuleArgsDict',
    'SecgroupV2RuleArgs',
    'SecgroupV2RuleArgsDict',
    'SubnetV2AllocationPoolArgs',
    'SubnetV2AllocationPoolArgsDict',
    'SubnetV2HostRouteArgs',
    'SubnetV2HostRouteArgsDict',
    'V1RouteArgs',
    'V1RouteArgsDict',
    'VpcRouteArgs',
    'VpcRouteArgsDict',
    'GetByTagsMatchArgs',
    'GetByTagsMatchArgsDict',
    'GetByTagsTagArgs',
    'GetByTagsTagArgsDict',
    'GetNetworkAclsByTagsMatchArgs',
    'GetNetworkAclsByTagsMatchArgsDict',
    'GetNetworkAclsByTagsTagArgs',
    'GetNetworkAclsByTagsTagArgsDict',
    'GetSecgroupsByTagsMatchArgs',
    'GetSecgroupsByTagsMatchArgsDict',
    'GetSecgroupsByTagsTagArgs',
    'GetSecgroupsByTagsTagArgsDict',
    'GetSubnetsByTagsMatchArgs',
    'GetSubnetsByTagsMatchArgsDict',
    'GetSubnetsByTagsTagArgs',
    'GetSubnetsByTagsTagArgsDict',
]

MYPY = False

if not MYPY:
    class AddressGroupIpExtraSetArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        Specifies the IP address, IP address range, or CIDR block.
        """
        remarks: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the supplementary information about the IP address,
        IP address range, or CIDR block.
        """
elif False:
    AddressGroupIpExtraSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupIpExtraSetArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 remarks: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: Specifies the IP address, IP address range, or CIDR block.
        :param pulumi.Input[_builtins.str] remarks: Specifies the supplementary information about the IP address,
               IP address range, or CIDR block.
        """
        pulumi.set(__self__, "ip", ip)
        if remarks is not None:
            pulumi.set(__self__, "remarks", remarks)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the IP address, IP address range, or CIDR block.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def remarks(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the supplementary information about the IP address,
        IP address range, or CIDR block.
        """
        return pulumi.get(self, "remarks")

    @remarks.setter
    def remarks(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remarks", value)


if not MYPY:
    class BandwidthPublicipArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the EIP or IPv6 port that uses the bandwidth.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 or IPv6 address.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The IP version, either 4 or 6.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP type. Possible values are *5_bgp* (dynamic BGP) and *5_sbgp* (static BGP).
        """
elif False:
    BandwidthPublicipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthPublicipArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the EIP or IPv6 port that uses the bandwidth.
        :param pulumi.Input[_builtins.str] ip_address: The IPv4 or IPv6 address.
        :param pulumi.Input[_builtins.int] ip_version: The IP version, either 4 or 6.
        :param pulumi.Input[_builtins.str] type: The EIP type. Possible values are *5_bgp* (dynamic BGP) and *5_sbgp* (static BGP).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the EIP or IPv6 port that uses the bandwidth.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 or IPv6 address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The IP version, either 4 or 6.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP type. Possible values are *5_bgp* (dynamic BGP) and *5_sbgp* (static BGP).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class BandwidthV2PublicipArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        type: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BandwidthV2PublicipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BandwidthV2PublicipArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EipBandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[_builtins.str]
        """
        Specifies whether the bandwidth is dedicated or shared.  
        Changing this will create a new resource. Possible values are as follows:
        + **PER**: Dedicated bandwidth
        + **WHOLE**: Shared bandwidth
        """
        charge_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether the bandwidth is billed by traffic or by bandwidth
        size. The value can be **traffic** or **bandwidth**. If the `charging_mode` is **prePaid**, only **bandwidth** is valid.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shared bandwidth ID.  
        This parameter is mandatory when `share_type` is set to **WHOLE**. Changing this will create a new resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the bandwidth name.  
        The name can contain `1` to `64` characters, including letters, digits, underscores (_), hyphens (-), and periods (.).
        This parameter is mandatory when `share_type` is set to **PER**.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The bandwidth size.  
        The value ranges from `1` to `300` Mbit/s. This parameter is mandatory when `share_type` is set to **PER**.
        """
elif False:
    EipBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EipBandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[_builtins.str],
                 charge_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] share_type: Specifies whether the bandwidth is dedicated or shared.  
               Changing this will create a new resource. Possible values are as follows:
               + **PER**: Dedicated bandwidth
               + **WHOLE**: Shared bandwidth
        :param pulumi.Input[_builtins.str] charge_mode: Specifies whether the bandwidth is billed by traffic or by bandwidth
               size. The value can be **traffic** or **bandwidth**. If the `charging_mode` is **prePaid**, only **bandwidth** is valid.
        :param pulumi.Input[_builtins.str] id: The shared bandwidth ID.  
               This parameter is mandatory when `share_type` is set to **WHOLE**. Changing this will create a new resource.
        :param pulumi.Input[_builtins.str] name: Specifies the bandwidth name.  
               The name can contain `1` to `64` characters, including letters, digits, underscores (_), hyphens (-), and periods (.).
               This parameter is mandatory when `share_type` is set to **PER**.
        :param pulumi.Input[_builtins.int] size: The bandwidth size.  
               The value ranges from `1` to `300` Mbit/s. This parameter is mandatory when `share_type` is set to **PER**.
        """
        pulumi.set(__self__, "share_type", share_type)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies whether the bandwidth is dedicated or shared.  
        Changing this will create a new resource. Possible values are as follows:
        + **PER**: Dedicated bandwidth
        + **WHOLE**: Shared bandwidth
        """
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "share_type", value)

    @_builtins.property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether the bandwidth is billed by traffic or by bandwidth
        size. The value can be **traffic** or **bandwidth**. If the `charging_mode` is **prePaid**, only **bandwidth** is valid.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shared bandwidth ID.  
        This parameter is mandatory when `share_type` is set to **WHOLE**. Changing this will create a new resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the bandwidth name.  
        The name can contain `1` to `64` characters, including letters, digits, underscores (_), hyphens (-), and periods (.).
        This parameter is mandatory when `share_type` is set to **PER**.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The bandwidth size.  
        The value ranges from `1` to `300` Mbit/s. This parameter is mandatory when `share_type` is set to **PER**.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class EipPublicipArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the EIP address to be assigned.  
        The value must be a valid **IPv4** address in the available IP address range.
        The system automatically assigns an EIP if you do not specify it. Changing this will create a new resource.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the IP version, either `4` (default) or `6`.

        <a name="vpc_eip_bandwidth"></a>
        The `bandwidth` block supports:
        """
        port_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port ID which the EIP associated with.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
        and **5_sbgp** (static BGP), the default value is **5_bgp**. Changing this will create a new resource.
        """
elif False:
    EipPublicipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EipPublicipArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 port_id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: Specifies the EIP address to be assigned.  
               The value must be a valid **IPv4** address in the available IP address range.
               The system automatically assigns an EIP if you do not specify it. Changing this will create a new resource.
        :param pulumi.Input[_builtins.int] ip_version: Specifies the IP version, either `4` (default) or `6`.
               
               <a name="vpc_eip_bandwidth"></a>
               The `bandwidth` block supports:
        :param pulumi.Input[_builtins.str] port_id: The port ID which the EIP associated with.
        :param pulumi.Input[_builtins.str] type: Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
               and **5_sbgp** (static BGP), the default value is **5_bgp**. Changing this will create a new resource.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the EIP address to be assigned.  
        The value must be a valid **IPv4** address in the available IP address range.
        The system automatically assigns an EIP if you do not specify it. Changing this will create a new resource.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the IP version, either `4` (default) or `6`.

        <a name="vpc_eip_bandwidth"></a>
        The `bandwidth` block supports:
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port ID which the EIP associated with.
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the EIP type. Possible values are **5_bgp** (dynamic BGP)
        and **5_sbgp** (static BGP), the default value is **5_bgp**. Changing this will create a new resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EipV1BandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[_builtins.str]
        """
        Whether the bandwidth is dedicated or shared.
        """
        charge_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the bandwidth is billed by traffic or by bandwidth size.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The shared bandwidth ID.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The dedicated bandwidth name.
        """
        size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The dedicated bandwidth size.
        """
elif False:
    EipV1BandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EipV1BandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[_builtins.str],
                 charge_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] share_type: Whether the bandwidth is dedicated or shared.
        :param pulumi.Input[_builtins.str] charge_mode: Whether the bandwidth is billed by traffic or by bandwidth size.
        :param pulumi.Input[_builtins.str] id: The shared bandwidth ID.
        :param pulumi.Input[_builtins.str] name: The dedicated bandwidth name.
        :param pulumi.Input[_builtins.int] size: The dedicated bandwidth size.
        """
        pulumi.set(__self__, "share_type", share_type)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[_builtins.str]:
        """
        Whether the bandwidth is dedicated or shared.
        """
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "share_type", value)

    @_builtins.property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the bandwidth is billed by traffic or by bandwidth size.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The shared bandwidth ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The dedicated bandwidth name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The dedicated bandwidth size.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class EipV1PublicipArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP address to be assigned.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The IP version.
        """
        port_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        schema: Deprecated
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The EIP type.
        """
elif False:
    EipV1PublicipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EipV1PublicipArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None,
                 port_id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: The EIP address to be assigned.
        :param pulumi.Input[_builtins.int] ip_version: The IP version.
        :param pulumi.Input[_builtins.str] port_id: schema: Deprecated
        :param pulumi.Input[_builtins.str] type: The EIP type.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP address to be assigned.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The EIP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkAclAssociatedSubnetArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        Specifies the ID of the subnet to associate with the network ACL.
        """
elif False:
    NetworkAclAssociatedSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkAclAssociatedSubnetArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Specifies the ID of the subnet to associate with the network ACL.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the ID of the subnet to associate with the network ACL.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class NetworkAclEgressRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Specifies the rule action. The value can be: **allow** and **deny**.
        """
        ip_version: pulumi.Input[_builtins.int]
        """
        Specifies the IP version of a network ACL rule.
        The value can be **4** (IPv4) and **6** (IPv6).
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
        or an IP protocol number (0–255). The value **any** indicates all protocols.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the network ACL rule description. The value can contain no more
        than 255 characters. The value cannot contain angle brackets (< or >).
        """
        destination_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination IP address or CIDR block of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        destination_ip_address_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination IP address group ID of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        destination_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.

        <a name="subnets"></a>
        The `associated_subnets` block supports:
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the network ACL rule name. The value can contain no more than 64 characters,
        including letters, digits, underscores (_), hyphens (-), and periods (.).
        """
        rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the rule.
        """
        source_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source IP address or CIDR block of a network ACL rule.
        The `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        source_ip_address_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source IP address group ID of a network ACL rule.
        `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        source_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.
        """
elif False:
    NetworkAclEgressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkAclEgressRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 ip_version: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_ip_address_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_port: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 source_ip_address_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Specifies the rule action. The value can be: **allow** and **deny**.
        :param pulumi.Input[_builtins.int] ip_version: Specifies the IP version of a network ACL rule.
               The value can be **4** (IPv4) and **6** (IPv6).
        :param pulumi.Input[_builtins.str] protocol: Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
               or an IP protocol number (0–255). The value **any** indicates all protocols.
        :param pulumi.Input[_builtins.str] description: Specifies the network ACL rule description. The value can contain no more
               than 255 characters. The value cannot contain angle brackets (< or >).
        :param pulumi.Input[_builtins.str] destination_ip_address: Specifies the destination IP address or CIDR block of a network ACL rule.
               The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] destination_ip_address_group_id: Specifies the destination IP address group ID of a network ACL rule.
               The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] destination_port: Specifies the destination ports of a network ACL rule.
               You can specify a single port or a port range. Separate every two entries with a comma.
               
               <a name="subnets"></a>
               The `associated_subnets` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the network ACL rule name. The value can contain no more than 64 characters,
               including letters, digits, underscores (_), hyphens (-), and periods (.).
        :param pulumi.Input[_builtins.str] rule_id: The ID of the rule.
        :param pulumi.Input[_builtins.str] source_ip_address: Specifies the source IP address or CIDR block of a network ACL rule.
               The `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] source_ip_address_group_id: Specifies the source IP address group ID of a network ACL rule.
               `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] source_port: Specifies the source ports of a network ACL rule.
               You can specify a single port or a port range. Separate every two entries with a comma.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_ip_address is not None:
            pulumi.set(__self__, "destination_ip_address", destination_ip_address)
        if destination_ip_address_group_id is not None:
            pulumi.set(__self__, "destination_ip_address_group_id", destination_ip_address_group_id)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if source_ip_address_group_id is not None:
            pulumi.set(__self__, "source_ip_address_group_id", source_ip_address_group_id)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rule action. The value can be: **allow** and **deny**.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the IP version of a network ACL rule.
        The value can be **4** (IPv4) and **6** (IPv6).
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
        or an IP protocol number (0–255). The value **any** indicates all protocols.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the network ACL rule description. The value can contain no more
        than 255 characters. The value cannot contain angle brackets (< or >).
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destinationIpAddress")
    def destination_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination IP address or CIDR block of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "destination_ip_address")

    @destination_ip_address.setter
    def destination_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="destinationIpAddressGroupId")
    def destination_ip_address_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination IP address group ID of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "destination_ip_address_group_id")

    @destination_ip_address_group_id.setter
    def destination_ip_address_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_ip_address_group_id", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.

        <a name="subnets"></a>
        The `associated_subnets` block supports:
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the network ACL rule name. The value can contain no more than 64 characters,
        including letters, digits, underscores (_), hyphens (-), and periods (.).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the rule.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source IP address or CIDR block of a network ACL rule.
        The `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="sourceIpAddressGroupId")
    def source_ip_address_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source IP address group ID of a network ACL rule.
        `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "source_ip_address_group_id")

    @source_ip_address_group_id.setter
    def source_ip_address_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_ip_address_group_id", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class NetworkAclIngressRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Specifies the rule action. The value can be: **allow** and **deny**.
        """
        ip_version: pulumi.Input[_builtins.int]
        """
        Specifies the IP version of a network ACL rule.
        The value can be **4** (IPv4) and **6** (IPv6).
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
        or an IP protocol number (0–255). The value **any** indicates all protocols.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the network ACL rule description. The value can contain no more
        than 255 characters. The value cannot contain angle brackets (< or >).
        """
        destination_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination IP address or CIDR block of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        destination_ip_address_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination IP address group ID of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        destination_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the destination ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.

        <a name="subnets"></a>
        The `associated_subnets` block supports:
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the network ACL rule name. The value can contain no more than 64 characters,
        including letters, digits, underscores (_), hyphens (-), and periods (.).
        """
        rule_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the rule.
        """
        source_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source IP address or CIDR block of a network ACL rule.
        The `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        source_ip_address_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source IP address group ID of a network ACL rule.
        `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        source_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the source ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.
        """
elif False:
    NetworkAclIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkAclIngressRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 ip_version: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_ip_address_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_port: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 source_ip_address_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Specifies the rule action. The value can be: **allow** and **deny**.
        :param pulumi.Input[_builtins.int] ip_version: Specifies the IP version of a network ACL rule.
               The value can be **4** (IPv4) and **6** (IPv6).
        :param pulumi.Input[_builtins.str] protocol: Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
               or an IP protocol number (0–255). The value **any** indicates all protocols.
        :param pulumi.Input[_builtins.str] description: Specifies the network ACL rule description. The value can contain no more
               than 255 characters. The value cannot contain angle brackets (< or >).
        :param pulumi.Input[_builtins.str] destination_ip_address: Specifies the destination IP address or CIDR block of a network ACL rule.
               The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] destination_ip_address_group_id: Specifies the destination IP address group ID of a network ACL rule.
               The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] destination_port: Specifies the destination ports of a network ACL rule.
               You can specify a single port or a port range. Separate every two entries with a comma.
               
               <a name="subnets"></a>
               The `associated_subnets` block supports:
        :param pulumi.Input[_builtins.str] name: Specifies the network ACL rule name. The value can contain no more than 64 characters,
               including letters, digits, underscores (_), hyphens (-), and periods (.).
        :param pulumi.Input[_builtins.str] rule_id: The ID of the rule.
        :param pulumi.Input[_builtins.str] source_ip_address: Specifies the source IP address or CIDR block of a network ACL rule.
               The `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] source_ip_address_group_id: Specifies the source IP address group ID of a network ACL rule.
               `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        :param pulumi.Input[_builtins.str] source_port: Specifies the source ports of a network ACL rule.
               You can specify a single port or a port range. Separate every two entries with a comma.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip_version", ip_version)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_ip_address is not None:
            pulumi.set(__self__, "destination_ip_address", destination_ip_address)
        if destination_ip_address_group_id is not None:
            pulumi.set(__self__, "destination_ip_address_group_id", destination_ip_address_group_id)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if source_ip_address is not None:
            pulumi.set(__self__, "source_ip_address", source_ip_address)
        if source_ip_address_group_id is not None:
            pulumi.set(__self__, "source_ip_address_group_id", source_ip_address_group_id)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rule action. The value can be: **allow** and **deny**.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input[_builtins.int]:
        """
        Specifies the IP version of a network ACL rule.
        The value can be **4** (IPv4) and **6** (IPv6).
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ip_version", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the rule protocol The value can be **tcp**, **udp**, **icmp**, **icmpv6**,
        or an IP protocol number (0–255). The value **any** indicates all protocols.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the network ACL rule description. The value can contain no more
        than 255 characters. The value cannot contain angle brackets (< or >).
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destinationIpAddress")
    def destination_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination IP address or CIDR block of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "destination_ip_address")

    @destination_ip_address.setter
    def destination_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="destinationIpAddressGroupId")
    def destination_ip_address_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination IP address group ID of a network ACL rule.
        The `destination_ip_address` and `destination_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "destination_ip_address_group_id")

    @destination_ip_address_group_id.setter
    def destination_ip_address_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_ip_address_group_id", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the destination ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.

        <a name="subnets"></a>
        The `associated_subnets` block supports:
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the network ACL rule name. The value can contain no more than 64 characters,
        including letters, digits, underscores (_), hyphens (-), and periods (.).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the rule.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceIpAddress")
    def source_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source IP address or CIDR block of a network ACL rule.
        The `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "source_ip_address")

    @source_ip_address.setter
    def source_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="sourceIpAddressGroupId")
    def source_ip_address_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source IP address group ID of a network ACL rule.
        `source_ip_address` and `source_address_group_id` cannot be configured at the same time.
        """
        return pulumi.get(self, "source_ip_address_group_id")

    @source_ip_address_group_id.setter
    def source_ip_address_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_ip_address_group_id", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the source ports of a network ACL rule.
        You can specify a single port or a port range. Separate every two entries with a comma.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class NetworkV2SegmentArgsDict(TypedDict):
        network_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of physical network.
        """
        physical_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The physical network where this network is implemented.
        """
        segmentation_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        An isolated segment on the physical network.
        """
elif False:
    NetworkV2SegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkV2SegmentArgs:
    def __init__(__self__, *,
                 network_type: Optional[pulumi.Input[_builtins.str]] = None,
                 physical_network: Optional[pulumi.Input[_builtins.str]] = None,
                 segmentation_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] network_type: The type of physical network.
        :param pulumi.Input[_builtins.str] physical_network: The physical network where this network is implemented.
        :param pulumi.Input[_builtins.int] segmentation_id: An isolated segment on the physical network.
        """
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if physical_network is not None:
            pulumi.set(__self__, "physical_network", physical_network)
        if segmentation_id is not None:
            pulumi.set(__self__, "segmentation_id", segmentation_id)

    @_builtins.property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of physical network.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_type", value)

    @_builtins.property
    @pulumi.getter(name="physicalNetwork")
    def physical_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The physical network where this network is implemented.
        """
        return pulumi.get(self, "physical_network")

    @physical_network.setter
    def physical_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "physical_network", value)

    @_builtins.property
    @pulumi.getter(name="segmentationId")
    def segmentation_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        An isolated segment on the physical network.
        """
        return pulumi.get(self, "segmentation_id")

    @segmentation_id.setter
    def segmentation_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "segmentation_id", value)


if not MYPY:
    class PortAllowedAddressPairArgsDict(TypedDict):
        ip_address: pulumi.Input[_builtins.str]
        mac_address: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PortAllowedAddressPairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortAllowedAddressPairArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str],
                 mac_address: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac_address", value)


if not MYPY:
    class PortExtraDhcpOptionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PortExtraDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortExtraDhcpOptionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)


if not MYPY:
    class PortFixedIpArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PortFixedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortFixedIpArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class PortV2AllowedAddressPairArgsDict(TypedDict):
        ip_address: pulumi.Input[_builtins.str]
        """
        The additional IP address.
        """
        mac_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The additional MAC address.
        """
elif False:
    PortV2AllowedAddressPairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortV2AllowedAddressPairArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str],
                 mac_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: The additional IP address.
        :param pulumi.Input[_builtins.str] mac_address: The additional MAC address.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        The additional IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The additional MAC address.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mac_address", value)


if not MYPY:
    class PortV2ExtraDhcpOptionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the DHCP option.
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the DHCP option.
        """
        ip_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        IP protocol version. Defaults to 4.
        """
elif False:
    PortV2ExtraDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortV2ExtraDhcpOptionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 ip_version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the DHCP option.
        :param pulumi.Input[_builtins.str] value: Value of the DHCP option.
        :param pulumi.Input[_builtins.int] ip_version: IP protocol version. Defaults to 4.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the DHCP option.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the DHCP option.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        IP protocol version. Defaults to 4.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ip_version", value)


if not MYPY:
    class PortV2FixedIpArgsDict(TypedDict):
        subnet_id: pulumi.Input[_builtins.str]
        """
        Subnet in which to allocate IP address for this port.
        """
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        IP address desired in the subnet for this port. If you don't specify `ip_address`,
        an available IP address from the specified subnet will be allocated to this port. This field will not be populated if
        it is left blank. To retrieve the assigned IP address, use the `all_fixed_ips`
        attribute.
        """
elif False:
    PortV2FixedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PortV2FixedIpArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[_builtins.str],
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subnet_id: Subnet in which to allocate IP address for this port.
        :param pulumi.Input[_builtins.str] ip_address: IP address desired in the subnet for this port. If you don't specify `ip_address`,
               an available IP address from the specified subnet will be allocated to this port. This field will not be populated if
               it is left blank. To retrieve the assigned IP address, use the `all_fixed_ips`
               attribute.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet in which to allocate IP address for this port.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IP address desired in the subnet for this port. If you don't specify `ip_address`,
        an available IP address from the specified subnet will be allocated to this port. This field will not be populated if
        it is left blank. To retrieve the assigned IP address, use the `all_fixed_ips`
        attribute.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class RouteTableRouteArgsDict(TypedDict):
        destination: pulumi.Input[_builtins.str]
        """
        Specifies the destination address in the CIDR notation format,
        for example, 192.168.200.0/24. The destination of each route must be unique and cannot overlap
        with any subnet in the VPC.
        """
        nexthop: pulumi.Input[_builtins.str]
        """
        Specifies the next hop.
        + If the route type is **ecs**, the value is an ECS instance ID in the VPC.
        + If the route type is **eni**, the value is the extension NIC of an ECS in the VPC.
        + If the route type is **vip**, the value is a virtual IP address.
        + If the route type is **nat**, the value is a VPN gateway ID.
        + If the route type is **peering**, the value is a VPC peering connection ID.
        + If the route type is **vpn**, the value is a VPN gateway ID.
        + If the route type is **dc**, the value is a Direct Connect gateway ID.
        + If the route type is **cc**, the value is a Cloud Connection ID.
        + If the route type is **egw**, the value is a VPCEP endpoint ID.
        + If the route type is **er**, the value is a ER instance ID.
        """
        type: pulumi.Input[_builtins.str]
        """
        Specifies the route type. Currently, the value can be:
        **ecs**, **eni**, **vip**, **nat**, **peering**, **vpn**, **dc**, **cc**, **egw** and **er**.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the supplementary information about the route.
        The value is a string of no more than 255 characters and cannot contain angle brackets (< or >).
        """
elif False:
    RouteTableRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteTableRouteArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[_builtins.str],
                 nexthop: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination: Specifies the destination address in the CIDR notation format,
               for example, 192.168.200.0/24. The destination of each route must be unique and cannot overlap
               with any subnet in the VPC.
        :param pulumi.Input[_builtins.str] nexthop: Specifies the next hop.
               + If the route type is **ecs**, the value is an ECS instance ID in the VPC.
               + If the route type is **eni**, the value is the extension NIC of an ECS in the VPC.
               + If the route type is **vip**, the value is a virtual IP address.
               + If the route type is **nat**, the value is a VPN gateway ID.
               + If the route type is **peering**, the value is a VPC peering connection ID.
               + If the route type is **vpn**, the value is a VPN gateway ID.
               + If the route type is **dc**, the value is a Direct Connect gateway ID.
               + If the route type is **cc**, the value is a Cloud Connection ID.
               + If the route type is **egw**, the value is a VPCEP endpoint ID.
               + If the route type is **er**, the value is a ER instance ID.
        :param pulumi.Input[_builtins.str] type: Specifies the route type. Currently, the value can be:
               **ecs**, **eni**, **vip**, **nat**, **peering**, **vpn**, **dc**, **cc**, **egw** and **er**.
        :param pulumi.Input[_builtins.str] description: Specifies the supplementary information about the route.
               The value is a string of no more than 255 characters and cannot contain angle brackets (< or >).
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "nexthop", nexthop)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the destination address in the CIDR notation format,
        for example, 192.168.200.0/24. The destination of each route must be unique and cannot overlap
        with any subnet in the VPC.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the next hop.
        + If the route type is **ecs**, the value is an ECS instance ID in the VPC.
        + If the route type is **eni**, the value is the extension NIC of an ECS in the VPC.
        + If the route type is **vip**, the value is a virtual IP address.
        + If the route type is **nat**, the value is a VPN gateway ID.
        + If the route type is **peering**, the value is a VPC peering connection ID.
        + If the route type is **vpn**, the value is a VPN gateway ID.
        + If the route type is **dc**, the value is a Direct Connect gateway ID.
        + If the route type is **cc**, the value is a Cloud Connection ID.
        + If the route type is **egw**, the value is a VPCEP endpoint ID.
        + If the route type is **er**, the value is a ER instance ID.
        """
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nexthop", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the route type. Currently, the value can be:
        **ecs**, **eni**, **vip**, **nat**, **peering**, **vpn**, **dc**, **cc**, **egw** and **er**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the supplementary information about the route.
        The value is a string of no more than 255 characters and cannot contain angle brackets (< or >).
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class RouterV2ExternalFixedIpArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address to set on the router.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subnet in which the fixed IP belongs to.
        """
elif False:
    RouterV2ExternalFixedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterV2ExternalFixedIpArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_address: The IP address to set on the router.
        :param pulumi.Input[_builtins.str] subnet_id: Subnet in which the fixed IP belongs to.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address to set on the router.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subnet in which the fixed IP belongs to.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class SecgroupRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The effective policy.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the description for the security group.
        """
        direction: NotRequired[pulumi.Input[_builtins.str]]
        """
        The direction of the rule. The value can be *egress* or *ingress*.
        """
        ethertype: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol version. The value can be *IPv4* or *IPv6*.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The security group rule ID.
        """
        port_range_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Deprecated
        """
        port_range_min: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Deprecated
        """
        ports: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port value range.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority number.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The protocol type.
        """
        remote_address_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the remote address group.
        """
        remote_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the peer security group.
        """
        remote_ip_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The remote IP address. The value can be in the CIDR format or IP addresses.
        """
elif False:
    SecgroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecgroupRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 ethertype: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_range_max: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range_min: Optional[pulumi.Input[_builtins.int]] = None,
                 ports: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_address_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_ip_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The effective policy.
        :param pulumi.Input[_builtins.str] description: Specifies the description for the security group.
        :param pulumi.Input[_builtins.str] direction: The direction of the rule. The value can be *egress* or *ingress*.
        :param pulumi.Input[_builtins.str] ethertype: The IP protocol version. The value can be *IPv4* or *IPv6*.
        :param pulumi.Input[_builtins.str] id: The security group rule ID.
        :param pulumi.Input[_builtins.int] port_range_max: schema: Deprecated
        :param pulumi.Input[_builtins.int] port_range_min: schema: Deprecated
        :param pulumi.Input[_builtins.str] ports: The port value range.
        :param pulumi.Input[_builtins.int] priority: The priority number.
        :param pulumi.Input[_builtins.str] protocol: The protocol type.
        :param pulumi.Input[_builtins.str] remote_address_group_id: The ID of the remote address group.
        :param pulumi.Input[_builtins.str] remote_group_id: The ID of the peer security group.
        :param pulumi.Input[_builtins.str] remote_ip_prefix: The remote IP address. The value can be in the CIDR format or IP addresses.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if ethertype is not None:
            pulumi.set(__self__, "ethertype", ethertype)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port_range_max is not None:
            pulumi.set(__self__, "port_range_max", port_range_max)
        if port_range_min is not None:
            pulumi.set(__self__, "port_range_min", port_range_min)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if remote_address_group_id is not None:
            pulumi.set(__self__, "remote_address_group_id", remote_address_group_id)
        if remote_group_id is not None:
            pulumi.set(__self__, "remote_group_id", remote_group_id)
        if remote_ip_prefix is not None:
            pulumi.set(__self__, "remote_ip_prefix", remote_ip_prefix)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The effective policy.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the description for the security group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The direction of the rule. The value can be *egress* or *ingress*.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def ethertype(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol version. The value can be *IPv4* or *IPv6*.
        """
        return pulumi.get(self, "ethertype")

    @ethertype.setter
    def ethertype(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ethertype", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The security group rule ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMax")
    def port_range_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_range_max")

    @port_range_max.setter
    def port_range_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_max", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMin")
    def port_range_min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_range_min")

    @port_range_min.setter
    def port_range_min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_min", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port value range.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority number.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The protocol type.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="remoteAddressGroupId")
    def remote_address_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the remote address group.
        """
        return pulumi.get(self, "remote_address_group_id")

    @remote_address_group_id.setter
    def remote_address_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_address_group_id", value)

    @_builtins.property
    @pulumi.getter(name="remoteGroupId")
    def remote_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the peer security group.
        """
        return pulumi.get(self, "remote_group_id")

    @remote_group_id.setter
    def remote_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_group_id", value)

    @_builtins.property
    @pulumi.getter(name="remoteIpPrefix")
    def remote_ip_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The remote IP address. The value can be in the CIDR format or IP addresses.
        """
        return pulumi.get(self, "remote_ip_prefix")

    @remote_ip_prefix.setter
    def remote_ip_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_ip_prefix", value)


if not MYPY:
    class SecgroupV2RuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[_builtins.str]]
        description: NotRequired[pulumi.Input[_builtins.str]]
        direction: NotRequired[pulumi.Input[_builtins.str]]
        ethertype: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        port_range_max: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Deprecated
        """
        port_range_min: NotRequired[pulumi.Input[_builtins.int]]
        """
        schema: Deprecated
        """
        ports: NotRequired[pulumi.Input[_builtins.str]]
        priority: NotRequired[pulumi.Input[_builtins.int]]
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        remote_address_group_id: NotRequired[pulumi.Input[_builtins.str]]
        remote_group_id: NotRequired[pulumi.Input[_builtins.str]]
        remote_ip_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    SecgroupV2RuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecgroupV2RuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 direction: Optional[pulumi.Input[_builtins.str]] = None,
                 ethertype: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 port_range_max: Optional[pulumi.Input[_builtins.int]] = None,
                 port_range_min: Optional[pulumi.Input[_builtins.int]] = None,
                 ports: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_address_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_ip_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] port_range_max: schema: Deprecated
        :param pulumi.Input[_builtins.int] port_range_min: schema: Deprecated
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if ethertype is not None:
            pulumi.set(__self__, "ethertype", ethertype)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port_range_max is not None:
            pulumi.set(__self__, "port_range_max", port_range_max)
        if port_range_min is not None:
            pulumi.set(__self__, "port_range_min", port_range_min)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if remote_address_group_id is not None:
            pulumi.set(__self__, "remote_address_group_id", remote_address_group_id)
        if remote_group_id is not None:
            pulumi.set(__self__, "remote_group_id", remote_group_id)
        if remote_ip_prefix is not None:
            pulumi.set(__self__, "remote_ip_prefix", remote_ip_prefix)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def ethertype(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ethertype")

    @ethertype.setter
    def ethertype(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ethertype", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMax")
    def port_range_max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_range_max")

    @port_range_max.setter
    def port_range_max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_max", value)

    @_builtins.property
    @pulumi.getter(name="portRangeMin")
    def port_range_min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_range_min")

    @port_range_min.setter
    def port_range_min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port_range_min", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="remoteAddressGroupId")
    def remote_address_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "remote_address_group_id")

    @remote_address_group_id.setter
    def remote_address_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_address_group_id", value)

    @_builtins.property
    @pulumi.getter(name="remoteGroupId")
    def remote_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "remote_group_id")

    @remote_group_id.setter
    def remote_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_group_id", value)

    @_builtins.property
    @pulumi.getter(name="remoteIpPrefix")
    def remote_ip_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "remote_ip_prefix")

    @remote_ip_prefix.setter
    def remote_ip_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_ip_prefix", value)


if not MYPY:
    class SubnetV2AllocationPoolArgsDict(TypedDict):
        end: pulumi.Input[_builtins.str]
        """
        The ending address.
        """
        start: pulumi.Input[_builtins.str]
        """
        The starting address.
        """
elif False:
    SubnetV2AllocationPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2AllocationPoolArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[_builtins.str],
                 start: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] end: The ending address.
        :param pulumi.Input[_builtins.str] start: The starting address.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> pulumi.Input[_builtins.str]:
        """
        The ending address.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end", value)

    @_builtins.property
    @pulumi.getter
    def start(self) -> pulumi.Input[_builtins.str]:
        """
        The starting address.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class SubnetV2HostRouteArgsDict(TypedDict):
        destination_cidr: pulumi.Input[_builtins.str]
        """
        The destination CIDR.
        """
        next_hop: pulumi.Input[_builtins.str]
        """
        The next hop in the route.
        """
elif False:
    SubnetV2HostRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2HostRouteArgs:
    def __init__(__self__, *,
                 destination_cidr: pulumi.Input[_builtins.str],
                 next_hop: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] destination_cidr: The destination CIDR.
        :param pulumi.Input[_builtins.str] next_hop: The next hop in the route.
        """
        pulumi.set(__self__, "destination_cidr", destination_cidr)
        pulumi.set(__self__, "next_hop", next_hop)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> pulumi.Input[_builtins.str]:
        """
        The destination CIDR.
        """
        return pulumi.get(self, "destination_cidr")

    @destination_cidr.setter
    def destination_cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_cidr", value)

    @_builtins.property
    @pulumi.getter(name="nextHop")
    def next_hop(self) -> pulumi.Input[_builtins.str]:
        """
        The next hop in the route.
        """
        return pulumi.get(self, "next_hop")

    @next_hop.setter
    def next_hop(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "next_hop", value)


if not MYPY:
    class V1RouteArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        nexthop: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    V1RouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class V1RouteArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 nexthop: Optional[pulumi.Input[_builtins.str]] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nexthop", value)


if not MYPY:
    class VpcRouteArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[_builtins.str]]
        nexthop: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VpcRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcRouteArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 nexthop: Optional[pulumi.Input[_builtins.str]] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "nexthop", value)


if not MYPY:
    class GetByTagsMatchArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        value: _builtins.str
        """
        Specifies the value of the match.
        """
elif False:
    GetByTagsMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetByTagsMatchArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param _builtins.str value: Specifies the value of the match.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the match.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetByTagsTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
elif False:
    GetByTagsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetByTagsTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param Sequence[_builtins.str] values: Specifies the values of the tag.
               
               <a name="matches"></a>
               The `matches` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetNetworkAclsByTagsMatchArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        value: _builtins.str
        """
        Specifies the value of the match.
        """
elif False:
    GetNetworkAclsByTagsMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkAclsByTagsMatchArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param _builtins.str value: Specifies the value of the match.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the match.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNetworkAclsByTagsTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
elif False:
    GetNetworkAclsByTagsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkAclsByTagsTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param Sequence[_builtins.str] values: Specifies the values of the tag.
               
               <a name="matches"></a>
               The `matches` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSecgroupsByTagsMatchArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        value: _builtins.str
        """
        Specifies the value of the match.
        """
elif False:
    GetSecgroupsByTagsMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecgroupsByTagsMatchArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param _builtins.str value: Specifies the value of the match.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the match.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetSecgroupsByTagsTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
elif False:
    GetSecgroupsByTagsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecgroupsByTagsTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param Sequence[_builtins.str] values: Specifies the values of the tag.
               
               <a name="matches"></a>
               The `matches` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSubnetsByTagsMatchArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        value: _builtins.str
        """
        Specifies the value of the match.
        """
elif False:
    GetSubnetsByTagsMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetsByTagsMatchArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param _builtins.str value: Specifies the value of the match.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Specifies the value of the match.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetSubnetsByTagsTagArgsDict(TypedDict):
        key: _builtins.str
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        values: Sequence[_builtins.str]
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
elif False:
    GetSubnetsByTagsTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetsByTagsTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: Specifies the key of the match. The value can be: **resource_name**.
        :param Sequence[_builtins.str] values: Specifies the values of the tag.
               
               <a name="matches"></a>
               The `matches` block supports:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Specifies the key of the match. The value can be: **resource_name**.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Specifies the values of the tag.

        <a name="matches"></a>
        The `matches` block supports:
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)


