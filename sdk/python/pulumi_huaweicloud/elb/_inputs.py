# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ListenerInsertHeadersArgs',
    'ListenerInsertHeadersArgsDict',
    'ListenerV2InsertHeadersArgs',
    'ListenerV2InsertHeadersArgsDict',
    'PoolPersistenceArgs',
    'PoolPersistenceArgsDict',
    'PoolV2PersistenceArgs',
    'PoolV2PersistenceArgsDict',
]

MYPY = False

if not MYPY:
    class ListenerInsertHeadersArgsDict(TypedDict):
        x_forwarded_elb_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether to transparently transmit the load balancer EIP to backend
        servers. After this function is enabled, the load balancer EIP is stored in the HTTP header and passes to backend servers.
        Value options:
        + **true**: This function is enabled.
        + **false (default)**: The function is disabled.
        """
        x_forwarded_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies whether to rewrite the X-Forwarded-Host header. If this function is
        enabled, **X-Forwarded-Host** is rewritten based on Host in the request and sent to backend servers. Value options:
        + **true (default)**: This function is enabled.
        + **false**: The function is disabled.
        """
elif False:
    ListenerInsertHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerInsertHeadersArgs:
    def __init__(__self__, *,
                 x_forwarded_elb_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_host: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] x_forwarded_elb_ip: Specifies whether to transparently transmit the load balancer EIP to backend
               servers. After this function is enabled, the load balancer EIP is stored in the HTTP header and passes to backend servers.
               Value options:
               + **true**: This function is enabled.
               + **false (default)**: The function is disabled.
        :param pulumi.Input[_builtins.str] x_forwarded_host: Specifies whether to rewrite the X-Forwarded-Host header. If this function is
               enabled, **X-Forwarded-Host** is rewritten based on Host in the request and sent to backend servers. Value options:
               + **true (default)**: This function is enabled.
               + **false**: The function is disabled.
        """
        if x_forwarded_elb_ip is not None:
            pulumi.set(__self__, "x_forwarded_elb_ip", x_forwarded_elb_ip)
        if x_forwarded_host is not None:
            pulumi.set(__self__, "x_forwarded_host", x_forwarded_host)

    @_builtins.property
    @pulumi.getter(name="xForwardedElbIp")
    def x_forwarded_elb_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether to transparently transmit the load balancer EIP to backend
        servers. After this function is enabled, the load balancer EIP is stored in the HTTP header and passes to backend servers.
        Value options:
        + **true**: This function is enabled.
        + **false (default)**: The function is disabled.
        """
        return pulumi.get(self, "x_forwarded_elb_ip")

    @x_forwarded_elb_ip.setter
    def x_forwarded_elb_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_elb_ip", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedHost")
    def x_forwarded_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies whether to rewrite the X-Forwarded-Host header. If this function is
        enabled, **X-Forwarded-Host** is rewritten based on Host in the request and sent to backend servers. Value options:
        + **true (default)**: This function is enabled.
        + **false**: The function is disabled.
        """
        return pulumi.get(self, "x_forwarded_host")

    @x_forwarded_host.setter
    def x_forwarded_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_host", value)


if not MYPY:
    class ListenerV2InsertHeadersArgsDict(TypedDict):
        x_forwarded_elb_ip: NotRequired[pulumi.Input[_builtins.str]]
        x_forwarded_host: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ListenerV2InsertHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ListenerV2InsertHeadersArgs:
    def __init__(__self__, *,
                 x_forwarded_elb_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 x_forwarded_host: Optional[pulumi.Input[_builtins.str]] = None):
        if x_forwarded_elb_ip is not None:
            pulumi.set(__self__, "x_forwarded_elb_ip", x_forwarded_elb_ip)
        if x_forwarded_host is not None:
            pulumi.set(__self__, "x_forwarded_host", x_forwarded_host)

    @_builtins.property
    @pulumi.getter(name="xForwardedElbIp")
    def x_forwarded_elb_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "x_forwarded_elb_ip")

    @x_forwarded_elb_ip.setter
    def x_forwarded_elb_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_elb_ip", value)

    @_builtins.property
    @pulumi.getter(name="xForwardedHost")
    def x_forwarded_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "x_forwarded_host")

    @x_forwarded_host.setter
    def x_forwarded_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "x_forwarded_host", value)


if not MYPY:
    class PoolPersistenceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of persistence mode. The current specification supports SOURCE_IP,
        HTTP_COOKIE, and APP_COOKIE.
        """
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the cookie if persistence mode is set appropriately. Required
        if `type = APP_COOKIE`.
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the sticky session timeout duration in minutes. This parameter is
        invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
        + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
        + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
        """
elif False:
    PoolPersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PoolPersistenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of persistence mode. The current specification supports SOURCE_IP,
               HTTP_COOKIE, and APP_COOKIE.
        :param pulumi.Input[_builtins.str] cookie_name: The name of the cookie if persistence mode is set appropriately. Required
               if `type = APP_COOKIE`.
        :param pulumi.Input[_builtins.int] timeout: Specifies the sticky session timeout duration in minutes. This parameter is
               invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
               + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
               + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
        """
        pulumi.set(__self__, "type", type)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of persistence mode. The current specification supports SOURCE_IP,
        HTTP_COOKIE, and APP_COOKIE.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the cookie if persistence mode is set appropriately. Required
        if `type = APP_COOKIE`.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the sticky session timeout duration in minutes. This parameter is
        invalid when type is set to APP_COOKIE. The value range varies depending on the protocol of the backend server group:
        + When the protocol of the backend server group is TCP or UDP, the value ranges from 1 to 60.
        + When the protocol of the backend server group is HTTP or HTTPS, the value ranges from 1 to 1440.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class PoolV2PersistenceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        timeout: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    PoolV2PersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PoolV2PersistenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "type", type)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


