# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ClusterActionRestart',
    'ClusterInstance',
    'ClusterV1Instance',
    'JobConfig',
    'GetClustersClusterResult',
    'GetClustersClusterInstanceResult',
    'GetFlavorsFlavorResult',
    'GetFlavorsV1FlavorResult',
    'GetJobExecutionRecordsRecordResult',
    'GetJobExecutionRecordsRecordCounterResult',
]

@pulumi.output_type
class ClusterActionRestart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayTime":
            suggest = "delay_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterActionRestart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterActionRestart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterActionRestart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: _builtins.str,
                 mode: _builtins.str,
                 delay_time: Optional[_builtins.int] = None):
        """
        :param _builtins.str level: Restart level.  
               Value options are as follows:
               + **SERVICE**: service restart.
               + **VM**: VM restart.
               
               Changing this parameter will create a new resource.
        :param _builtins.str mode: Restart mode.  
               Value options are as follows:
               + **IMMEDIATELY**: immediate restart.
               + **FORCIBLY**: forcible restart.
               Restarte the service process will interrupt the service process and restart the VMs in the cluster.
               + **SOFTLY**: common restart.
               
               Changing this parameter will create a new resource.
        :param _builtins.int delay_time: Restart delay, in seconds.
               
               Changing this parameter will create a new resource.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "mode", mode)
        if delay_time is not None:
            pulumi.set(__self__, "delay_time", delay_time)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        Restart level.  
        Value options are as follows:
        + **SERVICE**: service restart.
        + **VM**: VM restart.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        Restart mode.  
        Value options are as follows:
        + **IMMEDIATELY**: immediate restart.
        + **FORCIBLY**: forcible restart.
        Restarte the service process will interrupt the service process and restart the VMs in the cluster.
        + **SOFTLY**: common restart.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="delayTime")
    def delay_time(self) -> Optional[_builtins.int]:
        """
        Restart delay, in seconds.

        Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "delay_time")


@pulumi.output_type
class ClusterInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manageIp":
            suggest = "manage_ip"
        elif key == "privateIp":
            suggest = "private_ip"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "trafficIp":
            suggest = "traffic_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 manage_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 private_ip: Optional[_builtins.str] = None,
                 public_ip: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 traffic_ip: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Instance ID.
        :param _builtins.str manage_ip: Management IP address.
        :param _builtins.str name: Specifies cluster name. Changing this parameter will create a new resource.
        :param _builtins.str private_ip: Private IP.
        :param _builtins.str public_ip: Public IP.
        :param _builtins.str role: Instance role.
        :param _builtins.str traffic_ip: Traffic IP.
        :param _builtins.str type: Instance type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if manage_ip is not None:
            pulumi.set(__self__, "manage_ip", manage_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_ip is not None:
            pulumi.set(__self__, "traffic_ip", traffic_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="manageIp")
    def manage_ip(self) -> Optional[_builtins.str]:
        """
        Management IP address.
        """
        return pulumi.get(self, "manage_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies cluster name. Changing this parameter will create a new resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[_builtins.str]:
        """
        Private IP.
        """
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        """
        Public IP.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Instance role.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="trafficIp")
    def traffic_ip(self) -> Optional[_builtins.str]:
        """
        Traffic IP.
        """
        return pulumi.get(self, "traffic_ip")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Instance type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterV1Instance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manageIp":
            suggest = "manage_ip"
        elif key == "privateIp":
            suggest = "private_ip"
        elif key == "publicIp":
            suggest = "public_ip"
        elif key == "trafficIp":
            suggest = "traffic_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV1Instance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV1Instance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV1Instance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 manage_ip: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 private_ip: Optional[_builtins.str] = None,
                 public_ip: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 traffic_ip: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if manage_ip is not None:
            pulumi.set(__self__, "manage_ip", manage_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_ip is not None:
            pulumi.set(__self__, "traffic_ip", traffic_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="manageIp")
    def manage_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "manage_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="trafficIp")
    def traffic_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "traffic_ip")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class JobConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "retryType":
            suggest = "retry_type"
        elif key == "schedulerCycle":
            suggest = "scheduler_cycle"
        elif key == "schedulerCycleType":
            suggest = "scheduler_cycle_type"
        elif key == "schedulerDisposableType":
            suggest = "scheduler_disposable_type"
        elif key == "schedulerEnabled":
            suggest = "scheduler_enabled"
        elif key == "schedulerRunAt":
            suggest = "scheduler_run_at"
        elif key == "schedulerStartDate":
            suggest = "scheduler_start_date"
        elif key == "schedulerStopDate":
            suggest = "scheduler_stop_date"
        elif key == "throttlingDirtyWriteToBucket":
            suggest = "throttling_dirty_write_to_bucket"
        elif key == "throttlingDirtyWriteToDirectory":
            suggest = "throttling_dirty_write_to_directory"
        elif key == "throttlingDirtyWriteToLink":
            suggest = "throttling_dirty_write_to_link"
        elif key == "throttlingExtractorsNumber":
            suggest = "throttling_extractors_number"
        elif key == "throttlingLoaderNumber":
            suggest = "throttling_loader_number"
        elif key == "throttlingMaxErrorRecords":
            suggest = "throttling_max_error_records"
        elif key == "throttlingRecordDirtyData":
            suggest = "throttling_record_dirty_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[_builtins.str] = None,
                 retry_type: Optional[_builtins.str] = None,
                 scheduler_cycle: Optional[_builtins.int] = None,
                 scheduler_cycle_type: Optional[_builtins.str] = None,
                 scheduler_disposable_type: Optional[_builtins.str] = None,
                 scheduler_enabled: Optional[_builtins.bool] = None,
                 scheduler_run_at: Optional[_builtins.str] = None,
                 scheduler_start_date: Optional[_builtins.str] = None,
                 scheduler_stop_date: Optional[_builtins.str] = None,
                 throttling_dirty_write_to_bucket: Optional[_builtins.str] = None,
                 throttling_dirty_write_to_directory: Optional[_builtins.str] = None,
                 throttling_dirty_write_to_link: Optional[_builtins.str] = None,
                 throttling_extractors_number: Optional[_builtins.int] = None,
                 throttling_loader_number: Optional[_builtins.int] = None,
                 throttling_max_error_records: Optional[_builtins.int] = None,
                 throttling_record_dirty_data: Optional[_builtins.bool] = None):
        """
        :param _builtins.str group_name: Specifies group to which a job belongs. The default group is `DEFAULT`.
        :param _builtins.str retry_type: Specifies whether to automatically retry if a job fails to be executed.
               The options are as follows:
               + **NONE**: Do not retry.
               + **RETRY_TRIPLE**: Retry three times.
               
               Default value is `NONE`.
        :param _builtins.int scheduler_cycle: Specifies cycle of a scheduled task. If `scheduler_cycle_type` is set to minute
               and `scheduler_cycle` is set to 10, the scheduled task is executed every 10 minutes.
        :param _builtins.str scheduler_cycle_type: Specifies cycle type of a scheduled task. The options are as follows:
               `minute`, `hour`, `day`, `week`, `month`.
        :param _builtins.str scheduler_disposable_type: Specifies whether to delete a job after the job is executed.
               The options are as follows:
               + **NONE**: The job will not be deleted after it is executed.
               + **DELETE_AFTER_SUCCEED**: The job will be deleted only after it is successfully executed. It is applicable to
               massive one-time jobs.
               + **DELETE**: The job will be deleted after it is executed, regardless of the execution result.
        :param _builtins.bool scheduler_enabled: Specifies whether to enable a scheduled task.  Default value is `false`.
        :param _builtins.str scheduler_run_at: Specifies time when a scheduled task is triggered in a cycle. This parameter
               is valid only when `scheduler_cycle_type` is set to `hour`, `week`, or `month`.
               + If `scheduler_cycle_type` is set to month, cycle is set to 1, and runAt is set to 15, the scheduled task is executed
               on the 15th day of each month. You can set runAt to multiple values and separate the values with commas (,).
               For example, if runAt is set to 1,2,3,4,5, the scheduled task is executed on the first day, second day, third day,
               fourth day, and fifth day of each month.
               + If `scheduler_cycle_type` is set to week and runAt is set to mon,tue,wed,thu,fri, the scheduled task is executed on
               Monday to Friday.
               + If `scheduler_cycle_type` is set to hour and runAt is set to 27,57, the scheduled task is executed at the 27th and
               57th minute in the cycle.
        :param _builtins.str scheduler_start_date: Specifies start time of a scheduled task.
               For example, `2018-01-24 19:56:19`
        :param _builtins.str scheduler_stop_date: Specifies End time of a scheduled task. For example, `2018-01-27 23:59:00`.
               If you do not set the end time, the scheduled task is always executed and will never stop.
        :param _builtins.str throttling_dirty_write_to_bucket: Specifies name of the OBS bucket to which dirty data is
               written. This parameter is valid only when dirty data is written to `OBS`.
        :param _builtins.str throttling_dirty_write_to_directory: Specifies the directory in the OBS bucket or HDFS which
               dirty data is written to. For example, `/data/dirtydata/`.
        :param _builtins.str throttling_dirty_write_to_link: Specifies the link name to which dirty data is written to.
               The Dirty data can be written only to `OBS` or `HDFS`.
        :param _builtins.int throttling_extractors_number: Specifies maximum number of concurrent extraction jobs.
        :param _builtins.int throttling_loader_number: Specifies maximum number of loading jobs. This parameter is available
               only when HBase or Hive serves as the destination data source.
        :param _builtins.int throttling_max_error_records: Specifies maximum number of error records in a single
               shard. When the number of error records of a map exceeds the upper limit, the task automatically ends.
        :param _builtins.bool throttling_record_dirty_data: Specifies whether to write dirty data.
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if retry_type is not None:
            pulumi.set(__self__, "retry_type", retry_type)
        if scheduler_cycle is not None:
            pulumi.set(__self__, "scheduler_cycle", scheduler_cycle)
        if scheduler_cycle_type is not None:
            pulumi.set(__self__, "scheduler_cycle_type", scheduler_cycle_type)
        if scheduler_disposable_type is not None:
            pulumi.set(__self__, "scheduler_disposable_type", scheduler_disposable_type)
        if scheduler_enabled is not None:
            pulumi.set(__self__, "scheduler_enabled", scheduler_enabled)
        if scheduler_run_at is not None:
            pulumi.set(__self__, "scheduler_run_at", scheduler_run_at)
        if scheduler_start_date is not None:
            pulumi.set(__self__, "scheduler_start_date", scheduler_start_date)
        if scheduler_stop_date is not None:
            pulumi.set(__self__, "scheduler_stop_date", scheduler_stop_date)
        if throttling_dirty_write_to_bucket is not None:
            pulumi.set(__self__, "throttling_dirty_write_to_bucket", throttling_dirty_write_to_bucket)
        if throttling_dirty_write_to_directory is not None:
            pulumi.set(__self__, "throttling_dirty_write_to_directory", throttling_dirty_write_to_directory)
        if throttling_dirty_write_to_link is not None:
            pulumi.set(__self__, "throttling_dirty_write_to_link", throttling_dirty_write_to_link)
        if throttling_extractors_number is not None:
            pulumi.set(__self__, "throttling_extractors_number", throttling_extractors_number)
        if throttling_loader_number is not None:
            pulumi.set(__self__, "throttling_loader_number", throttling_loader_number)
        if throttling_max_error_records is not None:
            pulumi.set(__self__, "throttling_max_error_records", throttling_max_error_records)
        if throttling_record_dirty_data is not None:
            pulumi.set(__self__, "throttling_record_dirty_data", throttling_record_dirty_data)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        Specifies group to which a job belongs. The default group is `DEFAULT`.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="retryType")
    def retry_type(self) -> Optional[_builtins.str]:
        """
        Specifies whether to automatically retry if a job fails to be executed.
        The options are as follows:
        + **NONE**: Do not retry.
        + **RETRY_TRIPLE**: Retry three times.

        Default value is `NONE`.
        """
        return pulumi.get(self, "retry_type")

    @_builtins.property
    @pulumi.getter(name="schedulerCycle")
    def scheduler_cycle(self) -> Optional[_builtins.int]:
        """
        Specifies cycle of a scheduled task. If `scheduler_cycle_type` is set to minute
        and `scheduler_cycle` is set to 10, the scheduled task is executed every 10 minutes.
        """
        return pulumi.get(self, "scheduler_cycle")

    @_builtins.property
    @pulumi.getter(name="schedulerCycleType")
    def scheduler_cycle_type(self) -> Optional[_builtins.str]:
        """
        Specifies cycle type of a scheduled task. The options are as follows:
        `minute`, `hour`, `day`, `week`, `month`.
        """
        return pulumi.get(self, "scheduler_cycle_type")

    @_builtins.property
    @pulumi.getter(name="schedulerDisposableType")
    def scheduler_disposable_type(self) -> Optional[_builtins.str]:
        """
        Specifies whether to delete a job after the job is executed.
        The options are as follows:
        + **NONE**: The job will not be deleted after it is executed.
        + **DELETE_AFTER_SUCCEED**: The job will be deleted only after it is successfully executed. It is applicable to
        massive one-time jobs.
        + **DELETE**: The job will be deleted after it is executed, regardless of the execution result.
        """
        return pulumi.get(self, "scheduler_disposable_type")

    @_builtins.property
    @pulumi.getter(name="schedulerEnabled")
    def scheduler_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable a scheduled task.  Default value is `false`.
        """
        return pulumi.get(self, "scheduler_enabled")

    @_builtins.property
    @pulumi.getter(name="schedulerRunAt")
    def scheduler_run_at(self) -> Optional[_builtins.str]:
        """
        Specifies time when a scheduled task is triggered in a cycle. This parameter
        is valid only when `scheduler_cycle_type` is set to `hour`, `week`, or `month`.
        + If `scheduler_cycle_type` is set to month, cycle is set to 1, and runAt is set to 15, the scheduled task is executed
        on the 15th day of each month. You can set runAt to multiple values and separate the values with commas (,).
        For example, if runAt is set to 1,2,3,4,5, the scheduled task is executed on the first day, second day, third day,
        fourth day, and fifth day of each month.
        + If `scheduler_cycle_type` is set to week and runAt is set to mon,tue,wed,thu,fri, the scheduled task is executed on
        Monday to Friday.
        + If `scheduler_cycle_type` is set to hour and runAt is set to 27,57, the scheduled task is executed at the 27th and
        57th minute in the cycle.
        """
        return pulumi.get(self, "scheduler_run_at")

    @_builtins.property
    @pulumi.getter(name="schedulerStartDate")
    def scheduler_start_date(self) -> Optional[_builtins.str]:
        """
        Specifies start time of a scheduled task.
        For example, `2018-01-24 19:56:19`
        """
        return pulumi.get(self, "scheduler_start_date")

    @_builtins.property
    @pulumi.getter(name="schedulerStopDate")
    def scheduler_stop_date(self) -> Optional[_builtins.str]:
        """
        Specifies End time of a scheduled task. For example, `2018-01-27 23:59:00`.
        If you do not set the end time, the scheduled task is always executed and will never stop.
        """
        return pulumi.get(self, "scheduler_stop_date")

    @_builtins.property
    @pulumi.getter(name="throttlingDirtyWriteToBucket")
    def throttling_dirty_write_to_bucket(self) -> Optional[_builtins.str]:
        """
        Specifies name of the OBS bucket to which dirty data is
        written. This parameter is valid only when dirty data is written to `OBS`.
        """
        return pulumi.get(self, "throttling_dirty_write_to_bucket")

    @_builtins.property
    @pulumi.getter(name="throttlingDirtyWriteToDirectory")
    def throttling_dirty_write_to_directory(self) -> Optional[_builtins.str]:
        """
        Specifies the directory in the OBS bucket or HDFS which
        dirty data is written to. For example, `/data/dirtydata/`.
        """
        return pulumi.get(self, "throttling_dirty_write_to_directory")

    @_builtins.property
    @pulumi.getter(name="throttlingDirtyWriteToLink")
    def throttling_dirty_write_to_link(self) -> Optional[_builtins.str]:
        """
        Specifies the link name to which dirty data is written to.
        The Dirty data can be written only to `OBS` or `HDFS`.
        """
        return pulumi.get(self, "throttling_dirty_write_to_link")

    @_builtins.property
    @pulumi.getter(name="throttlingExtractorsNumber")
    def throttling_extractors_number(self) -> Optional[_builtins.int]:
        """
        Specifies maximum number of concurrent extraction jobs.
        """
        return pulumi.get(self, "throttling_extractors_number")

    @_builtins.property
    @pulumi.getter(name="throttlingLoaderNumber")
    def throttling_loader_number(self) -> Optional[_builtins.int]:
        """
        Specifies maximum number of loading jobs. This parameter is available
        only when HBase or Hive serves as the destination data source.
        """
        return pulumi.get(self, "throttling_loader_number")

    @_builtins.property
    @pulumi.getter(name="throttlingMaxErrorRecords")
    def throttling_max_error_records(self) -> Optional[_builtins.int]:
        """
        Specifies maximum number of error records in a single
        shard. When the number of error records of a map exceeds the upper limit, the task automatically ends.
        """
        return pulumi.get(self, "throttling_max_error_records")

    @_builtins.property
    @pulumi.getter(name="throttlingRecordDirtyData")
    def throttling_record_dirty_data(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to write dirty data.
        """
        return pulumi.get(self, "throttling_record_dirty_data")


@pulumi.output_type
class GetClustersClusterResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 id: _builtins.str,
                 instances: Sequence['outputs.GetClustersClusterInstanceResult'],
                 is_auto_off: _builtins.bool,
                 is_failure_remind: _builtins.str,
                 is_frozen: _builtins.str,
                 name: _builtins.str,
                 public_endpoint: _builtins.str,
                 recent_event: _builtins.int,
                 status: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str availability_zone: The AZ name.
        :param _builtins.str id: Instance ID.
        :param Sequence['GetClustersClusterInstanceArgs'] instances: The list of instance nodes.
               The Instance structure is documented below.
        :param _builtins.bool is_auto_off: Whether auto shutdown is enabled.
        :param _builtins.str is_failure_remind: Whether to notifications when a table/file migration job fails or an EIP exception occurs.
        :param _builtins.str is_frozen: Whether the node is frozen. The value can be 0 (not frozen) or 1 (frozen).
        :param _builtins.str name: Cluster name.
        :param _builtins.str public_endpoint: EIP bound to the cluster.
        :param _builtins.int recent_event: Number of events.
        :param _builtins.str status: Cluster status.  
               Value options are as follows:
               + **100**: creating.
               + **200**: normal.
               + **300**: failed.
               + **303**: failed to be created.
               + **500**: restarting.
               + **800**: frozen.
               + **900**: stopped.
               + **910**: stopping.
               + **920**: starting.
        :param _builtins.str version: Cluster version.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "is_auto_off", is_auto_off)
        pulumi.set(__self__, "is_failure_remind", is_failure_remind)
        pulumi.set(__self__, "is_frozen", is_frozen)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_endpoint", public_endpoint)
        pulumi.set(__self__, "recent_event", recent_event)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        The AZ name.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetClustersClusterInstanceResult']:
        """
        The list of instance nodes.
        The Instance structure is documented below.
        """
        return pulumi.get(self, "instances")

    @_builtins.property
    @pulumi.getter(name="isAutoOff")
    def is_auto_off(self) -> _builtins.bool:
        """
        Whether auto shutdown is enabled.
        """
        return pulumi.get(self, "is_auto_off")

    @_builtins.property
    @pulumi.getter(name="isFailureRemind")
    def is_failure_remind(self) -> _builtins.str:
        """
        Whether to notifications when a table/file migration job fails or an EIP exception occurs.
        """
        return pulumi.get(self, "is_failure_remind")

    @_builtins.property
    @pulumi.getter(name="isFrozen")
    def is_frozen(self) -> _builtins.str:
        """
        Whether the node is frozen. The value can be 0 (not frozen) or 1 (frozen).
        """
        return pulumi.get(self, "is_frozen")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Cluster name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> _builtins.str:
        """
        EIP bound to the cluster.
        """
        return pulumi.get(self, "public_endpoint")

    @_builtins.property
    @pulumi.getter(name="recentEvent")
    def recent_event(self) -> _builtins.int:
        """
        Number of events.
        """
        return pulumi.get(self, "recent_event")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Cluster status.  
        Value options are as follows:
        + **100**: creating.
        + **200**: normal.
        + **300**: failed.
        + **303**: failed to be created.
        + **500**: restarting.
        + **800**: frozen.
        + **900**: stopped.
        + **910**: stopping.
        + **920**: starting.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Cluster version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClustersClusterInstanceResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 is_frozen: _builtins.str,
                 manage_ip: _builtins.str,
                 name: _builtins.str,
                 private_ip: _builtins.str,
                 public_ip: _builtins.str,
                 role: _builtins.str,
                 status: _builtins.str,
                 traffic_ip: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: Instance ID.
        :param _builtins.str is_frozen: Whether the node is frozen. The value can be 0 (not frozen) or 1 (frozen).
        :param _builtins.str manage_ip: Management IP address.
        :param _builtins.str name: Cluster name.
        :param _builtins.str private_ip: Private IP.
        :param _builtins.str public_ip: Public IP.
        :param _builtins.str role: Instance role.
        :param _builtins.str status: Cluster status.  
               Value options are as follows:
               + **100**: creating.
               + **200**: normal.
               + **300**: failed.
               + **303**: failed to be created.
               + **500**: restarting.
               + **800**: frozen.
               + **900**: stopped.
               + **910**: stopping.
               + **920**: starting.
        :param _builtins.str traffic_ip: Traffic IP.
        :param _builtins.str type: Instance type.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_frozen", is_frozen)
        pulumi.set(__self__, "manage_ip", manage_ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "traffic_ip", traffic_ip)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isFrozen")
    def is_frozen(self) -> _builtins.str:
        """
        Whether the node is frozen. The value can be 0 (not frozen) or 1 (frozen).
        """
        return pulumi.get(self, "is_frozen")

    @_builtins.property
    @pulumi.getter(name="manageIp")
    def manage_ip(self) -> _builtins.str:
        """
        Management IP address.
        """
        return pulumi.get(self, "manage_ip")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Cluster name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> _builtins.str:
        """
        Private IP.
        """
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> _builtins.str:
        """
        Public IP.
        """
        return pulumi.get(self, "public_ip")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Instance role.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Cluster status.  
        Value options are as follows:
        + **100**: creating.
        + **200**: normal.
        + **300**: failed.
        + **303**: failed to be created.
        + **500**: restarting.
        + **800**: frozen.
        + **900**: stopped.
        + **910**: stopping.
        + **920**: starting.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="trafficIp")
    def traffic_ip(self) -> _builtins.str:
        """
        Traffic IP.
        """
        return pulumi.get(self, "traffic_ip")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Instance type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFlavorsFlavorResult(dict):
    def __init__(__self__, *,
                 cpu: _builtins.str,
                 id: _builtins.str,
                 memory: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str cpu: The numbers of CDM cluster vCPUs.
        :param _builtins.str id: The ID of the CDM flavor.
        :param _builtins.str memory: The memory size in GB.
        :param _builtins.str name: The name of the CDM flavor. Format is `cdm.<flavor_type>`.
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        """
        The numbers of CDM cluster vCPUs.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the CDM flavor.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        """
        The memory size in GB.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the CDM flavor. Format is `cdm.<flavor_type>`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFlavorsV1FlavorResult(dict):
    def __init__(__self__, *,
                 cpu: _builtins.str,
                 id: _builtins.str,
                 memory: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetJobExecutionRecordsRecordResult(dict):
    def __init__(__self__, *,
                 counters: Sequence['outputs.GetJobExecutionRecordsRecordCounterResult'],
                 creation_date: _builtins.str,
                 creation_user: _builtins.str,
                 delete_rows: _builtins.int,
                 error_details: _builtins.str,
                 error_summary: _builtins.str,
                 execute_date: _builtins.str,
                 external_id: _builtins.str,
                 is_delete_job: _builtins.bool,
                 is_execute_auto: _builtins.bool,
                 is_incrementing: _builtins.bool,
                 is_stoping_increment: _builtins.str,
                 last_udpate_user: _builtins.str,
                 last_update_date: _builtins.str,
                 progress: _builtins.float,
                 status: _builtins.str,
                 submission_id: _builtins.int,
                 update_rows: _builtins.int,
                 write_rows: _builtins.int):
        """
        :param Sequence['GetJobExecutionRecordsRecordCounterArgs'] counters: Indicates the job running result statistics. Only return when status is SUCCEEDED.
               The counters structure is documented below.
        :param _builtins.str creation_date: Indicates the creation time.
        :param _builtins.str creation_user: Indicates the user who created the job.
        :param _builtins.int delete_rows: Indicates the number of deleted rows.
        :param _builtins.str error_details: Indicates the error details.
        :param _builtins.str error_summary: Indicates the error summary.
        :param _builtins.str execute_date: Indicates the execution time.
        :param _builtins.str external_id: Indicates the job ID.
        :param _builtins.bool is_delete_job: Indicates whether the job to be deleted after it is executed.
        :param _builtins.bool is_execute_auto: Indicates whether the job executed as scheduled.
        :param _builtins.bool is_incrementing: Indicates whether the job migrates incremental data.
        :param _builtins.str is_stoping_increment: Indicates whether incremental data migration stopped.
        :param _builtins.str last_udpate_user: Indicates the user who last updated the job status.
        :param _builtins.str last_update_date: Indicates the time when the job was last updated.
        :param _builtins.float progress: Indicates the Job progress.
               + If a job fails, the value is **-1**.
               + Otherwise, the value ranges from **0** to **100**.
        :param _builtins.str status: Indicates the Job status.
               Value can be as follows:
               + **BOOTING**: The job is starting.
               + **FAILURE_ON_SUBMIT**: The job failed to be submitted.
               + **RUNNING**: The job is running.
               + **SUCCEEDED**: The job was successfully executed.
               + **FAILED**: The job execution failed.
               + **UNKNOWN**: The job status is unknown.
               + **NEVER_EXECUTED**: The job was not executed.
        :param _builtins.int submission_id: Indicates the job submission ID.
        :param _builtins.int update_rows: Indicates the number of updated rows.
        :param _builtins.int write_rows: Indicates the number of write rows.
        """
        pulumi.set(__self__, "counters", counters)
        pulumi.set(__self__, "creation_date", creation_date)
        pulumi.set(__self__, "creation_user", creation_user)
        pulumi.set(__self__, "delete_rows", delete_rows)
        pulumi.set(__self__, "error_details", error_details)
        pulumi.set(__self__, "error_summary", error_summary)
        pulumi.set(__self__, "execute_date", execute_date)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "is_delete_job", is_delete_job)
        pulumi.set(__self__, "is_execute_auto", is_execute_auto)
        pulumi.set(__self__, "is_incrementing", is_incrementing)
        pulumi.set(__self__, "is_stoping_increment", is_stoping_increment)
        pulumi.set(__self__, "last_udpate_user", last_udpate_user)
        pulumi.set(__self__, "last_update_date", last_update_date)
        pulumi.set(__self__, "progress", progress)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "submission_id", submission_id)
        pulumi.set(__self__, "update_rows", update_rows)
        pulumi.set(__self__, "write_rows", write_rows)

    @_builtins.property
    @pulumi.getter
    def counters(self) -> Sequence['outputs.GetJobExecutionRecordsRecordCounterResult']:
        """
        Indicates the job running result statistics. Only return when status is SUCCEEDED.
        The counters structure is documented below.
        """
        return pulumi.get(self, "counters")

    @_builtins.property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> _builtins.str:
        """
        Indicates the creation time.
        """
        return pulumi.get(self, "creation_date")

    @_builtins.property
    @pulumi.getter(name="creationUser")
    def creation_user(self) -> _builtins.str:
        """
        Indicates the user who created the job.
        """
        return pulumi.get(self, "creation_user")

    @_builtins.property
    @pulumi.getter(name="deleteRows")
    def delete_rows(self) -> _builtins.int:
        """
        Indicates the number of deleted rows.
        """
        return pulumi.get(self, "delete_rows")

    @_builtins.property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> _builtins.str:
        """
        Indicates the error details.
        """
        return pulumi.get(self, "error_details")

    @_builtins.property
    @pulumi.getter(name="errorSummary")
    def error_summary(self) -> _builtins.str:
        """
        Indicates the error summary.
        """
        return pulumi.get(self, "error_summary")

    @_builtins.property
    @pulumi.getter(name="executeDate")
    def execute_date(self) -> _builtins.str:
        """
        Indicates the execution time.
        """
        return pulumi.get(self, "execute_date")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        Indicates the job ID.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="isDeleteJob")
    def is_delete_job(self) -> _builtins.bool:
        """
        Indicates whether the job to be deleted after it is executed.
        """
        return pulumi.get(self, "is_delete_job")

    @_builtins.property
    @pulumi.getter(name="isExecuteAuto")
    def is_execute_auto(self) -> _builtins.bool:
        """
        Indicates whether the job executed as scheduled.
        """
        return pulumi.get(self, "is_execute_auto")

    @_builtins.property
    @pulumi.getter(name="isIncrementing")
    def is_incrementing(self) -> _builtins.bool:
        """
        Indicates whether the job migrates incremental data.
        """
        return pulumi.get(self, "is_incrementing")

    @_builtins.property
    @pulumi.getter(name="isStopingIncrement")
    def is_stoping_increment(self) -> _builtins.str:
        """
        Indicates whether incremental data migration stopped.
        """
        return pulumi.get(self, "is_stoping_increment")

    @_builtins.property
    @pulumi.getter(name="lastUdpateUser")
    def last_udpate_user(self) -> _builtins.str:
        """
        Indicates the user who last updated the job status.
        """
        return pulumi.get(self, "last_udpate_user")

    @_builtins.property
    @pulumi.getter(name="lastUpdateDate")
    def last_update_date(self) -> _builtins.str:
        """
        Indicates the time when the job was last updated.
        """
        return pulumi.get(self, "last_update_date")

    @_builtins.property
    @pulumi.getter
    def progress(self) -> _builtins.float:
        """
        Indicates the Job progress.
        + If a job fails, the value is **-1**.
        + Otherwise, the value ranges from **0** to **100**.
        """
        return pulumi.get(self, "progress")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Indicates the Job status.
        Value can be as follows:
        + **BOOTING**: The job is starting.
        + **FAILURE_ON_SUBMIT**: The job failed to be submitted.
        + **RUNNING**: The job is running.
        + **SUCCEEDED**: The job was successfully executed.
        + **FAILED**: The job execution failed.
        + **UNKNOWN**: The job status is unknown.
        + **NEVER_EXECUTED**: The job was not executed.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="submissionId")
    def submission_id(self) -> _builtins.int:
        """
        Indicates the job submission ID.
        """
        return pulumi.get(self, "submission_id")

    @_builtins.property
    @pulumi.getter(name="updateRows")
    def update_rows(self) -> _builtins.int:
        """
        Indicates the number of updated rows.
        """
        return pulumi.get(self, "update_rows")

    @_builtins.property
    @pulumi.getter(name="writeRows")
    def write_rows(self) -> _builtins.int:
        """
        Indicates the number of write rows.
        """
        return pulumi.get(self, "write_rows")


@pulumi.output_type
class GetJobExecutionRecordsRecordCounterResult(dict):
    def __init__(__self__, *,
                 bytes_read: _builtins.int,
                 bytes_written: _builtins.int,
                 file_skipped: _builtins.int,
                 files_read: _builtins.int,
                 files_written: _builtins.int,
                 rows_read: _builtins.int,
                 rows_written: _builtins.int,
                 rows_written_skipped: _builtins.int,
                 total_files: _builtins.int,
                 total_size: _builtins.int):
        """
        :param _builtins.int bytes_read: Indicates the number of bytes that are read.
        :param _builtins.int bytes_written: Indicates the number of bytes that are written.
        :param _builtins.int file_skipped: Indicates the number of files that are skipped.
        :param _builtins.int files_read: Indicates the number of files that are read.
        :param _builtins.int files_written: Indicates the number of files that are written.
        :param _builtins.int rows_read: Indicates the number of rows that are read.
        :param _builtins.int rows_written: Indicates the number of rows that are written.
        :param _builtins.int rows_written_skipped: Indicates the number of rows that are skipped.
        :param _builtins.int total_files: Indicates the total number of files.
        :param _builtins.int total_size: Indicates the total number of bytes.
        """
        pulumi.set(__self__, "bytes_read", bytes_read)
        pulumi.set(__self__, "bytes_written", bytes_written)
        pulumi.set(__self__, "file_skipped", file_skipped)
        pulumi.set(__self__, "files_read", files_read)
        pulumi.set(__self__, "files_written", files_written)
        pulumi.set(__self__, "rows_read", rows_read)
        pulumi.set(__self__, "rows_written", rows_written)
        pulumi.set(__self__, "rows_written_skipped", rows_written_skipped)
        pulumi.set(__self__, "total_files", total_files)
        pulumi.set(__self__, "total_size", total_size)

    @_builtins.property
    @pulumi.getter(name="bytesRead")
    def bytes_read(self) -> _builtins.int:
        """
        Indicates the number of bytes that are read.
        """
        return pulumi.get(self, "bytes_read")

    @_builtins.property
    @pulumi.getter(name="bytesWritten")
    def bytes_written(self) -> _builtins.int:
        """
        Indicates the number of bytes that are written.
        """
        return pulumi.get(self, "bytes_written")

    @_builtins.property
    @pulumi.getter(name="fileSkipped")
    def file_skipped(self) -> _builtins.int:
        """
        Indicates the number of files that are skipped.
        """
        return pulumi.get(self, "file_skipped")

    @_builtins.property
    @pulumi.getter(name="filesRead")
    def files_read(self) -> _builtins.int:
        """
        Indicates the number of files that are read.
        """
        return pulumi.get(self, "files_read")

    @_builtins.property
    @pulumi.getter(name="filesWritten")
    def files_written(self) -> _builtins.int:
        """
        Indicates the number of files that are written.
        """
        return pulumi.get(self, "files_written")

    @_builtins.property
    @pulumi.getter(name="rowsRead")
    def rows_read(self) -> _builtins.int:
        """
        Indicates the number of rows that are read.
        """
        return pulumi.get(self, "rows_read")

    @_builtins.property
    @pulumi.getter(name="rowsWritten")
    def rows_written(self) -> _builtins.int:
        """
        Indicates the number of rows that are written.
        """
        return pulumi.get(self, "rows_written")

    @_builtins.property
    @pulumi.getter(name="rowsWrittenSkipped")
    def rows_written_skipped(self) -> _builtins.int:
        """
        Indicates the number of rows that are skipped.
        """
        return pulumi.get(self, "rows_written_skipped")

    @_builtins.property
    @pulumi.getter(name="totalFiles")
    def total_files(self) -> _builtins.int:
        """
        Indicates the total number of files.
        """
        return pulumi.get(self, "total_files")

    @_builtins.property
    @pulumi.getter(name="totalSize")
    def total_size(self) -> _builtins.int:
        """
        Indicates the total number of bytes.
        """
        return pulumi.get(self, "total_size")


