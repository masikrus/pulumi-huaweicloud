// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dedicatedelb

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a Dedicated load balancer resource within HuaweiCloud.
//
// ## Example Usage
// ### Basic Loadbalancer
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/DedicatedElb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			vpcId := cfg.RequireObject("vpcId")
//			ipv4SubnetId := cfg.RequireObject("ipv4SubnetId")
//			l4FlavorId := cfg.RequireObject("l4FlavorId")
//			l7FlavorId := cfg.RequireObject("l7FlavorId")
//			epsId := cfg.RequireObject("epsId")
//			_, err := DedicatedElb.NewLoadbalancer(ctx, "basic", &DedicatedElb.LoadbalancerArgs{
//				Description:     pulumi.String("basic example"),
//				CrossVpcBackend: pulumi.Bool(true),
//				VpcId:           pulumi.Any(vpcId),
//				Ipv4SubnetId:    pulumi.Any(ipv4SubnetId),
//				L4FlavorId:      pulumi.Any(l4FlavorId),
//				L7FlavorId:      pulumi.Any(l7FlavorId),
//				AvailabilityZones: pulumi.StringArray{
//					pulumi.String("cn-north-4a"),
//					pulumi.String("cn-north-4b"),
//				},
//				EnterpriseProjectId: pulumi.Any(epsId),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Loadbalancer With Existing EIP
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/DedicatedElb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			vpcId := cfg.RequireObject("vpcId")
//			ipv4SubnetId := cfg.RequireObject("ipv4SubnetId")
//			ipv6NetworkId := cfg.RequireObject("ipv6NetworkId")
//			ipv6BandwidthId := cfg.RequireObject("ipv6BandwidthId")
//			l4FlavorId := cfg.RequireObject("l4FlavorId")
//			l7FlavorId := cfg.RequireObject("l7FlavorId")
//			epsId := cfg.RequireObject("epsId")
//			eipId := cfg.RequireObject("eipId")
//			_, err := DedicatedElb.NewLoadbalancer(ctx, "basic", &DedicatedElb.LoadbalancerArgs{
//				Description:     pulumi.String("basic example"),
//				CrossVpcBackend: pulumi.Bool(true),
//				VpcId:           pulumi.Any(vpcId),
//				Ipv6NetworkId:   pulumi.Any(ipv6NetworkId),
//				Ipv6BandwidthId: pulumi.Any(ipv6BandwidthId),
//				Ipv4SubnetId:    pulumi.Any(ipv4SubnetId),
//				L4FlavorId:      pulumi.Any(l4FlavorId),
//				L7FlavorId:      pulumi.Any(l7FlavorId),
//				AvailabilityZones: pulumi.StringArray{
//					pulumi.String("cn-north-4a"),
//					pulumi.String("cn-north-4b"),
//				},
//				EnterpriseProjectId: pulumi.Any(epsId),
//				Ipv4EipId:           pulumi.Any(eipId),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Loadbalancer With EIP
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/DedicatedElb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			vpcId := cfg.RequireObject("vpcId")
//			ipv4SubnetId := cfg.RequireObject("ipv4SubnetId")
//			ipv6NetworkId := cfg.RequireObject("ipv6NetworkId")
//			ipv6BandwidthId := cfg.RequireObject("ipv6BandwidthId")
//			l4FlavorId := cfg.RequireObject("l4FlavorId")
//			l7FlavorId := cfg.RequireObject("l7FlavorId")
//			_, err := DedicatedElb.NewLoadbalancer(ctx, "basic", &DedicatedElb.LoadbalancerArgs{
//				Description:     pulumi.String("basic example"),
//				CrossVpcBackend: pulumi.Bool(true),
//				VpcId:           pulumi.Any(vpcId),
//				Ipv6NetworkId:   pulumi.Any(ipv6NetworkId),
//				Ipv6BandwidthId: pulumi.Any(ipv6BandwidthId),
//				Ipv4SubnetId:    pulumi.Any(ipv4SubnetId),
//				L4FlavorId:      pulumi.Any(l4FlavorId),
//				L7FlavorId:      pulumi.Any(l7FlavorId),
//				AvailabilityZones: pulumi.StringArray{
//					pulumi.String("cn-north-4a"),
//					pulumi.String("cn-north-4b"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ### Loadbalancer With gateway
//
// ```go
// package main
//
// import (
//
//	"github.com/huaweicloud/pulumi-huaweicloud/sdk/go/huaweicloud/DedicatedElb"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			vpcId := cfg.RequireObject("vpcId")
//			ipv4SubnetId := cfg.RequireObject("ipv4SubnetId")
//			ipv6NetworkId := cfg.RequireObject("ipv6NetworkId")
//			_, err := DedicatedElb.NewLoadbalancer(ctx, "basic", &DedicatedElb.LoadbalancerArgs{
//				Description:      pulumi.String("basic example"),
//				LoadbalancerType: pulumi.String("gateway"),
//				VpcId:            pulumi.Any(vpcId),
//				Ipv4SubnetId:     pulumi.Any(ipv4SubnetId),
//				Ipv6NetworkId:    pulumi.Any(ipv6NetworkId),
//				AvailabilityZones: pulumi.StringArray{
//					pulumi.String("cn-north-4a"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ELB load balancer can be imported using the ID, e.g. bash
//
// ```sh
//
//	$ pulumi import huaweicloud:DedicatedElb/loadbalancer:Loadbalancer loadbalancer_1 <id>
//
// ```
//
//	Note that the imported state may not be identical to your resource definition, due to some attributes missing from the API response, security or some other reason. The missing attributes include`ipv6_bandwidth_id`, `iptype`, `bandwidth_charge_mode`, `sharetype`,
//
// `bandwidth_size`, `bandwidth_id`, `force_delete` and `deletion_protection_enable`. It is generally recommended running `terraform plan` after importing a load balancer. You can then decide if changes should be applied to the load balancer, or the resource definition should be updated to align with the load balancer. Also you can ignore changes as below. hcl resource "huaweicloud_elb_loadbalancer" "loadbalancer_1" {
//
//	...
//
//	lifecycle {
//
//	ignore_changes = [
//
//	ipv6_bandwidth_id, iptype, bandwidth_charge_mode, sharetype, bandwidth_size, bandwidth_id, force_delete,
//
//	deletion_protection_enable,
//
//	]
//
//	} }
type Loadbalancer struct {
	pulumi.CustomResourceState

	// Deprecated: Deprecated
	AutoPay pulumi.StringPtrOutput `pulumi:"autoPay"`
	// Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
	AutoRenew          pulumi.StringPtrOutput `pulumi:"autoRenew"`
	AutoscalingEnabled pulumi.BoolOutput      `pulumi:"autoscalingEnabled"`
	// Specifies the list of AZ names.
	AvailabilityZones pulumi.StringArrayOutput `pulumi:"availabilityZones"`
	// The IDs of subnets on the downstream plane.
	// + If this parameter is not specified, select subnets as follows:
	// - If IPv6 is enabled for a load balancer, the ID of subnet specified in `ipv6NetworkId` will be used.
	// - If IPv4 is enabled for a load balancer, the ID of subnet specified in `ipv4SubnetId` will be used.
	// - If only public network is available for a load balancer, the ID of any subnet in the VPC where the load balancer
	//   resides will be used. Subnets with more IP addresses are preferred.
	// + If there is more than one subnet, the first subnet in the list will be used, and the subnets must be in the VPC
	//   where the load balancer resides.
	BackendSubnets pulumi.StringArrayOutput `pulumi:"backendSubnets"`
	// Bandwidth billing type. Value options:
	// + **bandwidth**: Billed by bandwidth.
	// + **traffic**: Billed by traffic.
	BandwidthChargeMode pulumi.StringOutput `pulumi:"bandwidthChargeMode"`
	// Bandwidth ID of the shared bandwidth. It is mandatory when `sharetype`
	// is **WHOLE**. Changing this parameter will create a new resource.
	BandwidthId pulumi.StringOutput `pulumi:"bandwidthId"`
	// Bandwidth size. It is mandatory when `iptype` is set and `bandwidthId`
	// is empty. Changing this parameter will create a new resource.
	BandwidthSize pulumi.IntOutput `pulumi:"bandwidthSize"`
	// Indicates the billing mode. The value can be one of the following:
	// + **flavor**: Billed by the specifications you will select.
	// + **lcu**: Billed by LCU usage.
	ChargeMode pulumi.StringOutput `pulumi:"chargeMode"`
	// Specifies the charging mode of the ELB load balancer.
	// Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
	ChargingMode pulumi.StringOutput `pulumi:"chargingMode"`
	// Indicates the time when the load balancer was created, in RFC3339 format.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Enable this if you want to associate the IP addresses of backend servers with
	// your load balancer. Can only be true when updating.
	CrossVpcBackend pulumi.BoolOutput `pulumi:"crossVpcBackend"`
	// Specifies whether to enable deletion protection
	// for the load balancer. Value options:
	// + **true**: Enable deletion protection.
	// + **false**: Disable deletion protection.
	DeletionProtectionEnable pulumi.BoolPtrOutput `pulumi:"deletionProtectionEnable"`
	// Human-readable description for the load balancer.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The type of the subnet on the downstream plane. The value can be:
	// + **ipv4**: IPv4 subnet
	// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
	ElbVirsubnetType pulumi.StringOutput `pulumi:"elbVirsubnetType"`
	// The enterprise project id of the load balancer.
	EnterpriseProjectId pulumi.StringOutput `pulumi:"enterpriseProjectId"`
	// Specifies whether to forcibly delete the load balancer, remove the load balancer,
	// listeners, unbind associated pools. Defaults to **false**.
	ForceDelete pulumi.BoolPtrOutput `pulumi:"forceDelete"`
	// The scenario where the load balancer is frozen. Multiple values are separated using commas (,).
	// The value can be:
	// + **POLICE**: The load balancer is frozen due to security reasons.
	// + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
	// + **VERIFY**: Your account has not completed real-name authentication.
	// + **PARTNER**: The load balancer is frozen by the partner.
	// + **ARREAR**: Your account is in arrears.
	FrozenScene pulumi.StringOutput `pulumi:"frozenScene"`
	// Indicates whether the load balancer is a dedicated load balancer.
	// The value can be one of the following:
	// + **false**: The load balancer is a shared load balancer.
	// + **true**: The load balancer is a dedicated load balancer.
	Guaranteed pulumi.BoolOutput `pulumi:"guaranteed"`
	// The flavor ID of the gateway load balancer.
	GwFlavorId pulumi.StringOutput `pulumi:"gwFlavorId"`
	// Elastic IP type. Changing this parameter will create a new resource.
	Iptype pulumi.StringOutput `pulumi:"iptype"`
	// The ipv4 address of the load balancer.
	Ipv4Address pulumi.StringOutput `pulumi:"ipv4Address"`
	// The ipv4 eip address of the load balancer.
	Ipv4Eip pulumi.StringOutput `pulumi:"ipv4Eip"`
	// The ID of the EIP. Changing this parameter will create a new resource.
	Ipv4EipId pulumi.StringOutput `pulumi:"ipv4EipId"`
	// The ID of the port bound to the private IPv4 address of the load balancer.
	Ipv4PortId pulumi.StringOutput `pulumi:"ipv4PortId"`
	// The **IPv4 subnet ID** of the subnet on which to allocate the load balancer
	// ipv4 address.
	Ipv4SubnetId pulumi.StringPtrOutput `pulumi:"ipv4SubnetId"`
	// The ipv6 address of the Load Balancer.
	Ipv6Address pulumi.StringOutput `pulumi:"ipv6Address"`
	// The ipv6 bandwidth id. Only support shared bandwidth.
	Ipv6BandwidthId pulumi.StringPtrOutput `pulumi:"ipv6BandwidthId"`
	// The ipv6 eip address of the load balancer.
	Ipv6Eip pulumi.StringOutput `pulumi:"ipv6Eip"`
	// The type of the subnet on the downstream plane. The value can be:
	// + **ipv4**: IPv4 subnet
	// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
	Ipv6EipId pulumi.StringOutput `pulumi:"ipv6EipId"`
	// The **ID** of the subnet on which to allocate the load balancer ipv6 address.
	Ipv6NetworkId pulumi.StringPtrOutput `pulumi:"ipv6NetworkId"`
	// The L4 flavor id of the load balancer.
	L4FlavorId pulumi.StringOutput `pulumi:"l4FlavorId"`
	// The L7 flavor id of the load balancer.
	L7FlavorId pulumi.StringOutput `pulumi:"l7FlavorId"`
	// Specifies the type of the load balancer. Value options:
	// + **gateway**: indicates a gateway load balancer.
	// + Keep empty(default) indicates other types of load balancers.
	LoadbalancerType pulumi.StringOutput `pulumi:"loadbalancerType"`
	MinL7FlavorId    pulumi.StringOutput `pulumi:"minL7FlavorId"`
	// Human-readable name for the load balancer.
	Name pulumi.StringOutput `pulumi:"name"`
	// The operating status of the load balancer. The value can be:
	// + **ONLINE**: indicates that the load balancer is running normally.
	// + **FROZEN**: indicates that the load balancer is frozen.
	OperatingStatus pulumi.StringOutput `pulumi:"operatingStatus"`
	// Specifies the charging period of the ELB load balancer.
	// If `periodUnit` is set to **month**, the value ranges from `1` to `9`.
	// If `periodUnit` is set to **year**, the value ranges from `1` to `3`.
	// This parameter is mandatory if `chargingMode` is set to **prePaid**.
	Period pulumi.IntPtrOutput `pulumi:"period"`
	// Specifies the charging period unit of the ELB load balancer.
	// Valid values are **month** and **year**. This parameter is mandatory if `chargingMode` is set to **prePaid**.
	PeriodUnit pulumi.StringPtrOutput `pulumi:"periodUnit"`
	// The reason for update protection. Only valid when `protectionStatus` is
	// **consoleProtection**.
	ProtectionReason pulumi.StringPtrOutput `pulumi:"protectionReason"`
	// The protection status for update. Value options:
	// + **nonProtection**: No protection.
	// + **consoleProtection**: Console modification protection.
	ProtectionStatus pulumi.StringOutput `pulumi:"protectionStatus"`
	// The AZ group to which the load balancer belongs.
	PublicBorderGroup pulumi.StringOutput `pulumi:"publicBorderGroup"`
	// The region in which to create the load balancer resource. If omitted, the
	// provider-level region will be used. Changing this creates a new load balancer.
	Region pulumi.StringOutput `pulumi:"region"`
	// Bandwidth sharing type. Value options:
	// + **PER**: Dedicated bandwidth.
	// + **WHOLE**: Shared bandwidth.
	Sharetype pulumi.StringOutput `pulumi:"sharetype"`
	// The key/value pairs to associate with the load balancer.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// Indicates the time when the load balancer was updated, in RFC3339 format.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// The vpc on which to create the load balancer. Changing this creates a new
	// load balancer.
	VpcId pulumi.StringOutput `pulumi:"vpcId"`
	// Specifies traffic distributing policies when the WAF is faulty.
	// Value options:
	// + **discard**: Traffic will not be distributed.
	// + **forward**: Traffic will be distributed to the default backend servers.
	WafFailureAction pulumi.StringOutput `pulumi:"wafFailureAction"`
}

// NewLoadbalancer registers a new resource with the given unique name, arguments, and options.
func NewLoadbalancer(ctx *pulumi.Context,
	name string, args *LoadbalancerArgs, opts ...pulumi.ResourceOption) (*Loadbalancer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AvailabilityZones == nil {
		return nil, errors.New("invalid value for required argument 'AvailabilityZones'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource Loadbalancer
	err := ctx.RegisterResource("huaweicloud:DedicatedElb/loadbalancer:Loadbalancer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLoadbalancer gets an existing Loadbalancer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLoadbalancer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LoadbalancerState, opts ...pulumi.ResourceOption) (*Loadbalancer, error) {
	var resource Loadbalancer
	err := ctx.ReadResource("huaweicloud:DedicatedElb/loadbalancer:Loadbalancer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Loadbalancer resources.
type loadbalancerState struct {
	// Deprecated: Deprecated
	AutoPay *string `pulumi:"autoPay"`
	// Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
	AutoRenew          *string `pulumi:"autoRenew"`
	AutoscalingEnabled *bool   `pulumi:"autoscalingEnabled"`
	// Specifies the list of AZ names.
	AvailabilityZones []string `pulumi:"availabilityZones"`
	// The IDs of subnets on the downstream plane.
	// + If this parameter is not specified, select subnets as follows:
	// - If IPv6 is enabled for a load balancer, the ID of subnet specified in `ipv6NetworkId` will be used.
	// - If IPv4 is enabled for a load balancer, the ID of subnet specified in `ipv4SubnetId` will be used.
	// - If only public network is available for a load balancer, the ID of any subnet in the VPC where the load balancer
	//   resides will be used. Subnets with more IP addresses are preferred.
	// + If there is more than one subnet, the first subnet in the list will be used, and the subnets must be in the VPC
	//   where the load balancer resides.
	BackendSubnets []string `pulumi:"backendSubnets"`
	// Bandwidth billing type. Value options:
	// + **bandwidth**: Billed by bandwidth.
	// + **traffic**: Billed by traffic.
	BandwidthChargeMode *string `pulumi:"bandwidthChargeMode"`
	// Bandwidth ID of the shared bandwidth. It is mandatory when `sharetype`
	// is **WHOLE**. Changing this parameter will create a new resource.
	BandwidthId *string `pulumi:"bandwidthId"`
	// Bandwidth size. It is mandatory when `iptype` is set and `bandwidthId`
	// is empty. Changing this parameter will create a new resource.
	BandwidthSize *int `pulumi:"bandwidthSize"`
	// Indicates the billing mode. The value can be one of the following:
	// + **flavor**: Billed by the specifications you will select.
	// + **lcu**: Billed by LCU usage.
	ChargeMode *string `pulumi:"chargeMode"`
	// Specifies the charging mode of the ELB load balancer.
	// Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
	ChargingMode *string `pulumi:"chargingMode"`
	// Indicates the time when the load balancer was created, in RFC3339 format.
	CreatedAt *string `pulumi:"createdAt"`
	// Enable this if you want to associate the IP addresses of backend servers with
	// your load balancer. Can only be true when updating.
	CrossVpcBackend *bool `pulumi:"crossVpcBackend"`
	// Specifies whether to enable deletion protection
	// for the load balancer. Value options:
	// + **true**: Enable deletion protection.
	// + **false**: Disable deletion protection.
	DeletionProtectionEnable *bool `pulumi:"deletionProtectionEnable"`
	// Human-readable description for the load balancer.
	Description *string `pulumi:"description"`
	// The type of the subnet on the downstream plane. The value can be:
	// + **ipv4**: IPv4 subnet
	// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
	ElbVirsubnetType *string `pulumi:"elbVirsubnetType"`
	// The enterprise project id of the load balancer.
	EnterpriseProjectId *string `pulumi:"enterpriseProjectId"`
	// Specifies whether to forcibly delete the load balancer, remove the load balancer,
	// listeners, unbind associated pools. Defaults to **false**.
	ForceDelete *bool `pulumi:"forceDelete"`
	// The scenario where the load balancer is frozen. Multiple values are separated using commas (,).
	// The value can be:
	// + **POLICE**: The load balancer is frozen due to security reasons.
	// + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
	// + **VERIFY**: Your account has not completed real-name authentication.
	// + **PARTNER**: The load balancer is frozen by the partner.
	// + **ARREAR**: Your account is in arrears.
	FrozenScene *string `pulumi:"frozenScene"`
	// Indicates whether the load balancer is a dedicated load balancer.
	// The value can be one of the following:
	// + **false**: The load balancer is a shared load balancer.
	// + **true**: The load balancer is a dedicated load balancer.
	Guaranteed *bool `pulumi:"guaranteed"`
	// The flavor ID of the gateway load balancer.
	GwFlavorId *string `pulumi:"gwFlavorId"`
	// Elastic IP type. Changing this parameter will create a new resource.
	Iptype *string `pulumi:"iptype"`
	// The ipv4 address of the load balancer.
	Ipv4Address *string `pulumi:"ipv4Address"`
	// The ipv4 eip address of the load balancer.
	Ipv4Eip *string `pulumi:"ipv4Eip"`
	// The ID of the EIP. Changing this parameter will create a new resource.
	Ipv4EipId *string `pulumi:"ipv4EipId"`
	// The ID of the port bound to the private IPv4 address of the load balancer.
	Ipv4PortId *string `pulumi:"ipv4PortId"`
	// The **IPv4 subnet ID** of the subnet on which to allocate the load balancer
	// ipv4 address.
	Ipv4SubnetId *string `pulumi:"ipv4SubnetId"`
	// The ipv6 address of the Load Balancer.
	Ipv6Address *string `pulumi:"ipv6Address"`
	// The ipv6 bandwidth id. Only support shared bandwidth.
	Ipv6BandwidthId *string `pulumi:"ipv6BandwidthId"`
	// The ipv6 eip address of the load balancer.
	Ipv6Eip *string `pulumi:"ipv6Eip"`
	// The type of the subnet on the downstream plane. The value can be:
	// + **ipv4**: IPv4 subnet
	// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
	Ipv6EipId *string `pulumi:"ipv6EipId"`
	// The **ID** of the subnet on which to allocate the load balancer ipv6 address.
	Ipv6NetworkId *string `pulumi:"ipv6NetworkId"`
	// The L4 flavor id of the load balancer.
	L4FlavorId *string `pulumi:"l4FlavorId"`
	// The L7 flavor id of the load balancer.
	L7FlavorId *string `pulumi:"l7FlavorId"`
	// Specifies the type of the load balancer. Value options:
	// + **gateway**: indicates a gateway load balancer.
	// + Keep empty(default) indicates other types of load balancers.
	LoadbalancerType *string `pulumi:"loadbalancerType"`
	MinL7FlavorId    *string `pulumi:"minL7FlavorId"`
	// Human-readable name for the load balancer.
	Name *string `pulumi:"name"`
	// The operating status of the load balancer. The value can be:
	// + **ONLINE**: indicates that the load balancer is running normally.
	// + **FROZEN**: indicates that the load balancer is frozen.
	OperatingStatus *string `pulumi:"operatingStatus"`
	// Specifies the charging period of the ELB load balancer.
	// If `periodUnit` is set to **month**, the value ranges from `1` to `9`.
	// If `periodUnit` is set to **year**, the value ranges from `1` to `3`.
	// This parameter is mandatory if `chargingMode` is set to **prePaid**.
	Period *int `pulumi:"period"`
	// Specifies the charging period unit of the ELB load balancer.
	// Valid values are **month** and **year**. This parameter is mandatory if `chargingMode` is set to **prePaid**.
	PeriodUnit *string `pulumi:"periodUnit"`
	// The reason for update protection. Only valid when `protectionStatus` is
	// **consoleProtection**.
	ProtectionReason *string `pulumi:"protectionReason"`
	// The protection status for update. Value options:
	// + **nonProtection**: No protection.
	// + **consoleProtection**: Console modification protection.
	ProtectionStatus *string `pulumi:"protectionStatus"`
	// The AZ group to which the load balancer belongs.
	PublicBorderGroup *string `pulumi:"publicBorderGroup"`
	// The region in which to create the load balancer resource. If omitted, the
	// provider-level region will be used. Changing this creates a new load balancer.
	Region *string `pulumi:"region"`
	// Bandwidth sharing type. Value options:
	// + **PER**: Dedicated bandwidth.
	// + **WHOLE**: Shared bandwidth.
	Sharetype *string `pulumi:"sharetype"`
	// The key/value pairs to associate with the load balancer.
	Tags map[string]string `pulumi:"tags"`
	// Indicates the time when the load balancer was updated, in RFC3339 format.
	UpdatedAt *string `pulumi:"updatedAt"`
	// The vpc on which to create the load balancer. Changing this creates a new
	// load balancer.
	VpcId *string `pulumi:"vpcId"`
	// Specifies traffic distributing policies when the WAF is faulty.
	// Value options:
	// + **discard**: Traffic will not be distributed.
	// + **forward**: Traffic will be distributed to the default backend servers.
	WafFailureAction *string `pulumi:"wafFailureAction"`
}

type LoadbalancerState struct {
	// Deprecated: Deprecated
	AutoPay pulumi.StringPtrInput
	// Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
	AutoRenew          pulumi.StringPtrInput
	AutoscalingEnabled pulumi.BoolPtrInput
	// Specifies the list of AZ names.
	AvailabilityZones pulumi.StringArrayInput
	// The IDs of subnets on the downstream plane.
	// + If this parameter is not specified, select subnets as follows:
	// - If IPv6 is enabled for a load balancer, the ID of subnet specified in `ipv6NetworkId` will be used.
	// - If IPv4 is enabled for a load balancer, the ID of subnet specified in `ipv4SubnetId` will be used.
	// - If only public network is available for a load balancer, the ID of any subnet in the VPC where the load balancer
	//   resides will be used. Subnets with more IP addresses are preferred.
	// + If there is more than one subnet, the first subnet in the list will be used, and the subnets must be in the VPC
	//   where the load balancer resides.
	BackendSubnets pulumi.StringArrayInput
	// Bandwidth billing type. Value options:
	// + **bandwidth**: Billed by bandwidth.
	// + **traffic**: Billed by traffic.
	BandwidthChargeMode pulumi.StringPtrInput
	// Bandwidth ID of the shared bandwidth. It is mandatory when `sharetype`
	// is **WHOLE**. Changing this parameter will create a new resource.
	BandwidthId pulumi.StringPtrInput
	// Bandwidth size. It is mandatory when `iptype` is set and `bandwidthId`
	// is empty. Changing this parameter will create a new resource.
	BandwidthSize pulumi.IntPtrInput
	// Indicates the billing mode. The value can be one of the following:
	// + **flavor**: Billed by the specifications you will select.
	// + **lcu**: Billed by LCU usage.
	ChargeMode pulumi.StringPtrInput
	// Specifies the charging mode of the ELB load balancer.
	// Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
	ChargingMode pulumi.StringPtrInput
	// Indicates the time when the load balancer was created, in RFC3339 format.
	CreatedAt pulumi.StringPtrInput
	// Enable this if you want to associate the IP addresses of backend servers with
	// your load balancer. Can only be true when updating.
	CrossVpcBackend pulumi.BoolPtrInput
	// Specifies whether to enable deletion protection
	// for the load balancer. Value options:
	// + **true**: Enable deletion protection.
	// + **false**: Disable deletion protection.
	DeletionProtectionEnable pulumi.BoolPtrInput
	// Human-readable description for the load balancer.
	Description pulumi.StringPtrInput
	// The type of the subnet on the downstream plane. The value can be:
	// + **ipv4**: IPv4 subnet
	// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
	ElbVirsubnetType pulumi.StringPtrInput
	// The enterprise project id of the load balancer.
	EnterpriseProjectId pulumi.StringPtrInput
	// Specifies whether to forcibly delete the load balancer, remove the load balancer,
	// listeners, unbind associated pools. Defaults to **false**.
	ForceDelete pulumi.BoolPtrInput
	// The scenario where the load balancer is frozen. Multiple values are separated using commas (,).
	// The value can be:
	// + **POLICE**: The load balancer is frozen due to security reasons.
	// + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
	// + **VERIFY**: Your account has not completed real-name authentication.
	// + **PARTNER**: The load balancer is frozen by the partner.
	// + **ARREAR**: Your account is in arrears.
	FrozenScene pulumi.StringPtrInput
	// Indicates whether the load balancer is a dedicated load balancer.
	// The value can be one of the following:
	// + **false**: The load balancer is a shared load balancer.
	// + **true**: The load balancer is a dedicated load balancer.
	Guaranteed pulumi.BoolPtrInput
	// The flavor ID of the gateway load balancer.
	GwFlavorId pulumi.StringPtrInput
	// Elastic IP type. Changing this parameter will create a new resource.
	Iptype pulumi.StringPtrInput
	// The ipv4 address of the load balancer.
	Ipv4Address pulumi.StringPtrInput
	// The ipv4 eip address of the load balancer.
	Ipv4Eip pulumi.StringPtrInput
	// The ID of the EIP. Changing this parameter will create a new resource.
	Ipv4EipId pulumi.StringPtrInput
	// The ID of the port bound to the private IPv4 address of the load balancer.
	Ipv4PortId pulumi.StringPtrInput
	// The **IPv4 subnet ID** of the subnet on which to allocate the load balancer
	// ipv4 address.
	Ipv4SubnetId pulumi.StringPtrInput
	// The ipv6 address of the Load Balancer.
	Ipv6Address pulumi.StringPtrInput
	// The ipv6 bandwidth id. Only support shared bandwidth.
	Ipv6BandwidthId pulumi.StringPtrInput
	// The ipv6 eip address of the load balancer.
	Ipv6Eip pulumi.StringPtrInput
	// The type of the subnet on the downstream plane. The value can be:
	// + **ipv4**: IPv4 subnet
	// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
	Ipv6EipId pulumi.StringPtrInput
	// The **ID** of the subnet on which to allocate the load balancer ipv6 address.
	Ipv6NetworkId pulumi.StringPtrInput
	// The L4 flavor id of the load balancer.
	L4FlavorId pulumi.StringPtrInput
	// The L7 flavor id of the load balancer.
	L7FlavorId pulumi.StringPtrInput
	// Specifies the type of the load balancer. Value options:
	// + **gateway**: indicates a gateway load balancer.
	// + Keep empty(default) indicates other types of load balancers.
	LoadbalancerType pulumi.StringPtrInput
	MinL7FlavorId    pulumi.StringPtrInput
	// Human-readable name for the load balancer.
	Name pulumi.StringPtrInput
	// The operating status of the load balancer. The value can be:
	// + **ONLINE**: indicates that the load balancer is running normally.
	// + **FROZEN**: indicates that the load balancer is frozen.
	OperatingStatus pulumi.StringPtrInput
	// Specifies the charging period of the ELB load balancer.
	// If `periodUnit` is set to **month**, the value ranges from `1` to `9`.
	// If `periodUnit` is set to **year**, the value ranges from `1` to `3`.
	// This parameter is mandatory if `chargingMode` is set to **prePaid**.
	Period pulumi.IntPtrInput
	// Specifies the charging period unit of the ELB load balancer.
	// Valid values are **month** and **year**. This parameter is mandatory if `chargingMode` is set to **prePaid**.
	PeriodUnit pulumi.StringPtrInput
	// The reason for update protection. Only valid when `protectionStatus` is
	// **consoleProtection**.
	ProtectionReason pulumi.StringPtrInput
	// The protection status for update. Value options:
	// + **nonProtection**: No protection.
	// + **consoleProtection**: Console modification protection.
	ProtectionStatus pulumi.StringPtrInput
	// The AZ group to which the load balancer belongs.
	PublicBorderGroup pulumi.StringPtrInput
	// The region in which to create the load balancer resource. If omitted, the
	// provider-level region will be used. Changing this creates a new load balancer.
	Region pulumi.StringPtrInput
	// Bandwidth sharing type. Value options:
	// + **PER**: Dedicated bandwidth.
	// + **WHOLE**: Shared bandwidth.
	Sharetype pulumi.StringPtrInput
	// The key/value pairs to associate with the load balancer.
	Tags pulumi.StringMapInput
	// Indicates the time when the load balancer was updated, in RFC3339 format.
	UpdatedAt pulumi.StringPtrInput
	// The vpc on which to create the load balancer. Changing this creates a new
	// load balancer.
	VpcId pulumi.StringPtrInput
	// Specifies traffic distributing policies when the WAF is faulty.
	// Value options:
	// + **discard**: Traffic will not be distributed.
	// + **forward**: Traffic will be distributed to the default backend servers.
	WafFailureAction pulumi.StringPtrInput
}

func (LoadbalancerState) ElementType() reflect.Type {
	return reflect.TypeOf((*loadbalancerState)(nil)).Elem()
}

type loadbalancerArgs struct {
	// Deprecated: Deprecated
	AutoPay *string `pulumi:"autoPay"`
	// Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
	AutoRenew          *string `pulumi:"autoRenew"`
	AutoscalingEnabled *bool   `pulumi:"autoscalingEnabled"`
	// Specifies the list of AZ names.
	AvailabilityZones []string `pulumi:"availabilityZones"`
	// The IDs of subnets on the downstream plane.
	// + If this parameter is not specified, select subnets as follows:
	// - If IPv6 is enabled for a load balancer, the ID of subnet specified in `ipv6NetworkId` will be used.
	// - If IPv4 is enabled for a load balancer, the ID of subnet specified in `ipv4SubnetId` will be used.
	// - If only public network is available for a load balancer, the ID of any subnet in the VPC where the load balancer
	//   resides will be used. Subnets with more IP addresses are preferred.
	// + If there is more than one subnet, the first subnet in the list will be used, and the subnets must be in the VPC
	//   where the load balancer resides.
	BackendSubnets []string `pulumi:"backendSubnets"`
	// Bandwidth billing type. Value options:
	// + **bandwidth**: Billed by bandwidth.
	// + **traffic**: Billed by traffic.
	BandwidthChargeMode *string `pulumi:"bandwidthChargeMode"`
	// Bandwidth ID of the shared bandwidth. It is mandatory when `sharetype`
	// is **WHOLE**. Changing this parameter will create a new resource.
	BandwidthId *string `pulumi:"bandwidthId"`
	// Bandwidth size. It is mandatory when `iptype` is set and `bandwidthId`
	// is empty. Changing this parameter will create a new resource.
	BandwidthSize *int `pulumi:"bandwidthSize"`
	// Specifies the charging mode of the ELB load balancer.
	// Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
	ChargingMode *string `pulumi:"chargingMode"`
	// Enable this if you want to associate the IP addresses of backend servers with
	// your load balancer. Can only be true when updating.
	CrossVpcBackend *bool `pulumi:"crossVpcBackend"`
	// Specifies whether to enable deletion protection
	// for the load balancer. Value options:
	// + **true**: Enable deletion protection.
	// + **false**: Disable deletion protection.
	DeletionProtectionEnable *bool `pulumi:"deletionProtectionEnable"`
	// Human-readable description for the load balancer.
	Description *string `pulumi:"description"`
	// The enterprise project id of the load balancer.
	EnterpriseProjectId *string `pulumi:"enterpriseProjectId"`
	// Specifies whether to forcibly delete the load balancer, remove the load balancer,
	// listeners, unbind associated pools. Defaults to **false**.
	ForceDelete *bool `pulumi:"forceDelete"`
	// Elastic IP type. Changing this parameter will create a new resource.
	Iptype *string `pulumi:"iptype"`
	// The ipv4 address of the load balancer.
	Ipv4Address *string `pulumi:"ipv4Address"`
	// The ID of the EIP. Changing this parameter will create a new resource.
	Ipv4EipId *string `pulumi:"ipv4EipId"`
	// The **IPv4 subnet ID** of the subnet on which to allocate the load balancer
	// ipv4 address.
	Ipv4SubnetId *string `pulumi:"ipv4SubnetId"`
	// The ipv6 address of the Load Balancer.
	Ipv6Address *string `pulumi:"ipv6Address"`
	// The ipv6 bandwidth id. Only support shared bandwidth.
	Ipv6BandwidthId *string `pulumi:"ipv6BandwidthId"`
	// The **ID** of the subnet on which to allocate the load balancer ipv6 address.
	Ipv6NetworkId *string `pulumi:"ipv6NetworkId"`
	// The L4 flavor id of the load balancer.
	L4FlavorId *string `pulumi:"l4FlavorId"`
	// The L7 flavor id of the load balancer.
	L7FlavorId *string `pulumi:"l7FlavorId"`
	// Specifies the type of the load balancer. Value options:
	// + **gateway**: indicates a gateway load balancer.
	// + Keep empty(default) indicates other types of load balancers.
	LoadbalancerType *string `pulumi:"loadbalancerType"`
	MinL7FlavorId    *string `pulumi:"minL7FlavorId"`
	// Human-readable name for the load balancer.
	Name *string `pulumi:"name"`
	// Specifies the charging period of the ELB load balancer.
	// If `periodUnit` is set to **month**, the value ranges from `1` to `9`.
	// If `periodUnit` is set to **year**, the value ranges from `1` to `3`.
	// This parameter is mandatory if `chargingMode` is set to **prePaid**.
	Period *int `pulumi:"period"`
	// Specifies the charging period unit of the ELB load balancer.
	// Valid values are **month** and **year**. This parameter is mandatory if `chargingMode` is set to **prePaid**.
	PeriodUnit *string `pulumi:"periodUnit"`
	// The reason for update protection. Only valid when `protectionStatus` is
	// **consoleProtection**.
	ProtectionReason *string `pulumi:"protectionReason"`
	// The protection status for update. Value options:
	// + **nonProtection**: No protection.
	// + **consoleProtection**: Console modification protection.
	ProtectionStatus *string `pulumi:"protectionStatus"`
	// The region in which to create the load balancer resource. If omitted, the
	// provider-level region will be used. Changing this creates a new load balancer.
	Region *string `pulumi:"region"`
	// Bandwidth sharing type. Value options:
	// + **PER**: Dedicated bandwidth.
	// + **WHOLE**: Shared bandwidth.
	Sharetype *string `pulumi:"sharetype"`
	// The key/value pairs to associate with the load balancer.
	Tags map[string]string `pulumi:"tags"`
	// The vpc on which to create the load balancer. Changing this creates a new
	// load balancer.
	VpcId *string `pulumi:"vpcId"`
	// Specifies traffic distributing policies when the WAF is faulty.
	// Value options:
	// + **discard**: Traffic will not be distributed.
	// + **forward**: Traffic will be distributed to the default backend servers.
	WafFailureAction *string `pulumi:"wafFailureAction"`
}

// The set of arguments for constructing a Loadbalancer resource.
type LoadbalancerArgs struct {
	// Deprecated: Deprecated
	AutoPay pulumi.StringPtrInput
	// Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
	AutoRenew          pulumi.StringPtrInput
	AutoscalingEnabled pulumi.BoolPtrInput
	// Specifies the list of AZ names.
	AvailabilityZones pulumi.StringArrayInput
	// The IDs of subnets on the downstream plane.
	// + If this parameter is not specified, select subnets as follows:
	// - If IPv6 is enabled for a load balancer, the ID of subnet specified in `ipv6NetworkId` will be used.
	// - If IPv4 is enabled for a load balancer, the ID of subnet specified in `ipv4SubnetId` will be used.
	// - If only public network is available for a load balancer, the ID of any subnet in the VPC where the load balancer
	//   resides will be used. Subnets with more IP addresses are preferred.
	// + If there is more than one subnet, the first subnet in the list will be used, and the subnets must be in the VPC
	//   where the load balancer resides.
	BackendSubnets pulumi.StringArrayInput
	// Bandwidth billing type. Value options:
	// + **bandwidth**: Billed by bandwidth.
	// + **traffic**: Billed by traffic.
	BandwidthChargeMode pulumi.StringPtrInput
	// Bandwidth ID of the shared bandwidth. It is mandatory when `sharetype`
	// is **WHOLE**. Changing this parameter will create a new resource.
	BandwidthId pulumi.StringPtrInput
	// Bandwidth size. It is mandatory when `iptype` is set and `bandwidthId`
	// is empty. Changing this parameter will create a new resource.
	BandwidthSize pulumi.IntPtrInput
	// Specifies the charging mode of the ELB load balancer.
	// Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
	ChargingMode pulumi.StringPtrInput
	// Enable this if you want to associate the IP addresses of backend servers with
	// your load balancer. Can only be true when updating.
	CrossVpcBackend pulumi.BoolPtrInput
	// Specifies whether to enable deletion protection
	// for the load balancer. Value options:
	// + **true**: Enable deletion protection.
	// + **false**: Disable deletion protection.
	DeletionProtectionEnable pulumi.BoolPtrInput
	// Human-readable description for the load balancer.
	Description pulumi.StringPtrInput
	// The enterprise project id of the load balancer.
	EnterpriseProjectId pulumi.StringPtrInput
	// Specifies whether to forcibly delete the load balancer, remove the load balancer,
	// listeners, unbind associated pools. Defaults to **false**.
	ForceDelete pulumi.BoolPtrInput
	// Elastic IP type. Changing this parameter will create a new resource.
	Iptype pulumi.StringPtrInput
	// The ipv4 address of the load balancer.
	Ipv4Address pulumi.StringPtrInput
	// The ID of the EIP. Changing this parameter will create a new resource.
	Ipv4EipId pulumi.StringPtrInput
	// The **IPv4 subnet ID** of the subnet on which to allocate the load balancer
	// ipv4 address.
	Ipv4SubnetId pulumi.StringPtrInput
	// The ipv6 address of the Load Balancer.
	Ipv6Address pulumi.StringPtrInput
	// The ipv6 bandwidth id. Only support shared bandwidth.
	Ipv6BandwidthId pulumi.StringPtrInput
	// The **ID** of the subnet on which to allocate the load balancer ipv6 address.
	Ipv6NetworkId pulumi.StringPtrInput
	// The L4 flavor id of the load balancer.
	L4FlavorId pulumi.StringPtrInput
	// The L7 flavor id of the load balancer.
	L7FlavorId pulumi.StringPtrInput
	// Specifies the type of the load balancer. Value options:
	// + **gateway**: indicates a gateway load balancer.
	// + Keep empty(default) indicates other types of load balancers.
	LoadbalancerType pulumi.StringPtrInput
	MinL7FlavorId    pulumi.StringPtrInput
	// Human-readable name for the load balancer.
	Name pulumi.StringPtrInput
	// Specifies the charging period of the ELB load balancer.
	// If `periodUnit` is set to **month**, the value ranges from `1` to `9`.
	// If `periodUnit` is set to **year**, the value ranges from `1` to `3`.
	// This parameter is mandatory if `chargingMode` is set to **prePaid**.
	Period pulumi.IntPtrInput
	// Specifies the charging period unit of the ELB load balancer.
	// Valid values are **month** and **year**. This parameter is mandatory if `chargingMode` is set to **prePaid**.
	PeriodUnit pulumi.StringPtrInput
	// The reason for update protection. Only valid when `protectionStatus` is
	// **consoleProtection**.
	ProtectionReason pulumi.StringPtrInput
	// The protection status for update. Value options:
	// + **nonProtection**: No protection.
	// + **consoleProtection**: Console modification protection.
	ProtectionStatus pulumi.StringPtrInput
	// The region in which to create the load balancer resource. If omitted, the
	// provider-level region will be used. Changing this creates a new load balancer.
	Region pulumi.StringPtrInput
	// Bandwidth sharing type. Value options:
	// + **PER**: Dedicated bandwidth.
	// + **WHOLE**: Shared bandwidth.
	Sharetype pulumi.StringPtrInput
	// The key/value pairs to associate with the load balancer.
	Tags pulumi.StringMapInput
	// The vpc on which to create the load balancer. Changing this creates a new
	// load balancer.
	VpcId pulumi.StringPtrInput
	// Specifies traffic distributing policies when the WAF is faulty.
	// Value options:
	// + **discard**: Traffic will not be distributed.
	// + **forward**: Traffic will be distributed to the default backend servers.
	WafFailureAction pulumi.StringPtrInput
}

func (LoadbalancerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*loadbalancerArgs)(nil)).Elem()
}

type LoadbalancerInput interface {
	pulumi.Input

	ToLoadbalancerOutput() LoadbalancerOutput
	ToLoadbalancerOutputWithContext(ctx context.Context) LoadbalancerOutput
}

func (*Loadbalancer) ElementType() reflect.Type {
	return reflect.TypeOf((**Loadbalancer)(nil)).Elem()
}

func (i *Loadbalancer) ToLoadbalancerOutput() LoadbalancerOutput {
	return i.ToLoadbalancerOutputWithContext(context.Background())
}

func (i *Loadbalancer) ToLoadbalancerOutputWithContext(ctx context.Context) LoadbalancerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadbalancerOutput)
}

// LoadbalancerArrayInput is an input type that accepts LoadbalancerArray and LoadbalancerArrayOutput values.
// You can construct a concrete instance of `LoadbalancerArrayInput` via:
//
//	LoadbalancerArray{ LoadbalancerArgs{...} }
type LoadbalancerArrayInput interface {
	pulumi.Input

	ToLoadbalancerArrayOutput() LoadbalancerArrayOutput
	ToLoadbalancerArrayOutputWithContext(context.Context) LoadbalancerArrayOutput
}

type LoadbalancerArray []LoadbalancerInput

func (LoadbalancerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Loadbalancer)(nil)).Elem()
}

func (i LoadbalancerArray) ToLoadbalancerArrayOutput() LoadbalancerArrayOutput {
	return i.ToLoadbalancerArrayOutputWithContext(context.Background())
}

func (i LoadbalancerArray) ToLoadbalancerArrayOutputWithContext(ctx context.Context) LoadbalancerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadbalancerArrayOutput)
}

// LoadbalancerMapInput is an input type that accepts LoadbalancerMap and LoadbalancerMapOutput values.
// You can construct a concrete instance of `LoadbalancerMapInput` via:
//
//	LoadbalancerMap{ "key": LoadbalancerArgs{...} }
type LoadbalancerMapInput interface {
	pulumi.Input

	ToLoadbalancerMapOutput() LoadbalancerMapOutput
	ToLoadbalancerMapOutputWithContext(context.Context) LoadbalancerMapOutput
}

type LoadbalancerMap map[string]LoadbalancerInput

func (LoadbalancerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Loadbalancer)(nil)).Elem()
}

func (i LoadbalancerMap) ToLoadbalancerMapOutput() LoadbalancerMapOutput {
	return i.ToLoadbalancerMapOutputWithContext(context.Background())
}

func (i LoadbalancerMap) ToLoadbalancerMapOutputWithContext(ctx context.Context) LoadbalancerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoadbalancerMapOutput)
}

type LoadbalancerOutput struct{ *pulumi.OutputState }

func (LoadbalancerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Loadbalancer)(nil)).Elem()
}

func (o LoadbalancerOutput) ToLoadbalancerOutput() LoadbalancerOutput {
	return o
}

func (o LoadbalancerOutput) ToLoadbalancerOutputWithContext(ctx context.Context) LoadbalancerOutput {
	return o
}

// Deprecated: Deprecated
func (o LoadbalancerOutput) AutoPay() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.AutoPay }).(pulumi.StringPtrOutput)
}

// Specifies whether auto-renew is enabled. Valid values are **true** and **false**.
func (o LoadbalancerOutput) AutoRenew() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.AutoRenew }).(pulumi.StringPtrOutput)
}

func (o LoadbalancerOutput) AutoscalingEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.BoolOutput { return v.AutoscalingEnabled }).(pulumi.BoolOutput)
}

// Specifies the list of AZ names.
func (o LoadbalancerOutput) AvailabilityZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringArrayOutput { return v.AvailabilityZones }).(pulumi.StringArrayOutput)
}

// The IDs of subnets on the downstream plane.
//   - If this parameter is not specified, select subnets as follows:
//   - If IPv6 is enabled for a load balancer, the ID of subnet specified in `ipv6NetworkId` will be used.
//   - If IPv4 is enabled for a load balancer, the ID of subnet specified in `ipv4SubnetId` will be used.
//   - If only public network is available for a load balancer, the ID of any subnet in the VPC where the load balancer
//     resides will be used. Subnets with more IP addresses are preferred.
//   - If there is more than one subnet, the first subnet in the list will be used, and the subnets must be in the VPC
//     where the load balancer resides.
func (o LoadbalancerOutput) BackendSubnets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringArrayOutput { return v.BackendSubnets }).(pulumi.StringArrayOutput)
}

// Bandwidth billing type. Value options:
// + **bandwidth**: Billed by bandwidth.
// + **traffic**: Billed by traffic.
func (o LoadbalancerOutput) BandwidthChargeMode() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.BandwidthChargeMode }).(pulumi.StringOutput)
}

// Bandwidth ID of the shared bandwidth. It is mandatory when `sharetype`
// is **WHOLE**. Changing this parameter will create a new resource.
func (o LoadbalancerOutput) BandwidthId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.BandwidthId }).(pulumi.StringOutput)
}

// Bandwidth size. It is mandatory when `iptype` is set and `bandwidthId`
// is empty. Changing this parameter will create a new resource.
func (o LoadbalancerOutput) BandwidthSize() pulumi.IntOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.IntOutput { return v.BandwidthSize }).(pulumi.IntOutput)
}

// Indicates the billing mode. The value can be one of the following:
// + **flavor**: Billed by the specifications you will select.
// + **lcu**: Billed by LCU usage.
func (o LoadbalancerOutput) ChargeMode() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.ChargeMode }).(pulumi.StringOutput)
}

// Specifies the charging mode of the ELB load balancer.
// Valid values are **prePaid** and **postPaid**, defaults to **postPaid**.
func (o LoadbalancerOutput) ChargingMode() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.ChargingMode }).(pulumi.StringOutput)
}

// Indicates the time when the load balancer was created, in RFC3339 format.
func (o LoadbalancerOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Enable this if you want to associate the IP addresses of backend servers with
// your load balancer. Can only be true when updating.
func (o LoadbalancerOutput) CrossVpcBackend() pulumi.BoolOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.BoolOutput { return v.CrossVpcBackend }).(pulumi.BoolOutput)
}

// Specifies whether to enable deletion protection
// for the load balancer. Value options:
// + **true**: Enable deletion protection.
// + **false**: Disable deletion protection.
func (o LoadbalancerOutput) DeletionProtectionEnable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.BoolPtrOutput { return v.DeletionProtectionEnable }).(pulumi.BoolPtrOutput)
}

// Human-readable description for the load balancer.
func (o LoadbalancerOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The type of the subnet on the downstream plane. The value can be:
// + **ipv4**: IPv4 subnet
// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
func (o LoadbalancerOutput) ElbVirsubnetType() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.ElbVirsubnetType }).(pulumi.StringOutput)
}

// The enterprise project id of the load balancer.
func (o LoadbalancerOutput) EnterpriseProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.EnterpriseProjectId }).(pulumi.StringOutput)
}

// Specifies whether to forcibly delete the load balancer, remove the load balancer,
// listeners, unbind associated pools. Defaults to **false**.
func (o LoadbalancerOutput) ForceDelete() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.BoolPtrOutput { return v.ForceDelete }).(pulumi.BoolPtrOutput)
}

// The scenario where the load balancer is frozen. Multiple values are separated using commas (,).
// The value can be:
// + **POLICE**: The load balancer is frozen due to security reasons.
// + **ILLEGAL**: The load balancer is frozen due to violation of laws and regulations.
// + **VERIFY**: Your account has not completed real-name authentication.
// + **PARTNER**: The load balancer is frozen by the partner.
// + **ARREAR**: Your account is in arrears.
func (o LoadbalancerOutput) FrozenScene() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.FrozenScene }).(pulumi.StringOutput)
}

// Indicates whether the load balancer is a dedicated load balancer.
// The value can be one of the following:
// + **false**: The load balancer is a shared load balancer.
// + **true**: The load balancer is a dedicated load balancer.
func (o LoadbalancerOutput) Guaranteed() pulumi.BoolOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.BoolOutput { return v.Guaranteed }).(pulumi.BoolOutput)
}

// The flavor ID of the gateway load balancer.
func (o LoadbalancerOutput) GwFlavorId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.GwFlavorId }).(pulumi.StringOutput)
}

// Elastic IP type. Changing this parameter will create a new resource.
func (o LoadbalancerOutput) Iptype() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Iptype }).(pulumi.StringOutput)
}

// The ipv4 address of the load balancer.
func (o LoadbalancerOutput) Ipv4Address() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Ipv4Address }).(pulumi.StringOutput)
}

// The ipv4 eip address of the load balancer.
func (o LoadbalancerOutput) Ipv4Eip() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Ipv4Eip }).(pulumi.StringOutput)
}

// The ID of the EIP. Changing this parameter will create a new resource.
func (o LoadbalancerOutput) Ipv4EipId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Ipv4EipId }).(pulumi.StringOutput)
}

// The ID of the port bound to the private IPv4 address of the load balancer.
func (o LoadbalancerOutput) Ipv4PortId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Ipv4PortId }).(pulumi.StringOutput)
}

// The **IPv4 subnet ID** of the subnet on which to allocate the load balancer
// ipv4 address.
func (o LoadbalancerOutput) Ipv4SubnetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.Ipv4SubnetId }).(pulumi.StringPtrOutput)
}

// The ipv6 address of the Load Balancer.
func (o LoadbalancerOutput) Ipv6Address() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Ipv6Address }).(pulumi.StringOutput)
}

// The ipv6 bandwidth id. Only support shared bandwidth.
func (o LoadbalancerOutput) Ipv6BandwidthId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.Ipv6BandwidthId }).(pulumi.StringPtrOutput)
}

// The ipv6 eip address of the load balancer.
func (o LoadbalancerOutput) Ipv6Eip() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Ipv6Eip }).(pulumi.StringOutput)
}

// The type of the subnet on the downstream plane. The value can be:
// + **ipv4**: IPv4 subnet
// + **dualstack**: subnet that supports IPv4/IPv6 dual stack
func (o LoadbalancerOutput) Ipv6EipId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Ipv6EipId }).(pulumi.StringOutput)
}

// The **ID** of the subnet on which to allocate the load balancer ipv6 address.
func (o LoadbalancerOutput) Ipv6NetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.Ipv6NetworkId }).(pulumi.StringPtrOutput)
}

// The L4 flavor id of the load balancer.
func (o LoadbalancerOutput) L4FlavorId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.L4FlavorId }).(pulumi.StringOutput)
}

// The L7 flavor id of the load balancer.
func (o LoadbalancerOutput) L7FlavorId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.L7FlavorId }).(pulumi.StringOutput)
}

// Specifies the type of the load balancer. Value options:
// + **gateway**: indicates a gateway load balancer.
// + Keep empty(default) indicates other types of load balancers.
func (o LoadbalancerOutput) LoadbalancerType() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.LoadbalancerType }).(pulumi.StringOutput)
}

func (o LoadbalancerOutput) MinL7FlavorId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.MinL7FlavorId }).(pulumi.StringOutput)
}

// Human-readable name for the load balancer.
func (o LoadbalancerOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The operating status of the load balancer. The value can be:
// + **ONLINE**: indicates that the load balancer is running normally.
// + **FROZEN**: indicates that the load balancer is frozen.
func (o LoadbalancerOutput) OperatingStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.OperatingStatus }).(pulumi.StringOutput)
}

// Specifies the charging period of the ELB load balancer.
// If `periodUnit` is set to **month**, the value ranges from `1` to `9`.
// If `periodUnit` is set to **year**, the value ranges from `1` to `3`.
// This parameter is mandatory if `chargingMode` is set to **prePaid**.
func (o LoadbalancerOutput) Period() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.IntPtrOutput { return v.Period }).(pulumi.IntPtrOutput)
}

// Specifies the charging period unit of the ELB load balancer.
// Valid values are **month** and **year**. This parameter is mandatory if `chargingMode` is set to **prePaid**.
func (o LoadbalancerOutput) PeriodUnit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.PeriodUnit }).(pulumi.StringPtrOutput)
}

// The reason for update protection. Only valid when `protectionStatus` is
// **consoleProtection**.
func (o LoadbalancerOutput) ProtectionReason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringPtrOutput { return v.ProtectionReason }).(pulumi.StringPtrOutput)
}

// The protection status for update. Value options:
// + **nonProtection**: No protection.
// + **consoleProtection**: Console modification protection.
func (o LoadbalancerOutput) ProtectionStatus() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.ProtectionStatus }).(pulumi.StringOutput)
}

// The AZ group to which the load balancer belongs.
func (o LoadbalancerOutput) PublicBorderGroup() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.PublicBorderGroup }).(pulumi.StringOutput)
}

// The region in which to create the load balancer resource. If omitted, the
// provider-level region will be used. Changing this creates a new load balancer.
func (o LoadbalancerOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Bandwidth sharing type. Value options:
// + **PER**: Dedicated bandwidth.
// + **WHOLE**: Shared bandwidth.
func (o LoadbalancerOutput) Sharetype() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.Sharetype }).(pulumi.StringOutput)
}

// The key/value pairs to associate with the load balancer.
func (o LoadbalancerOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// Indicates the time when the load balancer was updated, in RFC3339 format.
func (o LoadbalancerOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// The vpc on which to create the load balancer. Changing this creates a new
// load balancer.
func (o LoadbalancerOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.VpcId }).(pulumi.StringOutput)
}

// Specifies traffic distributing policies when the WAF is faulty.
// Value options:
// + **discard**: Traffic will not be distributed.
// + **forward**: Traffic will be distributed to the default backend servers.
func (o LoadbalancerOutput) WafFailureAction() pulumi.StringOutput {
	return o.ApplyT(func(v *Loadbalancer) pulumi.StringOutput { return v.WafFailureAction }).(pulumi.StringOutput)
}

type LoadbalancerArrayOutput struct{ *pulumi.OutputState }

func (LoadbalancerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Loadbalancer)(nil)).Elem()
}

func (o LoadbalancerArrayOutput) ToLoadbalancerArrayOutput() LoadbalancerArrayOutput {
	return o
}

func (o LoadbalancerArrayOutput) ToLoadbalancerArrayOutputWithContext(ctx context.Context) LoadbalancerArrayOutput {
	return o
}

func (o LoadbalancerArrayOutput) Index(i pulumi.IntInput) LoadbalancerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Loadbalancer {
		return vs[0].([]*Loadbalancer)[vs[1].(int)]
	}).(LoadbalancerOutput)
}

type LoadbalancerMapOutput struct{ *pulumi.OutputState }

func (LoadbalancerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Loadbalancer)(nil)).Elem()
}

func (o LoadbalancerMapOutput) ToLoadbalancerMapOutput() LoadbalancerMapOutput {
	return o
}

func (o LoadbalancerMapOutput) ToLoadbalancerMapOutputWithContext(ctx context.Context) LoadbalancerMapOutput {
	return o
}

func (o LoadbalancerMapOutput) MapIndex(k pulumi.StringInput) LoadbalancerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Loadbalancer {
		return vs[0].(map[string]*Loadbalancer)[vs[1].(string)]
	}).(LoadbalancerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LoadbalancerInput)(nil)).Elem(), &Loadbalancer{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoadbalancerArrayInput)(nil)).Elem(), LoadbalancerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoadbalancerMapInput)(nil)).Elem(), LoadbalancerMap{})
	pulumi.RegisterOutputType(LoadbalancerOutput{})
	pulumi.RegisterOutputType(LoadbalancerArrayOutput{})
	pulumi.RegisterOutputType(LoadbalancerMapOutput{})
}
